!function (e) {
    var t = {};

    function n(r) {
        if (t[r]) return t[r].exports;
        var i = t[r] = {i: r, l: !1, exports: {}};
        return e[r].call(i.exports, i, i.exports, n), i.l = !0, i.exports
    }

    n.m = e, n.c = t, n.d = function (e, t, r) {
        n.o(e, t) || Object.defineProperty(e, t, {enumerable: !0, get: r})
    }, n.r = function (e) {
        "undefined" != typeof Symbol && Symbol.toStringTag && Object.defineProperty(e, Symbol.toStringTag, {value: "Module"}), Object.defineProperty(e, "__esModule", {value: !0})
    }, n.t = function (e, t) {
        if (1 & t && (e = n(e)), 8 & t) return e;
        if (4 & t && "object" == typeof e && e && e.__esModule) return e;
        var r = Object.create(null);
        if (n.r(r), Object.defineProperty(r, "default", {
            enumerable: !0,
            value: e
        }), 2 & t && "string" != typeof e) for (var i in e) n.d(r, i, function (t) {
            return e[t]
        }.bind(null, i));
        return r
    }, n.n = function (e) {
        var t = e && e.__esModule ? function () {
            return e.default
        } : function () {
            return e
        };
        return n.d(t, "a", t), t
    }, n.o = function (e, t) {
        return Object.prototype.hasOwnProperty.call(e, t)
    }, n.p = "", n(n.s = 11)
}([function (e, t, n) {
    "use strict";
    n.r(t), n.d(t, "AssetBasis", (function () {
        return m
    })), n.d(t, "AssetEntity", (function () {
        return _
    })), n.d(t, "DATA_VERSION", (function () {
        return I
    })), n.d(t, "DATA_VERSIONS", (function () {
        return N
    })), n.d(t, "DeserializeContext", (function () {
        return D
    })), n.d(t, "Deserializer", (function () {
        return X
    })), n.d(t, "EditType", (function () {
        return ee
    })), n.d(t, "HideFlag", (function () {
        return l
    })), n.d(t, "HideFlags", (function () {
        return d
    })), n.d(t, "JsonProcessor", (function () {
        return g
    })), n.d(t, "KEY_ASSET", (function () {
        return j
    })), n.d(t, "KEY_CHILDREN", (function () {
        return V
    })), n.d(t, "KEY_CLASS", (function () {
        return G
    })), n.d(t, "KEY_COMPONENTS", (function () {
        return k
    })), n.d(t, "KEY_DESERIALIZE", (function () {
        return U
    })), n.d(t, "KEY_EXTRAS", (function () {
        return H
    })), n.d(t, "KEY_SCENE", (function () {
        return B
    })), n.d(t, "KEY_SERIALIZE", (function () {
        return z
    })), n.d(t, "KEY_UUID", (function () {
        return F
    })), n.d(t, "LoadingStatus", (function () {
        return v
    })), n.d(t, "MissingComponent", (function () {
        return L
    })), n.d(t, "PropertyInfo", (function () {
        return oe
    })), n.d(t, "ResourceManager", (function () {
        return O
    })), n.d(t, "ResourceType", (function () {
        return A
    })), n.d(t, "SerializeContext", (function () {
        return K
    })), n.d(t, "SerializeManager", (function () {
        return J
    })), n.d(t, "SerializeUtil", (function () {
        return W
    })), n.d(t, "Serializer", (function () {
        return Q
    })), n.d(t, "TextProcessor", (function () {
        return y
    })), n.d(t, "_Key", (function () {
        return $
    })), n.d(t, "clone", (function () {
        return ie
    })), n.d(t, "customProperties", (function () {
        return ae
    })), n.d(t, "deserialize", (function () {
        return re
    })), n.d(t, "getHideFlags", (function () {
        return h
    })), n.d(t, "getItemsFromEnum", (function () {
        return le
    })), n.d(t, "hideFlag", (function () {
        return f
    })), n.d(t, "property", (function () {
        return se
    })), n.d(t, "serialize", (function () {
        return ne
    })), n.d(t, "serializeAsObject", (function () {
        return P
    })), n.d(t, "serializeAsReference", (function () {
        return R
    })), n.d(t, "serializeManager", (function () {
        return te
    })), n.d(t, "serializedField", (function () {
        return w
    }));
    var r = n(2), i = n(3), o = function (e, t) {
        return (o = Object.setPrototypeOf || {__proto__: []} instanceof Array && function (e, t) {
            e.__proto__ = t
        } || function (e, t) {
            for (var n in t) t.hasOwnProperty(n) && (e[n] = t[n])
        })(e, t)
    };

    function a(e, t) {
        function n() {
            this.constructor = e
        }

        o(e, t), e.prototype = null === t ? Object.create(t) : (n.prototype = t.prototype, new n)
    }

    function s(e, t, n, r) {
        var i, o = arguments.length, a = o < 3 ? t : null === r ? r = Object.getOwnPropertyDescriptor(t, n) : r;
        if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) a = Reflect.decorate(e, t, n, r); else for (var s = e.length - 1; s >= 0; s--) (i = e[s]) && (a = (o < 3 ? i(a) : o > 3 ? i(t, n, a) : i(t, n)) || a);
        return o > 3 && a && Object.defineProperty(t, n, a), a
    }

    var l, u = "hideFlags";

    function c(e, t) {
        return e | t
    }

    function p(e, t) {
        return e & ~t
    }

    !function (e) {
        e[e.None = 0] = "None", e[e.NotEditable = 1] = "NotEditable", e[e.NotTouchable = 2] = "NotTouchable", e[e.DontSave = 4] = "DontSave", e[e.Hide = 8] = "Hide", e[e.HideInMenu = 16] = "HideInMenu"
    }(l || (l = {}));
    var d = function (e) {
        function t() {
            var t = null !== e && e.apply(this, arguments) || this;
            return t.flagMask = 0, t
        }

        return a(t, e), Object.defineProperty(t.prototype, "dontSave", {
            get: function () {
                return 0 != (4 & this.flagMask)
            }, set: function (e) {
                this.flagMask = e ? c(this.flagMask, 4) : p(this.flagMask, 4)
            }, enumerable: !0, configurable: !0
        }), Object.defineProperty(t.prototype, "notEditable", {
            get: function () {
                return 0 != (1 & this.flagMask)
            }, set: function (e) {
                this.flagMask = e ? c(this.flagMask, 1) : p(this.flagMask, 1)
            }, enumerable: !0, configurable: !0
        }), Object.defineProperty(t.prototype, "notTouchable", {
            get: function () {
                return 0 != (2 & this.flagMask)
            }, set: function (e) {
                this.flagMask = e ? c(this.flagMask, 2) : p(this.flagMask, 2)
            }, enumerable: !0, configurable: !0
        }), Object.defineProperty(t.prototype, "hide", {
            get: function () {
                return 0 != (8 & this.flagMask)
            }, set: function (e) {
                this.flagMask = e ? c(this.flagMask, 8) : p(this.flagMask, 8)
            }, enumerable: !0, configurable: !0
        }), t
    }(DebuggerClass);

    function h(e, t) {
        return void 0 === t && (t = !1), u in e ? e[u] : u in e.constructor ? e.constructor[u] : t ? e[u] = new d : null
    }

    function f(e) {
        return function (t) {
            var n = new d;
            n.flagMask = e, t[u] = n
        }
    }

    __reflect(d, "@egret/core/HideFlags");
    var m = function (e) {
        function t() {
            var t = null !== e && e.apply(this, arguments) || this;
            return t.uri = "", t.type = "", t.status = "NotLoaded", t.subResources = [], t.data = null, t
        }

        return a(t, e), t = s([f(20), Object(r.component)({isAbstract: !1})], t)
    }(r.Component);
    __reflect(m, "@egret/core/AssetBasis");
    var _ = function (e) {
        function t() {
            var t = null !== e && e.apply(this, arguments) || this;
            return t._compBasis = null, t
        }

        return a(t, e), Object.defineProperty(t.prototype, "compBasis", {
            get: function () {
                return this._compBasis || (this._compBasis = this.getComponent(m)), this._compBasis
            }, enumerable: !0, configurable: !0
        }), Object.defineProperty(t.prototype, "uri", {
            get: function () {
                return this.compBasis.uri
            }, set: function (e) {
                this.compBasis.uri = e
            }, enumerable: !0, configurable: !0
        }), Object.defineProperty(t.prototype, "type", {
            get: function () {
                return this.compBasis.type
            }, set: function (e) {
                this.compBasis.type = e
            }, enumerable: !0, configurable: !0
        }), Object.defineProperty(t.prototype, "status", {
            get: function () {
                return this.compBasis.status
            }, set: function (e) {
                this.compBasis.status = e
            }, enumerable: !0, configurable: !0
        }), Object.defineProperty(t.prototype, "data", {
            get: function () {
                return this.compBasis.data
            }, set: function (e) {
                this.compBasis.data = e
            }, enumerable: !0, configurable: !0
        }), Object.defineProperty(t.prototype, "subResources", {
            get: function () {
                return this.compBasis.subResources
            }, set: function (e) {
                for (var t = this.compBasis.subResources, n = 0, r = e; n < r.length; n++) {
                    var i = r[n];
                    t.push(i)
                }
            }, enumerable: !0, configurable: !0
        }), t.INVALID_INDEX = -1, t = s([Object(r.entity)({requireComponents: [m]})], t)
    }(r.Entity);
    __reflect(_, "@egret/core/AssetEntity");
    var g = function (e) {
        function t() {
            return null !== e && e.apply(this, arguments) || this
        }

        return a(t, e), t.prototype.load = function (e, t, n) {
            return t.loadResouceData(e, "text", n).then((function (e) {
                if (null === e) return null;
                try {
                    return JSON.parse(e)
                } catch (e) {
                    return null
                }
            }))
        }, t
    }(DebuggerClass);
    __reflect(g, "@egret/core/JsonProcessor");
    var v, y = function (e) {
        function t() {
            return null !== e && e.apply(this, arguments) || this
        }

        return a(t, e), t.prototype.load = function (e, t) {
            return t.loader.getText(e, t.baseUrl)
        }, t
    }(DebuggerClass);
    __reflect(y, "@egret/core/TextProcessor"), function (e) {
        e.NotLoaded = "NotLoaded", e.Loading = "Loading", e.Ok = "Ok", e.LoadFailed = "LoadFailed", e.ParseFailed = "ParseFailed"
    }(v || (v = {}));
    var b = {
        json: "json",
        jpg: "image",
        jpeg: "image",
        bmp: "image",
        png: "image",
        pvr: "pvr",
        dds: "dds",
        ktx: "ktx",
        xml: "xml",
        bin: "binary",
        glsl: "glsl"
    }, x = {
        json: {
            prefab: "prefab",
            scene: "scene",
            mat: "material",
            image: "texture",
            shader: "shader",
            ani: "animationJson"
        }, glsl: {shader: "text"}, bin: {ani: "animation", mesh: "mesh", gan: "bakedAnimation"}
    }, T = function (e) {
        function t() {
            var t = null !== e && e.apply(this, arguments) || this;
            return t._customSuffixMap = {}, t._customSubSuffixMap = {}, t._loaders = Object.create(null), t
        }

        return a(t, e), t.prototype.getTypeByUri = function (e) {
            var t = e.lastIndexOf(".");
            if (t < 0) return "";
            var n = e.substring(t + 1).toLowerCase();
            if (!n) return "";
            var r = b[n] || this._customSuffixMap[n];
            if (!r) return "";
            var i = x[n] || this._customSubSuffixMap[n];
            if (!i) return r;
            var o = e.lastIndexOf(".", t - 1);
            if (o >= 0) {
                var a = e.substring(o + 1, t).toLowerCase();
                return a && i[a] || r
            }
            return r
        }, t.prototype.setProcessor = function (e, t, n, r) {
            void 0 === n && (n = null), void 0 === r && (r = null), t ? (this._loaders[e] = t, null !== n && (b[n] || (this._customSuffixMap[n] = e), null !== r && (x[n] || (x[n] = Object.create(null)), x[n][r] || (x[n][r] = e)))) : delete this._loaders[e]
        }, t.prototype.getProcessor = function (e) {
            return this._loaders[e] || null
        }, t
    }(DebuggerClass);
    __reflect(T, "@egret/core/ProcessorCollection");
    var E = function (e) {
        function t() {
            return null !== e && e.apply(this, arguments) || this
        }

        return a(t, e), t.prototype.load = function (e, t) {
            return t.loader.loadBinary(e, t.baseUrl)
        }, t
    }(DebuggerClass);
    __reflect(E, "@egret/core/BinaryProcessor");
    var C = function (e) {
        function t() {
            return null !== e && e.apply(this, arguments) || this
        }

        return a(t, e), t.prototype.load = function (e, t) {
            return t.loader.getText(e, t.baseUrl).then((function (n) {
                var r, i;
                try {
                    r = JSON.parse(n)
                } catch (e) {
                    r = n
                }
                return i = "string" == typeof r ? S(e, r) : function (e, t) {
                    if (-1 !== t.indexOf("://")) return t;
                    var n = (e = e.split("\\").join("/")).match(/#.*|\?.*/), r = "";
                    n && (r = n[0]);
                    var i = e.lastIndexOf("/");
                    e = -1 !== i ? e.substring(0, i + 1) + t : t;
                    return e + r
                }(e, r.file), t.loadUri(i).then((function (e) {
                    var t = new egret.BitmapData(e.data.source), n = new egret.Texture;
                    return n.bitmapData = t, new egret.BitmapFont(n, r)
                }), (function (e) {
                    throw e
                }))
            }))
        }, t
    }(DebuggerClass);
    __reflect(C, "@egret/core/FontProcessor");
    var S = function (e, t) {
        var n = "", r = t.split("\n")[2], i = r.indexOf('file="');
        return -1 !== i && (i = (r = r.substring(i + 6)).indexOf('"'), n = r.substring(0, i)), i = (e = e.split("\\").join("/")).lastIndexOf("/"), e = -1 !== i ? e.substring(0, i + 1) + n : n
    }, M = function (e) {
        function t() {
            return null !== e && e.apply(this, arguments) || this
        }

        return a(t, e), t.prototype.getText = function (e, t) {
            return __ConfigData[e] ? Promise.resolve(__ConfigData[e]) : this.loadText(e, t)
        }, t
    }(DebuggerClass);
    __reflect(M, "@egret/core/_ResourceLoader_internal");
    var A, O = function (e) {
        function t() {
            this._processors = new T, this.loader = new M, this.queue = {}, this._resources = Object.create(null), this._resourceNameMap = Object.create(null), this._assetDirty = !1, this._baseUrl = "", this._resources["@%@"] = Object.create(null);
            var e = this._processors;
            return e.setProcessor("text", new y), e.setProcessor("json", new g), e.setProcessor("binary", new E), e.setProcessor("font", new C), this
        }

        return a(t, DebuggerClass), Object.defineProperty(t, "instance", {
            get: function () {
                return this._instance = this._instance || new t, this._instance
            }, enumerable: !0, configurable: !0
        }), t.prototype.setProcessor = function (e, t, n, r) {
            void 0 === n && (n = null), void 0 === r && (r = null), this._processors.setProcessor(e, t, n, r)
        }, t.prototype.builtins = function () {
            return Object.values(this._resources["@%@"]).filter((function (e) {
                return e && e.uri.startsWith(t.BUILTIN + "/")
            }))
        }, t.prototype.getResourceItem = function (e) {
            e = this.tempFormatUri(e);
            var t = this._adjustBaseUrlParam(this.baseUrl), n = this._resources[t];
            return n && n[e] || null
        }, t.prototype.getResource = function (e) {
            var t = this.getResourceItem(e);
            return t && t.data || null
        }, t.prototype.getResourceItemByName = function (e) {
            var t = this._resourceNameMap[e];
            return t ? this.getResourceItem(t) : null
        }, t.prototype.getResourceByName = function (e) {
            var t = this._resourceNameMap[e];
            return t ? this.getResource(t) : null
        }, t.prototype.addResource = function (e, t) {
            t = this._adjustBaseUrlParam(t);
            var n = this._resources[t];
            n || (n = Object.create(null), this._resources[t] = n);
            var i = e.data;
            i && i instanceof r.Component && i.entity && i.entity instanceof _ && (i.entity.status = e.status || (i ? "Ok" : "LoadFailed"), i.entity.uri = e.uri, i.entity.type = e.type, i.entity.data = e.data, e = i.entity), n[e.uri] = e
        }, t.prototype.resourceUses = function (e, t) {
            if ("string" == typeof e) {
                if (!(n = this.getResourceItem(e))) return !1;
                e = n
            }
            if ("string" == typeof t) {
                var n;
                if (!(n = this.getResourceItem(t))) return !1;
                t = n
            }
            if (!e.subResources) return !1;
            for (var r = 0, i = e.subResources; r < i.length; r++) {
                var o = i[r];
                if (o === t.uri) return !0;
                var a = this.getResourceItem(o);
                if (a && this.resourceUses(a, t)) return !0
            }
            return !1
        }, t.prototype.getReadyResource = function (e, t) {
            var n = this.getResourceItem(e);
            return n && n.type === t && "Ok" === n.status ? n : null
        }, t.prototype._adjustBaseUrlParam = function (e) {
            return void 0 !== e && e !== this._baseUrl || (e = "@%@"), e
        }, Object.defineProperty(t.prototype, "disposedAssets", {
            get: function () {
                var e = this, t = [];
                return this._assetDirty && (this._assetDirty = !1, Object.values(this._resources).map((function (n) {
                    Object.keys(n).map((function (r) {
                        var i = n[r];
                        e._shouldRemoveAsset(i) && (t.push(i), delete n[r])
                    }))
                }))), t
            }, enumerable: !0, configurable: !0
        }), t.prototype._shouldRemoveAsset = function (e) {
            return !1
        }, Object.defineProperty(t.prototype, "baseUrl", {
            get: function () {
                return this._baseUrl
            }, set: function (e) {
                this._baseUrl = e
            }, enumerable: !0, configurable: !0
        }), t.prototype.loadResouceData = function (e, t) {
            return this._loadData(e, t)
        }, t.prototype.loadConfig = function (e) {
            var t = this;
            return this._resourceNameMap = Object.create(null), this.loadResouceData(e, "json").then((function (n) {
                if (!n) {
                    var r = "failed to parse res configuration file " + e;
                    throw new Error(r)
                }
                if (Array.isArray(n.resources)) {
                    n.resources.map((function (e) {
                        var n = {uri: e.url, type: e.type};
                        return t.addResource(n, t.baseUrl), t._resourceNameMap[e.name] = e.url, n
                    }));
                    return !0
                }
                r = "failed to find valid 'resources' in res configuration file " + e;
                throw new Error(r)
            }))
        }, t.prototype.load = function (e) {
            return this._loadItem(e)
        }, t.prototype.loadUri = function (e) {
            var t = {uri: e = this.tempFormatUri(e), type: this._processors.getTypeByUri(e)};
            return this.load(t)
        }, t.prototype.reloadUri = function (e) {
            var t = this.removeResource(e), n = {uri: e, type: t ? t.type : this._processors.getTypeByUri(e)};
            return this.load(n)
        }, t.prototype.removeResource = function (e, t) {
            t = this._adjustBaseUrlParam(t);
            var n = this._resources[t], r = n[e];
            return delete n[e], r || null
        }, t.prototype._loadData = function (e, t) {
            var n = this._processors.getProcessor(t);
            if (!n) {
                var r = "Resource loader of #type[" + t + "] cannot be found.";
                return Promise.reject(r)
            }
            return n.load(e, this)
        }, t.prototype._loadItem = function (e) {
            var t = this, n = this.getResourceItem(e.uri);
            if (n && "Ok" === n.status) return Promise.resolve(n);
            if (!this.queue[e.uri]) {
                var r = this._loadData(e.uri, e.type).then((function (n) {
                    return delete t.queue[e.uri], e.data = n, e.status = "Ok", t.addResource(e), Promise.resolve(e)
                })).catch((function () {
                    return delete t.queue[e.uri], e.status = "LoadFailed", t.addResource(e), Promise.resolve(e)
                }));
                e.status = "Loading", this.queue[e.uri] = r
            }
            return this.queue[e.uri]
        }, t.prototype.tempFormatUri = function (e) {
            return e.split("/").filter((function (e) {
                return "." !== e
            })).join("/")
        }, t.BUILTIN = "builtin", t._instance = null, t
    }();

    function w(e, t) {
        if (!t) return function (t, n) {
            var r = t.constructor;
            r.__serializeKeys = r.__serializeKeys || {}, r.__serializeKeys[n] = e
        };
        var n = e.constructor;
        n.__serializeKeys = n.__serializeKeys || {}, n.__serializeKeys[t] = null
    }

    function R(e, t) {
        var n = e.constructor;
        n.__serializeKeysAsReference = n.__serializeKeysAsReference || [], n.__serializeKeysAsReference.push(t)
    }

    function P(e, t) {
        var n = e.constructor;
        n.__serializeKeysAsObject = n.__serializeKeysAsObject || [], n.__serializeKeysAsObject.push(t)
    }

    __reflect(O, "@egret/core/ResourceManager"), function (e) {
        e.Unknown = "", e.Sound = "sound", e.Image = "image", e.Vert = "vert", e.Frag = "frag", e.Font = "font", e.Pvr = "pvr", e.Dds = "dds", e.Ktx = "ktx", e.Tilemap = "tilemap", e.Xml = "xml", e.Json = "json", e.Text = "text", e.Blob = "blob", e.Binary = "binary", e.Glsl = "glsl", e.Texture = "texture", e.RenderTexture = "renderTexture", e.Material = "material", e.EntityModel = "entityModel", e.Scene = "scene", e.Prefab = "prefab", e.Shader = "shader", e.Mesh = "mesh", e.Animation = "animation", e.TextureDesc = "textureDesc", e.MovieClip = "movieClip", e.AnimationJson = "animationJson", e.BakedAnimation = "bakedAnimation"
    }(A || (A = {}));
    var L = function (e) {
        function t() {
            var t = null !== e && e.apply(this, arguments) || this;
            return t.missingObject = null, t
        }

        return a(t, e), Object.defineProperty(t.prototype, "missingClass", {
            get: function () {
                return this.missingObject ? this.missingObject.class : ""
            }, enumerable: !0, configurable: !0
        }), s([w], t.prototype, "missingObject", void 0), t = s([Object(r.component)({isAbstract: !1})], t)
    }(r.Component);
    __reflect(L, "@egret/core/MissingComponent");
    var D = function (e) {
        function t() {
            var t = null !== e && e.apply(this, arguments) || this;
            return t.assets = [], t.entities = {}, t.components = {}, t.usedComponents = new Set, t.id = "", t
        }

        return a(t, e), t.prototype.copy = function (e) {
            var t;
            e && (this.reset(), (t = this.assets).push.apply(t, e.assets), Object.assign(this.entities, e.entities), Object.assign(this.components, e.components))
        }, t.prototype.reset = function () {
            var e = this;
            this.assets.length = 0, Object.keys(this.entities).slice().map((function (t) {
                return delete e.entities[t]
            })), Object.keys(this.components).slice().map((function (t) {
                return delete e.components[t]
            })), this.usedComponents.clear(), this.id = ""
        }, t
    }(DebuggerClass);
    __reflect(D, "@egret/core/DeserializeContext");
    var I = "5", N = [I], z = "serialize", U = "deserialize", F = "uuid", k = "components", V = "children", B = "scene",
        G = "__class", j = "__asset", H = "__extras", W = function (e) {
            function t() {
                return null !== e && e.apply(this, arguments) || this
            }

            return a(t, e), t.propertyHasGetterAndSetter = function (e, t) {
                for (var n = Object.getPrototypeOf(e); n;) {
                    var r = Object.getOwnPropertyDescriptor(n, t);
                    if (r && r.get && r.set) return !0;
                    n = Object.getPrototypeOf(n)
                }
                return !1
            }, t.equal = function (e, t) {
                var n = typeof e;
                if (n !== typeof t) return !1;
                if (null === e && null === t) return !0;
                if (null === e || null === t) return !1;
                if ("object" !== n) return e === t;
                if ((Array.isArray(e) || ArrayBuffer.isView(e)) && (Array.isArray(t) || ArrayBuffer.isView(t))) {
                    var i = e.length;
                    if (i !== t.length) return !1;
                    if (0 === i) return !0;
                    for (var o = 0; o < i; ++o) if (!this.equal(e[o], t[o])) return !1;
                    return !0
                }
                if (e.constructor !== t.constructor) return !1;
                if (e instanceof _ || e instanceof r.Entity || e instanceof r.Component) return e === t;
                if (e.constructor === Object) {
                    for (var a in e) if (!this.equal(e[a], t[a])) return !1;
                    return !0
                }
                if (z in e) return this.equal(e.serialize(), t.serialize());
                if (F in e) for (var a in e) if (!this.equal(e[a], t[a])) return !1;
                throw new Error("Unsupported data.")
            }, t.getSerializedKeys = function (e, t) {
                if (void 0 === t && (t = {}), !e) return t;
                var n = e.__serializeKeys;
                if (n) for (var r in n) t[r] = n[r] || r;
                return e.prototype && e.prototype.__proto__.constructor !== Object && this.getSerializedKeys(e.prototype.__proto__.constructor, t), t
            }, t.getSerializeKeysAsReference = function (e, t) {
                if (void 0 === t && (t = null), !e) return t;
                var n = e.__serializeKeysAsReference;
                return n && (t = t || new Set, n.map((function (e) {
                    return t.add(e)
                }))), e.prototype && e.prototype.__proto__.constructor !== Object && (t = this.getSerializeKeysAsReference(e.prototype.__proto__.constructor, t)), t
            }, t.getSerializeKeysAsObject = function (e, t) {
                if (void 0 === t && (t = null), !e) return t;
                var n = e.__serializeKeysAsObject;
                return n && (t = t || new Set, n.map((function (e) {
                    return t.add(e)
                }))), e.prototype && e.prototype.__proto__.constructor !== Object && (t = this.getSerializeKeysAsObject(e.prototype.__proto__.constructor, t)), t
            }, t.getDeserializedIgnoreKeys = function (e, t) {
                return void 0 === t && (t = null), e.__deserializeIgnore && (t = t || new Set, e.__deserializeIgnore.map((function (e) {
                    return t.add(e)
                }))), e.prototype && e.prototype.__proto__.constructor !== Object && (t = this.getDeserializedIgnoreKeys(e.prototype.__proto__.constructor, t)), t
            }, t.factory = null, t
        }(DebuggerClass);
    __reflect(W, "@egret/core/SerializeUtil");
    var X = function (e) {
        function t() {
            var t = null !== e && e.apply(this, arguments) || this;
            return t.root = null, t._isRunning = !1, t._context = new D, t._uuidMapping = Object.create(null), t._componentDataMap = Object.create(null), t._entityDataMap = Object.create(null), t._config = Object.create(null), t._entityContext = null, t
        }

        return a(t, e), Object.defineProperty(t.prototype, "isRunning", {
            get: function () {
                return this._isRunning
            }, enumerable: !0, configurable: !0
        }), t.prototype.deserialize = function (e, t, n, r) {
            return this._isRunning && console.error("The deserialization is not complete."), this._isRunning = !0, this.root = null, this._entityContext = n || null, this._onConfig(t || void 0), this._deserializeObject(e, r || null), this._reset(), this.root
        }, t.prototype._deserializeObject = function (e, n) {
            var r = this;
            if (e.assets && e.assets.map((function (e) {
                return r._context.assets.push(e)
            })), e.components && e.components.map((function (e) {
                return r._componentDataMap[e.uuid] = e
            })), e.entities && e.entities.map((function (e) {
                return r._entityDataMap[e.uuid] = e
            })), e.entities) {
                for (var i = 0, o = e.entities; i < o.length; i++) {
                    var a = o[i];
                    t.$sceneEnabled = !0, this._createEntity(a), t.$sceneEnabled = !1
                }
                for (var s = e.entities.length - 1; s >= 0; s--) {
                    a = e.entities[s];
                    var l = this._context.entities[a.uuid];
                    l && this._deserializeEntity(a, l)
                }
            }
            if (e.components) for (var u = 0, c = e.components; u < c.length; u++) {
                var p = c[u], d = p.uuid, h = this._context.components[d];
                if (h || (n ? h = this._createComponent(p, n) : console.warn("deserialize component with no entity")), h) {
                    if (this.root = this.root || h, h.constructor === L) continue;
                    var f = h[U];
                    f && "function" == typeof f ? h.deserialize(p) : this._deserializeProperties(p, h)
                }
            }
        }, t.prototype._onConfig = function (e) {
            e && (this._config = e)
        }, t.prototype._deserializeEntity = function (e, t) {
            if (this._deserializeProperties(e, t), t instanceof r.Entity && k in e) for (var n = 0, i = e[k]; n < i.length; n++) {
                var o = i[n];
                this._createComponent(this._componentDataMap[o.uuid], t, e)
            }
        }, t.prototype._deserializeProperties = function (e, t) {
            var n = W.getSerializedKeys(t.constructor), r = W.getSerializeKeysAsObject(t.constructor) || new Set,
                i = W.getDeserializedIgnoreKeys(t.constructor) || new Set;
            for (var o in this._adjustDeserializeKeys(e, n, i), e) {
                var a = n && o in n ? n[o] : o;
                r.has(a) ? this._deserializeProperty(e, o, a, t) : i && i.has(a) || this._deserializeProperty(e, o, a, t)
            }
            return t
        }, t.prototype._deserializeProperty = function (e, t, n, r) {
            var i = W.propertyHasGetterAndSetter(r, n), o = r[n],
                a = this._getPropertyValue(e[t], i && o && (o.constructor === Array || o.constructor === Object) ? null : o);
            void 0 !== a && (r[n] = a)
        }, t.prototype._adjustDeserializeKeys = function (e, t, n) {
            n.add(F), n.add(G), n.add(k), n.add(V)
        }, t.prototype._createEntity = function (e, t) {
            void 0 === t && (t = !1);
            var n = e[G], r = t ? W.factory.createEntityTemplate(n) : W.factory.createEntitySelf(n);
            if (!r) return null;
            for (var o = 0, a = r.components; o < a.length; o++) {
                var s = a[o];
                if (k in e) for (var l = 0, u = e[k]; l < u.length; l++) {
                    var c = u[l].uuid;
                    if (this._componentDataMap[c][G] === i.Reflect.getQualifiedClassName(s)) {
                        this._context.components[c] = s, this._uuidMapping[s.uuid] = c;
                        break
                    }
                }
            }
            return this._context.entities[e.uuid] = r, this.root = this.root || r, r
        }, t.prototype._createComponent = function (e, t, n) {
            var r = this, o = this._context.components[e.uuid];
            if (o) return o;
            var a = e[G], s = i.Reflect.getDefinitionByName(a);
            if (s) {
                var l = t ? t.getComponents(s) : [];
                if (t && (o = l.find((function (e) {
                    return !r._context.usedComponents.has(e.uuid) && e.constructor === s
                })) || null) && this._context.usedComponents.add(o.uuid), o) console.warn("Component is created but not indexed?"); else if (l.length > 0 && !s.allowMultiple) console.warn("try to deserialize more than one " + s.name + " components for entity(" + t.uuid + ")"); else {
                    var u = void 0 === e._enabled || e._enabled;
                    o = t.addComponent(s, u), this._context.usedComponents.add(o.uuid)
                }
            } else (o = t.addComponent(L)).missingObject = e, console.warn("Component " + a + " is not defined.");
            return o ? (this._context.components[e.uuid] = o, o) : (console.warn("Component " + a + " failed to create."), null)
        }, t.prototype._getPropertyValue = function (e, t) {
            switch (void 0 === t && (t = null), typeof e) {
                case"function":
                    return;
                case"object":
                    break;
                case"undefined":
                default:
                    return e
            }
            if (null === e) return null;
            if (t) {
                if (ArrayBuffer.isView(t)) {
                    for (var n = 0, r = Math.min(e.length, t.length); n < r; ++n) t[n] = e[n];
                    return t
                }
                if (Array.isArray(t) && 0 === t.length) {
                    for (n = 0, r = e.length; n < r; ++n) t[n] = this._getPropertyValue(e[n]);
                    return t
                }
                if (t[U]) return t.deserialize(e)
            }
            if (Array.isArray(e)) {
                t = [];
                for (n = 0, r = e.length; n < r; ++n) t[n] = this._getPropertyValue(e[n]);
                return t
            }
            if (j in e) {
                var o = e[j];
                return o >= 0 ? O.instance.getResource(this._context.assets[o]) : null
            }
            var a = e[G];
            if (F in e) {
                var s = e.uuid;
                if (s in this._context.entities) return this._context.entities[s];
                if (s in this._context.components) return this._context.components[s];
                if (this._entityContext) for (var l = 0, u = this._entityContext.entities; l < u.length; l++) {
                    var c = u[l];
                    if (c.uuid === s) return c;
                    for (var p = 0, d = c.components; p < d.length; p++) {
                        var h = d[p];
                        if (h && h.uuid === s) return h
                    }
                }
                console.warn("Cant find corresponding object with link:", e)
            } else {
                if (!a) {
                    for (var f in t = {}, e) t[f] = this._getPropertyValue(e[f]);
                    return t
                }
                var m = i.Reflect.getDefinitionByName(a);
                if (m) {
                    var _ = (t = new m)[U];
                    if (_ && "function" == typeof _) return t.deserialize(e);
                    console.warn("deserialize method of", a, "is unknown")
                } else console.warn("cant find definition of class", a)
            }
        }, t.prototype._reset = function () {
            this._context.reset(), this._uuidMapping = Object.create(null), this._componentDataMap = Object.create(null), this._config = Object.create(null), this._isRunning = !0
        }, t.$sceneEnabled = !1, t.$sceneID = 1, t
    }(DebuggerClass);
    __reflect(X, "@egret/core/Deserializer");
    var Y = function () {
        return {version: I, minVersion: I, assets: [], entities: [], components: []}
    }, q = function (e) {
        e.assets.length = 0, e.entities.length = 0, e.components.length = 0
    }, Z = function (e) {
        return {
            version: e.version,
            minVersion: e.minVersion,
            assets: e.assets.slice(),
            entities: e.entities.slice(),
            components: e.components.slice()
        }
    }, K = function (e) {
        function t() {
            var t = null !== e && e.apply(this, arguments) || this;
            return t.serializeds = [], t.data = Y(), t.config = {}, t._defaultGameObjects = {}, t
        }

        return a(t, e), t.prototype.getEntityTemplate = function (e) {
            var t = this._defaultGameObjects[e];
            if (!t) {
                if (!(t = W.factory.createEntityTemplate(e))) return null;
                this._defaultGameObjects[e] = t
            }
            return t
        }, t.prototype.reset = function () {
            this.serializeds.length = 0, q(this.data);
            for (var e = 0, t = Object.keys(this._defaultGameObjects); e < t.length; e++) {
                var n = t[e], r = this._defaultGameObjects[n];
                r && r.destroy()
            }
            this._defaultGameObjects = Object.create(null), this.config = Object.create(null)
        }, t.prototype.result = function () {
            return Z(this.data)
        }, t
    }(DebuggerClass);
    __reflect(K, "@egret/core/SerializeContext");
    var Q = function (e) {
        function t() {
            return this._isRunning = !1, this._context = new K, this
        }

        return a(t, DebuggerClass), Object.defineProperty(t.prototype, "isRunning", {
            get: function () {
                return this._isRunning
            }, enumerable: !0, configurable: !0
        }), t.prototype.serialize = function (e, t) {
            this._isRunning && console.error("The serialization is not complete."), this._reset(), this._isRunning = !0, this._onConfig(t), this._serializeObject(e);
            var n = this._context.result();
            return this._isRunning = !1, n
        }, t.prototype._reset = function () {
            this._context.reset()
        }, t.prototype._onConfig = function (e) {
            e && (this._context.config = e)
        }, t.prototype._serializeObject = function (e) {
            var t = h(e);
            if (t && t.dontSave) return !1;
            if (this._context.serializeds.indexOf(e.uuid) >= 0) return !0;
            var n = this._serializeReference(e);
            if (!n) return !1;
            var o = null;
            if (e instanceof r.Entity) {
                if (e.isDestroyed) return console.warn("Entity is destroyed"), !1;
                o = this._getEntityTemplate(e), this._context.data.entities.push(n)
            } else if (e instanceof r.Component) {
                if (e.isDestroyed) return console.warn("Component is destroyed"), !1;
                if (!e.entity) return console.warn("Component", e, "has not an entity"), !1;
                o = this._getComponentTemplate(e), this._context.data.components.push(n)
            } else console.warn("unexpected object type in _serializeObject():", i.Reflect.getQualifiedClassName(e)), this._context.data.entities.push(n);
            return this._context.serializeds.push(e.uuid), this._serializeProperties(e, n, o), !0
        }, t.prototype._serializeReference = function (e) {
            var t;
            if (e) {
                var n = i.Reflect.getQualifiedClassName(e);
                return (t = {uuid: e.uuid})[G] = n, t
            }
        }, t.prototype._serializeProperties = function (e, t, n) {
            var i = W.getSerializedKeys(e.constructor), o = W.getSerializeKeysAsReference(e.constructor) || new Set,
                a = W.getSerializeKeysAsObject(e.constructor) || new Set, s = new Set;
            this._adjustSerializeKeys(e, i, o, s);
            var l = function (t) {
                return !!n && ((!s || !s.has(t)) && W.equal(e[t], n[t]))
            };
            if (i) for (var u in i) {
                if (!l(u)) void 0 !== (d = this._serializeProperty(e[u], e, u)) && (t[u] = d)
            }
            if (o) for (var c = 0, p = Array.from(o); c < p.length; c++) {
                if (!l(u = p[c])) {
                    var d = this._serializeReference(e[u]);
                    t[u] = d
                }
            }
            if (a) for (var h = 0, f = Array.from(a); h < f.length; h++) {
                u = f[h];
                var m = e[u];
                if (Array.isArray(m) || ArrayBuffer.isView(m)) {
                    for (var _ = [], g = 0, v = m; g < v.length; g++) {
                        var y = v[g];
                        y instanceof r.Component ? this._serializeObject(y.entity) && _.push({uuid: y.uuid}) : y instanceof r.Entity && this._serializeObject(y) && _.push({uuid: y.uuid})
                    }
                    t[u] = _
                } else m instanceof r.Component ? this._serializeObject(m.entity) && (t[u] = {uuid: m.uuid}) : m instanceof r.Entity && this._serializeObject(m) && (t[u] = {uuid: m.uuid})
            }
        }, t.prototype._adjustSerializeKeys = function (e, t, n, i) {
            t.uuid = "uuid";
            e instanceof r.Entity ? (t[k] = k, t.enabled = "enabled") : e instanceof r.Component && (t.enabled = "enabled")
        }, t.prototype._serializeProperty = function (e, t, n) {
            switch (typeof e) {
                case"function":
                    return;
                case"object":
                    break;
                case"undefined":
                default:
                    return e
            }
            if (null === e) return null;
            if (Array.isArray(e) || ArrayBuffer.isView(e)) {
                for (var i = [], o = 0, a = e; o < a.length; o++) {
                    var s = a[o];
                    if (n !== k) void 0 !== (c = this._serializeProperty(s, t, n)) && i.push(c); else if (s instanceof r.Component) {
                        var l = h(s);
                        if (l && l.dontSave) continue;
                        this._serializeObject(s) && i.push({uuid: s.uuid})
                    }
                }
                return i
            }
            if (!e.constructor || e.constructor === Object) {
                i = {};
                for (var u in e) {
                    var c;
                    void 0 !== (c = this._serializeProperty(e[u], t, n)) && (i[u] = c)
                }
                return i
            }
            return z in e ? e.serialize() : F in e ? e instanceof r.Component && e.entity instanceof _ ? this._serializeAsset(e.entity) : e instanceof r.Entity || e instanceof r.Component ? e && e.uuid ? {uuid: e.uuid} : void 0 : this._serializeStruct(e) : void console.error("Serialize error.", e)
        }, t.prototype._serializeAsset = function (e) {
            var t, n;
            if (!e.uri) return (t = {})[j] = _.INVALID_INDEX, t;
            var r = this._context.data.assets, i = r.indexOf(e.uri);
            return i < 0 && (i = r.length, r.push(e.uri)), (n = {})[j] = i, n
        }, t.prototype._serializeStruct = function (e) {
            var t, n = i.Reflect.getQualifiedClassName(e), r = ((t = {})[G] = n, t);
            return this._serializeProperties(e, r, null), r
        }, t.prototype._getEntityTemplate = function (e) {
            return this._context.getEntityTemplate(i.Reflect.getQualifiedClassName(e))
        }, t.prototype._getComponentTemplate = function (e) {
            var t = this._getEntityTemplate(e.entity);
            return t ? t.getOrAddComponent(e.constructor) : null
        }, t
    }();
    __reflect(Q, "@egret/core/Serializer");
    var J = function (e) {
        function t() {
            var t = null !== e && e.apply(this, arguments) || this;
            return t._createSerializer = null, t._createDeserializer = null, t._serializer = null, t._deserializer = null, t
        }

        return a(t, e), Object.defineProperty(t.prototype, "createSerializer", {
            set: function (e) {
                e = e || t._defaultSerializerFn, this._createSerializer !== e && (this._createSerializer = e, this._serializer = this._createSerializer())
            }, enumerable: !0, configurable: !0
        }), Object.defineProperty(t.prototype, "createDeserializer", {
            set: function (e) {
                e = e || t._defaultDeserializerFn, this._createDeserializer !== e && (this._createDeserializer = e, this._deserializer = this._createDeserializer())
            }, enumerable: !0, configurable: !0
        }), Object.defineProperty(t.prototype, "serializer", {
            get: function () {
                return this._createSerializer = this._createSerializer || t._defaultSerializerFn, this._serializer || (this._serializer = this._createSerializer()), this._serializer.isRunning ? this._createSerializer() : this._serializer
            }, enumerable: !0, configurable: !0
        }), Object.defineProperty(t.prototype, "deserializer", {
            get: function () {
                return this._createDeserializer = this._createDeserializer || t._defaultDeserializerFn, this._deserializer || (this._deserializer = this._createDeserializer()), this._deserializer.isRunning ? this._createDeserializer() : this._deserializer
            }, enumerable: !0, configurable: !0
        }), t._defaultSerializerFn = function () {
            return new Q
        }, t._defaultDeserializerFn = function () {
            return new X
        }, t
    }(DebuggerClass);
    __reflect(J, "@egret/core/SerializeManager");
    var $, ee, te = new J;

    function ne(e, t) {
        return te.serializer.serialize(e, t)
    }

    function re(e, t, n, r) {
        return te.deserializer.deserialize(e, t, n, r)
    }

    function ie(e) {
        var t = te.serializer.serialize(e);
        return te.deserializer.deserialize(t)
    }

    !function (e) {
        e.EditableProperties = "__editableProperties__", e.CustomEditableProperties = "__customEditableProperties__"
    }($ || ($ = {})), function (e) {
        e.Boolean = "boolean", e.Uint = "uint", e.Int = "int", e.Float = "float", e.String = "string", e.Size = "size", e.Rectangle = "rectangle", e.Vector2 = "vector2", e.Vector3 = "vector3", e.Vector4 = "vector4", e.Matrix3 = "matrix3", e.Matrix4 = "matrix4", e.Quaternion = "quaternion", e.Color = "color", e.Entity = "entity", e.Component = "component", e.Asset = "asset", e.Button = "button", e.Enum = "enum", e.Nested = "nested"
    }(ee || (ee = {}));
    var oe = function (e) {
        function t(e, t, n, r) {
            void 0 === n && (n = null), void 0 === r && (r = !1);
            return this.name = e, this.editType = t, this.option = n || void 0, this.isArray = r, this
        }

        return a(t, DebuggerClass), t
    }();

    function ae(e) {
        return function (t) {
            t.__customEditableProperties__ = e
        }
    }

    function se(e, t, n) {
        return void 0 === t && (t = null), void 0 === n && (n = !1), function (r, o) {
            r.hasOwnProperty("__editableProperties__") || (r.__editableProperties__ = []);
            var a = r.__editableProperties__;
            void 0 !== e && (t && t.componentClass && (t.componentClass = i.Reflect.getQualifiedClassName(t.componentClass)), a.push(new oe(o, e, t, n)))
        }
    }

    function le(e) {
        var t = [];
        for (var n in e) isNaN(Number(n)) && t.push({label: n, value: e[n]});
        return t
    }

    __reflect(oe, "@egret/core/PropertyInfo")
}, function (e, t, n) {
    "use strict";
    n.r(t), function (e) {
        n.d(t, "Application", (function () {
            return ge
        })), n.d(t, "BasicApplication", (function () {
            return Je
        })), n.d(t, "Behaviour", (function () {
            return Me
        })), n.d(t, "Box", (function () {
            return Q
        })), n.d(t, "Capsule", (function () {
            return te
        })), n.d(t, "Circle", (function () {
            return Y
        })), n.d(t, "Clock", (function () {
            return Re
        })), n.d(t, "ColliderType", (function () {
            return a
        })), n.d(t, "Color", (function () {
            return G
        })), n.d(t, "ComponentType", (function () {
            return se
        })), n.d(t, "Const", (function () {
            return r
        })), n.d(t, "ConstString", (function () {
            return de
        })), n.d(t, "CubicBezierCurve3", (function () {
            return oe
        })), n.d(t, "Curve", (function () {
            return ie
        })), n.d(t, "CurvePath", (function () {
            return fe
        })), n.d(t, "EgretProUtil", (function () {
            return _e
        })), n.d(t, "EngineFactory", (function () {
            return tt
        })), n.d(t, "EngineUtil", (function () {
            return $e
        })), n.d(t, "EntityModel", (function () {
            return Ae
        })), n.d(t, "EntityModelAssetEntity", (function () {
            return De
        })), n.d(t, "EntityModelLoader", (function () {
            return He
        })), n.d(t, "EulerOrder", (function () {
            return i
        })), n.d(t, "ExecuteMode", (function () {
            return he
        })), n.d(t, "Frustum", (function () {
            return ne
        })), n.d(t, "FrustumCone", (function () {
            return ee
        })), n.d(t, "GameComponent", (function () {
            return me
        })), n.d(t, "GameDeserializer", (function () {
            return Ve
        })), n.d(t, "GameEntity", (function () {
            return Ne
        })), n.d(t, "GameEntityFactory", (function () {
            return et
        })), n.d(t, "GameEntityUtil", (function () {
            return nt
        })), n.d(t, "GameSerializer", (function () {
            return ke
        })), n.d(t, "GlobalEntity", (function () {
            return Ue
        })), n.d(t, "Helpers", (function () {
            return Le
        })), n.d(t, "ImageLoader", (function () {
            return je
        })), n.d(t, "JointType", (function () {
            return s
        })), n.d(t, "KeepModelInfoMode", (function () {
            return Pe
        })), n.d(t, "MathUtil", (function () {
            return T
        })), n.d(t, "Matrix2D", (function () {
            return B
        })), n.d(t, "Matrix3", (function () {
            return g
        })), n.d(t, "Matrix4", (function () {
            return I
        })), n.d(t, "NodeLayer", (function () {
            return ce
        })), n.d(t, "NodeNames", (function () {
            return le
        })), n.d(t, "NodeTags", (function () {
            return ue
        })), n.d(t, "Plane", (function () {
            return q
        })), n.d(t, "PrefabDeserializer", (function () {
            return Ge
        })), n.d(t, "PrefabSerializer", (function () {
            return Be
        })), n.d(t, "Quaternion", (function () {
            return V
        })), n.d(t, "Ray", (function () {
            return j
        })), n.d(t, "RaycastInfo", (function () {
            return H
        })), n.d(t, "Rectangle", (function () {
            return X
        })), n.d(t, "RigidbodyType", (function () {
            return o
        })), n.d(t, "Scene", (function () {
            return be
        })), n.d(t, "SceneManager", (function () {
            return Ie
        })), n.d(t, "Screen", (function () {
            return Oe
        })), n.d(t, "Signals", (function () {
            return we
        })), n.d(t, "Sphere", (function () {
            return $
        })), n.d(t, "Spherical", (function () {
            return re
        })), n.d(t, "Stage", (function () {
            return ve
        })), n.d(t, "SystemManager", (function () {
            return Fe
        })), n.d(t, "SystemOrder", (function () {
            return pe
        })), n.d(t, "TestPointInfo", (function () {
            return W
        })), n.d(t, "Transform", (function () {
            return Se
        })), n.d(t, "TreeNode", (function () {
            return ye
        })), n.d(t, "Triangle", (function () {
            return Z
        })), n.d(t, "Vector2", (function () {
            return f
        })), n.d(t, "Vector3", (function () {
            return E
        })), n.d(t, "Vector4", (function () {
            return L
        })), n.d(t, "_TransformNeedUpdate", (function () {
            return xe
        })), n.d(t, "_helpBoxA", (function () {
            return J
        })), n.d(t, "_helpMatrix3A", (function () {
            return v
        })), n.d(t, "_helpMatrix3B", (function () {
            return y
        })), n.d(t, "_helpMatrix3C", (function () {
            return b
        })), n.d(t, "_helpMatrix3D", (function () {
            return x
        })), n.d(t, "_helpMatrix4A", (function () {
            return z
        })), n.d(t, "_helpMatrix4B", (function () {
            return U
        })), n.d(t, "_helpMatrix4C", (function () {
            return F
        })), n.d(t, "_helpMatrix4D", (function () {
            return k
        })), n.d(t, "_helpVector2A", (function () {
            return _
        })), n.d(t, "_helpVector3A", (function () {
            return C
        })), n.d(t, "_helpVector3B", (function () {
            return S
        })), n.d(t, "_helpVector3C", (function () {
            return M
        })), n.d(t, "_helpVector3D", (function () {
            return A
        })), n.d(t, "_helpVector3E", (function () {
            return O
        })), n.d(t, "_helpVector3F", (function () {
            return w
        })), n.d(t, "_helpVector3G", (function () {
            return R
        })), n.d(t, "_helpVector3H", (function () {
            return P
        }));
        var r, i, o, a, s, l = n(3), u = n(0), c = n(2);
        !function (e) {
            e[e.PI = 3.141592653589793] = "PI", e[e.PI_HALF = 1.5707963267948966] = "PI_HALF", e[e.PI_QUARTER = .7853981633974483] = "PI_QUARTER", e[e.PI_DOUBLE = 6.283185307179586] = "PI_DOUBLE", e[e.RAD_DEG = 57.29577951308232] = "RAD_DEG", e[e.DEG_RAD = .017453292519943295] = "DEG_RAD", e[e.EPSILON = 2220446049250313e-31] = "EPSILON", e[e.SQRT_2 = 1.4142135623731] = "SQRT_2", e[e.SQRT1_2 = .70710678118655] = "SQRT1_2"
        }(r || (r = {})), function (e) {
            e[e.XYZ = 1] = "XYZ", e[e.XZY = 2] = "XZY", e[e.YXZ = 3] = "YXZ", e[e.YZX = 4] = "YZX", e[e.ZXY = 5] = "ZXY", e[e.ZYX = 6] = "ZYX"
        }(i || (i = {})), function (e) {
            e[e.Static = 0] = "Static", e[e.Kinematic = 1] = "Kinematic", e[e.Dynamic = 2] = "Dynamic"
        }(o || (o = {})), function (e) {
            e[e.Box = 0] = "Box", e[e.Sphere = 1] = "Sphere", e[e.FrustumCone = 2] = "FrustumCone", e[e.Cylinder = 3] = "Cylinder", e[e.Cone = 4] = "Cone", e[e.Capsule = 5] = "Capsule", e[e.ConvexHull = 6] = "ConvexHull", e[e.Mesh = 7] = "Mesh"
        }(a || (a = {})), function (e) {
            e[e.Prismatic = 0] = "Prismatic", e[e.Revolute = 1] = "Revolute", e[e.Cylindrical = 2] = "Cylindrical", e[e.Spherical = 3] = "Spherical", e[e.Universal = 4] = "Universal", e[e.ConeTwist = 5] = "ConeTwist"
        }(s || (s = {}));
        /*! *****************************************************************************
Copyright (c) Microsoft Corporation. All rights reserved.
Licensed under the Apache License, Version 2.0 (the "License"); you may not use
this file except in compliance with the License. You may obtain a copy of the
License at http://www.apache.org/licenses/LICENSE-2.0

THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED
WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,
MERCHANTABLITY OR NON-INFRINGEMENT.

See the Apache Version 2.0 License for specific language governing permissions
and limitations under the License.
***************************************************************************** */
        var p = function (e, t) {
            return (p = Object.setPrototypeOf || {__proto__: []} instanceof Array && function (e, t) {
                e.__proto__ = t
            } || function (e, t) {
                for (var n in t) t.hasOwnProperty(n) && (e[n] = t[n])
            })(e, t)
        };

        function d(e, t) {
            function n() {
                this.constructor = e
            }

            p(e, t), e.prototype = null === t ? Object.create(t) : (n.prototype = t.prototype, new n)
        }

        function h(e, t, n, r) {
            var i, o = arguments.length, a = o < 3 ? t : null === r ? r = Object.getOwnPropertyDescriptor(t, n) : r;
            if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) a = Reflect.decorate(e, t, n, r); else for (var s = e.length - 1; s >= 0; s--) (i = e[s]) && (a = (o < 3 ? i(a) : o > 3 ? i(t, n, a) : i(t, n)) || a);
            return o > 3 && a && Object.defineProperty(t, n, a), a
        }

        var f = function (e) {
            function t() {
                var t = null !== e && e.apply(this, arguments) || this;
                return t.x = 0, t.y = 0, t.updater = null, t
            }

            var n;
            return d(t, e), n = t, t.create = function (e, t) {
                void 0 === e && (e = 0), void 0 === t && (t = 0);
                var n = l.Pool.getPool(this, !0).borrow();
                return n.initialize(), n.set(e, t)
            }, t.dot = function (e, t) {
                return e.x * t.x + e.y * t.y
            }, t.normalize = function (e, t) {
                void 0 === t && (t = n.LEFT);
                var r = e.x, i = e.y, o = Math.sqrt(r * r + i * i);
                o > 2220446049250313e-31 ? (o = 1 / o, e.x = r * o, e.y = i * o) : (e.x = t.x, e.y = t.y)
            }, t.getDistance = function (e, t) {
                return m.subtract(e, t).length
            }, t.prototype.uninitialize = function () {
                this.updater = null
            }, t.prototype.serialize = function () {
                return this.toArray([0, 0])
            }, t.prototype.deserialize = function (e) {
                return this.fromArray(e)
            }, t.prototype.copy = function (e) {
                return this.set(e.x, e.y)
            }, t.prototype.clone = function () {
                return (new n).set(this.x, this.y)
            }, t.prototype.set = function (e, t) {
                return this.x = e, this.y = t, this
            }, t.prototype.clear = function () {
                return this.x = this.y = 0, this
            }, t.prototype.fromArray = function (e, t) {
                return void 0 === t && (t = 0), this.x = e[t], this.y = e[t + 1], this
            }, t.prototype.toArray = function (e, t) {
                return void 0 === t && (t = 0), e[t] = this.x, e[t + 1] = this.y, e
            }, t.prototype.equal = function (e, t) {
                return void 0 === t && (t = 2220446049250313e-31), Math.abs(this.x - e.x) <= t && Math.abs(this.y - e.y) <= t
            }, t.prototype.normalize = function (e, t) {
                void 0 === e && (e = null), void 0 === t && (t = n.RIGHT), null === e && (e = this);
                var r = e.x, i = e.y, o = Math.sqrt(r * r + i * i);
                return o > 2220446049250313e-31 ? (o = 1 / o, this.x = r * o, this.y = i * o) : this.copy(t), this
            }, t.prototype.negate = function (e) {
                return void 0 === e && (e = null), null === e && (e = this), this.x = -e.x, this.y = -e.y, this
            }, t.prototype.add = function (e, t) {
                return void 0 === t && (t = null), null === t && (t = e, e = this), this.x = e.x + t.x, this.y = e.y + t.y, this
            }, t.prototype.subtract = function (e, t) {
                return void 0 === t && (t = null), null === t && (t = e, e = this), this.x = e.x - t.x, this.y = e.y - t.y, this
            }, t.prototype.multiply = function (e, t) {
                return void 0 === t && (t = null), null === t && (t = e, e = this), this.x = e.x * t.x, this.y = e.y * t.y, this
            }, t.prototype.divide = function (e, t) {
                return void 0 === t && (t = null), null === t && (t = e, e = this), 0 === t.x || t.y, this.x = e.x / t.x, this.y = e.y / t.y, this
            }, t.prototype.addScalar = function (e, t) {
                return void 0 === t && (t = null), null === t && (t = this), this.x = t.x + e, this.y = t.y + e, this
            }, t.prototype.multiplyScalar = function (e, t) {
                return void 0 === t && (t = null), null === t && (t = this), this.x = t.x * e, this.y = t.y * e, this
            }, t.prototype.lerp = function (e, t, n) {
                return void 0 === n && (n = 0), "number" == typeof t && (n = t, t = e, e = this), this.x = e.x + (t.x - e.x) * n, this.y = e.y + (t.y - e.y) * n, this
            }, t.prototype.min = function (e, t) {
                return void 0 === t && (t = null), null === t && (t = e, e = this), this.x = Math.min(e.x, t.x), this.y = Math.min(e.y, t.y), this
            }, t.prototype.max = function (e, t) {
                return void 0 === t && (t = null), null === t && (t = e, e = this), this.x = Math.max(e.x, t.x), this.y = Math.max(e.y, t.y), this
            }, t.prototype.clamp = function (e, t, n) {
                return void 0 === n && (n = null), null === n && (n = this), (e.x > t.x || e.y > t.y) && console.warn("Invalid arguments."), this.x = Math.max(e.x, Math.min(t.x, n.x)), this.y = Math.max(e.y, Math.min(t.y, n.y)), this
            }, t.prototype.reflect = function (e, t) {
                return void 0 === t && (t = null), null === t && (t = this), this.subtract(t, m.multiplyScalar(2 * n.dot(t, e), e))
            }, t.prototype.applyMatrix = function (e, t) {
                void 0 === t && (t = null), null === t && (t = this);
                var n = t.x, r = t.y, i = e.rawData;
                return this.x = i[0] * n + i[2] * r + i[4], this.y = i[1] * n + i[3] * r + i[5], this
            }, t.prototype.applyMatrixDelta = function (e, t) {
                void 0 === t && (t = null), null === t && (t = this);
                var n = t.x, r = t.y, i = e.rawData;
                return this.x = i[0] * n + i[2] * r, this.y = i[1] * n + i[3] * r, this
            }, t.prototype.dot = function (e) {
                return this.x * e.x + this.y * e.y
            }, t.prototype.getAngle = function (e) {
                var t = this.squaredLength * e.squaredLength;
                if (t < 2220446049250313e-31) return 0;
                var n = this.dot(e) / Math.sqrt(t);
                return Math.acos(Math.max(-1, Math.min(1, n)))
            }, t.prototype.getSquaredDistance = function (e) {
                return m.subtract(e, this).squaredLength
            }, t.prototype.getDistance = function (e) {
                return m.subtract(e, this).length
            }, Object.defineProperty(t.prototype, "length", {
                get: function () {
                    var e = this.x, t = this.y;
                    return Math.sqrt(e * e + t * t)
                }, enumerable: !0, configurable: !0
            }), Object.defineProperty(t.prototype, "squaredLength", {
                get: function () {
                    var e = this.x, t = this.y;
                    return e * e + t * t
                }, enumerable: !0, configurable: !0
            }), t.ZERO = (new n).set(0, 0), t.ONE = (new n).set(1, 1), t.MINUS_ONE = (new n).set(-1, -1), t.UP = (new n).set(0, -1), t.DOWN = (new n).set(0, 1), t.LEFT = (new n).set(-1, 0), t.RIGHT = (new n).set(1, 0), t = n = h([Object(l.pool)()], t)
        }(l.Releasable);
        __reflect(f, "@egret/engine/Vector2");
        var m = f.create(), _ = f.create(), g = function (e) {
            function t() {
                var t = null !== e && e.apply(this, arguments) || this;
                return t.rawData = null, t
            }

            var n;
            return d(t, e), n = t, t.create = function (e, t) {
                void 0 === e && (e = null), void 0 === t && (t = 0);
                var n = l.Pool.getPool(this, !0).borrow();
                return n.initialize(e, t), n
            }, t.prototype.initialize = function (t, n) {
                void 0 === t && (t = null), void 0 === n && (n = 0), e.prototype.initialize.call(this);
                var r = this.rawData;
                return null !== t ? this.rawData = new Float32Array(t, n, 9) : null === r && (this.rawData = new Float32Array(9)), this.identity(), this
            }, t.prototype.serialize = function () {
                var e = this.rawData;
                return [e[0], e[1], e[2], e[3], e[4], e[5], e[6], e[7], e[8]]
            }, t.prototype.deserialize = function (e) {
                return this.fromArray(e)
            }, t.prototype.copy = function (e) {
                return this.fromArray(e.rawData)
            }, t.prototype.clone = function () {
                return n.create().copy(this)
            }, t.prototype.set = function (e, t, n, r, i, o, a, s, l) {
                var u = this.rawData;
                return u[0] = e, u[3] = t, u[6] = n, u[1] = r, u[4] = i, u[7] = o, u[2] = a, u[5] = s, u[8] = l, this
            }, t.prototype.identity = function () {
                var e = this.rawData;
                return e[0] = 1, e[3] = 0, e[6] = 0, e[1] = 0, e[4] = 1, e[7] = 0, e[2] = 0, e[5] = 0, e[8] = 1, this
            }, t.prototype.fromArray = function (e, t) {
                void 0 === t && (t = 0);
                var n = this.rawData;
                return n[0] = e[t++], n[1] = e[t++], n[2] = e[t++], n[3] = e[t++], n[4] = e[t++], n[5] = e[t++], n[6] = e[t++], n[7] = e[t++], n[8] = e[t++], this
            }, t.prototype.toArray = function (e, t) {
                void 0 === t && (t = 0);
                for (var n = this.rawData, r = 0; r < 9; ++r) e[r + t] = n[r];
                return e
            }, t.prototype.fromScale = function (e) {
                var t = this.rawData;
                return t[0] = e.x, t[3] = 0, t[6] = 0, t[1] = 0, t[4] = e.y, t[7] = 0, t[2] = 0, t[5] = 0, t[8] = e.z, this
            }, t.prototype.fromUVTransform = function (e, t, n, r, i, o, a) {
                void 0 === i && (i = 0), void 0 === o && (o = 0), void 0 === a && (a = 0);
                var s = Math.cos(i), l = Math.sin(i);
                return this.set(n * s, n * l, -n * (s * o + l * a) + o + e, -r * l, r * s, -r * (-l * o + s * a) + a + t, 0, 0, 1)
            }, t.prototype.fromMatrix4 = function (e) {
                var t = e.rawData;
                return this.set(t[0], t[4], t[8], t[1], t[5], t[9], t[2], t[6], t[10]), this
            }, t.prototype.fromAxis = function (e, t) {
                var n = Math.cos(t), r = Math.sin(t), i = 1 - n, o = e.x, a = e.y, s = e.z, l = i * o, u = i * a;
                return this.set(l * o + n, l * a - r * s, l * s + r * a, l * a + r * s, u * a + n, u * s - r * o, l * s - r * a, u * s + r * o, i * s * s + n)
            }, t.prototype.getNormalMatrix = function (e) {
                return this.fromMatrix4(e).inverse().transpose()
            }, t.prototype.transpose = function (e) {
                void 0 === e && (e = null), null === e && (e = this);
                var t = this.rawData, n = e.rawData, r = 0;
                return r = n[1], t[1] = n[3], t[3] = r, r = n[2], t[2] = n[6], t[6] = r, r = n[5], t[5] = n[7], t[7] = r, this
            }, t.prototype.inverse = function (e) {
                void 0 === e && (e = null), null === e && (e = this);
                var t = e.rawData, n = t[0], r = t[3], i = t[6], o = t[1], a = t[4], s = t[7], l = t[2], u = t[5],
                    c = t[8], p = c * a - u * s, d = u * i - c * r, h = s * r - a * i, f = n * p + o * d + l * h;
                if (0 === f) return console.warn("Cannot invert this matrix, the determinant is 0."), this.identity();
                var m = 1 / f, _ = this.rawData;
                return _[0] = p * m, _[1] = (l * s - c * o) * m, _[2] = (u * o - l * a) * m, _[3] = d * m, _[4] = (c * n - l * i) * m, _[5] = (l * r - u * n) * m, _[6] = h * m, _[7] = (o * i - s * n) * m, _[8] = (a * n - o * r) * m, this
            }, t.prototype.multiply = function (e, t) {
                void 0 === t && (t = null), null === t && (t = e, e = this);
                var n = e.rawData, r = t.rawData, i = this.rawData, o = n[0], a = n[3], s = n[6], l = n[1], u = n[4],
                    c = n[7], p = n[2], d = n[5], h = n[8], f = r[0], m = r[3], _ = r[6], g = r[1], v = r[4], y = r[7],
                    b = r[2], x = r[5], T = r[8];
                return i[0] = o * f + a * g + s * b, i[3] = o * m + a * v + s * x, i[6] = o * _ + a * y + s * T, i[1] = l * f + u * g + c * b, i[4] = l * m + u * v + c * x, i[7] = l * _ + u * y + c * T, i[2] = p * f + d * g + h * b, i[5] = p * m + d * v + h * x, i[8] = p * _ + d * y + h * T, this
            }, t.prototype.premultiply = function (e) {
                return this.multiply(e, this)
            }, Object.defineProperty(t.prototype, "determinant", {
                get: function () {
                    var e = this.rawData, t = e[0], n = e[3], r = e[6], i = e[1], o = e[4], a = e[7], s = e[2],
                        l = e[5], u = e[8];
                    return t * o * u - t * l * a - i * n * u + i * l * r + s * n * a - s * o * r
                }, enumerable: !0, configurable: !0
            }), t.IDENTITY = (new n).initialize(), t = n = h([Object(l.pool)()], t)
        }(l.Releasable);
        __reflect(g, "@egret/engine/Matrix3");
        var v = g.create(), y = g.create(), b = g.create(), x = g.create(), T = function (e) {
            function t() {
                return null !== e && e.apply(this, arguments) || this
            }

            return d(t, e), t.euclideanModulo = function (e, t) {
                return (e % t + t) % t
            }, t.clamp = function (e, t, n) {
                return void 0 === t && (t = 0), void 0 === n && (n = 1), e < t ? t : e > n ? n : e
            }, t.lerp = function (e, t, n) {
                return e + (t - e) * n
            }, t.inverseLerp = function (e, t, n) {
                return (n - e) / (t - e)
            }, t.isPowerOfTwo = function (e) {
                return 0 == (e & e - 1) && 0 !== e
            }, t.ceilPowerOfTwo = function (e) {
                return Math.pow(2, Math.ceil(Math.log(e) / Math.LN2))
            }, t.floorPowerOfTwo = function (e) {
                return Math.pow(2, Math.floor(Math.log(e) / Math.LN2))
            }, t.normalizeRadian = function (e) {
                return e = (e + 3.141592653589793) % 6.283185307179586, e += e > 0 ? -3.141592653589793 : 3.141592653589793
            }, t
        }(DebuggerClass);
        __reflect(T, "@egret/engine/MathUtil");
        var E = function (e) {
            function t() {
                var t = null !== e && e.apply(this, arguments) || this;
                return t.x = 0, t.y = 0, t.z = 0, t.updater = null, t
            }

            var n;
            return d(t, e), n = t, t.create = function (e, t, n) {
                void 0 === e && (e = 0), void 0 === t && (t = 0), void 0 === n && (n = 0);
                var r = l.Pool.getPool(this, !0).borrow();
                return r.initialize(), r.set(e, t, n)
            }, t.dot = function (e, t) {
                return e.x * t.x + e.y * t.y + e.z * t.z
            }, t.normalize = function (e, t) {
                void 0 === t && (t = n.FORWARD);
                var r = e.x, i = e.y, o = e.z, a = Math.sqrt(r * r + i * i + o * o);
                a > 2220446049250313e-31 ? (a = 1 / a, e.x = r * a, e.y = i * a, e.z = o * a) : (e.x = t.x, e.y = t.y, e.z = t.z)
            }, t.getLength = function (e) {
                var t = e.x, n = e.y, r = e.z;
                return Math.sqrt(t * t + n * n + r * r)
            }, t.getDistance = function (e, t) {
                return A.subtract(e, t).length
            }, t.distanceTo = function (e, t, n, r) {
                void 0 === n && (n = 0), void 0 === r && (r = 0);
                var i = e[n] - t[r], o = e[n + 1] - t[r + 1], a = e[n + 2] - t[r + 2];
                return Math.sqrt(i * i + o * o + a * a)
            }, t.prototype.uninitialize = function () {
                this.updater = null
            }, t.prototype.serialize = function () {
                return this.toArray([0, 0, 0])
            }, t.prototype.deserialize = function (e) {
                return this.fromArray(e)
            }, t.prototype.copy = function (e) {
                return this.set(e.x, e.y, e.z)
            }, t.prototype.clone = function () {
                return n.create(this.x, this.y, this.z)
            }, t.prototype.set = function (e, t, n) {
                return this.x = e, this.y = t, this.z = n, this
            }, t.prototype.clear = function () {
                return this.x = this.y = this.z = 0, this
            }, t.prototype.fromArray = function (e, t) {
                return void 0 === t && (t = 0), this.x = e[t], this.y = e[t + 1], this.z = e[t + 2], this
            }, t.prototype.toArray = function (e, t) {
                return void 0 === t && (t = 0), e[t] = this.x, e[t + 1] = this.y, e[t + 2] = this.z, e
            }, t.prototype.fromMatrixPosition = function (e) {
                var t = e.rawData;
                return this.x = t[12], this.y = t[13], this.z = t[14], this.fromArray(e.rawData, 12)
            }, t.prototype.fromMatrixColumn = function (e, t) {
                return this.fromArray(e.rawData, 4 * t)
            }, t.prototype.fromSphericalCoords = function (e, t, n) {
                void 0 === t && (t = 0), void 0 === n && (n = 0), arguments.length > 1 && (n = e.theta, t = e.phi, e = e.radius);
                var r = Math.sin(t) * e;
                return this.x = r * Math.sin(n), this.y = Math.cos(t) * e, this.z = r * Math.cos(n), this
            }, t.prototype.equal = function (e, t) {
                return void 0 === t && (t = 2220446049250313e-31), Math.abs(this.x - e.x) <= t && Math.abs(this.y - e.y) <= t && Math.abs(this.z - e.z) <= t
            }, t.prototype.normalize = function (e, t) {
                void 0 === e && (e = null), void 0 === t && (t = n.FORWARD), null === e && (e = this);
                var r = e.x, i = e.y, o = e.z, a = Math.sqrt(r * r + i * i + o * o);
                return a > 2220446049250313e-31 ? (a = 1 / a, this.x = r * a, this.y = i * a, this.z = o * a) : this.copy(t), this
            }, t.prototype.orthoNormal = function (e) {
                void 0 === e && (e = null), null === e && (e = this);
                var t = e.x, n = e.y, r = e.z;
                if (r > 0 ? r > .70710678118655 : r < .70710678118655) {
                    var i = 1 / Math.sqrt(n * n + r * r);
                    this.x = 0, this.y = -r * i, this.z = n * i
                } else {
                    i = 1 / Math.sqrt(t * t + n * n);
                    this.x = -n * i, this.y = t * i, this.z = 0
                }
                return this
            }, t.prototype.negate = function (e) {
                return void 0 === e && (e = null), null === e && (e = this), this.x = -e.x, this.y = -e.y, this.z = -e.z, this
            }, t.prototype.applyMatrix3 = function (e, t) {
                void 0 === t && (t = null), null === t && (t = this);
                var n = t.x, r = t.y, i = t.z, o = e.rawData;
                return e.constructor === g ? (this.x = o[0] * n + o[3] * r + o[6] * i, this.y = o[1] * n + o[4] * r + o[7] * i, this.z = o[2] * n + o[5] * r + o[8] * i) : (this.x = o[0] * n + o[4] * r + o[8] * i, this.y = o[1] * n + o[5] * r + o[9] * i, this.z = o[2] * n + o[6] * r + o[10] * i), this
            }, t.prototype.applyMatrix = function (e, t) {
                void 0 === t && (t = null), null === t && (t = this);
                var n = t.x, r = t.y, i = t.z, o = e.rawData, a = o[3] * n + o[7] * r + o[11] * i + o[15];
                return a < -2220446049250313e-31 || 2220446049250313e-31 < a ? (a = 1 / a, this.x = (o[0] * n + o[4] * r + o[8] * i + o[12]) * a, this.y = (o[1] * n + o[5] * r + o[9] * i + o[13]) * a, this.z = (o[2] * n + o[6] * r + o[10] * i + o[14]) * a) : (console.warn("Dividing by zero."), this.x = this.y = this.z = 0), this
            }, t.prototype.applyDirection = function (e, t) {
                void 0 === t && (t = null), null === t && (t = this);
                var n = t.x, r = t.y, i = t.z, o = e.rawData;
                return this.x = o[0] * n + o[4] * r + o[8] * i, this.y = o[1] * n + o[5] * r + o[9] * i, this.z = o[2] * n + o[6] * r + o[10] * i, this.normalize()
            }, t.prototype.applyQuaternion = function (e, t) {
                void 0 === t && (t = null), null === t && (t = this);
                var n = t.x, r = t.y, i = t.z, o = e.rawData[0], a = e.rawData[1], s = e.rawData[2], l = e.rawData[3],
                    u = l * n + a * i - s * r, c = l * r + s * n - o * i, p = l * i + o * r - a * n,
                    d = -o * n - a * r - s * i;
                return this.x = u * l + d * -o + c * -s - p * -a, this.y = c * l + d * -a + p * -o - u * -s, this.z = p * l + d * -s + u * -a - c * -o, this
            }, t.prototype.add = function (e, t) {
                return void 0 === t && (t = null), null === t && (t = e, e = this), this.x = e.x + t.x, this.y = e.y + t.y, this.z = e.z + t.z, this
            }, t.prototype.subtract = function (e, t) {
                return void 0 === t && (t = null), null === t && (t = e, e = this), this.x = e.x - t.x, this.y = e.y - t.y, this.z = e.z - t.z, this
            }, t.prototype.multiply = function (e, t) {
                return void 0 === t && (t = null), null === t && (t = e, e = this), this.x = e.x * t.x, this.y = e.y * t.y, this.z = e.z * t.z, this
            }, t.prototype.divide = function (e, t) {
                return void 0 === t && (t = null), null === t && (t = e, e = this), 0 !== t.x && 0 !== t.y && 0 !== t.z || console.warn("Dividing by zero."), this.x = e.x / t.x, this.y = e.y / t.y, this.z = e.z / t.z, this
            }, t.prototype.cross = function (e, t) {
                void 0 === t && (t = null), null === t && (t = e, e = this);
                var n = e.x, r = e.y, i = e.z, o = t.x, a = t.y, s = t.z;
                return this.x = r * s - i * a, this.y = i * o - n * s, this.z = n * a - r * o, this
            }, t.prototype.addScalar = function (e, t) {
                return void 0 === t && (t = null), null === t && (t = this), this.x = t.x + e, this.y = t.y + e, this.z = t.z + e, this
            }, t.prototype.multiplyScalar = function (e, t) {
                return void 0 === t && (t = null), null === t && (t = this), this.x = t.x * e, this.y = t.y * e, this.z = t.z * e, this
            }, t.prototype.lerp = function (e, t, n) {
                return void 0 === n && (n = 0), arguments.length < 3 && (n = t, t = e, e = this), this.x = e.x + (t.x - e.x) * n, this.y = e.y + (t.y - e.y) * n, this.z = e.z + (t.z - e.z) * n, this
            }, t.prototype.slerp = function (e, t, r) {
                void 0 === r && (r = 0), arguments.length < 3 && (r = t, t = e, e = this);
                var i = n.getLength(e), o = n.getLength(t);
                if (i < 2220446049250313e-31 || o < 2220446049250313e-31) return this.lerp(e, t, r);
                var a = n.dot(e, t) / (i * o);
                if (a > .9999999999999998) return this.lerp(e, t, r);
                var s = T.lerp(i, o, r);
                if (a < -.9999999999999998) {
                    var l = this.orthoNormal(e);
                    v.fromAxis(l, 3.141592653589793 * r)
                } else {
                    l = this.cross(e, t).normalize();
                    v.fromAxis(l, Math.acos(a) * r)
                }
                return this.multiplyScalar(1 / i, e).applyMatrix3(v).multiplyScalar(s), this
            }, t.prototype.min = function (e, t) {
                return void 0 === t && (t = null), null === t && (t = e, e = this), this.x = Math.min(e.x, t.x), this.y = Math.min(e.y, t.y), this.z = Math.min(e.z, t.z), this
            }, t.prototype.max = function (e, t) {
                return void 0 === t && (t = null), null === t && (t = e, e = this), this.x = Math.max(e.x, t.x), this.y = Math.max(e.y, t.y), this.z = Math.max(e.z, t.z), this
            }, t.prototype.clamp = function (e, t, n) {
                return void 0 === n && (n = null), null === n && (n = this), (e.x > t.x || e.y > t.y || e.z > t.z) && console.warn("Invalid arguments."), this.x = Math.max(e.x, Math.min(t.x, n.x)), this.y = Math.max(e.y, Math.min(t.y, n.y)), this.z = Math.max(e.z, Math.min(t.z, n.z)), this
            }, t.prototype.reflect = function (e, t) {
                return void 0 === t && (t = null), null === t && (t = this), this.subtract(t, A.multiplyScalar(2 * n.dot(t, e), e))
            }, t.prototype.dot = function (e) {
                return this.x * e.x + this.y * e.y + this.z * e.z
            }, t.prototype.getAngle = function (e) {
                var t = this.squaredLength * e.squaredLength;
                if (t < 2220446049250313e-31) return console.warn("Dividing by zero."), 0;
                var n = this.dot(e) / Math.sqrt(t);
                return Math.acos(Math.max(-1, Math.min(1, n)))
            }, t.prototype.getSquaredDistance = function (e) {
                return A.subtract(e, this).squaredLength
            }, t.prototype.getDistance = function (e) {
                return A.subtract(e, this).length
            }, Object.defineProperty(t.prototype, "length", {
                get: function () {
                    var e = this.x, t = this.y, n = this.z;
                    return Math.sqrt(e * e + t * t + n * n)
                }, enumerable: !0, configurable: !0
            }), Object.defineProperty(t.prototype, "squaredLength", {
                get: function () {
                    var e = this.x, t = this.y, n = this.z;
                    return e * e + t * t + n * n
                }, enumerable: !0, configurable: !0
            }), t.ZERO = (new n).set(0, 0, 0), t.ONE = (new n).set(1, 1, 1), t.MINUS_ONE = (new n).set(-1, -1, -1), t.UP = (new n).set(0, 1, 0), t.DOWN = (new n).set(0, -1, 0), t.LEFT = (new n).set(-1, 0, 0), t.RIGHT = (new n).set(1, 0, 0), t.FORWARD = (new n).set(0, 0, 1), t.BACK = (new n).set(0, 0, -1), t = n = h([Object(l.pool)()], t)
        }(l.Releasable);
        __reflect(E, "@egret/engine/Vector3");
        var C = E.create(), S = E.create(), M = E.create(), A = E.create(), O = E.create(), w = E.create(),
            R = E.create(), P = E.create(), L = function (e) {
                function t() {
                    var t = null !== e && e.apply(this, arguments) || this;
                    return t.x = 0, t.y = 0, t.z = 0, t.w = 1, t.updater = null, t
                }

                var n;
                return d(t, e), n = t, t.create = function (e, t, n, r) {
                    void 0 === e && (e = 0), void 0 === t && (t = 0), void 0 === n && (n = 0), void 0 === r && (r = 1);
                    var i = l.Pool.getPool(this, !0).borrow();
                    return i.initialize(), i.set(e, t, n, r)
                }, t.prototype.uninitialize = function () {
                    this.updater = null
                }, t.prototype.serialize = function () {
                    return this.toArray([0, 0, 0, 0])
                }, t.prototype.deserialize = function (e) {
                    return this.fromArray(e)
                }, t.prototype.copy = function (e) {
                    return this.set(e.x, e.y, e.z, e.w)
                }, t.prototype.clone = function () {
                    return n.create(this.x, this.y, this.z, this.w)
                }, t.prototype.set = function (e, t, n, r) {
                    return this.x = e, this.y = t, this.z = n, this.w = r, this
                }, t.prototype.clear = function () {
                    return this.x = this.y = this.z = 0, this.w = 1, this
                }, t.prototype.fromArray = function (e, t) {
                    return void 0 === t && (t = 0), this.x = e[t], this.y = e[t + 1], this.z = e[t + 2], this.w = e[t + 3], this
                }, t.prototype.toArray = function (e, t) {
                    return void 0 === t && (t = 0), e[t] = this.x, e[t + 1] = this.y, e[t + 2] = this.z, e[t + 3] = this.w, e
                }, t.prototype.equal = function (e, t) {
                    return void 0 === t && (t = 2220446049250313e-31), Math.abs(this.x - e.x) <= t && Math.abs(this.y - e.y) <= t && Math.abs(this.z - e.z) <= t && Math.abs(this.w - e.w) <= t
                }, t.prototype.normalize = function (e) {
                    void 0 === e && (e = null), null === e && (e = this);
                    var t = e.x, n = e.y, r = e.z, i = e.w, o = Math.sqrt(t * t + n * n + r * r + i * i);
                    return o > 2220446049250313e-31 ? (o = 1 / o, this.x = t * o, this.y = n * o, this.z = r * o, this.w = i * o) : this.clear(), this
                }, t.prototype.inverse = function (e) {
                    return void 0 === e && (e = null), null === e && (e = this), this.x = -1 * e.x, this.y = -1 * e.y, this.z = -1 * e.z, this.w = e.w, this
                }, t.prototype.subtract = function (e, t) {
                    return void 0 === t && (t = null), null === t && (t = e, e = this), this.x = e.x - t.x, this.y = e.y - t.y, this.z = e.z - t.z, this.w = e.w - t.w, this
                }, t.prototype.multiplyScalar = function (e, t) {
                    return void 0 === t && (t = null), null === t && (t = this), this.x = t.x * e, this.y = t.y * e, this.z = t.z * e, this.w = t.w * e, this
                }, t.prototype.lerp = function (e, t, n) {
                    return void 0 === n && (n = 0), arguments.length < 3 && (n = t, t = e, e = this), this.x = e.x + (t.x - e.x) * n, this.y = e.y + (t.y - e.y) * n, this.z = e.z + (t.z - e.z) * n, this.w = e.w + (t.w - e.w) * n, this
                }, t.prototype.dot = function (e) {
                    return this.x * e.x + this.y * e.y + this.z * e.z + this.w * e.w
                }, t.prototype.getAngle = function (e) {
                    return 2 * Math.acos(Math.abs(T.clamp(this.dot(e), -1, 1)))
                }, t.prototype.getDistance = function (e) {
                    return D.subtract(e, this).length
                }, Object.defineProperty(t.prototype, "length", {
                    get: function () {
                        var e = this.x, t = this.y, n = this.z, r = this.w;
                        return Math.sqrt(e * e + t * t + n * n + r * r)
                    }, enumerable: !0, configurable: !0
                }), Object.defineProperty(t.prototype, "squaredLength", {
                    get: function () {
                        var e = this.x, t = this.y, n = this.z, r = this.w;
                        return e * e + t * t + n * n + r * r
                    }, enumerable: !0, configurable: !0
                }), t = n = h([Object(l.pool)()], t)
            }(l.Releasable);
        __reflect(L, "@egret/engine/Vector4");
        var D = L.create(), I = function (e) {
            function t() {
                var t = null !== e && e.apply(this, arguments) || this;
                return t.rawData = null, t
            }

            var n;
            return d(t, e), n = t, t.create = function (e, t) {
                void 0 === e && (e = null), void 0 === t && (t = 0);
                var n = l.Pool.getPool(this, !0).borrow();
                return n.initialize(e, t), n
            }, t.prototype.initialize = function (t, n) {
                void 0 === t && (t = null), void 0 === n && (n = 0), e.prototype.initialize.call(this);
                var r = this.rawData;
                return null !== t ? this.rawData = new Float32Array(t, n, 16) : null === r && (this.rawData = new Float32Array(16)), this.identity(), this
            }, t.prototype.serialize = function () {
                var e = this.rawData;
                return [e[0], e[1], e[2], e[3], e[4], e[5], e[6], e[7], e[8], e[9], e[10], e[11], e[12], e[13], e[14], e[15]]
            }, t.prototype.deserialize = function (e) {
                return this.fromArray(e)
            }, t.prototype.copy = function (e) {
                return this.fromArray(e.rawData)
            }, t.prototype.clone = function () {
                return n.create().copy(this)
            }, t.prototype.set = function (e, t, n, r, i, o, a, s, l, u, c, p, d, h, f, m) {
                var _ = this.rawData;
                return _[0] = e, _[4] = t, _[8] = n, _[12] = r, _[1] = i, _[5] = o, _[9] = a, _[13] = s, _[2] = l, _[6] = u, _[10] = c, _[14] = p, _[3] = d, _[7] = h, _[11] = f, _[15] = m, this
            }, t.prototype.identity = function () {
                var e = this.rawData;
                return e[0] = 1, e[1] = e[2] = e[3] = 0, e[4] = e[6] = e[7] = 0, e[5] = 1, e[8] = e[9] = e[11] = 0, e[10] = 1, e[12] = e[13] = e[14] = 0, e[15] = 1, this
            }, t.prototype.fromArray = function (e, t) {
                void 0 === t && (t = 0);
                for (var n = 0; n < 16; n++) this.rawData[n] = e[n + t];
                return this
            }, t.prototype.toArray = function (e, t) {
                void 0 === t && (t = 0);
                for (var n = this.rawData, r = 0; r < 16; ++r) e[r + t] = n[r];
                return e
            }, t.prototype.fromTranslate = function (e, t) {
                void 0 === t && (t = !1), t || this.identity();
                var n = this.rawData;
                return n[12] = e.x, n[13] = e.y, n[14] = e.z, this
            }, t.prototype.fromRotation = function (e, t) {
                return void 0 === t && (t = !1), this.compose(t ? C.fromArray(this.rawData, 12) : E.ZERO, e, E.ONE)
            }, t.prototype.fromEuler = function (e, t, n) {
                void 0 === t && (t = 3), void 0 === n && (n = !1);
                var r = Math.cos, i = Math.sin, o = e.x, a = e.y, s = e.z, l = r(o), u = i(o), c = r(a), p = i(a),
                    d = r(s), h = i(s), f = this.rawData;
                switch (t) {
                    case 1:
                        var m = l * d, _ = l * h, g = u * d, v = u * h;
                        f[0] = c * d, f[4] = -c * h, f[8] = p, f[1] = _ + g * p, f[5] = m - v * p, f[9] = -u * c, f[2] = v - m * p, f[6] = g + _ * p, f[10] = l * c;
                        break;
                    case 2:
                        var y = l * c, b = l * p, x = u * c, T = u * p;
                        f[0] = c * d, f[4] = -h, f[8] = p * d, f[1] = y * h + T, f[5] = l * d, f[9] = b * h - x, f[2] = x * h - b, f[6] = u * d, f[10] = T * h + y;
                        break;
                    case 3:
                        var E = c * d, C = c * h, S = p * d, M = p * h;
                        f[0] = E + M * u, f[4] = S * u - C, f[8] = l * p, f[1] = l * h, f[5] = l * d, f[9] = -u, f[2] = C * u - S, f[6] = M + E * u, f[10] = l * c;
                        break;
                    case 4:
                        y = l * c, b = l * p, x = u * c, T = u * p;
                        f[0] = c * d, f[4] = T - y * h, f[8] = x * h + b, f[1] = h, f[5] = l * d, f[9] = -u * d, f[2] = -p * d, f[6] = b * h + x, f[10] = y - T * h;
                        break;
                    case 5:
                        E = c * d, C = c * h, S = p * d, M = p * h;
                        f[0] = E - M * u, f[4] = -l * h, f[8] = S + C * u, f[1] = C + S * u, f[5] = l * d, f[9] = M - E * u, f[2] = -l * p, f[6] = u, f[10] = l * c;
                        break;
                    case 6:
                        m = l * d, _ = l * h, g = u * d, v = u * h;
                        f[0] = c * d, f[4] = g * p - _, f[8] = m * p + v, f[1] = c * h, f[5] = v * p + m, f[9] = _ * p - g, f[2] = -p, f[6] = u * c, f[10] = l * c
                }
                return f[3] = f[7] = f[11] = 0, n || (f[12] = f[13] = f[14] = 0, f[15] = 1), this
            }, t.prototype.toEuler = function (e, t) {
                void 0 === e && (e = null), void 0 === t && (t = 3), null === e && (e = E.create());
                var n = this.rawData, r = n[0], i = n[4], o = n[8], a = n[1], s = n[5], l = n[9], u = n[2], c = n[6],
                    p = n[10], d = .9999999999999998;
                switch (t) {
                    case 1:
                        e.y = Math.asin(T.clamp(o, -1, 1)), Math.abs(o) < d ? (e.x = Math.atan2(-l, p), e.z = Math.atan2(-i, r)) : (e.x = Math.atan2(c, s), e.z = 0);
                        break;
                    case 2:
                        e.z = Math.asin(-T.clamp(i, -1, 1)), Math.abs(i) < d ? (e.x = Math.atan2(c, s), e.y = Math.atan2(o, r)) : (e.x = Math.atan2(-l, p), e.y = 0);
                        break;
                    case 3:
                        e.x = Math.asin(-T.clamp(l, -1, 1)), Math.abs(l) < d ? (e.y = Math.atan2(o, p), e.z = Math.atan2(a, s)) : (e.y = Math.atan2(-u, r), e.z = 0);
                        break;
                    case 4:
                        e.z = Math.asin(T.clamp(a, -1, 1)), Math.abs(a) < d ? (e.x = Math.atan2(-l, s), e.y = Math.atan2(-u, r)) : (e.x = 0, e.y = Math.atan2(o, p));
                        break;
                    case 5:
                        e.x = Math.asin(T.clamp(c, -1, 1)), Math.abs(c) < d ? (e.y = Math.atan2(-u, p), e.z = Math.atan2(-i, s)) : (e.y = 0, e.z = Math.atan2(a, r));
                        break;
                    case 6:
                        e.y = Math.asin(-T.clamp(u, -1, 1)), Math.abs(u) < d ? (e.x = Math.atan2(c, p), e.z = Math.atan2(a, r)) : (e.x = 0, e.z = Math.atan2(-i, s))
                }
                return e
            }, t.prototype.fromScale = function (e, t) {
                void 0 === t && (t = !1), t && C.fromArray(this.rawData, 12), this.identity();
                var n = this.rawData;
                return n[0] = e.x, n[5] = e.y, n[10] = e.z, t && (n[12] = C.x, n[13] = C.y, n[14] = C.z), this
            }, t.prototype.fromRotationX = function (e) {
                var t = Math.cos(e), n = Math.sin(e);
                return this.set(1, 0, 0, 0, 0, t, -n, 0, 0, n, t, 0, 0, 0, 0, 1)
            }, t.prototype.fromRotationY = function (e) {
                var t = Math.cos(e), n = Math.sin(e);
                return this.set(t, 0, n, 0, 0, 1, 0, 0, -n, 0, t, 0, 0, 0, 0, 1)
            }, t.prototype.fromRotationZ = function (e) {
                var t = Math.cos(e), n = Math.sin(e);
                return this.set(t, -n, 0, 0, n, t, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1)
            }, t.prototype.fromAxis = function (e, t) {
                var n = Math.cos(t), r = Math.sin(t), i = 1 - n, o = e.x, a = e.y, s = e.z, l = i * o, u = i * a;
                return this.set(l * o + n, l * a - r * s, l * s + r * a, 0, l * a + r * s, u * a + n, u * s - r * o, 0, l * s - r * a, u * s + r * o, i * s * s + n, 0, 0, 0, 0, 1)
            }, t.prototype.perspectiveProjectMatrix = function (e, t, n, r, i, o) {
                var a = 1 / (t - e), s = 1 / (n - r), l = 1 / (i - o), u = 2 * i, c = this.rawData;
                return c[0] = u * a, c[1] = c[2] = c[3] = 0, c[4] = c[6] = c[7] = 0, c[5] = u * s, c[8] = (t + e) * a, c[9] = (n + r) * s, c[10] = -(i + o) * l, c[11] = 1, c[12] = c[13] = c[15] = 0, c[14] = u * o * l, this
            }, t.prototype.orthographicProjectMatrix = function (e, t, n, r, i, o) {
                var a = 1 / (t - e), s = 1 / (n - r), l = 1 / (i - o), u = this.rawData;
                return u[0] = 2 * a, u[1] = u[2] = u[3] = 0, u[4] = u[6] = u[7] = 0, u[5] = 2 * s, u[8] = u[9] = u[11] = 0, u[10] = -2 * l, u[12] = -(t + e) * a, u[13] = -(n + r) * s, u[14] = (i + o) * l, u[15] = 1, this
            }, t.prototype.fromProjection = function (e, t, n, r, i, o, a, s) {
                void 0 === s && (s = null);
                var l = z;
                a = 1 - a;
                var u = (null !== s ? -s.x : 0) - .5, c = (null !== s ? s.y : 0) + .5, p = null !== s ? s.w : 1,
                    d = null !== s ? s.h : 1;
                if (i > 0) {
                    var h = 2 * e * Math.tan(.5 * n), f = (b = u * (v = o * (y = h))) + (u * (T = h) - b) * a,
                        m = (x = c * y) + (c * (E = T / o) - x) * a, _ = (v + (T - v) * a) * p,
                        g = (y + (E - y) * a) * d;
                    this.perspectiveProjectMatrix(f, f + _, m, m - g, e, t)
                }
                if (i < 1) {
                    f = (b = u * (v = r * o)) + (u * (T = r) - b) * a;
                    var v, y, b, x, T, E, C = (x = c * (y = r)) + (c * (E = r / o) - x) * a;
                    _ = (v + (T - v) * a) * p, g = (y + (E - y) * a) * d;
                    l.orthographicProjectMatrix(f, f + _, C, C - g, e, t)
                }
                return 0 === i ? this.copy(l) : 1 === i || this.lerp(l, this, Math.pow(i, 8)), this
            }, t.prototype.fromAxises = function (e, t, n) {
                return this.set(e.x, t.x, n.x, 0, e.y, t.y, n.y, 0, e.z, t.z, n.z, 0, 0, 0, 0, 1)
            }, t.prototype.compose = function (e, t, n) {
                var r = t.rawData[0], i = t.rawData[1], o = t.rawData[2], a = t.rawData[3], s = n.x, l = n.y, u = n.z,
                    c = r + r, p = i + i, d = o + o, h = r * c, f = r * p, m = r * d, _ = i * p, g = i * d, v = o * d,
                    y = a * c, b = a * p, x = a * d, T = this.rawData;
                return T[0] = (1 - (_ + v)) * s, T[1] = (f + x) * s, T[2] = (m - b) * s, T[4] = (f - x) * l, T[5] = (1 - (h + v)) * l, T[6] = (g + y) * l, T[8] = (m + b) * u, T[9] = (g - y) * u, T[10] = (1 - (h + _)) * u, T[12] = e.x, T[13] = e.y, T[14] = e.z, T[3] = T[7] = T[11] = 0, T[15] = 1, this
            }, t.prototype.decompose = function (e, t, n) {
                void 0 === e && (e = null), void 0 === t && (t = null), void 0 === n && (n = null);
                var r = this.rawData;
                if (null !== e && (e.x = r[12], e.y = r[13], e.z = r[14]), null !== t || null !== n) {
                    var i = C.set(r[0], r[1], r[2]).length, o = C.set(r[4], r[5], r[6]).length,
                        a = C.set(r[8], r[9], r[10]).length;
                    if (this.determinant < 0 && (i = -i), null !== t) {
                        var s = N, l = s.rawData, u = 1 / i, c = 1 / o, p = 1 / a;
                        s.copy(this), l[0] *= u, l[1] *= u, l[2] *= u, l[4] *= c, l[5] *= c, l[6] *= c, l[8] *= p, l[9] *= p, l[10] *= p, t.fromMatrix(s)
                    }
                    null !== n && (n.x = i, n.y = o, n.z = a)
                }
                return this
            }, t.prototype.extractRotation = function (e) {
                void 0 === e && (e = null), null === e && (e = this);
                var t = e.rawData, n = 1 / C.fromMatrixColumn(e, 0).length, r = 1 / C.fromMatrixColumn(e, 1).length,
                    i = 1 / C.fromMatrixColumn(e, 2).length, o = this.rawData;
                return o[0] = t[0] * n, o[1] = t[1] * n, o[2] = t[2] * n, o[3] = 0, o[4] = t[4] * r, o[5] = t[5] * r, o[6] = t[6] * r, o[7] = 0, o[8] = t[8] * i, o[9] = t[9] * i, o[10] = t[10] * i, o[11] = 0, o[12] = o[13] = o[14] = 0, o[15] = 1, this
            }, t.prototype.transpose = function (e) {
                void 0 === e && (e = null), null === e && (e = this);
                var t = e.rawData, n = 0, r = this.rawData;
                return n = t[1], r[1] = t[4], r[4] = n, n = t[2], r[2] = t[8], r[8] = n, n = t[6], r[6] = t[9], r[9] = n, n = t[3], r[3] = t[12], r[12] = n, n = t[7], r[7] = t[13], r[13] = n, n = t[11], r[11] = t[14], r[14] = n, this
            }, t.prototype.inverse = function (e) {
                void 0 === e && (e = null), null === e && (e = this);
                var t = e.rawData, n = t[0], r = t[4], i = t[8], o = t[12], a = t[1], s = t[5], l = t[9], u = t[13],
                    c = t[2], p = t[6], d = t[10], h = t[14], f = t[3], m = t[7], _ = t[11], g = t[15], v = l * p,
                    y = u * p, b = s * d, x = u * d, T = s * h, E = l * h, C = a * d, S = a * h, M = u * c, A = l * c,
                    O = a * p, w = s * c, R = E * m - x * m + y * _ - T * _ - v * g + b * g,
                    P = o * d * m - i * h * m - o * p * _ + r * h * _ + i * p * g - r * d * g,
                    L = i * u * m - o * l * m + o * s * _ - r * u * _ - i * s * g + r * l * g,
                    D = o * v - i * y - o * b + r * x + i * T - r * E, I = n * R + a * P + c * L + f * D;
                if (0 === I) return this.identity();
                var N = 1 / I, z = this.rawData;
                return z[0] = R * N, z[1] = (x * f - E * f - M * _ + S * _ + A * g - C * g) * N, z[2] = (T * f - y * f + M * m - S * m - w * g + O * g) * N, z[3] = (v * f - b * f - A * m + C * m + w * _ - O * _) * N, z[4] = P * N, z[5] = (i * h * f - o * d * f + o * c * _ - n * h * _ - i * c * g + n * d * g) * N, z[6] = (o * p * f - r * h * f - o * c * m + n * h * m + r * c * g - n * p * g) * N, z[7] = (r * d * f - i * p * f + i * c * m - n * d * m - r * c * _ + n * p * _) * N, z[8] = L * N, z[9] = (o * l * f - i * u * f - o * a * _ + n * u * _ + i * a * g - n * l * g) * N, z[10] = (r * u * f - o * s * f + o * a * m - n * u * m - r * a * g + n * s * g) * N, z[11] = (i * s * f - r * l * f - i * a * m + n * l * m + r * a * _ - n * s * _) * N, z[12] = D * N, z[13] = (i * M - o * A + o * C - n * x - i * S + n * E) * N, z[14] = (o * w - r * M - o * O + n * y + r * S - n * T) * N, z[15] = (r * A - i * w + i * O - n * v - r * C + n * b) * N, this
            }, t.prototype.multiply = function (e, t) {
                void 0 === t && (t = null), null === t && (t = e, e = this);
                var n = e.rawData, r = t.rawData, i = this.rawData, o = n[0], a = n[4], s = n[8], l = n[12], u = n[1],
                    c = n[5], p = n[9], d = n[13], h = n[2], f = n[6], m = n[10], _ = n[14], g = n[3], v = n[7],
                    y = n[11], b = n[15], x = r[0], T = r[4], E = r[8], C = r[12], S = r[1], M = r[5], A = r[9],
                    O = r[13], w = r[2], R = r[6], P = r[10], L = r[14], D = r[3], I = r[7], N = r[11], z = r[15];
                return i[0] = o * x + a * S + s * w + l * D, i[4] = o * T + a * M + s * R + l * I, i[8] = o * E + a * A + s * P + l * N, i[12] = o * C + a * O + s * L + l * z, i[1] = u * x + c * S + p * w + d * D, i[5] = u * T + c * M + p * R + d * I, i[9] = u * E + c * A + p * P + d * N, i[13] = u * C + c * O + p * L + d * z, i[2] = h * x + f * S + m * w + _ * D, i[6] = h * T + f * M + m * R + _ * I, i[10] = h * E + f * A + m * P + _ * N, i[14] = h * C + f * O + m * L + _ * z, i[3] = g * x + v * S + y * w + b * D, i[7] = g * T + v * M + y * R + b * I, i[11] = g * E + v * A + y * P + b * N, i[15] = g * C + v * O + y * L + b * z, this
            }, t.prototype.premultiply = function (e) {
                return this.multiply(e, this)
            }, t.prototype.multiplyScalar = function (e, t) {
                void 0 === t && (t = null), null === t && (t = this);
                var n = t.rawData, r = this.rawData;
                return r[0] = n[0] * e, r[1] = n[1] * e, r[2] = n[2] * e, r[3] = n[3] * e, r[4] = n[4] * e, r[5] = n[5] * e, r[6] = n[6] * e, r[7] = n[7] * e, r[8] = n[8] * e, r[9] = n[9] * e, r[10] = n[10] * e, r[11] = n[11] * e, r[12] = n[12] * e, r[13] = n[13] * e, r[14] = n[14] * e, r[15] = n[15] * e, this
            }, t.prototype.lerp = function (e, t, n) {
                void 0 === n && (n = 0), "number" == typeof t && (n = t, t = e, e = this);
                var r = this.rawData;
                if (0 === n) {
                    for (var i = 0; i < 16; i++) r[i] = e.rawData[i];
                    return this
                }
                if (1 === n) {
                    for (i = 0; i < 16; i++) r[i] = t.rawData[i];
                    return this
                }
                for (i = 0; i < 16; i++) {
                    var o = e.rawData[i];
                    r[i] = o + (t.rawData[i] - o) * n
                }
                return this
            }, t.prototype.lookAt = function (e, t, n) {
                return this.lookRotation(C.subtract(t, e), n), this
            }, t.prototype.lookRotation = function (e, t) {
                var n = M.normalize(e), r = C.cross(t, n).normalize(C, E.RIGHT), i = S.cross(n, r), o = this.rawData;
                return o[0] = r.x, o[4] = i.x, o[8] = n.x, o[1] = r.y, o[5] = i.y, o[9] = n.y, o[2] = r.z, o[6] = i.z, o[10] = n.z, this
            }, t.prototype.getRight = function (e) {
                var t = this.rawData, n = 1 / (t[3] + t[15]), r = t[12], i = t[13], o = t[14];
                return e.x = (t[0] + r) * n - r, e.y = (t[1] + i) * n - i, e.z = (t[2] + o) * n - o, E.normalize(e, E.RIGHT), e
            }, t.prototype.getUp = function (e) {
                var t = this.rawData, n = 1 / (t[7] + t[15]), r = t[12], i = t[13], o = t[14];
                return e.x = (t[4] + r) * n - r, e.y = (t[5] + i) * n - i, e.z = (t[6] + o) * n - o, E.normalize(e, E.RIGHT), e
            }, t.prototype.getForward = function (e) {
                var t = this.rawData, n = 1 / (t[11] + t[15]), r = t[12], i = t[13], o = t[14];
                return e.x = (t[8] + r) * n - r, e.y = (t[9] + i) * n - i, e.z = (t[10] + o) * n - o, E.normalize(e, E.RIGHT), e
            }, Object.defineProperty(t.prototype, "determinant", {
                get: function () {
                    var e = this.rawData, t = e[0], n = e[4], r = e[8], i = e[12], o = e[1], a = e[5], s = e[9],
                        l = e[13], u = e[2], c = e[6], p = e[10], d = e[14], h = s * c, f = l * c, m = a * p, _ = l * p,
                        g = a * d, v = s * d, y = o * p, b = o * d, x = l * u, T = s * u, E = o * c, C = a * u;
                    return e[3] * (+i * h - r * f - i * m + n * _ + r * g - n * v) + e[7] * (+t * v - t * _ + i * y - r * b + r * x - i * T) + e[11] * (+t * f - t * g - i * E + n * b + i * C - n * x) + e[15] * (-r * C - t * h + t * m + r * E - n * y + n * T)
                }, enumerable: !0, configurable: !0
            }), Object.defineProperty(t.prototype, "maxScaleOnAxis", {
                get: function () {
                    var e = this.rawData, t = e[0] * e[0] + e[1] * e[1] + e[2] * e[2],
                        n = e[4] * e[4] + e[5] * e[5] + e[6] * e[6], r = e[8] * e[8] + e[9] * e[9] + e[10] * e[10];
                    return Math.sqrt(Math.max(t, n, r))
                }, enumerable: !0, configurable: !0
            }), t.IDENTITY = (new n).initialize(), t = n = h([Object(l.pool)()], t)
        }(l.Releasable);
        __reflect(I, "@egret/engine/Matrix4");
        var N = I.create(), z = I.create(), U = I.create(), F = I.create(), k = I.create(), V = function (e) {
            function t() {
                var t = null !== e && e.apply(this, arguments) || this;
                return t.rawData = null, t.updater = null, t
            }

            var n;
            return d(t, e), n = t, t.create = function (e, t) {
                void 0 === e && (e = null), void 0 === t && (t = 0);
                var n = l.Pool.getPool(this, !0).borrow();
                return n.initialize(e, t), n
            }, t.prototype.initialize = function (t, n) {
                void 0 === t && (t = null), void 0 === n && (n = 0), e.prototype.initialize.call(this);
                var r = this.rawData;
                return null !== t ? this.rawData = new Float32Array(t, n, 4) : null === r && (this.rawData = new Float32Array(4)), this.identity(), this
            }, t.prototype.uninitialize = function () {
                this.updater = null
            }, t.prototype.serialize = function () {
                var e = this.rawData;
                return [e[0], e[1], e[2], e[3]]
            }, t.prototype.deserialize = function (e) {
                return this.fromArray(e)
            }, t.prototype.copy = function (e) {
                return this.rawData.set(e.rawData), this
            }, t.prototype.clone = function () {
                return n.create().copy(this)
            }, t.prototype.set = function (e, t, n, r) {
                var i = this.rawData;
                return i[0] = e, i[1] = t, i[2] = n, i[3] = r, this.normalize()
            }, t.prototype.identity = function () {
                var e = this.rawData;
                return e[0] = e[1] = e[2] = 0, e[3] = 1, this
            }, t.prototype.fromArray = function (e, t) {
                return void 0 === t && (t = 0), this.rawData[0] = e[t++], this.rawData[1] = e[t++], this.rawData[2] = e[t++], this.rawData[3] = e[t++], this.normalize()
            }, t.prototype.toArray = function (e, t) {
                void 0 === t && (t = 0);
                var n = this.rawData;
                return e[t] = n[0], e[t + 1] = n[1], e[t + 2] = n[2], e[t + 3] = n[3], e
            }, t.prototype.fromEuler = function (e, t, n, r) {
                var i, o, a;
                void 0 === r && (r = 3), e.hasOwnProperty("x") ? (i = .5 * e.x, o = .5 * e.y, a = .5 * e.z, r = t || 3) : (i = .5 * e, o = .5 * t, a = .5 * n, r = r || 3);
                var s = Math.cos, l = Math.sin, u = s(i), c = s(o), p = s(a), d = l(i), h = l(o), f = l(a),
                    m = this.rawData;
                switch (r) {
                    case 1:
                        m[0] = d * c * p + u * h * f, m[1] = u * h * p - d * c * f, m[2] = u * c * f + d * h * p, m[3] = u * c * p - d * h * f;
                        break;
                    case 2:
                        m[0] = d * c * p - u * h * f, m[1] = u * h * p - d * c * f, m[2] = u * c * f + d * h * p, m[3] = u * c * p + d * h * f;
                        break;
                    case 3:
                        m[0] = d * c * p + u * h * f, m[1] = u * h * p - d * c * f, m[2] = u * c * f - d * h * p, m[3] = u * c * p + d * h * f;
                        break;
                    case 4:
                        m[0] = d * c * p + u * h * f, m[1] = u * h * p + d * c * f, m[2] = u * c * f - d * h * p, m[3] = u * c * p - d * h * f;
                        break;
                    case 5:
                        m[0] = d * c * p - u * h * f, m[1] = u * h * p + d * c * f, m[2] = u * c * f + d * h * p, m[3] = u * c * p - d * h * f;
                        break;
                    case 6:
                        m[0] = d * c * p - u * h * f, m[1] = u * h * p + d * c * f, m[2] = u * c * f - d * h * p, m[3] = u * c * p + d * h * f
                }
                return this
            }, t.prototype.toEuler = function (e, t) {
                return void 0 === t && (t = 3), z.fromRotation(this).toEuler(e, t)
            }, t.prototype.fromMatrix = function (e) {
                var t = e.rawData, n = t[0], r = t[4], i = t[8], o = t[1], a = t[5], s = t[9], l = t[2], u = t[6],
                    c = t[10], p = n + a + c, d = 0, h = this.rawData;
                return p > 0 ? (d = .5 / Math.sqrt(p + 1), h[0] = (u - s) * d, h[1] = (i - l) * d, h[2] = (o - r) * d, h[3] = .25 / d) : n > a && n > c ? (d = 2 * Math.sqrt(1 + n - a - c), h[0] = .25 * d, h[1] = (r + o) / d, h[2] = (i + l) / d, h[3] = (u - s) / d) : a > c ? (d = 2 * Math.sqrt(1 + a - n - c), h[0] = (r + o) / d, h[1] = .25 * d, h[2] = (s + u) / d, h[3] = (i - l) / d) : (d = 2 * Math.sqrt(1 + c - n - a), h[0] = (i + l) / d, h[1] = (s + u) / d, h[2] = .25 * d, h[3] = (o - r) / d), this.normalize()
            }, t.prototype.fromAxis = function (e, t) {
                var n = .5 * t, r = Math.sin(n), i = this.rawData;
                return i[0] = e.x * r, i[1] = e.y * r, i[2] = e.z * r, i[3] = Math.cos(n), this
            }, t.prototype.fromVectors = function (e, t) {
                var n = E.dot(e, t) + 1, r = C, i = this.rawData;
                return n < 2220446049250313e-31 ? (n = 0, Math.abs(e.x) > Math.abs(e.z) ? r.set(-e.y, e.x, 0) : r.set(0, -e.z, e.y)) : r.cross(e, t), i[0] = r.x, i[1] = r.y, i[2] = r.z, i[3] = n, this.normalize()
            }, t.prototype.equal = function (e, t) {
                void 0 === t && (t = 2220446049250313e-31);
                var n = this.rawData, r = e.rawData;
                return Math.abs(n[0] - r[0]) <= t && Math.abs(n[1] - r[1]) <= t && Math.abs(n[2] - r[2]) <= t && Math.abs(n[3] - r[3]) <= t
            }, t.prototype.normalize = function (e) {
                void 0 === e && (e = null), null === e && (e = this);
                var t = e.rawData, n = t[0], r = t[1], i = t[2], o = t[3], a = Math.sqrt(n * n + r * r + i * i + o * o),
                    s = this.rawData;
                return a > 2220446049250313e-31 ? (a = 1 / a, s[0] = n * a, s[1] = r * a, s[2] = i * a, s[3] = o * a) : this.identity(), this
            }, t.prototype.inverse = function (e) {
                void 0 === e && (e = null), null === e && (e = this);
                var t = this.rawData, n = e.rawData;
                return t[0] = -1 * n[0], t[1] = -1 * n[1], t[2] = -1 * n[2], t[3] = n[3], this
            }, t.prototype.multiply = function (e, t) {
                void 0 === t && (t = null), null === t && (t = e, e = this);
                var n = e.rawData, r = n[0], i = n[1], o = n[2], a = n[3], s = t.rawData, l = s[0], u = s[1], c = s[2],
                    p = s[3], d = this.rawData;
                return d[0] = r * p + a * l + i * c - o * u, d[1] = i * p + a * u + o * l - r * c, d[2] = o * p + a * c + r * u - i * l, d[3] = a * p - r * l - i * u - o * c, this
            }, t.prototype.premultiply = function (e) {
                return this.multiply(e, this)
            }, t.prototype.multiplyScalar = function (e, t) {
                void 0 === t && (t = null), null === t && (t = this);
                var n = this.rawData, r = t.rawData;
                return n[0] = r[0] * e, n[1] = r[1] * e, n[2] = r[2] * e, n[3] = r[3] * e, this
            }, t.prototype.lerp = function (e, t, n) {
                void 0 === n && (n = 0), "number" == typeof t && (n = t, t = e, e = this);
                var r = e.rawData, i = r[0], o = r[1], a = r[2], s = r[3], l = t.rawData, u = l[0], c = l[1], p = l[2],
                    d = l[3], h = this.rawData;
                return i * u + o * c + a * p + s * d < 0 ? (h[0] = i + (-u - i) * n, h[1] = o + (-c - o) * n, h[2] = a + (-p - a) * n, h[3] = s + (-d - s) * n) : (h[0] = i + (u - i) * n, h[1] = o + (c - o) * n, h[2] = a + (p - a) * n, h[3] = s + (d - s) * n), this.normalize()
            }, t.prototype.slerp = function (e, t, n) {
                if (void 0 === n && (n = 0), "number" == typeof t && (n = t, t = e, e = this), 0 === n) return this.copy(e);
                if (1 === n) return this.copy(t);
                var r = e.rawData, i = r[0], o = r[1], a = r[2], s = r[3], l = t.rawData, u = l[0], c = l[1], p = l[2],
                    d = l[3], h = i * u + o * c + a * p + s * d, f = this.rawData;
                if (h < 0 ? (f[0] = -u, f[1] = -c, f[2] = -p, f[3] = -d, h = -h) : (f[0] = u, f[1] = c, f[2] = p, f[3] = d), h >= 1) return f[0] = i, f[1] = o, f[2] = a, f[3] = s, this;
                var m = 1 - h * h;
                if (m < 2220446049250313e-31) return this.lerp(e, this, n);
                var _ = Math.sqrt(m), g = Math.atan2(_, h), v = Math.sin((1 - n) * g) / _, y = Math.sin(n * g) / _;
                return f[0] = i * v + f[0] * y, f[1] = o * v + f[1] * y, f[2] = a * v + f[2] * y, f[3] = s * v + f[3] * y, this
            }, t.prototype.lookAt = function (e, t, n) {
                return this.fromMatrix(z.lookAt(e, t, n))
            }, t.prototype.lookRotation = function (e, t) {
                return this.fromMatrix(z.lookRotation(e, t))
            }, t.prototype.dot = function (e) {
                var t = this.rawData, n = e.rawData;
                return t[0] * n[0] + t[1] * n[1] + t[2] * n[2] + t[3] * n[3]
            }, t.prototype.getAngle = function (e) {
                return 2 * Math.acos(Math.abs(T.clamp(this.dot(e), -1, 1)))
            }, t.IDENTITY = (new n).initialize(), t = n = h([Object(l.pool)()], t)
        }(l.Releasable);
        __reflect(V, "@egret/engine/Quaternion");
        var B = function (e) {
            function t() {
                var t = null !== e && e.apply(this, arguments) || this;
                return t.rawData = null, t
            }

            var n;
            return d(t, e), n = t, t.create = function (e, t) {
                void 0 === e && (e = null), void 0 === t && (t = 0);
                var n = l.Pool.getPool(this, !0).borrow();
                return n.initialize(e, t), n
            }, t.prototype.initialize = function (t, n) {
                void 0 === t && (t = null), void 0 === n && (n = 0), e.prototype.initialize.call(this);
                var r = this.rawData;
                return null !== t ? this.rawData = new Float32Array(t, n, 6) : null === r && (this.rawData = new Float32Array(6)), this.identity(), this
            }, t.prototype.serialize = function () {
                var e = this.rawData;
                return [e[0], e[1], e[2], e[3], e[4], e[5]]
            }, t.prototype.deserialize = function (e) {
                return this.fromArray(e)
            }, t.prototype.copy = function (e) {
                return this.fromArray(e.rawData)
            }, t.prototype.clone = function () {
                return n.create().copy(this)
            }, t.prototype.set = function (e, t, n, r, i, o) {
                var a = this.rawData;
                return a[0] = e, a[1] = t, a[2] = n, a[3] = r, a[4] = i, a[5] = o, this
            }, t.prototype.identity = function () {
                var e = this.rawData;
                return e[0] = 1, e[1] = 0, e[2] = 0, e[3] = 1, e[4] = 0, e[5] = 0, this
            }, t.prototype.fromArray = function (e, t) {
                void 0 === t && (t = 0);
                var n = this.rawData;
                return n[0] = e[t++], n[1] = e[t++], n[2] = e[t++], n[3] = e[t++], n[4] = e[t++], n[5] = e[t++], this
            }, t.prototype.toArray = function (e, t) {
                void 0 === t && (t = 0);
                for (var n = this.rawData, r = 0; r < 6; ++r) e[r + t] = n[r];
                return e
            }, t.prototype.fromTransform = function (e, t, n, r, i, o, a, s) {
                var l, u, c, p;
                return 0 === n ? (l = 1, u = 0) : (l = Math.cos(n), u = Math.sin(n)), 0 === r ? (c = -u, p = l) : (r += n, c = -Math.sin(r), p = Math.cos(r)), 1 !== i && (l *= i, u *= i), 1 !== o && (c *= o, p *= o), 0 === a && 0 === s || (e += -l * a - u * s + a, t += c * a - p * s + s), this.set(l, u, c, p, e, t)
            }, t.prototype.decompose = function (e, t, n) {
                void 0 === e && (e = null), void 0 === t && (t = null), void 0 === n && (n = null);
                var r = this.rawData;
                if (null !== e && (e.x = r[4], e.y = r[5]), null !== t || null !== n) {
                    var i = r[0], o = r[1], a = r[2], s = r[3], l = Math.atan(o / i), u = Math.atan(-a / s),
                        c = -.70710678118655 < l && l < .70710678118655 ? i / Math.cos(l) : o / Math.sin(l),
                        p = -.70710678118655 < u && u < .70710678118655 ? s / Math.cos(u) : -a / Math.sin(u);
                    null !== n ? (n.x = c, n.y = p) : (c < 0 && (l += 3.141592653589793), p < 0 && (u += 3.141592653589793)), null !== t && (t.x = l, t.y = u - l)
                }
                return this
            }, t.prototype.inverse = function (e) {
                void 0 === e && (e = null), null === e && (e = this);
                var t = e.rawData, n = t[0], r = t[1], i = t[2], o = t[3], a = t[4], s = t[5], l = this.rawData;
                if (0 === r && 0 === i) return l[1] = l[2] = 0, 0 === n || 0 === o ? l[0] = l[3] = l[4] = l[5] = 0 : (l[0] = 1 / n, l[3] = 1 / o, l[4] = -l[0] * a, l[5] = -l[3] * s), this;
                var u = n * o + r * -i;
                if (0 === u) return console.warn("Cannot invert this matrix, the determinant is 0."), this.identity();
                var c = 1 / u;
                return l[0] = o * c, l[1] = -r * c, l[2] = -i * c, l[3] = n * c, l[4] = -(l[0] * a + l[2] * s), l[5] = -(l[1] * a + l[3] * s), this
            }, t.prototype.multiply = function (e, t) {
                void 0 === t && (t = null), null === t && (t = e, e = this);
                var n = e.rawData, r = t.rawData, i = this.rawData, o = n[0], a = n[1], s = n[2], l = n[3], u = n[4],
                    c = n[5], p = r[0], d = r[1], h = r[2], f = r[3], m = r[4], _ = r[5], g = p * o, v = 0, y = 0,
                    b = f * l, x = m * o + u, T = _ * l + c;
                return 0 === a && 0 === s || (v += p * a, y += f * s, x += _ * s, T += m * a), 0 === d && 0 === h || (g += d * s, v += d * l, y += h * o, b += h * a), i[0] = g, i[1] = v, i[2] = y, i[3] = b, i[4] = x, i[5] = T, this
            }, t.prototype.premultiply = function (e) {
                return this.multiply(e, this)
            }, t.prototype.transformAngle = function (e) {
                return _.x = Math.cos(e), _.y = Math.sin(e), _.applyMatrixDelta(this), Math.atan2(_.y, _.x)
            }, Object.defineProperty(t.prototype, "determinant", {
                get: function () {
                    var e = this.rawData;
                    return e[0] * e[4] + -e[1] * e[2]
                }, enumerable: !0, configurable: !0
            }), t.IDENTITY = (new n).initialize(), t = n = h([Object(l.pool)()], t)
        }(l.Releasable);
        __reflect(B, "@egret/engine/Matrix2D");
        var G = function (e) {
            function t() {
                var t = null !== e && e.apply(this, arguments) || this;
                return t.r = 1, t.g = 1, t.b = 1, t.a = 1, t
            }

            var n;
            return d(t, e), n = t, t.create = function (e, t, n, r) {
                void 0 === e && (e = 1), void 0 === t && (t = 1), void 0 === n && (n = 1), void 0 === r && (r = 1);
                var i = l.Pool.getPool(this, !0).borrow();
                return i.initialize(), i.set(e, t, n, r)
            }, t.prototype.serialize = function () {
                return this.toArray([0, 0, 0, 0])
            }, t.prototype.deserialize = function (e) {
                return this.fromArray(e)
            }, t.prototype.clone = function () {
                return (new n).set(this.r, this.g, this.b, this.a)
            }, t.prototype.copy = function (e) {
                return this.set(e.r, e.g, e.b, e.a)
            }, t.prototype.set = function (e, t, n, r) {
                return void 0 === r && (r = 1), this.r = e, this.g = t, this.b = n, arguments.length > 3 && (this.a = r), this
            }, t.prototype.fromArray = function (e, t) {
                return void 0 === t && (t = 0), this.r = e[t], this.g = e[t + 1], this.b = e[t + 2], this.a = e[t + 3], this
            }, t.prototype.toArray = function (e, t) {
                return void 0 === t && (t = 0), e[t] = this.r, e[t + 1] = this.g, e[t + 2] = this.b, e[t + 3] = this.a, e
            }, t.prototype.fromHex = function (e, t) {
                return void 0 === t && (t = !1), t ? (this.r = (e >> 32 & 255) / 255, this.g = (e >> 16 & 255) / 255, this.b = (e >> 8 & 255) / 255, this.a = (255 & e) / 255) : (this.r = (e >> 16 & 255) / 255, this.g = (e >> 8 & 255) / 255, this.b = (255 & e) / 255), this
            }, t.prototype.toHex = function (e) {
                return void 0 === e && (e = !1), e ? 255 * this.r << 32 ^ 255 * this.g << 16 ^ 255 * this.b << 8 ^ 255 * this.a << 0 : 255 * this.r << 16 ^ 255 * this.g << 8 ^ 255 * this.b << 0
            }, t.prototype.equal = function (e, t) {
                return void 0 === t && (t = 2220446049250313e-31), Math.abs(this.r - e.r) <= t && Math.abs(this.g - e.g) <= t && Math.abs(this.b - e.b) <= t && Math.abs(this.a - e.a) <= t
            }, t.prototype.multiply = function (e, t) {
                return void 0 === t && (t = null), null === t && (t = e), e = this, this.r = e.r * t.r, this.g = e.g * t.g, this.b = e.b * t.b, this.a = e.a * t.a, this
            }, t.prototype.multiplyScalar = function (e, t) {
                return void 0 === t && (t = null), null === t && (t = this), this.r = t.r * e, this.g = t.g * e, this.b = t.b * e, this.a = t.a * e, this
            }, t.prototype.lerp = function (e, t, n) {
                return void 0 === n && (n = 0), "number" == typeof t && (n = t, t = e, e = this), this.r = e.r + (t.r - e.r) * n, this.g = e.g + (t.g - e.g) * n, this.b = e.b + (t.b - e.b) * n, this.a = e.a + (t.a - e.a) * n, this
            }, t.ZERO = (new n).set(0, 0, 0, 0), t.BLACK = (new n).set(0, 0, 0, 1), t.GRAY = (new n).set(.5, .5, .5, 1), t.WHITE = (new n).set(1, 1, 1, 1), t.RED = (new n).set(1, 0, 0, 1), t.GREEN = (new n).set(0, 1, 0, 1), t.BLUE = (new n).set(0, 0, 1, 1), t.YELLOW = (new n).set(1, 1, 0, 1), t.INDIGO = (new n).set(0, 1, 1, 1), t.PURPLE = (new n).set(1, 0, 1, 1), t = n = h([Object(l.pool)()], t)
        }(l.Releasable);
        __reflect(G, "@egret/engine/Color");
        var j = function (e) {
            function t() {
                var t = null !== e && e.apply(this, arguments) || this;
                return t.origin = E.create(), t.direction = E.create(), t
            }

            var n;
            return d(t, e), n = t, t.create = function (e, t) {
                void 0 === e && (e = E.ZERO), void 0 === t && (t = E.FORWARD);
                var n = l.Pool.getPool(this, !0).borrow();
                return n.initialize(), n.set(e, t)
            }, t.prototype.serialize = function () {
                return this.toArray([0, 0, 0, 0, 0, 0])
            }, t.prototype.deserialize = function (e) {
                return this.fromArray(e)
            }, t.prototype.copy = function (e) {
                return this.set(e.origin, e.direction)
            }, t.prototype.clone = function () {
                return n.create(this.origin, this.direction)
            }, t.prototype.set = function (e, t) {
                return this.origin.copy(e), this.direction.copy(t), this
            }, t.prototype.fromArray = function (e, t) {
                return void 0 === t && (t = 0), this.origin.fromArray(e, t), this.direction.fromArray(e, t + 3), this
            }, t.prototype.toArray = function (e, t) {
                return void 0 === t && (t = 0), this.direction.toArray(this.origin.toArray(e, t), t + 3)
            }, t.prototype.fromPoints = function (e, t) {
                return this.direction.subtract(t, this.origin.copy(e)).normalize(), this
            }, t.prototype.applyMatrix = function (e, t) {
                return void 0 === t && (t = null), null === t && (t = this), this.origin.applyMatrix(e, t.origin), this.direction.applyDirection(e, t.direction), this
            }, t.prototype.getClosestPointToPoint = function (e, t) {
                var n = t !== this.origin ? this.origin : O.copy(this.origin),
                    r = t !== this.direction ? this.direction : w.copy(this.direction), i = t.subtract(e, n).dot(r);
                return i < 0 ? t.copy(n) : t.copy(r).multiplyScalar(i).add(n)
            }, t.prototype.getPointAt = function (e, t) {
                var n = t !== this.origin ? this.origin : O.copy(this.origin),
                    r = t !== this.direction ? this.direction : w.copy(this.direction);
                return t.multiplyScalar(e, r).add(n)
            }, t.prototype.getSquaredDistance = function (e) {
                var t = O.subtract(e, this.origin).dot(this.direction);
                return t < 0 ? this.origin.getSquaredDistance(e) : this.getPointAt(t, O).getSquaredDistance(e)
            }, t.prototype.getDistance = function (e) {
                return Math.sqrt(this.getSquaredDistance(e))
            }, t.prototype.getDistanceToPlane = function (e) {
                var t = this.origin, n = e.normal, r = n.dot(this.direction);
                if (0 === r) return 0 === e.getDistance(t) ? 0 : -1;
                var i = -(t.dot(n) + e.constant) / r;
                return i >= 0 ? i : -1
            }, h([Object(u.property)("vector3")], t.prototype, "origin", void 0), h([Object(u.property)("vector3")], t.prototype, "direction", void 0), t = n = h([Object(l.pool)()], t)
        }(l.Releasable);
        __reflect(j, "@egret/engine/Ray");
        var H = function (e) {
            function t() {
                var t = null !== e && e.apply(this, arguments) || this;
                return t.backfaceCulling = !0, t.modifyNormal = !1, t.subMeshIndex = -1, t.triangleIndex = -1, t.distance = -1, t.position = E.create(), t.coord = f.create(), t.normal = null, t.transform = null, t.collider = null, t.rigidbody = null, t
            }

            return d(t, e), t.create = function () {
                var e = l.Pool.getPool(this, !0).borrow();
                return e.initialize(), e
            }, t.prototype.uninitialize = function () {
                e.prototype.uninitialize.call(this), this.clear()
            }, t.prototype.copy = function (e) {
                return this.subMeshIndex = e.subMeshIndex, this.triangleIndex = e.triangleIndex, this.distance = e.distance, this.position.copy(e.position), this.coord.copy(e.coord), this.normal && e.normal && this.normal.copy(e.normal), this.transform = e.transform, this.collider = e.collider, this.rigidbody = e.rigidbody, this
            }, t.prototype.clear = function () {
                return this.backfaceCulling = !0, this.modifyNormal = !1, this.subMeshIndex = -1, this.triangleIndex = -1, this.distance = -1, this.position.set(0, 0, 0), this.coord.set(0, 0), this.normal = null, this.transform = null, this.collider = null, this.rigidbody = null, this
            }, t = h([Object(l.pool)()], t)
        }(l.Releasable);
        __reflect(H, "@egret/engine/RaycastInfo");
        var W = function (e) {
            function t() {
                var t = null !== e && e.apply(this, arguments) || this;
                return t.transform = null, t.collider = null, t.rigidbody = null, t
            }

            return d(t, e), t
        }(DebuggerClass);
        __reflect(W, "@egret/engine/TestPointInfo");
        var X = function (e) {
            function t() {
                var t = null !== e && e.apply(this, arguments) || this;
                return t.x = 0, t.y = 0, t.w = 0, t.h = 0, t
            }

            var n;
            return d(t, e), n = t, t.create = function (e, t, n, r) {
                void 0 === e && (e = 0), void 0 === t && (t = 0), void 0 === n && (n = 0), void 0 === r && (r = 0);
                var i = l.Pool.getPool(this, !0).borrow();
                return i.initialize(), i.set(e, t, n, r)
            }, t.prototype.serialize = function () {
                return this.toArray([0, 0, 0, 0])
            }, t.prototype.deserialize = function (e) {
                return this.fromArray(e)
            }, t.prototype.copy = function (e) {
                return this.set(e.x, e.y, e.w, e.h)
            }, t.prototype.clone = function () {
                return n.create(this.x, this.y, this.w, this.h)
            }, t.prototype.set = function (e, t, n, r) {
                return this.x = e, this.y = t, this.w = n, this.h = r, this
            }, t.prototype.fromArray = function (e, t) {
                return void 0 === t && (t = 0), this.x = e[t], this.y = e[t + 1], this.w = e[t + 2], this.h = e[t + 3], this
            }, t.prototype.toArray = function (e, t) {
                return void 0 === t && (t = 0), e[t] = this.x, e[t + 1] = this.y, e[t + 2] = this.w, e[t + 3] = this.h, e
            }, t.prototype.multiplyScalar = function (e, t) {
                return void 0 === t && (t = null), null === t && (t = this), this.x = t.x * e, this.y = t.y * e, this.w = t.w * e, this.h = t.h * e, this
            }, t.prototype.contains = function (e) {
                var t = this.x, n = this.y, r = this.x + this.w, i = this.y + this.h;
                if (e.hasOwnProperty("w")) {
                    var o = e.x, a = e.y, s = e.x + e.w, l = e.y + e.h;
                    return t <= o && s <= r && n <= a && l <= i
                }
                return e.x > t && e.x < r && e.y > n && e.y < i
            }, t = n = h([Object(l.pool)()], t)
        }(l.Releasable);
        __reflect(X, "@egret/engine/Rectangle");
        var Y = function (e) {
            function t() {
                var t = null !== e && e.apply(this, arguments) || this;
                return t.radius = 0, t.center = f.create(), t
            }

            var n;
            return d(t, e), n = t, t.create = function (e, t, n) {
                void 0 === e && (e = 0), void 0 === t && (t = 0), void 0 === n && (n = 0);
                var r = l.Pool.getPool(this, !0).borrow();
                return r.initialize(), r.set(e, t, n)
            }, t.prototype.serialize = function () {
                return this.toArray([0, 0, 0])
            }, t.prototype.deserialize = function (e) {
                return this.fromArray(e)
            }, t.prototype.copy = function (e) {
                return this.set(e.center.x, e.center.y, e.radius)
            }, t.prototype.clone = function () {
                return n.create(this.center.x, this.center.y, this.radius)
            }, t.prototype.set = function (e, t, n) {
                return this.center.x = e, this.center.y = t, this.radius = n, this
            }, t.prototype.fromArray = function (e, t) {
                return void 0 === t && (t = 0), this.center.x = e[t], this.center.y = e[t + 1], this.radius = e[t + 2], this
            }, t.prototype.toArray = function (e, t) {
                return void 0 === t && (t = 0), e[t] = this.center.x, e[t + 1] = this.center.y, e[t + 2] = this.radius, e
            }, h([Object(u.property)("float", {minimum: 0})], t.prototype, "radius", void 0), h([Object(u.property)("vector2")], t.prototype, "center", void 0), t = n = h([Object(l.pool)()], t)
        }(l.Releasable);
        __reflect(Y, "@egret/engine/Circle");
        var q = function (e) {
            function t() {
                var t = null !== e && e.apply(this, arguments) || this;
                return t.constant = 0, t.normal = E.create(), t
            }

            var n;
            return d(t, e), n = t, t.create = function (e, t) {
                void 0 === e && (e = E.UP), void 0 === t && (t = 0);
                var n = l.Pool.getPool(this, !0).borrow();
                return n.initialize(), n.set(e, t)
            }, t.prototype.serialize = function () {
                return this.toArray([0, 0, 0, 0])
            }, t.prototype.deserialize = function (e) {
                return this.fromArray(e)
            }, t.prototype.clone = function () {
                return n.create(this.normal, this.constant)
            }, t.prototype.copy = function (e) {
                return this.set(e.normal, e.constant)
            }, t.prototype.set = function (e, t) {
                return this.constant = t, this.normal.copy(e), this
            }, t.prototype.fromArray = function (e, t) {
                return void 0 === t && (t = 0), this.normal.fromArray(e, t), this.constant = e[t + 3], this
            }, t.prototype.toArray = function (e, t) {
                return void 0 === t && (t = 0), (e = this.normal.toArray(e, t))[t + 3] = this.constant, e
            }, t.prototype.fromPoint = function (e, t) {
                return this.constant = -E.dot(t, e), this.normal.copy(t), this
            }, t.prototype.fromPoints = function (e, t, n) {
                var r = M.subtract(n, t).cross(A.subtract(e, t)).normalize();
                return this.fromPoint(e, r), this
            }, t.prototype.normalize = function (e) {
                void 0 === e && (e = null), null === e && (e = this);
                var t = 1 / e.normal.length;
                return this.constant = e.constant * t, this.normal.multiplyScalar(t, e.normal), this
            }, t.prototype.negate = function (e) {
                return void 0 === e && (e = null), null === e && (e = this), this.constant = -e.constant, this.normal.negate(e.normal), this
            }, t.prototype.applyMatrix = function (e, t) {
                void 0 === t && (t = null), null === t && (t = b.getNormalMatrix(e));
                var n = this.getCoplanarPoint(M).applyMatrix(e), r = this.normal.applyMatrix3(t).normalize();
                return this.constant = -n.dot(r), this
            }, t.prototype.getProjectionPoint = function (e, t) {
                var n = this.normal;
                return n = t !== n ? n : M.copy(n), t.multiplyScalar(-this.getDistance(e), n).add(e)
            }, t.prototype.getCoplanarPoint = function (e) {
                var t = this.normal;
                return t = e !== t ? t : M.copy(t), e.multiplyScalar(-this.constant, t)
            }, t.prototype.getDistance = function (e) {
                return this.normal.dot(e) + this.constant
            }, t.prototype.raycast = function (e, t) {
                void 0 === t && (t = null);
                var n = e.getDistanceToPlane(this);
                if (n > 0) {
                    if (null !== t) {
                        var r = t.normal;
                        t.distance = n, e.getPointAt(n, t.position), null !== r && r.copy(this.normal)
                    }
                    return !0
                }
                return !1
            }, t.UP = (new n).set(E.UP, 0), t.DOWN = (new n).set(E.DOWN, 0), t.LEFT = (new n).set(E.BACK, 0), t.RIGHT = (new n).set(E.BACK, 0), t.FORWARD = (new n).set(E.FORWARD, 0), t.BACK = (new n).set(E.BACK, 0), h([Object(u.property)("float", {minimum: 0})], t.prototype, "constant", void 0), h([Object(u.property)("vector3")], t.prototype, "normal", void 0), t = n = h([Object(l.pool)()], t)
        }(l.Releasable);
        __reflect(q, "@egret/engine/Plane");
        var Z = function (e) {
            function t() {
                var t = null !== e && e.apply(this, arguments) || this;
                return t.a = E.create(), t.b = E.create(), t.c = E.create(), t
            }

            var n;
            return d(t, e), n = t, t.create = function (e, t, n) {
                void 0 === e && (e = E.ZERO), void 0 === t && (t = E.ZERO), void 0 === n && (n = E.ZERO);
                var r = l.Pool.getPool(this, !0).borrow();
                return r.initialize(), r.set(e, t, n)
            }, t.getNormal = function (e, t, n, r, i) {
                void 0 === i && (i = E.FORWARD), r.subtract(n, e), r.cross(M.subtract(t, e));
                var o = r.squaredLength;
                return o > 0 ? r.multiplyScalar(1 / Math.sqrt(o)) : r.copy(i)
            }, t.prototype.serialize = function () {
                return this.toArray([0, 0, 0, 0, 0, 0, 0, 0, 0])
            }, t.prototype.deserialize = function (e) {
                return this.fromArray(e)
            }, t.prototype.copy = function (e) {
                return this.set(e.a, e.b, e.c)
            }, t.prototype.clone = function () {
                return n.create(this.a, this.b, this.c)
            }, t.prototype.set = function (e, t, n) {
                return void 0 === e && (e = E.ZERO), void 0 === t && (t = E.ZERO), void 0 === n && (n = E.ZERO), this.a.copy(e), this.b.copy(t), this.c.copy(n), this
            }, t.prototype.fromArray = function (e, t) {
                return void 0 === t && (t = 0), this.a.fromArray(e, t), this.b.fromArray(e, t + 3), this.c.fromArray(e, t + 6), this
            }, t.prototype.toArray = function (e, t) {
                return void 0 === t && (t = 0), this.a.toArray(e, t), this.b.toArray(e, t + 3), this.c.toArray(e, t + 6), e
            }, t.prototype.getCenter = function (e) {
                return e.add(this.a, this.b).add(this.c).multiplyScalar(1 / 3)
            }, t.prototype.getNormal = function (e) {
                return n.getNormal(this.a, this.b, this.c, e)
            }, t.prototype.getPointAt = function (e, t, n) {
                return n.x = T.lerp(this.a.x, this.c.x, e) + T.lerp(0, this.b.x - this.a.x, t), n.y = T.lerp(this.a.y, this.b.y, t) + T.lerp(0, this.c.y - this.a.y, e), n.z = T.lerp(this.a.z, this.c.z, e) + T.lerp(0, this.b.z - this.a.z, t), n
            }, t.prototype.getClosestPointToPoint = function (e, t) {
                var n, r, i = C, o = S, a = M, s = A, l = O, u = w, c = this.a, p = this.b, d = this.c;
                i.subtract(p, c), o.subtract(d, c), s.subtract(e, c);
                var h = i.dot(s), f = o.dot(s);
                if (h <= 0 && f <= 0) return t.copy(c);
                l.subtract(e, p);
                var m = i.dot(l), _ = o.dot(l);
                if (m >= 0 && _ <= m) return t.copy(p);
                var g = h * _ - m * f;
                if (g <= 0 && h >= 0 && m <= 0) return n = h / (h - m), t.multiplyScalar(n, i).add(c);
                u.subtract(e, d);
                var v = i.dot(u), y = o.dot(u);
                if (y >= 0 && v <= y) return t.copy(d);
                var b = v * f - h * y;
                if (b <= 0 && f >= 0 && y <= 0) return r = f / (f - y), t.multiplyScalar(r, o).add(c);
                var x = m * y - v * _;
                if (x <= 0 && _ - m >= 0 && v - y >= 0) return a.subtract(d, p), r = (_ - m) / (_ - m + (v - y)), t.multiplyScalar(r, a).add(p);
                var T = 1 / (x + b + g);
                return n = b * T, r = g * T, t.add(c, o.multiplyScalar(r).add(i.multiplyScalar(n)))
            }, t.prototype.raycast = function (e, t) {
                void 0 === t && (t = null);
                var n = C, r = S, i = M, o = A, a = e.direction, s = e.origin, l = this.a, u = this.b, c = this.c;
                n.subtract(c, l), r.subtract(u, l), o.cross(n, r);
                var p = a.dot(o), d = 1;
                if (p > 0) {
                    if (null === t || t.backfaceCulling) return !1
                } else {
                    if (!(p < 0)) return !1;
                    d = -1, p = -p
                }
                i.subtract(s, l);
                var h = d * a.dot(r.cross(i, r));
                if (h < 0) return !1;
                var f = d * a.dot(n.cross(i));
                if (f < 0) return !1;
                if (h + f > p) return !1;
                var m = -d * i.dot(o);
                return !(m < 0) && (null !== t && (p = 1 / p, t.coord.x = h * p, t.coord.y = f * p, e.getPointAt(t.distance = m * p, t.position), null !== t.normal && t.normal.copy(o)), !0)
            }, Object.defineProperty(t.prototype, "area", {
                get: function () {
                    return O.subtract(this.c, this.a), w.subtract(this.b, this.a), .5 * O.cross(w).length
                }, enumerable: !0, configurable: !0
            }), h([Object(u.property)("vector3")], t.prototype, "a", void 0), h([Object(u.property)("vector3")], t.prototype, "b", void 0), h([Object(u.property)("vector3")], t.prototype, "c", void 0), t = n = h([Object(l.pool)()], t)
        }(l.Releasable);
        __reflect(Z, "@egret/engine/Triangle");
        var K = [E.create(), E.create(), E.create(), E.create(), E.create(), E.create(), E.create(), E.create()],
            Q = function (e) {
                function t() {
                    var t = null !== e && e.apply(this, arguments) || this;
                    return t._dirtyRadius = !0, t._dirtyCenter = !0, t._dirtySize = !0, t._boundingSphereRadius = 0, t._minimum = E.create(Number.MAX_VALUE, Number.MAX_VALUE, Number.MAX_VALUE), t._maximum = E.create(-Number.MAX_VALUE, -Number.MAX_VALUE, -Number.MAX_VALUE), t._center = E.create(), t._size = E.create(), t
                }

                var n;
                return d(t, e), n = t, t.create = function (e, t) {
                    void 0 === e && (e = null), void 0 === t && (t = null);
                    var n = l.Pool.getPool(this, !0).borrow();
                    return n.initialize(), n.set(e, t)
                }, t.prototype._updateValue = function (e) {
                    e === this._center ? this.center = this._center : e === this._size && (this.size = this._size)
                }, t.prototype.initialize = function () {
                    var e = this._updateValue.bind(this);
                    this._center.updater = new l.Updater(this._center, e), this._size.updater = new l.Updater(this._size, e)
                }, t.prototype.serialize = function () {
                    return this.toArray([0, 0, 0, 0, 0, 0])
                }, t.prototype.deserialize = function (e) {
                    return this.fromArray(e)
                }, t.prototype.clone = function () {
                    return n.create(this._minimum, this._maximum)
                }, t.prototype.copy = function (e) {
                    return this.set(e.minimum, e.maximum)
                }, t.prototype.clear = function () {
                    return this._minimum.set(Number.MAX_VALUE, Number.MAX_VALUE, Number.MAX_VALUE), this._maximum.set(-Number.MAX_VALUE, -Number.MAX_VALUE, -Number.MAX_VALUE), this._dirtyCenter = !0, this._dirtyRadius = !0, this._dirtySize = !0, this
                }, t.prototype.set = function (e, t) {
                    return void 0 === e && (e = null), void 0 === t && (t = null), null !== e && e !== this._minimum && this._minimum.copy(e), null !== t && t !== this._maximum && this._maximum.copy(t), this._dirtyCenter = !0, this._dirtyRadius = !0, this._dirtySize = !0, this
                }, t.prototype.fromArray = function (e, t) {
                    return void 0 === t && (t = 0), this._minimum.fromArray(e, t), this._maximum.fromArray(e, t + 3), this._dirtyCenter = !0, this._dirtyRadius = !0, this._dirtySize = !0, this
                }, t.prototype.toArray = function (e, t) {
                    return void 0 === t && (t = 0), this._minimum.toArray(e, t), this._maximum.toArray(e, t + 3), e
                }, t.prototype.fromPoints = function (e) {
                    this.clear();
                    for (var t = 0, n = e; t < n.length; t++) {
                        var r = n[t];
                        this.add(r)
                    }
                    return this
                }, t.prototype.applyMatrix = function (e, t) {
                    if (void 0 === t && (t = null), null === t && (t = this), t.isEmpty) return t !== this && this.copy(t), this;
                    var n = t, r = n._minimum, i = n._maximum;
                    return K[0].set(r.x, r.y, r.z).applyMatrix(e), K[1].set(r.x, r.y, i.z).applyMatrix(e), K[2].set(r.x, i.y, r.z).applyMatrix(e), K[3].set(r.x, i.y, i.z).applyMatrix(e), K[4].set(i.x, r.y, r.z).applyMatrix(e), K[5].set(i.x, r.y, i.z).applyMatrix(e), K[6].set(i.x, i.y, r.z).applyMatrix(e), K[7].set(i.x, i.y, i.z).applyMatrix(e), this.fromPoints(K), this
                }, t.prototype.add = function (e, t) {
                    void 0 === t && (t = null), null === t && (t = this);
                    var r = t, i = r._minimum, o = r._maximum;
                    return e instanceof n ? (this._minimum.min(e.minimum, i), this._maximum.max(e.maximum, o)) : (this._minimum.min(e, i), this._maximum.max(e, o)), this._dirtyRadius = !0, this._dirtyCenter = !0, this._dirtySize = !0, this
                }, t.prototype.expand = function (e, t) {
                    if (void 0 === t && (t = null), this.isEmpty) return this;
                    null === t && (t = this);
                    var n = t, r = n._minimum, i = n._maximum;
                    return "number" == typeof e ? (this._minimum.addScalar(-e, r), this._maximum.addScalar(e, i)) : (this._minimum.subtract(e, r), this._maximum.add(e, i)), this._dirtyRadius = !0, this._dirtyCenter = !0, this._dirtySize = !0, this
                }, t.prototype.translate = function (e, t) {
                    if (void 0 === t && (t = null), this.isEmpty) return this;
                    null === t && (t = this);
                    var n = t, r = n._minimum, i = n._maximum;
                    return "number" == typeof e ? (this._minimum.addScalar(e, r), this._maximum.addScalar(e, i)) : (this._minimum.add(e, r), this._maximum.add(e, i)), this._dirtyRadius = !0, this._dirtyCenter = !0, this._dirtySize = !0, this
                }, t.prototype.getClosestPointToPoint = function (e, t) {
                    return void 0 === t && (t = null), null === t && (t = E.create()), this.isEmpty ? t.copy(E.ZERO) : t.clamp(this._minimum, this._maximum, e)
                }, t.prototype.getDistance = function (e) {
                    return this.isEmpty ? O.copy(E.ZERO).subtract(e).length : O.clamp(this._minimum, this._maximum, e).subtract(e).length
                }, t.prototype.contains = function (e) {
                    if (this.isEmpty) return !1;
                    var t = this._minimum, r = this._maximum;
                    if (e instanceof n) {
                        var i = e.minimum, o = e.maximum;
                        return t.x <= i.x && o.x <= r.x && t.y <= i.y && o.y <= r.y && t.z <= i.z && o.z <= r.z
                    }
                    return e.x >= t.x && e.x <= r.x && e.y >= t.y && e.y <= r.y && e.z >= t.z && e.z <= r.z
                }, t.prototype.intersects = function (e) {
                    var t = e.minimum, n = e.maximum, r = this._minimum, i = this._maximum;
                    return !(i.x < t.x || r.x > n.x) && (!(i.y < t.y || r.y > n.y) && !(i.z < t.z || r.z > n.z))
                }, t.prototype.raycast = function (e, t) {
                    if (void 0 === t && (t = null), this.isEmpty) return !1;
                    var n, r, i, o, a, s, l = 0, u = e.origin, c = e.direction, p = this.minimum, d = this.maximum,
                        h = 1 / c.x, f = 1 / c.y, m = 1 / c.z;
                    if (h >= 0 ? (n = (p.x - u.x) * h, r = (d.x - u.x) * h) : (n = (d.x - u.x) * h, r = (p.x - u.x) * h), f >= 0 ? (i = (p.y - u.y) * f, o = (d.y - u.y) * f) : (i = (d.y - u.y) * f, o = (p.y - u.y) * f), n > o || i > r) return !1;
                    if ((i > n || n != n) && (n = i, l = 1), (o < r || r != r) && (r = o), m >= 0 ? (a = (p.z - u.z) * m, s = (d.z - u.z) * m) : (a = (d.z - u.z) * m, s = (p.z - u.z) * m), n > s || a > r) return !1;
                    if ((a > n || n != n) && (n = a, l = 2), (s < r || r != r) && (r = s), r < 0) return !1;
                    if (n <= 0) return !1;
                    if (null !== t) {
                        var _ = t.normal;
                        if (e.getPointAt(t.distance = n >= 0 ? n : r, t.position), null !== _) switch (l) {
                            case 0:
                                _.set(h > 0 ? -1 : 1, 0, 0);
                                break;
                            case 1:
                                _.set(0, f > 0 ? -1 : 1, 0);
                                break;
                            case 2:
                                _.set(0, 0, m > 0 ? -1 : 1)
                        }
                    }
                    return !0
                }, t.prototype.intersectsSphere = function (e) {
                    if (this.isEmpty) return !1;
                    var t = e.radius, n = e.center;
                    return O.copy(n).clamp(this._minimum, this._maximum).getSquaredDistance(n) <= t * t
                }, Object.defineProperty(t.prototype, "isEmpty", {
                    get: function () {
                        var e = this._minimum, t = this._maximum;
                        return t.x < e.x || t.y < e.y || t.z < e.z
                    }, enumerable: !0, configurable: !0
                }), Object.defineProperty(t.prototype, "boundingSphereRadius", {
                    get: function () {
                        return this._dirtyRadius && (this.isEmpty ? this._boundingSphereRadius = 0 : (O.subtract(this._maximum, this._minimum).multiplyScalar(.5), this._boundingSphereRadius = O.length), this._dirtyRadius = !1), this._boundingSphereRadius
                    }, enumerable: !0, configurable: !0
                }), Object.defineProperty(t.prototype, "minimum", {
                    get: function () {
                        return this._minimum
                    }, enumerable: !0, configurable: !0
                }), Object.defineProperty(t.prototype, "maximum", {
                    get: function () {
                        return this._maximum
                    }, enumerable: !0, configurable: !0
                }), Object.defineProperty(t.prototype, "size", {
                    get: function () {
                        return this._dirtySize && (this.isEmpty ? this._size.copy(E.ZERO) : this._size.subtract(this._maximum, this._minimum), this._dirtySize = !1), this._size
                    }, set: function (e) {
                        if (!this.isEmpty) {
                            var t = this.center, n = this._size.copy(e), r = O.copy(n).multiplyScalar(.5);
                            this._minimum.copy(t).subtract(r), this._maximum.copy(t).add(r), this._dirtyRadius = !0
                        }
                    }, enumerable: !0, configurable: !0
                }), Object.defineProperty(t.prototype, "center", {
                    get: function () {
                        return this._dirtyCenter && (this.isEmpty ? this._center.copy(E.ZERO) : this._center.add(this._maximum, this._minimum).multiplyScalar(.5), this._dirtyCenter = !1), this._center
                    }, set: function (e) {
                        if (!this.isEmpty) {
                            var t = this.size, n = this._center.copy(e), r = O.copy(t).multiplyScalar(.5);
                            this._minimum.subtract(n, r), this._maximum.add(n, r)
                        }
                    }, enumerable: !0, configurable: !0
                }), t.ONE = (new n).set(E.MINUS_ONE.clone().multiplyScalar(.5), E.ONE.clone().multiplyScalar(.5)), h([Object(u.property)("vector3", {minimum: 0})], t.prototype, "size", null), h([Object(u.property)("vector3")], t.prototype, "center", null), t = n = h([Object(l.pool)()], t)
            }(l.Releasable);
        __reflect(Q, "@egret/engine/Box");
        var J = Q.create(), $ = function (e) {
            function t() {
                var t = null !== e && e.apply(this, arguments) || this;
                return t.radius = 0, t.center = E.create(), t
            }

            var n;
            return d(t, e), n = t, t.create = function (e, t) {
                void 0 === e && (e = E.ZERO), void 0 === t && (t = 0);
                var n = l.Pool.getPool(this, !0).borrow();
                return n.initialize(), n.set(e, t)
            }, t.prototype.serialize = function () {
                return this.toArray([0, 0, 0, 0])
            }, t.prototype.deserialize = function (e) {
                return this.fromArray(e)
            }, t.prototype.clone = function () {
                return n.create(this.center, this.radius)
            }, t.prototype.copy = function (e) {
                return this.set(e.center, e.radius)
            }, t.prototype.set = function (e, t) {
                return this.radius = t, this.center.copy(e), this
            }, t.prototype.fromArray = function (e, t) {
                return void 0 === t && (t = 0), this.radius = e[t + 3], this.center.fromArray(e, t), this
            }, t.prototype.toArray = function (e, t) {
                return void 0 === t && (t = 0), e[t + 3] = this.radius, e = this.center.toArray(e, t)
            }, t.prototype.applyMatrix = function (e) {
                return this.center.applyMatrix(e), this.radius = this.radius * e.maxScaleOnAxis, this
            }, t.prototype.fromPoints = function (e, t) {
                void 0 === t && (t = null), null !== t ? this.center.copy(t) : this.center.copy(J.fromPoints(e).center);
                for (var n = 0, r = 0, i = e; r < i.length; r++) {
                    var o = i[r];
                    n = Math.max(n, this.center.getDistance(o))
                }
                return this.radius = Math.sqrt(n), this
            }, t.prototype.contains = function (e) {
                if (e instanceof n) {
                    var t = this.radius - e.radius;
                    return t >= 0 && this.center.getSquaredDistance(e.center), !1
                }
                return this.center.getSquaredDistance(e) <= this.radius * this.radius
            }, t.prototype.getClosestPointToPoint = function (e, t) {
                var n = this.radius, r = this.center;
                if (t === r) throw new Error;
                return r.getSquaredDistance(e) > n * n ? (t.subtract(r, e).normalize(), t.multiplyScalar(n).add(r)) : t.copy(e), t
            }, t.prototype.getDistance = function (e) {
                return this.center.getDistance(e) - this.radius
            }, t.prototype.raycast = function (e, t) {
                void 0 === t && (t = null);
                var n = this.radius * this.radius, r = O.subtract(this.center, e.origin), i = r.dot(e.direction),
                    o = r.dot(r) - i * i;
                if (o > n) return !1;
                var a = Math.sqrt(n - o), s = i - a;
                if (s < 0 || i + a < 0) return !1;
                if (null !== t) {
                    var l = t.position, u = t.normal;
                    e.getPointAt(s, l), t.distance = s, null !== u && u.subtract(l, this.center).normalize()
                }
                return !0
            }, h([Object(u.property)("float", {minimum: 0})], t.prototype, "radius", void 0), h([Object(u.property)("vector3")], t.prototype, "center", void 0), t = n = h([Object(l.pool)()], t)
        }(l.Releasable);
        __reflect($, "@egret/engine/Sphere");
        var ee = function (e) {
            function t() {
                var t = null !== e && e.apply(this, arguments) || this;
                return t.topRadius = .5, t.bottomRadius = .5, t.height = 1, t.center = E.create(), t
            }

            var n;
            return d(t, e), n = t, t.create = function (e, t, n, r) {
                void 0 === e && (e = E.ZERO), void 0 === t && (t = .5), void 0 === n && (n = .5), void 0 === r && (r = 1);
                var i = l.Pool.getPool(this, !0).borrow();
                return i.initialize(), i.set(e, t, n, r)
            }, t.prototype.serialize = function () {
                return this.toArray([0, 0, 0, 0, 0, 0])
            }, t.prototype.deserialize = function (e) {
                return this.fromArray(e)
            }, t.prototype.clone = function () {
                return n.create(this.center, this.topRadius, this.bottomRadius, this.height)
            }, t.prototype.copy = function (e) {
                return this.set(e.center, e.topRadius, e.bottomRadius, e.height)
            }, t.prototype.set = function (e, t, n, r) {
                return this.topRadius = t, this.bottomRadius = n, this.height = r, this.center.copy(e), this
            }, t.prototype.fromArray = function (e, t) {
                return void 0 === t && (t = 0), this.center.fromArray(e, t), this.topRadius = e[t + 3], this.bottomRadius = e[t + 4], this.height = e[t + 5], this
            }, t.prototype.toArray = function (e, t) {
                return void 0 === t && (t = 0), (e = this.center.toArray(e, t))[t + 3] = this.topRadius, e[t + 4] = this.bottomRadius, e[t + 5] = this.height, e
            }, t.prototype.contains = function (e) {
                var t = e.x, n = e.y, r = e.z, i = this.topRadius, o = this.bottomRadius, a = this.height,
                    s = this.center, l = .5 * a;
                if (n < s.y - l || s.y + l < n) return !1;
                var u = i < o ? o : i;
                if (t < s.x - u || s.x + u < t) return !1;
                if (r < s.z - u || s.z + u < r) return !1;
                var c = t - s.x, p = n - (s.y + l), d = r - s.z, h = T.lerp(i, o, p / a);
                return c * c + d * d <= h * h
            }, t.prototype.raycast = function (e, t) {
                void 0 === t && (t = null);
                var n = this.topRadius, r = this.bottomRadius, i = this.height, o = this.center,
                    a = O.copy(e.origin).subtract(o), s = w.multiplyScalar(1e5, e.direction).add(a), l = n === r,
                    u = a.x, c = a.y, p = a.z, d = .5 * i, h = s.x - u, f = s.y - c, m = s.z - p, _ = 0, g = 1;
                if (-2220446049250313e-31 < f && f < 2220446049250313e-31) {
                    if (c <= -d || d <= c) return !1
                } else {
                    var v = 1 / f, y = (-d - c) * v, b = (d - c) * v;
                    if (y > b) {
                        var x = y;
                        y = b, b = x
                    }
                    y > 0 && (_ = y), b < 1 && (g = b)
                }
                if (_ >= 1 || g <= 0) return !1;
                var T, E = 0, C = 1, S = 0, M = 0;
                if (l) {
                    if ((z = (D = u * h + p * m) * D - (L = h * h + m * m) * (I = u * u + p * p - r * r)) < 0) return !1;
                    if (L > 0) {
                        if (C = (-D + (U = Math.sqrt(z))) / L, (E = (-D - U) / L) >= 1 || C <= 0) return !1
                    } else {
                        if (I >= 0) return !1;
                        E = 0, C = 1
                    }
                } else {
                    var A = r - n, R = Math.sqrt(A * A + i * i), P = i / A * r - d;
                    S = A / R;
                    var L, D, I, N = (M = i / R) * M,
                        z = (D = N * (u * h + (c -= P) * f + p * m) - c * f) * D - (L = N * (h * h + f * f + m * m) - f * f) * (I = N * (u * u + c * c + p * p) - c * c);
                    if (0 !== L) {
                        if (z < 0) return !1;
                        var U = Math.sqrt(z), F = 1 / L;
                        if (L < 0) {
                            if (f > 0) {
                                if (E = 0, (C = (-D + U) * F) <= 0) return !1
                            } else if (C = 1, (E = (-D - U) * F) >= 1) return !1
                        } else if (C = (-D + U) * F, (E = (-D - U) * F) >= 1 || C <= 0) return !1
                    } else {
                        var k = -I / (2 * D);
                        if (D > 0) {
                            if (E = 0, C = k, k <= 0) return !1
                        } else if (E = k, C = 1, k >= 1) return !1
                    }
                    c += P
                }
                if (C <= _ || g <= E) return !1;
                if (E < _) {
                    if (0 === (T = _)) return !1;
                    null !== t && null !== t.normal && t.normal.set(0, f > 0 ? -1 : 1, 0)
                } else {
                    if (0 === (T = E)) return !1;
                    null !== t && null !== t.normal && (t.normal.set(u + h * T, 0, p + m * T).normalize(), l || (t.normal.multiplyScalar(M), t.normal.y += S))
                }
                return null !== t && (t.distance = T, t.position.set(u + T * h, c + T * f, p + T * m).add(o)), !0
            }, h([Object(u.property)("float", {minimum: 0})], t.prototype, "topRadius", void 0), h([Object(u.property)("float", {minimum: 0})], t.prototype, "bottomRadius", void 0), h([Object(u.property)("float", {minimum: 0})], t.prototype, "height", void 0), h([Object(u.property)("vector3")], t.prototype, "center", void 0), t = n = h([Object(l.pool)()], t)
        }(l.Releasable);
        __reflect(ee, "@egret/engine/FrustumCone");
        var te = function (e) {
            function t() {
                var t = null !== e && e.apply(this, arguments) || this;
                return t.radius = 0, t.height = 0, t.center = E.create(), t
            }

            var n;
            return d(t, e), n = t, t.create = function (e, t, n) {
                void 0 === e && (e = E.ZERO), void 0 === t && (t = 0), void 0 === n && (n = 0);
                var r = l.Pool.getPool(this, !0).borrow();
                return r.initialize(), r.set(e, t, n)
            }, t.prototype.serialize = function () {
                return this.toArray([0, 0, 0, 0, 0])
            }, t.prototype.deserialize = function (e) {
                return this.fromArray(e)
            }, t.prototype.clone = function () {
                return n.create(this.center, this.radius, this.height)
            }, t.prototype.copy = function (e) {
                return this.set(e.center, e.radius, e.height)
            }, t.prototype.set = function (e, t, n) {
                return this.radius = t, this.height = n, this.center.copy(e), this
            }, t.prototype.fromArray = function (e, t) {
                return void 0 === t && (t = 0), this.center.fromArray(e, t), this.radius = e[t + 3], this.height = e[t + 4], this
            }, t.prototype.toArray = function (e, t) {
                return void 0 === t && (t = 0), (e = this.center.toArray(e, t))[t + 3] = this.radius, e[t + 4] = this.height, e
            }, t.prototype.contains = function (e) {
                var t = e.x, n = e.y, r = e.z, i = this.radius, o = this.center, a = .5 * this.height;
                if (n < o.y - a - i || o.y + a + i < n) return !1;
                if (t < o.x - i || o.x + i < t) return !1;
                if (r < o.z - i || o.z + i < r) return !1;
                var s, l = t - o.x, u = n - o.y, c = r - o.z, p = i * i;
                return a > 0 ? u < -a ? ((s = O.copy(o)).y -= a, s.getSquaredDistance(e) <= p) : a < u ? ((s = O.copy(o)).y += a, s.getSquaredDistance(e) <= p) : l * l + c * c <= p : o.getSquaredDistance(e) <= p
            }, t.prototype.raycast = function (e, t) {
                void 0 === t && (t = null);
                var n, r = this.radius, i = this.center, o = .5 * this.height, a = O.copy(e.origin).subtract(i),
                    s = w.multiplyScalar(1e5, e.direction).add(a), l = a.x, u = a.y, c = a.z, p = r * r, d = s.x - l,
                    h = s.y - u, f = s.z - c, m = 0, _ = 1, g = d * d + f * f, v = l * d + c * f, y = l * l + c * c - p,
                    b = v * v - g * y;
                if (b < 0) return !1;
                if (g > 0) {
                    var x = Math.sqrt(b), T = 1 / g;
                    if (_ = (-v + x) * T, (m = (-v - x) * T) >= 1 || _ <= 0) return !1
                } else {
                    if (y >= 0) return !1;
                    m = 0, _ = 1
                }
                var E = u + h * m;
                if (-o < E && E < o) {
                    if (m > 0) {
                        if (n = m, null !== t) {
                            var C = l + n * d, S = c + n * f, M = t.normal;
                            t.distance = n, t.position.set(C, E, S).add(i), null !== M && M.set(C, 0, S).normalize()
                        }
                        return !0
                    }
                    return !1
                }
                var A = R.set(i.x, i.y + (E < 0 ? -o : o), i.z), L = P.subtract(A, e.origin), D = L.dot(e.direction),
                    I = L.dot(L) - D * D;
                if (I > p) return !1;
                var N = Math.sqrt(p - I), z = D - N;
                if (z < 0 || D + N < 0) return !1;
                if (null !== t) {
                    var U = t.position;
                    M = t.normal;
                    e.getPointAt(t.distance = z, U), null !== M && M.subtract(U, A).normalize()
                }
                return !0
            }, h([Object(u.property)("float", {minimum: 0})], t.prototype, "radius", void 0), h([Object(u.property)("float", {minimum: 0})], t.prototype, "height", void 0), h([Object(u.property)("vector3")], t.prototype, "center", void 0), t = n = h([Object(l.pool)()], t)
        }(l.Releasable);
        __reflect(te, "@egret/engine/Capsule");
        var ne = function (e) {
            function t() {
                var t = null !== e && e.apply(this, arguments) || this;
                return t.planes = [q.create(), q.create(), q.create(), q.create(), q.create(), q.create()], t
            }

            var n;
            return d(t, e), n = t, t.create = function () {
                var e = l.Pool.getPool(this, !0).borrow();
                return e.initialize(), e
            }, t.prototype.serialize = function () {
                return this.toArray(new Array(24))
            }, t.prototype.deserialize = function (e) {
                return this.fromArray(e)
            }, t.prototype.clone = function () {
                return n.create().set(this.planes)
            }, t.prototype.copy = function (e) {
                return this.set(e.planes)
            }, t.prototype.set = function (e) {
                for (var t = 0, n = 0, r = e; n < r.length; n++) {
                    var i = r[n];
                    this.planes[t++].copy(i)
                }
                return this
            }, t.prototype.fromArray = function (e, t) {
                void 0 === t && (t = 0);
                for (var n = 0, r = this.planes; n < r.length; n++) {
                    r[n].fromArray(e, t), t += 4
                }
                return this
            }, t.prototype.toArray = function (e, t) {
                void 0 === t && (t = 0);
                for (var n = 0, r = this.planes; n < r.length; n++) {
                    r[n].toArray(e, t), t += 4
                }
                return e
            }, t.prototype.fromMatrix = function (e) {
                var t = this.planes, n = e.rawData, r = n[0], i = n[1], o = n[2], a = n[3], s = n[4], l = n[5],
                    u = n[6], c = n[7], p = n[8], d = n[9], h = n[10], f = n[11], m = n[12], _ = n[13], g = n[14],
                    v = n[15], y = O;
                return t[0].set(y.set(a - r, c - s, f - p), v - m).normalize(), t[1].set(y.set(a + r, c + s, f + p), v + m).normalize(), t[2].set(y.set(a + i, c + l, f + d), v + _).normalize(), t[3].set(y.set(a - i, c - l, f - d), v - _).normalize(), t[4].set(y.set(a - o, c - u, f - h), v - g).normalize(), t[5].set(y.set(a + o, c + u, f + h), v + g).normalize(), this
            }, t.prototype.containsPoint = function (e) {
                for (var t = 0, n = this.planes; t < n.length; t++) {
                    if (n[t].getDistance(e) < 0) return !1
                }
                return !0
            }, t.prototype.intersectsSphere = function (e) {
                for (var t = e.center, n = -e.radius, r = 0, i = this.planes; r < i.length; r++) {
                    if (i[r].getDistance(t) < n) return !1
                }
                return !0
            }, t = n = h([Object(l.pool)()], t)
        }(l.Releasable);
        __reflect(ne, "@egret/engine/Frustum");
        var re = function (e) {
            function t() {
                var t = null !== e && e.apply(this, arguments) || this;
                return t.radius = 1, t.phi = 0, t.theta = 0, t
            }

            var n;
            return d(t, e), n = t, t.create = function (e, t, n) {
                void 0 === e && (e = 1), void 0 === t && (t = 0), void 0 === n && (n = 0);
                var r = l.Pool.getPool(this, !0).borrow();
                return r.initialize(), r.set(e, t, n)
            }, t.prototype.serialize = function () {
                return this.toArray([0, 0, 0])
            }, t.prototype.deserialize = function (e) {
                return this.fromArray(e)
            }, t.prototype.clone = function () {
                return n.create(this.radius, this.phi, this.theta)
            }, t.prototype.copy = function (e) {
                return this.set(e.radius, e.phi, e.theta)
            }, t.prototype.set = function (e, t, n) {
                return this.radius = e, this.phi = t, this.theta = n, this
            }, t.prototype.fromArray = function (e, t) {
                return void 0 === t && (t = 0), this.radius = e[t], this.phi = e[t + 1], this.theta = e[t + 2], this
            }, t.prototype.toArray = function (e, t) {
                return void 0 === t && (t = 0), e[t] = this.radius, e[t + 1] = this.phi, e[t + 2] = this.theta, e
            }, t.prototype.fromCartesianCoords = function (e, t, n) {
                return void 0 === t && (t = 0), void 0 === n && (n = 0), 1 === arguments.length && (n = e.z, t = e.y, e = e.x), this.radius = Math.sqrt(e * e + t * t + n * n), 0 === this.radius ? (this.theta = 0, this.phi = 0) : (this.theta = Math.atan2(e, n), this.phi = Math.acos(T.clamp(t / this.radius, -1, 1))), this
            }, t.prototype.makeSafe = function () {
                return this.phi = Math.max(2220446049250313e-31, Math.min(3.141592653589793, this.phi)), this
            }, t = n = h([Object(l.pool)()], t)
        }(l.Releasable);
        __reflect(re, "@egret/engine/Spherical");
        var ie = function (e) {
            function t() {
                var t = null !== e && e.apply(this, arguments) || this;
                return t._needUpdate = 1, t._lengthDivisions = 200, t._lengths = [], t
            }

            return d(t, e), t.prototype.needUpdate = function (e) {
                this._needUpdate |= e
            }, t.prototype.update = function (e) {
                if (0 != (1 & (this._needUpdate & e))) {
                    var t = this._lengthDivisions, n = this._lengths, r = this.getPoint(0, null).release(),
                        i = r.clone().release(), o = 0;
                    n.length = t, n[0] = 0;
                    for (var a = 1; a <= t; ++a) this.getPoint(a / t, r), o += r.getDistance(i), n[a] = o, i.copy(r)
                }
                this._needUpdate &= ~e
            }, t.prototype.getPointAt = function (e, t) {
                var n = this.getUtoTmapping(e);
                return this.getPoint(n, t)
            }, t.prototype.getPoints = function (e, t, n, r) {
                void 0 === e && (e = 6), void 0 === t && (t = !1), void 0 === n && (n = null), void 0 === r && (r = 0), null === n && (n = []);
                for (var i = 0; i <= e; ++i) n[r + i] = t ? this.getPointAt(i / e, null) : this.getPoint(i / e, null);
                return n
            }, t.prototype.getPointsArray = function (e, t, n, r) {
                void 0 === e && (e = 5), void 0 === t && (t = !1), void 0 === n && (n = null), void 0 === r && (r = 0), null === n && (n = []);
                var i, o = this.constructor._vectorLength;
                (i = t ? this.getPointAt(0, null).release() : this.getPoint(0, null).release()).toArray(n, r);
                for (var a = 1; a <= e; ++a) t ? this.getPointAt(a / e, i) : this.getPoint(a / e, i), i.toArray(n, r + a * o);
                return n
            }, t.prototype.getUtoTmapping = function (e, t) {
                void 0 === t && (t = -1);
                var n = this.lengths, r = n.length, i = 0;
                t <= 0 && (t = e * n[r - 1]);
                for (var o = 0, a = r - 1, s = 0; o <= a;) if ((s = n[i = Math.floor(o + (a - o) / 2)] - t) < 0) o = i + 1; else {
                    if (!(s > 0)) {
                        a = i;
                        break
                    }
                    a = i - 1
                }
                if (n[i = a] === t) return i / (r - 1);
                var l = n[i];
                return (i + (t - l) / (n[i + 1] - l)) / (r - 1)
            }, t.prototype.getTangent = function (e, t) {
                void 0 === t && (t = null);
                var n = e - 1e-4, r = e + 1e-4;
                n < 0 && (n = 0), r > 1 && (r = 1);
                var i = this.getPoint(n, null).release();
                return this.getPoint(r, t).subtract(i).normalize()
            }, t.prototype.getTangentAt = function (e, t) {
                void 0 === t && (t = null);
                var n = this.getUtoTmapping(e);
                return this.getTangent(n, t)
            }, Object.defineProperty(t.prototype, "arcLengthDivisions", {
                get: function () {
                    return this._lengthDivisions
                }, set: function (e) {
                    this._lengthDivisions !== e && (this._lengthDivisions = e, this.needUpdate(1))
                }, enumerable: !0, configurable: !0
            }), Object.defineProperty(t.prototype, "length", {
                get: function () {
                    var e = this.lengths;
                    return e[e.length - 1]
                }, enumerable: !0, configurable: !0
            }), Object.defineProperty(t.prototype, "lengths", {
                get: function () {
                    return 0 != (1 & this._needUpdate) && this.update(1), this._lengths
                }, enumerable: !0, configurable: !0
            }), t.vectorLength = 3, t
        }(DebuggerClass);
        __reflect(ie, "@egret/engine/Curve");
        var oe = function (e) {
            function t(t) {
                void 0 === t && (t = null);
                var n = e.call(this) || this;
                return n.v0 = E.create(), n.v1 = E.create(), n.v2 = E.create(), n.v3 = null === t ? E.create() : t, n
            }

            return d(t, e), t.prototype.serialize = function () {
                return [this.v0.x, this.v0.y, this.v0.z, this.v1.x, this.v1.y, this.v1.z, this.v2.x, this.v2.y, this.v2.z, this.v3.x, this.v3.y, this.v3.z]
            }, t.prototype.deserialize = function (e) {
                return this.v0.fromArray(e, 0), this.v1.fromArray(e, 3), this.v2.fromArray(e, 6), this.v3.fromArray(e, 9), this
            }, t.prototype.getPoint = function (e, t) {
                null === t && (t = E.create());
                var n = this.v0, r = this.v1, i = this.v2, o = this.v3;
                return t.set(ae(e, n.x, r.x, i.x, o.x), ae(e, n.y, r.y, i.y, o.y), ae(e, n.z, r.z, i.z, o.z)), t
            }, t
        }(ie);

        function ae(e, t, n, r, i) {
            return function (e, t) {
                var n = 1 - e;
                return n * n * n * t
            }(e, t) + function (e, t) {
                var n = 1 - e;
                return 3 * n * n * e * t
            }(e, n) + function (e, t) {
                return 3 * (1 - e) * e * e * t
            }(e, r) + function (e, t) {
                return e * e * e * t
            }(e, i)
        }

        __reflect(oe, "@egret/engine/CubicBezierCurve3");
        var se, le, ue, ce, pe, de, he, fe = function (e) {
            function t() {
                var t = null !== e && e.apply(this, arguments) || this;
                return t._autoClose = !1, t._needUpdate = 1, t._lengths = [], t._curves = [], t
            }

            return d(t, e), t.prototype.needUpdate = function (e) {
                this._needUpdate |= e
            }, t.prototype.update = function (e) {
                if (0 != (1 & (this._needUpdate & e))) for (var t = this._lengths, n = this._curves, r = 0, i = 0, o = n.length; i < o; ++i) r += n[i].length, t.push(r);
                this._needUpdate &= ~e
            }, t.prototype.serialize = function () {
                for (var e = [], t = 0, n = this.curves; t < n.length; t++) {
                    var r = n[t];
                    e.push.apply(e, r.serialize())
                }
                return e
            }, t.prototype.deserialize = function (e) {
                for (var t = [], n = 0; n < e.length; n += 12) {
                    t = e.slice(n, n + 13);
                    var r = new oe;
                    r.deserialize(t), this.add(r)
                }
                return this
            }, t.prototype.add = function (e) {
                var t = this._curves;
                return !(t.indexOf(e) >= 0) && (t.push(e), !0)
            }, t.prototype.remove = function (e) {
                var t = this._curves, n = t.indexOf(e);
                return n >= 0 && (t.splice(n, 1), !0)
            }, t.prototype.getPoint = function (e, t) {
                for (var n = e * this.length, r = this.lengths, i = this._curves, o = 0; o < r.length;) {
                    if (r[o] >= n) {
                        var a = r[o] - n, s = i[o], l = s.length, u = 0 === l ? 0 : 1 - a / l;
                        return s.getPointAt(u, t)
                    }
                    o++
                }
                return null
            }, t.prototype.getPoints = function (e, t, n, r) {
                if (void 0 === e && (e = 12), void 0 === t && (t = !1), void 0 === n && (n = null), null === n && (n = []), t) for (var i = 0; i <= e; i++) n.push(this.getPoint(i / e, null)); else {
                    i = 0;
                    for (var o = this.curves, a = o.length; i < a; ++i) for (var s = o[i].getPoints(e), l = 0; l < s.length; l++) {
                        var u = s[l];
                        n.push(u)
                    }
                }
                return this.autoClose && n.length > 1 && n.push(n[0]), n
            }, Object.defineProperty(t.prototype, "autoClose", {
                get: function () {
                    return this._autoClose
                }, set: function (e) {
                    this._autoClose !== e && (this._autoClose = e)
                }, enumerable: !0, configurable: !0
            }), Object.defineProperty(t.prototype, "length", {
                get: function () {
                    var e = this.lengths;
                    return e[e.length - 1]
                }, enumerable: !0, configurable: !0
            }), Object.defineProperty(t.prototype, "lengths", {
                get: function () {
                    return 0 != (1 & this._needUpdate) && this.update(1), this._lengths
                }, enumerable: !0, configurable: !0
            }), Object.defineProperty(t.prototype, "curves", {
                get: function () {
                    return this._curves
                }, enumerable: !0, configurable: !0
            }), t
        }(DebuggerClass);
        __reflect(fe, "@egret/engine/CurvePath"), function (e) {
            e.Asset = "asset", e.Transform = "transform", e.Collider = "collider", e.Renderer = "renderer", e.Renderer2D = "renderer2D", e.Camera = "camera", e.CameraPostprocessing = "cameraPostprocessing", e.Light = "light"
        }(se || (se = {})), function (e) {
            e.Noname = "Noname", e.Global = "Global", e.Root = "Root", e.MainCamera = "Main Camera", e.Editor = "Editor", e.MissingPrefab = "Missing Prefab"
        }(le || (le = {})), function (e) {
            e.Untagged = "Untagged", e.Respawn = "Respawn", e.Finish = "Finish", e.EditorOnly = "EditorOnly", e.MainCamera = "MainCamera", e.Player = "Player", e.GameController = "GameController", e.Global = "Global"
        }(ue || (ue = {})), function (e) {
            e[e.Nothing = 0] = "Nothing", e[e.BuiltinLayer0 = 1] = "BuiltinLayer0", e[e.BuiltinLayer1 = 2] = "BuiltinLayer1", e[e.BuiltinLayer2 = 4] = "BuiltinLayer2", e[e.BuiltinLayer3 = 8] = "BuiltinLayer3", e[e.BuiltinLayer4 = 16] = "BuiltinLayer4", e[e.BuiltinLayer5 = 32] = "BuiltinLayer5", e[e.BuiltinLayer6 = 64] = "BuiltinLayer6", e[e.BuiltinLayer7 = 128] = "BuiltinLayer7", e[e.UserLayer8 = 256] = "UserLayer8", e[e.UserLayer9 = 512] = "UserLayer9", e[e.UserLayer10 = 1024] = "UserLayer10", e[e.UserLayer11 = 2048] = "UserLayer11", e[e.UserLayer12 = 4096] = "UserLayer12", e[e.UserLayer13 = 8192] = "UserLayer13", e[e.UserLayer14 = 16384] = "UserLayer14", e[e.UserLayer15 = 32768] = "UserLayer15", e[e.UserLayer16 = 65536] = "UserLayer16", e[e.UserLayer17 = 131072] = "UserLayer17", e[e.UserLayer18 = 262144] = "UserLayer18", e[e.UserLayer19 = 524288] = "UserLayer19", e[e.UserLayer20 = 1048576] = "UserLayer20", e[e.UserLayer21 = 2097152] = "UserLayer21", e[e.UserLayer22 = 4194304] = "UserLayer22", e[e.UserLayer23 = 8388608] = "UserLayer23", e[e.UserLayer24 = 16777216] = "UserLayer24", e[e.UserLayer25 = 16777216] = "UserLayer25", e[e.UserLayer26 = 67108864] = "UserLayer26", e[e.UserLayer27 = 134217728] = "UserLayer27", e[e.UserLayer28 = 268435456] = "UserLayer28", e[e.UserLayer29 = 536870912] = "UserLayer29", e[e.UserLayer30 = 1073741824] = "UserLayer30", e[e.UserLayer31 = -2147483648] = "UserLayer31", e[e.Default = 1] = "Default", e[e.TransparentFX = 2] = "TransparentFX", e[e.IgnoreRayCast = 4] = "IgnoreRayCast", e[e.Water = 16] = "Water", e[e.UI = 32] = "UI", e[e.Postprocessing = 256] = "Postprocessing", e[e.EditorOrthographic = 8] = "EditorOrthographic", e[e.EditorPerspective = 64] = "EditorPerspective", e[e.EditorBackground = 128] = "EditorBackground", e[e.Everything = -201] = "Everything"
        }(ce || (ce = {})), function (e) {
            e[e.Begin = 0] = "Begin", e[e.Enable = 1e3] = "Enable", e[e.Start = 2e3] = "Start", e[e.FixedUpdate = 3e3] = "FixedUpdate", e[e.Update = 4e3] = "Update", e[e.Animation = 5e3] = "Animation", e[e.LateUpdate = 6e3] = "LateUpdate", e[e.BeforeRenderer = 7e3] = "BeforeRenderer", e[e.Renderer = 8e3] = "Renderer", e[e.Disable = 9e3] = "Disable", e[e.End = 1e4] = "End"
        }(pe || (pe = {})), function (e) {
            e.PathSeparator = "/"
        }(de || (de = {})), function (e) {
            e[e.Running = 1] = "Running", e[e.Preview = 2] = "Preview", e[e.Editor = 4] = "Editor", e[e.Mobile = 8] = "Mobile", e[e.WebView = 16] = "WebView", e[e.Headless = 32] = "Headless", e[e.Server = 128] = "Server", e[e.Client = 256] = "Client", e[e.UserMode16 = 65536] = "UserMode16", e[e.UserMode17 = 131072] = "UserMode17", e[e.UserMode18 = 262144] = "UserMode18", e[e.UserMode19 = 524288] = "UserMode19", e[e.UserMode20 = 1048576] = "UserMode20", e[e.UserMode21 = 2097152] = "UserMode21", e[e.UserMode22 = 4194304] = "UserMode22", e[e.UserMode23 = 8388608] = "UserMode23", e[e.UserMode24 = 16777216] = "UserMode24", e[e.UserMode25 = 16777216] = "UserMode25", e[e.UserMode26 = 67108864] = "UserMode26", e[e.UserMode27 = 134217728] = "UserMode27", e[e.UserMode28 = 268435456] = "UserMode28", e[e.UserMode29 = 536870912] = "UserMode29", e[e.UserMode30 = 1073741824] = "UserMode30", e[e.UserMode31 = -2147483648] = "UserMode31"
        }(he || (he = {}));
        var me = function (e) {
            function t() {
                return null !== e && e.apply(this, arguments) || this
            }

            return d(t, e), t = h([Object(c.component)({isAbstract: !0})], t)
        }(c.Component);
        __reflect(me, "@egret/engine/GameComponent");
        var _e = function (e) {
            function t() {
                var t = null !== e && e.apply(this, arguments) || this;
                return t.commandsList = {}, t.eventsMap = {}, t.notifyLevel = 0, t
            }

            return d(t, e), t.prototype.execute = function (e) {
                for (var t, n = [], r = 1; r < arguments.length; r++) n[r - 1] = arguments[r];
                var i = this.commandsList[e];
                if (i) {
                    var o = (t = i.func).call.apply(t, [i.thisObject].concat(n));
                    return o
                }
                return console.error("execute error!You must register:'" + e + "' before you execute command."), null
            }, t.prototype.register = function (e, t, n) {
                this.commandsList[e] ? console.error("register error!You has register:'" + e + "' before.") : this.commandsList[e] = {
                    func: t,
                    thisObject: n
                }
            }, t.prototype.addEventListener = function (e, t, n, r) {
                var i = this.eventsMap[e];
                i ? 0 !== this.notifyLevel && (i = this.eventsMap[e] = i.concat()) : i = this.eventsMap[e] = [];
                var o = {type: e, target: t, func: n, thisObject: r};
                i.push(o)
            }, t.prototype.removeEventListener = function (e, t, n) {
                var r = this.eventsMap[e];
                if (r) {
                    0 !== this.notifyLevel && (this.eventsMap[e] = r = r.concat());
                    for (var i = 0, o = r; i < o.length; i++) {
                        var a = o[i];
                        if (a.target === t && a.func === n) {
                            var s = r.indexOf(a);
                            r.splice(s, 1)
                        }
                    }
                    0 === r.length && (this.eventsMap[e] = null)
                }
            }, t.prototype.dispatch = function (e, t) {
                for (var n, r = [], i = 2; i < arguments.length; i++) r[i - 2] = arguments[i];
                var o = this.eventsMap[e];
                if (o) {
                    var a = o.length;
                    if (0 !== a) {
                        this.notifyLevel++;
                        for (var s = 0, l = o; s < l.length; s++) {
                            var u = l[s];
                            t === u.target && (n = u.func).call.apply(n, [u.thisObject].concat(r))
                        }
                        this.notifyLevel--
                    }
                }
            }, t
        }(DebuggerClass);
        __reflect(_e, "@egret/engine/EgretProUtil");
        var ge = function (e) {
            function t() {
                var t = null !== e && e.apply(this, arguments) || this;
                return t.onRunningModeChanged = l.Signal.create(), t.version = "1.6.0", t.options = null, t.globalEntity = null, t.signals = null, t.clock = null, t.screen = null, t.stage = null, t.helpers = null, t.renderContext = null, t.systemManager = null, t.sceneManager = null, t.entityContext = null, t.assetContext = null, t.egretProUtil = new _e, t.driveByEgret2d = !1, t.gameEntityContext = null, t.contexts = [], t._isRunning = !1, t._executeMode = 1, t
            }

            return d(t, e), Object.defineProperty(t, "instance", {
                get: function () {
                    return this._instance
                }, set: function (e) {
                    this._instance !== e && (this._instance = e)
                }, enumerable: !0, configurable: !0
            }), t.prototype.initialize = function (e) {
                t.instance = this;
                console.info("Egret", this.version), console.info("Egret initialize."), this.options = e, this._executeMode = e.executeMode
            }, t.prototype.getContext = function (e) {
                for (var t = this.contexts, n = 0, r = t; n < r.length; n++) {
                    var i = r[n];
                    if (i.entityClass === e) return i
                }
                var o = new c.Context(e);
                return t.push(o), o
            }, t.prototype.start = function () {
                t.instance = this, this._isRunning || (this.systemManager._registerPreSystems(), this._isRunning = !0, this.clock.reset(), console.info("Egret start."))
            }, t.prototype.pause = function () {
                t.instance = this, this._isRunning && (this._isRunning = !1, console.info("Egret pause."))
            }, t.prototype.resume = function () {
                t.instance = this, this._isRunning || (this._isRunning = !0, this.clock.reset(), console.info("Egret resume."))
            }, Object.defineProperty(t.prototype, "isRunning", {
                get: function () {
                    return this._isRunning
                }, enumerable: !0, configurable: !0
            }), Object.defineProperty(t.prototype, "executeMode", {
                get: function () {
                    return this._executeMode
                }, set: function (e) {
                    if (this._executeMode !== e) {
                        var t = this._executeMode;
                        this._executeMode = e, this.onRunningModeChanged.dispatch(t)
                    }
                }, enumerable: !0, configurable: !0
            }), t._instance = null, t
        }(DebuggerClass);
        __reflect(ge, "@egret/engine/Application"), ("undefined" != typeof window ? window : e).Application = ge;
        var ve = function (e) {
            function t() {
                var t = null !== e && e.apply(this, arguments) || this;
                return t.onResize = l.Signal.create(), t.scaler = 1, t._matchFactor = 1, t._size = {
                    w: 2048,
                    h: 1920
                }, t._viewport = X.create(0, 0, 1, 1), t
            }

            return d(t, e), t.prototype._updateViewport = function () {
                var e = ge.instance.screen, t = e.size, n = this._size, r = this._viewport,
                    i = 0 != (8 & ge.instance.executeMode), o = t.w, a = t.h;
                i && (e.rotated = n.w > n.h ? a > o : o > a) ? (o = t.h, a = t.w) : e.rotated = !1;
                var s = Math.min(n.w, o) / o, l = Math.min(n.h, a) / a;
                this.scaler = T.lerp(s, l, this._matchFactor), r.w = Math.ceil(o * this.scaler), r.h = Math.ceil(a * this.scaler), r.w > n.w ? (r.w = n.w, this.scaler = r.w / o, r.h = Math.ceil(a * this.scaler)) : r.h > n.h ? (r.h = n.h, this.scaler = r.h / a, r.w = Math.ceil(o * this.scaler)) : this.scaler = T.lerp(o / n.w, a / n.h, this._matchFactor), this.onResize.dispatch(this)
            }, t.prototype.uninitialize = function () {
                e.prototype.uninitialize.call(this);
                this.onResize.removeAll(), this.scaler = 1, this._matchFactor = 1, this._size.w = 1024, this._size.h = 1024
            }, t.prototype.screenToStage = function (e, t) {
                void 0 === t && (t = null), null === t && (t = E.create());
                var n = ge.instance.screen, r = n.size, i = this._viewport, o = e.x, a = e.y;
                return n.rotated ? (t.y = (r.w - (o - i.x)) * i.w / r.h, t.x = (a - i.y) * i.h / r.w) : (t.x = (o - i.x) * i.w / r.w, t.y = (a - i.y) * i.h / r.h), t
            }, t.prototype.stageToScreen = function (e, t) {
                void 0 === t && (t = null), null === t && (t = E.create());
                var n = ge.instance.screen, r = n.size, i = this._viewport, o = e.x, a = e.y;
                return n.rotated ? (t.x = r.w + i.x - a / i.w * r.h, t.y = o / i.h * r.w + i.y) : (t.x = o / i.w * r.w + i.x, t.y = a / i.h * r.h + i.y), t
            }, Object.defineProperty(t.prototype, "matchFactor", {
                get: function () {
                    return this._matchFactor
                }, set: function (e) {
                    e < 0 ? e = 0 : e > 1 && (e = 1), this._matchFactor !== e && (this._matchFactor = e, this._updateViewport())
                }, enumerable: !0, configurable: !0
            }), Object.defineProperty(t.prototype, "size", {
                get: function () {
                    return this._size
                }, set: function (e) {
                    this._size.w = e.w > 1 ? e.w : 1, this._size.h = e.h > 1 ? e.h : 1, this._updateViewport()
                }, enumerable: !0, configurable: !0
            }), Object.defineProperty(t.prototype, "viewport", {
                get: function () {
                    return this._viewport
                }, enumerable: !0, configurable: !0
            }), h([Object(u.property)("float", {
                minimum: 0,
                maximum: 1
            })], t.prototype, "matchFactor", null), h([Object(u.property)("size")], t.prototype, "size", null), h([Object(u.property)("rectangle", {readonly: !0})], t.prototype, "viewport", null), t = h([Object(u.hideFlag)(16), Object(c.component)({
                isRemovable: !1,
                isAbstract: !1
            })], t)
        }(me);
        __reflect(ve, "@egret/engine/Stage");
        var ye = function (e) {
            function t() {
                var t = null !== e && e.apply(this, arguments) || this;
                return t.name = "Noname", t.tag = "Untagged", t.children = [], t.scene = null, t._enabledDirty = !0, t._globalEnabled = !1, t._layer = 1, t._parent = null, t
            }

            return d(t, e), t.prototype._destroy = function () {
                var t = this._parent;
                this.removeChildren(), null !== t && t._removeChild(this), e.prototype._destroy.call(this)
            }, t.prototype._addChild = function (e) {
                var t = this.children;
                t.indexOf(e) < 0 ? (e._parent = this, t[t.length] = e) : console.error("Add child error.")
            }, t.prototype._removeChild = function (e) {
                var t = this.children, n = t.indexOf(e);
                n >= 0 ? (e._parent = null, t.splice(n, 1)) : console.error("Remove child error.")
            }, t.prototype.uninitialize = function () {
                e.prototype.uninitialize.call(this);
                this.name = "Noname", this.tag = "", this.children.length = 0, this.scene = null, this._enabledDirty = !0, this._globalEnabled = !1, this._parent = null
            }, t.prototype.handleEvent = function (t, n) {
                this._enabledDirty = !0, e.prototype.handleEvent.call(this, t, n);
                for (var r = 0, i = this.children; r < i.length; r++) {
                    var o = i[r];
                    o.entity.enabled && o.entity.handleEvent(t, !1)
                }
            }, t.prototype.removeChildren = function () {
                for (var e = this.children, t = e.length; t-- > 0;) {
                    var n = e[t];
                    null !== n && n.entity.destroy()
                }
            }, t.prototype.getChildIndex = function (e) {
                return e._parent === this ? this.children.indexOf(e) : -1
            }, t.prototype.setChildIndex = function (e, t) {
                if (e._parent === this) {
                    var n = this.children;
                    if (0 <= t && t < n.length) {
                        var r = n.indexOf(e);
                        if (r !== t) return n.splice(r, 1), n.splice(t, 0, e), ge.instance.signals.onNodeIndexChanged.dispatch(e, r, t), !0
                    }
                } else console.warn("Set child index error.");
                return !1
            }, t.prototype.getChildren = function (e, t) {
                void 0 === e && (e = null), void 0 === t && (t = 0), null === e && (e = []);
                for (var n = 0, r = this.children; n < r.length; n++) {
                    var i = r[n];
                    if (Array.isArray(e)) e.push(i); else {
                        var o = i.name;
                        if (o in e) {
                            var a = e[o];
                            Array.isArray(a) ? a.push(i) : e[o] = [a, i]
                        } else e[o] = i
                    }
                    1 !== t && i.getChildren(e, t > 0 ? t - 1 : 0)
                }
                return e
            }, t.prototype.getChildAt = function (e) {
                var t = this.children;
                return 0 <= e && e < t.length ? t[e] : null
            }, t.prototype.getChildByName = function (e) {
                for (var t = this, n = 0, r = e.split("/"); n < r.length; n++) {
                    var i = r[n];
                    if (i.length > 0) {
                        for (var o = t, a = 0, s = t.children; a < s.length; a++) {
                            var l = s[a];
                            if (l.name === i) {
                                t = l;
                                break
                            }
                        }
                        if (o === t) return null
                    }
                }
                return t
            }, t.prototype.contains = function (e) {
                if (e.scene !== this.scene) return !1;
                for (var t = e; t !== this && null !== t;) t = t._parent;
                return t === this
            }, Object.defineProperty(t.prototype, "isActiveAndEnabled", {
                get: function () {
                    if (this._enabledDirty) {
                        var e = this._parent;
                        null !== e ? e.isActiveAndEnabled ? this._globalEnabled = this._enabled && this.entity.enabled : this._globalEnabled = !1 : this._globalEnabled = this._enabled, this._enabledDirty = !1
                    }
                    return this._globalEnabled
                }, enumerable: !0, configurable: !0
            }), Object.defineProperty(t.prototype, "layer", {
                get: function () {
                    return this._layer
                }, set: function (e) {
                    if (this._layer !== e) {
                        var t = this._layer;
                        this._layer = e, ge.instance.signals.onNodeLayerChanged.dispatch(this, t, e)
                    }
                }, enumerable: !0, configurable: !0
            }), Object.defineProperty(t.prototype, "path", {
                get: function () {
                    for (var e = this.name, t = this._parent; null !== t;) e = t.name + "/" + e, t = t._parent;
                    return e
                }, enumerable: !0, configurable: !0
            }), Object.defineProperty(t.prototype, "childCount", {
                get: function () {
                    return this.children.length
                }, enumerable: !0, configurable: !0
            }), Object.defineProperty(t.prototype, "parent", {
                get: function () {
                    return this._parent
                }, set: function (e) {
                    if ((null === this.scene || this !== this.scene.root) && (null === e && (e = this.scene.root), this._parent !== e)) if (e === this || this.contains(e)) console.error("Set the parent of the node error."); else {
                        var t = this._parent, n = this.entity.isActiveAndEnabled;
                        null !== t && t._removeChild(this), e._addChild(this);
                        for (var r = [this], i = 0, o = r; i < o.length; i++) {
                            var a = o[i];
                            a.scene = e.scene, a.children.length > 0 && r.push.apply(r, a.children)
                        }
                        this._enabledDirty = !0;
                        var s = this.entity.isActiveAndEnabled;
                        n !== s && this.entity.handleEvent(s, !1), ge.instance.signals.onNodeParentChanged.dispatch(this, t, e)
                    }
                }, enumerable: !0, configurable: !0
            }), h([Object(u.property)("string"), u.serializedField], t.prototype, "name", void 0), h([Object(u.property)("enum", {listItems: Object(u.getItemsFromEnum)(ue)}), u.serializedField], t.prototype, "tag", void 0), h([Object(u.property)("enum", {listItems: Object(u.getItemsFromEnum)(ce)}), u.serializedField], t.prototype, "layer", null), t = h([Object(u.hideFlag)(16), Object(c.component)({
                isRemovable: !1,
                isAbstract: !1
            })], t)
        }(c.Component);
        __reflect(ye, "@egret/engine/TreeNode");
        var be = function (e) {
            function t() {
                var t = null !== e && e.apply(this, arguments) || this;
                return t.name = "Noname", t.model = null, t
            }

            return d(t, e), t.prototype.uninitialize = function () {
                e.prototype.uninitialize.call(this), this.name = "Noname", this.model = null
            }, Object.defineProperty(t.prototype, "root", {
                get: function () {
                    return this.entity.getComponent(ye)
                }, enumerable: !0, configurable: !0
            }), t = h([Object(u.hideFlag)(16), Object(c.component)({isRemovable: !1, isAbstract: !1})], t)
        }(c.Component);
        __reflect(be, "@egret/engine/Scene");
        var xe, Te = E.create(), Ee = V.create(), Ce = I.create();
        !function (e) {
            e[e.All = 63] = "All", e[e.PRS = 7] = "PRS", e[e.MIM = 48] = "MIM", e[e.Position = 1] = "Position", e[e.Rotation = 2] = "Rotation", e[e.Scale = 4] = "Scale", e[e.Euler = 8] = "Euler", e[e.Matrix = 16] = "Matrix", e[e.InverseMatrix = 32] = "InverseMatrix"
        }(xe || (xe = {}));
        var Se = function (e) {
            function t() {
                var t = null !== e && e.apply(this, arguments) || this;
                return t.onChanged = l.Signal.create(), t.worldMatrixDeterminant = 0, t._localDirty = 63, t._worldDirty = 63, t._localSkewZ = 0, t._localPosition = E.create(), t._localRotation = V.create(), t._localEulerAngles = E.create(), t._localScale = E.create(1, 1, 1), t._position = E.create(), t._rotation = V.create(), t._eulerAngles = E.create(), t._scale = E.create(1, 1, 1), t._localMatrix = I.create(), t._matrix = I.create(), t._inverseMatrix = I.create(), t._parentMatrix = null, t
            }

            var n;
            return d(t, e), n = t, t.prototype._onPositionUpdate = function (e) {
                e === this._localPosition ? this.needUpdate(!0, 1) : this.position = e
            }, t.prototype._onRotationUpdate = function (e) {
                e === this._localRotation ? this.needUpdate(!0, 2) : this.rotation = e
            }, t.prototype._onEulerAnglesUpdate = function (e) {
                e === this._localEulerAngles ? this.localEulerAngles = e : this.eulerAngles = e
            }, t.prototype._onScaleUpdate = function (e) {
                e === this._localScale && this.needUpdate(!0, 4)
            }, t.prototype._getParentTransform = function (e) {
                if (null !== e) {
                    var t = e.entity.transform;
                    if (null !== t && t.constructor === n) return t
                }
                return null
            }, t.prototype._worldTransformStays = function (e) {
                e ? (Te.copy(this.position), Ee.copy(this.rotation)) : (this.position = Te, this.rotation = Ee)
            }, t.prototype._updateMatrix = function (e) {
                if (e) {
                    var t = this.localMatrix, n = this._getParentTransform(this.entity.node.parent);
                    null !== n ? this._matrix.multiply(n.localToWorldMatrix, t) : this._matrix.copy(t), this.worldMatrixDeterminant = this._matrix.determinant, this._worldDirty &= -17
                } else {
                    if (2 & this._localDirty || 4 & this._localDirty) {
                        this._localMatrix.compose(this.localPosition, this.localRotation, this.localScale);
                        var r = this._localSkewZ;
                        if (0 !== r) {
                            var i = .017453292519943295 * r, o = .017453292519943295 * this.localEulerAngles.z,
                                a = this._localMatrix.rawData;
                            a[4] = -Math.sin(o + i) * this._localScale.y, a[5] = Math.cos(o + i) * this._localScale.y
                        }
                        this._localDirty &= -8
                    } else 1 & this._localDirty && (this._localMatrix.fromTranslate(this.localPosition, !0), this._localDirty &= -2);
                    this._localDirty &= -17
                }
            }, t.prototype._updateToParentMatrix = function (e) {
                var t = this.localMatrix;
                if (this !== e) {
                    var n = this._getParentTransform(e.entity.node);
                    this._parentMatrix.multiply(n.getLocalToParentMatrix(e), t)
                } else this._parentMatrix.copy(t)
            }, t.prototype._updateEuler = function (e, t) {
                void 0 === t && (t = 3), e ? (this.rotation.toEuler(this._eulerAngles, t), this._eulerAngles.multiplyScalar(57.29577951308232), this._worldDirty &= -9) : (this.localRotation.toEuler(this._localEulerAngles, t), this._localEulerAngles.multiplyScalar(57.29577951308232), this._localDirty &= -9)
            }, t.prototype.initialize = function (t, n, r) {
                void 0 === r && (r = null), e.prototype.initialize.call(this, t, n, r);
                var i = this._onPositionUpdate.bind(this), o = this._onRotationUpdate.bind(this),
                    a = this._onEulerAnglesUpdate.bind(this), s = this._onScaleUpdate.bind(this);
                this._localPosition.updater = new l.Updater(this._localPosition, i), this._position.updater = new l.Updater(this._position, i), this._localRotation.updater = new l.Updater(this._localRotation, o), this._rotation.updater = new l.Updater(this._rotation, o), this._localEulerAngles.updater = new l.Updater(this._localEulerAngles, a), this._eulerAngles.updater = new l.Updater(this._eulerAngles, a), this._localScale.updater = new l.Updater(this._localScale, s), this._scale.updater = new l.Updater(this._scale, s)
            }, t.prototype.uninitialize = function () {
                e.prototype.uninitialize.call(this), this.onChanged.removeAll()
            }, t.prototype.needUpdate = function (e, t) {
                if (e) {
                    if (this._localDirty |= 48 | t, 2 & t ? this._localDirty |= 12 : 4 & t && (this._localDirty |= 2), 1 & t) {
                        var r = !1, i = this._localPosition;
                        i.x != i.x && (r = !0, i.x = 0), i.y != i.y && (r = !0, i.y = 0), i.z != i.z && (r = !0, i.z = 0), r && console.error("Error local position.")
                    }
                    if (2 & t) {
                        r = !1;
                        var o = this._localRotation.rawData;
                        o[0] != o[0] && (r = !0, o[0] = 0), o[1] != o[1] && (r = !0, o[1] = 0), o[2] != o[2] && (r = !0, o[2] = 0), o[3] != o[3] && (r = !0, o[3] = 1), r && console.error("Error local rotation.")
                    }
                    if (4 & t) {
                        r = !1;
                        var a = this._localScale;
                        a.x != a.x && (r = !0, a.x = 1), a.y != a.y && (r = !0, a.y = 1), a.z != a.z && (r = !0, a.z = 1), r && console.error("Error local scale.")
                    }
                }
                this._worldDirty & t && 16 & this._worldDirty || (this._worldDirty |= 48 | t, 2 & t ? this._worldDirty |= 12 : 4 & t && (this._worldDirty |= 2));
                for (var s = 0, l = this.entity.node.children; s < l.length; s++) {
                    var u = l[s].entity.transform;
                    null !== u && u.constructor === n && u.needUpdate(!1, 63)
                }
                this.onChanged.dispatch(this)
            }, t.prototype.setLocalPosition = function (e, t, n) {
                void 0 === t && (t = 0), void 0 === n && (n = 0);
                var r = this._localPosition;
                return 1 === arguments.length ? (r.x = e.x, r.y = e.y, r.z = e.z) : (r.x = e, r.y = t, r.z = n), this.needUpdate(!0, 1), this
            }, Object.defineProperty(t.prototype, "localPosition", {
                get: function () {
                    return this._localPosition
                }, set: function (e) {
                    var t = this._localPosition;
                    t.x = e.x, t.y = e.y, t.z = e.z, this.needUpdate(!0, 1)
                }, enumerable: !0, configurable: !0
            }), t.prototype.setLocalRotation = function (e, t, n, r) {
                void 0 === t && (t = 0), void 0 === n && (n = 0), void 0 === r && (r = 0);
                var i = this._localRotation, o = i.rawData;
                if (1 === arguments.length) {
                    var a = e.rawData;
                    o[0] = a[0], o[1] = a[1], o[2] = a[2], o[3] = a[3]
                } else o[0] = e, o[1] = t, o[2] = n, o[3] = r;
                return this.needUpdate(!0, 2), this
            }, Object.defineProperty(t.prototype, "localRotation", {
                get: function () {
                    return this._localRotation
                }, set: function (e) {
                    var t = this._localRotation.rawData, n = e.rawData;
                    t[0] = n[0], t[1] = n[1], t[2] = n[2], t[3] = n[3], this.needUpdate(!0, 2)
                }, enumerable: !0, configurable: !0
            }), Object.defineProperty(t.prototype, "localSkewZ", {
                get: function () {
                    return this._localSkewZ
                }, set: function (e) {
                    this._localSkewZ !== e && (this._localSkewZ = e, this.needUpdate(!0, 2))
                }, enumerable: !0, configurable: !0
            }), t.prototype.setLocalEulerAngles = function (e, t, n, r) {
                void 0 === t && (t = 3), void 0 === n && (n = 0), void 0 === r && (r = 3);
                var i = this._localEulerAngles;
                return arguments.length < 3 ? (i.x = e.x, i.y = e.y, i.z = e.z, Te.multiplyScalar(.017453292519943295, i), this._localRotation.fromEuler(Te, t)) : (i.x = e, i.y = t, i.z = n, Te.multiplyScalar(.017453292519943295, i), this._localRotation.fromEuler(Te, r)), this.needUpdate(!0, 2), this._localDirty &= -9, this
            }, Object.defineProperty(t.prototype, "localEulerAngles", {
                get: function () {
                    return 8 & this._localDirty && this._updateEuler(!1), this._localEulerAngles
                }, set: function (e) {
                    var t = this._localEulerAngles;
                    t.x = e.x, t.y = e.y, t.z = e.z, Te.multiplyScalar(.017453292519943295, t), this._localRotation.fromEuler(Te), this.needUpdate(!0, 2), this._localDirty &= -9
                }, enumerable: !0, configurable: !0
            }), t.prototype.setLocalScale = function (e, t, n) {
                void 0 === t && (t = 1), void 0 === n && (n = 1);
                var r = 2220446049250313e-31, i = this._localScale;
                return 1 === arguments.length ? e.hasOwnProperty("x") ? (i.x = e.x || r, i.y = e.y || r, i.z = e.z || r) : (i.x = e || r, i.y = e || r, i.z = e || r) : (i.x = e || r, i.y = t || r, i.z = n || r), this.needUpdate(!0, 4), this
            }, Object.defineProperty(t.prototype, "localScale", {
                get: function () {
                    return this._localScale
                }, set: function (e) {
                    var t = 2220446049250313e-31, n = this._localScale;
                    n.x = e.x || t, n.y = e.y || t, n.z = e.z || t, this.needUpdate(!0, 4)
                }, enumerable: !0, configurable: !0
            }), Object.defineProperty(t.prototype, "localMatrix", {
                get: function () {
                    return 16 & this._localDirty && this._updateMatrix(!1), this._localMatrix
                }, enumerable: !0, configurable: !0
            }), t.prototype.setPosition = function (e, t, n) {
                void 0 === t && (t = 0), void 0 === n && (n = 0);
                var r = this._localPosition;
                1 === arguments.length ? (r.x = e.x, r.y = e.y, r.z = e.z) : (r.x = e, r.y = t, r.z = n);
                var i = this._getParentTransform(this.entity.node.parent);
                return null !== i && r.applyMatrix(i.worldToLocalMatrix), this.needUpdate(!0, 1), this
            }, Object.defineProperty(t.prototype, "position", {
                get: function () {
                    return 1 & this._worldDirty && (this.localToWorldMatrix.decompose(this._position, null, null), this._worldDirty &= -2), this._position
                }, set: function (e) {
                    var t = this._localPosition;
                    t.x = e.x, t.y = e.y, t.z = e.z;
                    var n = this._getParentTransform(this.entity.node.parent);
                    null !== n && t.applyMatrix(n.worldToLocalMatrix), this.needUpdate(!0, 1)
                }, enumerable: !0, configurable: !0
            }), t.prototype.setRotation = function (e, t, n, r) {
                void 0 === t && (t = 0), void 0 === n && (n = 0), void 0 === r && (r = 0);
                var i = this._localRotation, o = i.rawData;
                if (1 === arguments.length) {
                    var a = e.rawData;
                    o[0] = a[0], o[1] = a[1], o[2] = a[2], o[3] = a[3]
                } else o[0] = e, o[1] = t, o[2] = n, o[3] = r;
                var s = this._getParentTransform(this.entity.node.parent);
                return null !== s && i.premultiply(Ee.inverse(s.rotation)).normalize(), this.needUpdate(!0, 2), this
            }, Object.defineProperty(t.prototype, "rotation", {
                get: function () {
                    return 2 & this._worldDirty && (this.localToWorldMatrix.decompose(null, this._rotation, null), this._worldDirty &= -3), this._rotation
                }, set: function (e) {
                    var t = this._localRotation, n = t.rawData, r = e.rawData;
                    n[0] = r[0], n[1] = r[1], n[2] = r[2], n[3] = r[3];
                    var i = this._getParentTransform(this.entity.node.parent);
                    null !== i && t.premultiply(Ee.inverse(i.rotation)).normalize(), this.needUpdate(!0, 2)
                }, enumerable: !0, configurable: !0
            }), t.prototype.setEulerAngles = function (e, t, n, r) {
                void 0 === t && (t = 3), void 0 === n && (n = 0), void 0 === r && (r = 3);
                var i = this._localRotation;
                arguments.length < 3 ? (Te.multiplyScalar(.017453292519943295, e), i.fromEuler(Te, t)) : (Te.set(.017453292519943295 * e, .017453292519943295 * t, .017453292519943295 * n), i.fromEuler(Te, r));
                var o = this._getParentTransform(this.entity.node.parent);
                return null !== o && i.premultiply(Ee.inverse(o.rotation)).normalize(), this.needUpdate(!0, 2), this
            }, Object.defineProperty(t.prototype, "eulerAngles", {
                get: function () {
                    return 8 & this._worldDirty && this._updateEuler(!0), this._eulerAngles
                }, set: function (e) {
                    Te.multiplyScalar(.017453292519943295, e), this._localRotation.fromEuler(Te);
                    var t = this._getParentTransform(this.entity.node.parent);
                    null !== t && this._localRotation.premultiply(Ee.inverse(t.rotation)).normalize(), this.needUpdate(!0, 2)
                }, enumerable: !0, configurable: !0
            }), Object.defineProperty(t.prototype, "scale", {
                get: function () {
                    return 4 & this._worldDirty && (this.localToWorldMatrix.decompose(null, null, this._scale), this._worldDirty &= -5), this._scale
                }, enumerable: !0, configurable: !0
            }), Object.defineProperty(t.prototype, "localToWorldMatrix", {
                get: function () {
                    return 16 & this._worldDirty && this._updateMatrix(!0), this._matrix
                }, enumerable: !0, configurable: !0
            }), Object.defineProperty(t.prototype, "worldToLocalMatrix", {
                get: function () {
                    return 32 & this._worldDirty && (this._inverseMatrix.inverse(this.localToWorldMatrix), this._worldDirty &= -33), this._inverseMatrix
                }, enumerable: !0, configurable: !0
            }), t.prototype.translate = function (e, t, n, r) {
                return void 0 === t && (t = !1), void 0 === n && (n = 0), void 0 === r && (r = !1), arguments.length >= 3 && (e = Te.set(e, t, n), t = r), t ? this.position = this._localPosition.add(e, this.position) : this.localPosition = this._localPosition.add(e), this
            }, t.prototype.rotate = function (e, t, n, r) {
                return void 0 === t && (t = !1), void 0 === n && (n = 0), void 0 === r && (r = !1), arguments.length >= 3 && (e = Te.set(e, t, n), t = r), t ? this.eulerAngles = this._localEulerAngles.add(e, this.eulerAngles) : (this.localEulerAngles, this.localEulerAngles = this._localEulerAngles.add(e)), this
            }, t.prototype.rotateOnAxis = function (e, t, n) {
                return void 0 === n && (n = !1), Ee.fromAxis(e, .017453292519943295 * t), this.localRotation = n ? this._localRotation.premultiply(Ee).normalize() : this._localRotation.multiply(Ee).normalize(), this
            }, t.prototype.rotateAround = function (e, t, n) {
                return this.rotateOnAxis(t, n, !0), this.position = this._localPosition.applyMatrix(Ce.fromRotation(Ee.fromAxis(t, .017453292519943295 * n)).fromTranslate(e, !0), this.position), this
            }, t.prototype.lookAt = function (e, t) {
                return void 0 === t && (t = E.UP), this.rotation = this._localRotation.fromMatrix(Ce.lookAt(this.position, e.constructor === n ? e.position : e, t)), this
            }, t.prototype.lookRotation = function (e, t) {
                return void 0 === t && (t = E.UP), this.rotation = this._localRotation.fromMatrix(Ce.lookRotation(e, t)), this
            }, t.prototype.getRight = function (e) {
                return void 0 === e && (e = null), null === e && (e = E.create()), e.applyDirection(this.localToWorldMatrix, E.RIGHT)
            }, t.prototype.getUp = function (e) {
                return void 0 === e && (e = null), null === e && (e = E.create()), e.applyDirection(this.localToWorldMatrix, E.UP)
            }, t.prototype.getForward = function (e) {
                return void 0 === e && (e = null), null === e && (e = E.create()), e.applyDirection(this.localToWorldMatrix, E.FORWARD)
            }, t.prototype.setParent = function (e, t) {
                return void 0 === t && (t = !1), t && this._worldTransformStays(!0), this.entity.node.parent = e.entity.node, t && this._worldTransformStays(!1), this
            }, t.prototype.getLocalToParentMatrix = function (e) {
                return null === this._parentMatrix && (this._parentMatrix = I.create()), this._updateToParentMatrix(e), this._parentMatrix
            }, h([Object(u.property)("vector3"), u.serializedField], t.prototype, "localPosition", null), h([u.serializedField], t.prototype, "localRotation", null), h([Object(u.property)("vector3", {step: 1})], t.prototype, "localEulerAngles", null), h([Object(u.property)("vector3"), u.serializedField], t.prototype, "localScale", null), t = n = h([Object(u.hideFlag)(16), Object(c.component)({
                type: "transform",
                isAbstract: !1
            })], t)
        }(c.Component);
        __reflect(Se, "@egret/engine/Transform");
        var Me = function (e) {
            function t() {
                var t = null !== e && e.apply(this, arguments) || this;
                return t._isAwaked = !1, t._isStarted = !1, t._config = null, t
            }

            return d(t, e), t.prototype._destroy = function () {
                this._getExecuteEnabled() && this._isAwaked && this.onDestroy && this.onDestroy(), e.prototype._destroy.call(this)
            }, t.prototype._getExecuteEnabled = function () {
                var e = ge.instance.executeMode, t = this.constructor.extensions;
                if (null !== t) {
                    var n = t, r = n.allOfExecuteMode, i = n.anyOfExecuteMode, o = n.noneOfExecuteMode;
                    return !(void 0 !== r && (r & e) !== r || void 0 !== i && 0 == (i & e) || void 0 !== o && 0 != (o & e))
                }
                return 0 != (1 & e)
            }, t.prototype.initialize = function (t, n, r) {
                void 0 === r && (r = null), e.prototype.initialize.call(this, t, n, r), this._getExecuteEnabled() && (this.isActiveAndEnabled ? (this.onAwake && this.onAwake(r), this._isAwaked = !0) : this._config = r)
            }, t.prototype.uninitialize = function () {
                e.prototype.uninitialize.call(this), this._isAwaked = !1, this._isStarted = !1, this._config = null
            }, t.prototype.handleEvent = function (t, n) {
                if (this._getExecuteEnabled()) {
                    var r = ge.instance.helpers, i = r.addedBehaviours, o = r.behaviours;
                    if (t) this._isAwaked || (this.onAwake && this.onAwake(this._config), this._isAwaked = !0, this._config = null), this.onEnable && this.onEnable(), i[i.length] = this, o[o.length] = this; else {
                        this.onDisable && this.onDisable();
                        var a = i.indexOf(this);
                        a >= 0 && (i[a] = null), (a = o.indexOf(this)) >= 0 && (o[a] = null)
                    }
                }
                e.prototype.handleEvent.call(this, t, n)
            }, t = h([Object(c.component)({isAbstract: !0})], t)
        }(me);
        __reflect(Me, "@egret/engine/Behaviour");
        var Ae = function (e) {
            function t() {
                var t = null !== e && e.apply(this, arguments) || this;
                return t.name = "", t.modelData = null, t
            }

            return d(t, e), t = h([Object(u.hideFlag)(20), Object(c.component)({isAbstract: !1})], t)
        }(c.Component);
        __reflect(Ae, "@egret/engine/EntityModel");
        var Oe = function (e) {
            function t() {
                var t = null !== e && e.apply(this, arguments) || this;
                return t.onResize = l.Signal.create(), t.rotated = !1, t.useDevicePixelRatio = !1, t.pixelRatio = 1, t.devicePixelRatio = 1, t._size = {
                    w: 2048,
                    h: 1920
                }, t
            }

            return d(t, e), t.prototype.uninitialize = function () {
                e.prototype.uninitialize.call(this), this.onResize.removeAll()
            }, Object.defineProperty(t.prototype, "size", {
                get: function () {
                    return this._size
                }, set: function (e) {
                    this._size.w = e.w > 1 ? e.w : 1, this._size.h = e.h > 1 ? e.h : 1, this.onResize.dispatch()
                }, enumerable: !0, configurable: !0
            }), h([Object(u.property)("boolean"), u.serializedField], t.prototype, "useDevicePixelRatio", void 0), h([Object(u.property)("float", {
                minimum: .1,
                maximum: 10
            }), u.serializedField], t.prototype, "pixelRatio", void 0), h([Object(u.property)("size")], t.prototype, "size", null), t = h([Object(u.hideFlag)(16), Object(c.component)({
                isRemovable: !1,
                isAbstract: !1
            })], t)
        }(c.Component);
        __reflect(Oe, "@egret/engine/Screen");
        var we = function (e) {
            function t() {
                var t = null !== e && e.apply(this, arguments) || this;
                return t._signals = {}, t.onNodeLayerChanged = t.addSignal("onNodeLayerChanged"), t.onNodeSceneChanged = t.addSignal("onNodeSceneChanged"), t.onNodeParentChanged = t.addSignal("onNodeParentChanged"), t.onNodeIndexChanged = t.addSignal("onNodeIndexChanged"), t
            }

            return d(t, e), t.prototype.addSignal = function (e) {
                var t = this._signals;
                return e in t ? t[e] : t[e] = l.Signal.create()
            }, t.prototype.removeSignal = function (e) {
                var t = this._signals;
                return e in t && (t[e].removeAll(), delete t[e], !0)
            }, t.prototype.getSignal = function (e, t) {
                void 0 === t && (t = !1);
                var n = this._signals;
                return e in n ? n[e] : t ? this.addSignal(e) : null
            }, t = h([Object(u.hideFlag)(28), Object(c.component)({isRemovable: !1, isAbstract: !1})], t)
        }(c.Component);
        __reflect(we, "@egret/engine/Signals");
        var Re = function (e) {
            function t() {
                var t = null !== e && e.apply(this, arguments) || this;
                return t.tickCompensateSpeed = 3, t.tickInterval = 1 / 60, t.frameInterval = 1 / 60, t.timeScale = 1, t.tickCount = 0, t.frameCount = 0, t.deltaTickCount = 0, t.deltaFrameCount = 0, t.now = 0, t.unscaledTickTime = 0, t.unscaledFrameTime = 0, t.unscaledTickDeltaTime = 0, t.unscaledFrameDeltaTime = 0, t.wholeCost = 0, t.totalCost = 0, t.tickCost = 0, t.frameCost = 0, t._needReset = 0, t._beginTime = -1, t._timeScale = 1, t._unusedFrameDeltaTime = 0, t._unusedTickDeltaTime = 0, t
            }

            return d(t, e), t.prototype._getNow = function () {
                return Date.now ? Date.now() : (new Date).getTime()
            }, t.prototype.reset = function () {
                this._needReset = 2
            }, t.prototype.update = function (e) {
                e *= .001, this.tickInterval <= 0 && (this.tickInterval = 1 / 60), this.deltaFrameCount > 0 && (this.unscaledFrameDeltaTime = 0), this._beginTime < 0 && (this._beginTime = e);
                var t = this.unscaledFrameTime, n = e - this._beginTime, r = n - t;
                if (this.deltaTickCount = 0, this.deltaFrameCount = 0, this.unscaledFrameTime = n, this.now = this._getNow(), this._timeScale = this.timeScale, 2 === this._needReset) return this.tickCount++, this.frameCount++, this.deltaTickCount++, this.deltaFrameCount++, this.unscaledTickDeltaTime = this.tickInterval, this.unscaledFrameDeltaTime = this.frameInterval, this._needReset = 1, this;
                if (this._needReset = 0, this._unusedTickDeltaTime += r, this._unusedTickDeltaTime >= this.tickInterval) {
                    for (; this._unusedTickDeltaTime >= this.tickInterval && this.deltaTickCount < this.tickCompensateSpeed;) this._unusedTickDeltaTime -= this.tickInterval, this.deltaTickCount++;
                    this.unscaledTickDeltaTime = this.tickInterval
                }
                return this.frameInterval > 0 ? (this._unusedFrameDeltaTime += r, this._unusedFrameDeltaTime >= this.frameInterval && (this._unusedFrameDeltaTime %= this.frameInterval, this.frameCount++, this.deltaFrameCount++), this.unscaledFrameDeltaTime += r) : (this.frameCount++, this.deltaFrameCount++, this.unscaledFrameDeltaTime = r), this
            }, t.prototype.timestamp = function () {
                return this._getNow()
            }, Object.defineProperty(t.prototype, "tickTime", {
                get: function () {
                    return this.unscaledTickTime * this._timeScale
                }, enumerable: !0, configurable: !0
            }), Object.defineProperty(t.prototype, "frameTime", {
                get: function () {
                    return this.unscaledFrameTime * this._timeScale
                }, enumerable: !0, configurable: !0
            }), Object.defineProperty(t.prototype, "tickDeltaTime", {
                get: function () {
                    return this.unscaledTickDeltaTime * this._timeScale
                }, enumerable: !0, configurable: !0
            }), Object.defineProperty(t.prototype, "frameDeltaTime", {
                get: function () {
                    return this.unscaledFrameDeltaTime * this._timeScale
                }, enumerable: !0, configurable: !0
            }), h([Object(u.property)("uint", {
                minimum: 1,
                maximum: 100
            }), u.serializedField], t.prototype, "tickCompensateSpeed", void 0), h([Object(u.property)("float", {
                minimum: .001,
                maximum: 1
            }), u.serializedField], t.prototype, "tickInterval", void 0), h([Object(u.property)("float", {
                minimum: 0,
                maximum: 1
            }), u.serializedField], t.prototype, "frameInterval", void 0), h([Object(u.property)("float", {minimum: 0})], t.prototype, "timeScale", void 0), h([Object(u.property)("uint", {readonly: !0})], t.prototype, "tickCount", void 0), h([Object(u.property)("uint", {readonly: !0})], t.prototype, "frameCount", void 0), h([Object(u.property)("float", {readonly: !0})], t.prototype, "unscaledTickTime", void 0), h([Object(u.property)("float", {readonly: !0})], t.prototype, "unscaledFrameTime", void 0), t = h([Object(u.hideFlag)(16), Object(c.component)({
                isRemovable: !1,
                isAbstract: !1
            })], t)
        }(c.Component);
        __reflect(Re, "@egret/engine/Clock");
        var Pe, Le = function (e) {
            function t() {
                var t = null !== e && e.apply(this, arguments) || this;
                return t.addedBehaviours = [], t.behaviours = [], t
            }

            return d(t, e), t = h([Object(u.hideFlag)(28), Object(c.component)({isRemovable: !1, isAbstract: !1})], t)
        }(c.Component);
        __reflect(Le, "@egret/engine/Helpers"), function (e) {
            e[e.No = 0] = "No", e[e.Yes = 1] = "Yes"
        }(Pe || (Pe = {}));
        var De = function (e) {
            function t() {
                return null !== e && e.apply(this, arguments) || this
            }

            return d(t, e), t.createInstance = function (e, n, r) {
                var i = u.ResourceManager.instance.getResource(e);
                if (i && i instanceof c.Component && i.entity instanceof u.AssetEntity) {
                    var o = i;
                    if (!o.modelData) return console.warn("no entityModel comp in asset", e), null;
                    var a = Object(u.deserialize)(o.modelData, n && {prefab: n}, r);
                    if (a && n && n.keepModelInfo === Pe.Yes) {
                        var s = t.getEntityExtras(a) || {};
                        Object.assign(s, {prefab: o}), t.setEntityExtras(a, s)
                    }
                    return a
                }
                return console.warn("Failed to create", e, ", which does not exist"), null
            }, t.coypEntityExtrasFromRes = function (e, n, r, i) {
                var o = u.ResourceManager.instance.getResource(n);
                if (o) {
                    var a = o;
                    if (!a.modelData) return void console.warn("no entityModel comp in asset", n);
                    var s = Object(u.deserialize)(a.modelData, r && {prefab: r}, i);
                    if (s && r && r.keepModelInfo === Pe.Yes) {
                        var l = t.getEntityExtras(s) || {};
                        Object.assign(l, {prefab: a}), t.setEntityExtras(s, l), t.copyExtrasRecursive(s, e), s.destroy()
                    } else console.warn("Failed to set extras")
                } else console.warn("Failed to create", n, ", which does not exist")
            }, t.copyExtrasRecursive = function (e, n) {
                var r = t.getEntityExtras(e);
                r ? t.setEntityExtras(n, r) : console.warn("entityExtras null,entity:" + e);
                for (var i = 0; i < e.components.length; i++) {
                    var o = e.components[i], a = t.getComponentExtras(o);
                    a ? t.setComponentExtras(n.components[i], a) : console.warn("componentExtras null,component:" + o)
                }
                for (i = 0; i < e.node.childCount; i++) {
                    var s = e.node.children[i].entity, l = n.node.children[i].entity;
                    t.copyExtrasRecursive(s, l)
                }
            }, t.isEntityPrefabRoot = function (e) {
                if (!e) return !1;
                var t = this.getEntityExtras(e);
                return !(!t || !t.prefab)
            }, t.isEntityPrefabChild = function (e) {
                if (!e) return !1;
                var t = this.getEntityExtras(e);
                return !(!(t && t.rootID && t.linkedID) || t.prefab)
            }, t.getEntityExtras = function (e) {
                return e[u.KEY_EXTRAS] || null
            }, t.getComponentExtras = function (e) {
                return e[u.KEY_EXTRAS] || null
            }, t.setEntityExtras = function (e, t) {
                e[u.KEY_EXTRAS] = t
            }, t.setComponentExtras = function (e, t) {
                e[u.KEY_EXTRAS] = t
            }, t.getEntityLinkedId = function (e) {
                var t = this.getEntityExtras(e);
                if (!t) return null;
                if (void 0 !== t.linkedID) return t.linkedID;
                var n = t.prefab;
                if (!n) return null;
                var r = n.modelData;
                if (!r) return null;
                var i = r.entities && r.entities[0];
                return i ? i.uuid : null
            }, t.getEntityRootId = function (e) {
                var t = this.getEntityExtras(e);
                return t && (t.rootID || e.uuid) || null
            }, t.getComponentLinkedId = function (e) {
                var t = this.getComponentExtras(e);
                return t && t.linkedID || null
            }, t.getModelUri = function (e) {
                return e && e.entity ? e.entity.uri : (console.warn("invalid EntityModel"), "")
            }, t.create = function (e, t, n, r) {
                var i = u.AssetEntity.requireComponents.concat([Ae]),
                    o = ge.instance.assetContext.createEntityInstance(!0, i, !0, n), a = o.getComponent(Ae);
                o.type = r ? "scene" : "prefab", o.uri = t, o.data = a, o.status = "Ok";
                var s = t.lastIndexOf("/");
                return a.name = s < 0 || s >= t.length - 1 ? t : t.substr(s + 1), a.modelData = e, o
            }, t
        }(DebuggerClass);
        __reflect(De, "@egret/engine/EntityModelAssetEntity");
        var Ie = function (e) {
            function t() {
                var t = null !== e && e.apply(this, arguments) || this;
                return t.scenes = [], t.globalScene = null, t.editorScene = null, t
            }

            return d(t, e), t.prototype.initialize = function (t, n) {
                e.prototype.initialize.call(this, t, n);
                var r = this.scenes;
                this.globalScene = this.createScene("Global", !1), r.splice(r.indexOf(this.globalScene), 1), this.editorScene = this.createScene("Editor", !1), r.splice(r.indexOf(this.editorScene), 1)
            }, t.prototype.createScene = function (e, t) {
                void 0 === t && (t = !0);
                var n = this.scenes, r = n.length > 0 ? n[0] : null,
                    i = ge.instance.gameEntityContext.createEntity(!0, [ye, be]).getComponent(be);
                return i.name = e, t || null === r || (this.activeScene = r), i
            }, t.prototype.loadScene = function (e, t) {
                var n = this;
                return void 0 === t && (t = !0), u.ResourceManager.instance.loadUri(e).then((function () {
                    var r = n.scenes, i = r.length > 0 ? r[0] : null,
                        o = De.createInstance(e, void 0, ge.instance.gameEntityContext);
                    if (null !== o) {
                        var a = o.getComponent(be);
                        return null !== a ? a.model = u.ResourceManager.instance.getResource(e) : console.warn("Scene of resource " + e + " does not exist."), t || null === i || (n.activeScene = i), a
                    }
                    return null
                }))
            }, t.prototype.removeScene = function (e) {
                return !e.entity.isDestroyed && (e.entity.destroy(), !0)
            }, t.prototype.removeAllScene = function (e) {
                void 0 === e && (e = null);
                for (var t = this.scenes, n = t.length; n-- > 0;) {
                    var r = t[n];
                    (null === e || e.indexOf(r) < 0) && r.entity.destroy()
                }
            }, t.prototype.getSceneByName = function (e) {
                for (var t = 0, n = this.scenes; t < n.length; t++) {
                    var r = n[t];
                    if (r.name === e) return r
                }
                return null
            }, Object.defineProperty(t.prototype, "sceneCount", {
                get: function () {
                    return this.scenes.length
                }, enumerable: !0, configurable: !0
            }), Object.defineProperty(t.prototype, "activeScene", {
                get: function () {
                    var e = this.scenes;
                    return 0 === e.length && (console.warn("Try to get the active scene that does not exist."), this.createScene("Noname")), e[0]
                }, set: function (e) {
                    if (this.globalScene !== e && this.editorScene !== e) {
                        var t = this.scenes;
                        if (0 !== t.length) {
                            if (1 !== t.length && t[0] !== e) {
                                var n = t.indexOf(e);
                                n > 0 ? (t.splice(n, 1), t.unshift(e)) : console.error("This application does not contains the scene.")
                            }
                        } else console.error("Try to active a scene that not in scene list.")
                    } else console.error("Cannot active global scene.")
                }, enumerable: !0, configurable: !0
            }), t = h([Object(u.hideFlag)(28), Object(c.component)({isRemovable: !1, isAbstract: !1})], t)
        }(c.Component);
        __reflect(Ie, "@egret/engine/SceneManager");
        var Ne = function (e) {
            function t() {
                var t = null !== e && e.apply(this, arguments) || this;
                return t.node = null, t.transform = null, t.renderer = null, t._beforeRenderComponentCount = 0, t
            }

            return d(t, e), t.prototype._addComponent = function (t) {
                e.prototype._addComponent.call(this, t);
                var n = t.constructor.componentType;
                t.constructor === ye ? this.node = t : "transform" === n ? this.transform = t : "renderer" === n || "renderer2D" === n ? this.renderer = t : t instanceof Me && t.onBeforeRender && this._beforeRenderComponentCount++
            }, t.prototype._removeComponent = function (t, n) {
                e.prototype._removeComponent.call(this, t, n);
                t === this.node ? this.node = null : t === this.transform ? this.transform = null : t === this.renderer ? this.renderer = null : t instanceof Me && t.onBeforeRender && this._beforeRenderComponentCount--
            }, t.prototype.getComponentInParent = function (e, t) {
                void 0 === t && (t = !1);
                var n = this.getComponent(e);
                if (null === n) {
                    var r = this.node, i = r.enabled, o = r.parent;
                    null !== o && (t || i && o.entity.enabled) && (n = o.entity.getComponentInParent(e, t))
                }
                return n
            }, t.prototype.getComponentInChildren = function (e, t) {
                void 0 === t && (t = !1);
                var n = this.getComponent(e), r = this.node, i = r.enabled, o = r.children;
                if (null === n && (t || i)) for (var a = 0, s = o; a < s.length; a++) {
                    var l = s[a];
                    if ((t || l.entity.enabled) && null !== (n = l.entity.getComponentInChildren(e, t))) break
                }
                return n
            }, t.prototype.getComponentsInParent = function (e, t, n) {
                void 0 === t && (t = !1), void 0 === n && (n = null), n = this.getComponents(e, n);
                var r = this.node, i = r.enabled, o = r.parent;
                return null !== o && (t || i && o.entity.enabled) && o.entity.getComponentsInParent(e, t, n), n
            }, t.prototype.getComponentsInChildren = function (e, t, n) {
                void 0 === t && (t = !1), void 0 === n && (n = null), n = this.getComponents(e, n);
                var r = this.node, i = r.enabled, o = r.children;
                if (t || i) for (var a = 0, s = o; a < s.length; a++) {
                    var l = s[a];
                    (t || l.entity.enabled) && l.entity.getComponentsInChildren(e, t, n)
                }
                return n
            }, t.prototype.sendMessage = function (e, t, n) {
                if (void 0 === t && (t = null), void 0 === n && (n = !0), this.isDestroyed) return this._destroyError(), this;
                for (var r = 0, i = this.components; r < i.length; r++) {
                    var o = i[r];
                    o.enabled && o instanceof Me && (e in o ? o[e](t) : n && console.warn("The " + l.Reflect.getQualifiedClassName(o) + " behaviour does not have a method named " + e + "."))
                }
                return this
            }, t.prototype.sendMessageUpwards = function (e, t, n) {
                void 0 === t && (t = null), void 0 === n && (n = !0), this.sendMessage(e, t, n);
                var r = this.node, i = r.enabled, o = r.parent;
                return i && null !== o && o.entity.enabled && o.entity.sendMessageUpwards(e, t, n), this
            }, t.prototype.broadcastMessage = function (e, t, n) {
                if (void 0 === n && (n = !0), this.sendMessage(e, t, n), this.node.enabled) for (var r = 0, i = this.node.children; r < i.length; r++) {
                    var o = i[r];
                    o.enabled && o.entity.broadcastMessage(e, t, n)
                }
                return this
            }, Object.defineProperty(t.prototype, "isActiveAndEnabled", {
                get: function () {
                    if (this.isDestroyed) return this._destroyError(), !1;
                    var e = this.node;
                    if (null !== e) {
                        var t = e.parent;
                        if (null !== t) return this._enabled && t.isActiveAndEnabled
                    }
                    return this._enabled
                }, enumerable: !0, configurable: !0
            }), Object.defineProperty(t.prototype, "dontDestroy", {
                get: function () {
                    return this.node.scene === ge.instance.sceneManager.globalScene
                }, set: function (e) {
                    var t = ge.instance.sceneManager, n = this.node;
                    e !== (n.scene === t.globalScene) && (n.parent = e ? t.globalScene.root : t.activeScene.root)
                }, enumerable: !0, configurable: !0
            }), Object.defineProperty(t.prototype, "parent", {
                get: function () {
                    if (this.isDestroyed) return this._destroyError(), null;
                    var e = this.node;
                    return null !== e.parent ? e.parent.entity : null
                }, set: function (e) {
                    if (this.isDestroyed) this._destroyError(); else {
                        var t = this.node;
                        t.parent = null !== e ? e.node : t.scene.root
                    }
                }, enumerable: !0, configurable: !0
            }), t.prototype.traverse = function (e, t) {
                if (void 0 === t && (t = 0), !0 === e(this, t)) return !0;
                for (var n = 0, r = this.node.children; n < r.length; n++) {
                    if (r[n].entity.traverse(e, t + 1)) return !0
                }
                return !1
            }, t.prototype.traverseReversely = function (e, t) {
                void 0 === t && (t = 0), void 0 === t && (t = 0);
                var n = this.node && this.node.children;
                if (n) for (var r = n.length - 1; r >= 0; r--) if (n[r].entity.traverseReversely(e, t + 1)) return !1;
                return !!e(this, t)
            }, t = h([Object(c.entity)({requireComponents: [ye]})], t)
        }(c.Entity);
        __reflect(Ne, "@egret/engine/GameEntity");
        var ze, Ue = function (e) {
            function t() {
                return null !== e && e.apply(this, arguments) || this
            }

            return d(t, e), t = h([Object(c.entity)()], t)
        }(c.Entity);
        __reflect(Ue, "@egret/engine/GlobalEntity"), function (e) {
            e[e.ExecuteEnabled = 1] = "ExecuteEnabled", e[e.Awaked = 2] = "Awaked", e[e.LastEnabled = 4] = "LastEnabled", e[e.Started = 8] = "Started"
        }(ze || (ze = {}));
        var Fe = function (e) {
            function t() {
                var t = null !== e && e.apply(this, arguments) || this;
                return t._isStartup = !1, t._preSystemCount = 0, t._addedSystems = [], t._removedSystems = [], t._systems = [], t._startSystems = [], t._tickSystems = [], t._frameSystems = [], t._frameCleanupSystems = [], t._tickCleanupSystems = [], t._systemRecord = {}, t._reactiveSystems = {}, t
            }

            return d(t, e), t.preRegisterSystem = function (e, t) {
                void 0 === t && (t = 4e3);
                for (var n = this._preSystems, r = 0, i = n; r < i.length; r++) {
                    if (i[r][0] === e) return void console.warn("The system has been pre registered.", l.Reflect.getQualifiedClassName(e))
                }
                n.push([e, t])
            }, t.prototype._getSystemInsertIndex = function (e, t) {
                var n = -1, r = e.length;
                if (r > 0) {
                    if (t < e[0].order) return 0;
                    if (t >= e[r - 1].order) return r
                }
                for (var i = 0; i < r - 1; ++i) if (e[i].order <= t && t < e[i + 1].order) {
                    n = i + 1;
                    break
                }
                return n < 0 ? e.length : n
            }, t.prototype._registerPreSystems = function () {
                this._isStartup = !0;
                var e = t._preSystems;
                if (e.length !== this._preSystemCount) {
                    for (var n = 0, r = e; n < r.length; n++) {
                        var i = r[n];
                        i[0].uuid in this._systemRecord || this.registerSystem.apply(this, i)
                    }
                    this._preSystemCount = e.length
                }
            }, t.prototype._registerSystem = function (e) {
                var t = e.order, n = this, r = n._systems, i = n._startSystems, o = n._tickSystems, a = n._frameSystems,
                    s = n._frameCleanupSystems, l = n._tickCleanupSystems, u = n._reactiveSystems,
                    c = n._getSystemInsertIndex;
                r.splice(c(r, t), 0, e), e.onStart && i.splice(c(i, t), 0, e), e.onTick && o.splice(c(o, t), 0, e), e.onFrame && a.splice(c(a, t), 0, e), e.onFrameCleanup && s.splice(c(s, t), 0, e), e.onTickCleanup && l.splice(c(l, t), 0, e), (e.onEntityAdded || e.onComponentEnabled || e.onComponentDisabled || e.onEntityRemoved) && (e.onTick || e.onFrame || a.splice(c(a, t), 0, e), u[e.uuid] = e)
            }, t.prototype._unregisterSystem = function (e) {
                var t = this, n = t._systems, r = t._startSystems, i = t._tickSystems, o = t._frameSystems,
                    a = t._frameCleanupSystems, s = t._tickCleanupSystems, l = t._reactiveSystems;
                0 != (2 & e.states) && e.onDestory && e.onDestory(), n.splice(n.indexOf(e), 1), e.onStart && r.splice(r.indexOf(e), 1), e.onTick && i.splice(i.indexOf(e), 1), e.onFrame && o.splice(o.indexOf(e), 1), e.onFrameCleanup && a.splice(a.indexOf(e), 1), e.onTickCleanup && s.splice(s.indexOf(e), 1), (e.onEntityAdded || e.onComponentEnabled || e.onComponentDisabled || e.onEntityRemoved) && (e.onTick || e.onFrame || o.splice(o.indexOf(e), 1), delete l[e.uuid])
            }, t.prototype._reactive = function (e, t, n) {
                for (var r = 0, i = e.collectors; r < i.length; r++) {
                    var o = i[r];
                    if (n) {
                        if (e.onComponentDisabled && 0 == (1 & o.reactiveType)) for (var a = 0, s = o.removedComponents; a < s.length; a++) {
                            null !== (_ = s[a]) && e.onComponentDisabled(_, o.group)
                        }
                        if (e.onEntityRemoved && 0 == (2 & o.reactiveType)) {
                            c.Entity._reactiveRemoveEnabled = !0;
                            for (var l = 0, u = o.removedEntities; l < u.length; l++) {
                                null !== (h = u[l]) && e.onEntityRemoved(h, o.group)
                            }
                            c.Entity._reactiveRemoveEnabled = !1
                        }
                    }
                    if (t) {
                        if (e.onEntityAdded && 0 == (4 & o.reactiveType)) for (var p = 0, d = o.addedEntities; p < d.length; p++) {
                            var h;
                            null !== (h = d[p]) && e.onEntityAdded(h, o.group)
                        }
                        if (e.onComponentEnabled && 0 == (8 & o.reactiveType)) for (var f = 0, m = o.addedComponents; f < m.length; f++) {
                            var _;
                            null !== (_ = m[f]) && e.onComponentEnabled(_, o.group)
                        }
                    }
                    o.clear()
                }
            }, t.prototype.startup = function (e) {
                this._registerPreSystems();
                var t = this._addedSystems;
                if (t.length > 0) {
                    for (var n = 0, r = 0, i = t; r < i.length; r++) {
                        var o = i[r];
                        if (null !== o) {
                            if (Array.isArray(o)) {
                                var a = o[0], s = a.allOfExecuteMode, u = a.anyOfExecuteMode, c = a.noneOfExecuteMode;
                                0 !== s && (s & e) !== s || 0 !== u && 0 == (u & e) || 0 !== c && 0 != (c & e) || (this.registerSystem.apply(this, o), t[n] = null)
                            } else this._registerSystem(o), t[n] = null;
                            n++
                        }
                    }
                    Object(l.filterArray)(t, null)
                }
                this._isStartup = !1;
                for (var p = 0, d = this._systems; p < d.length; p++) {
                    var h = (w = d[p]).constructor;
                    s = h.allOfExecuteMode, u = h.anyOfExecuteMode, c = h.noneOfExecuteMode;
                    0 !== s && (s & e) !== s || 0 !== u && 0 == (u & e) || 0 !== c && 0 != (c & e) ? w.states &= -2 : w.states |= 1;
                    var f = w.enabled && 0 != (1 & w.states);
                    if (f && 0 != (4 & w.states) !== f) {
                        w.onEnable && w.onEnable();
                        for (var m = 0, _ = w.collectors; m < _.length; m++) {
                            _[m].enabled = !0
                        }
                        if (console.debug(l.Reflect.getQualifiedClassName(w), "enabled."), w.onEntityAdded) for (var g = 0, v = w.groups; g < v.length; g++) for (var y = v[g], b = y.matcher.extraOfComponents, x = 0, T = y.entities; x < T.length; x++) {
                            var E = T[x];
                            if (w.onEntityAdded(E, y), b.length > 0 && w.onComponentEnabled) for (var C = 0, S = E.components; C < S.length; C++) {
                                var M = S[C];
                                M.enabled && b.indexOf(M.constructor) >= 0 && w.onComponentEnabled(M, y)
                            }
                        }
                    }
                }
                for (var A = 0, O = this._startSystems; A < O.length; A++) {
                    var w;
                    (w = O[A]).enabled && 0 != (1 & w.states) && 0 == (8 & w.states) && (w.onStart(), w.states |= 8)
                }
            }, t.prototype.execute = function (e, t) {
                var n = ge.instance.clock, r = this._reactiveSystems, i = 0, o = 0;
                i = n.timestamp();
                for (var a = 0; a < e; ++a) {
                    n.tickCount++, n.unscaledTickTime += n.unscaledTickDeltaTime;
                    for (var s = 0, l = this._tickSystems; s < l.length; s++) {
                        (p = l[s]).enabled && 0 != (1 & p.states) && (o = n.timestamp(), p.uuid in r && this._reactive(p, !0, !0), p.onTick(n.tickDeltaTime, a), p.totalCost = n.timestamp() - o)
                    }
                }
                if (n.tickCost = n.timestamp() - i, i = n.timestamp(), t > 0) for (var u = 0, c = this._frameSystems; u < c.length; u++) {
                    var p;
                    (p = c[u]).enabled && 0 != (1 & p.states) && (o = n.timestamp(), p.uuid in r && this._reactive(p, !0, !0), p.onFrame && p.onFrame(n.frameDeltaTime), p.totalCost += n.timestamp() - o)
                }
                n.frameCost = n.timestamp() - i
            }, t.prototype.cleanup = function (e) {
                var t = ge.instance.clock, n = 0, r = 0, i = 0;
                if (n = t.timestamp(), e > 0) for (i = this._frameCleanupSystems.length; i-- > 0;) {
                    (o = this._frameCleanupSystems[i]).enabled && 0 != (1 & o.states) && (r = t.timestamp(), o.onFrameCleanup(t.frameDeltaTime), o.totalCost += t.timestamp() - r)
                }
                for (t.tickCost += t.timestamp() - n, n = t.timestamp(), i = this._tickCleanupSystems.length; i-- > 0;) {
                    var o;
                    (o = this._tickCleanupSystems[i]).enabled && (r = t.timestamp(), o.onTickCleanup(t.frameDeltaTime), o.totalCost += t.timestamp() - r)
                }
                t.frameCost += t.timestamp() - n
            }, t.prototype.teardown = function () {
                for (var e = this._reactiveSystems, t = 0, n = this._systems; t < n.length; t++) {
                    var r = (T = n[t]).enabled && 0 != (1 & T.states);
                    if (0 != (4 & T.states) !== r) if (r) T.states |= 4; else {
                        if (T.states &= -5, T.onEntityRemoved) {
                            c.Entity._reactiveRemoveEnabled = !0;
                            for (var i = 0, o = T.groups; i < o.length; i++) for (var a = o[i], s = a.matcher.extraOfComponents, u = 0, p = a.entities; u < p.length; u++) {
                                var d = p[u];
                                if (s.length > 0 && T.onComponentDisabled) for (var h = 0, f = d.components; h < f.length; h++) {
                                    var m = f[h];
                                    m.enabled && s.indexOf(m.constructor) >= 0 && T.onComponentDisabled(m, a)
                                }
                                T.onEntityRemoved(d, a)
                            }
                            c.Entity._reactiveRemoveEnabled = !1
                        }
                        T.uuid in e && this._reactive(T, !1, !0);
                        for (var _ = 0, g = T.collectors; _ < g.length; _++) {
                            var v = g[_];
                            v.enabled = !1, v.clear()
                        }
                        T.onDisable && T.onDisable(), console.debug(l.Reflect.getQualifiedClassName(T), "disabled.")
                    }
                }
                var y = this._removedSystems;
                if (y.length > 0) {
                    for (var b = 0, x = y; b < x.length; b++) {
                        var T = x[b];
                        this._unregisterSystem(T)
                    }
                    y.length = 0
                }
            }, t.prototype.registerSystem = function (e, t) {
                void 0 === t && (t = 4e3);
                var n = this.getSystem(e);
                if (null !== n) return console.warn("The system has been registered.", l.Reflect.getQualifiedClassName(e)), !1;
                var r = ge.instance, i = r.executeMode, o = e.allOfExecuteMode, a = e.anyOfExecuteMode,
                    s = e.noneOfExecuteMode;
                return 0 !== o && (o & i) !== o || 0 !== a && 0 == (a & i) || 0 !== s && 0 != (s & i) ? (this._addedSystems.push([e, t]), !1) : ((n = new e).initialize(t, r), this._systemRecord[e.uuid] = n, this._isStartup ? this._registerSystem(n) : this._addedSystems.push(n), n.onAwake && n.onAwake(), n.states |= 2, !0)
            }, t.prototype.unregisterSystem = function (e) {
                e instanceof c.System && (e = e.constructor);
                var t = this.getSystem(e);
                if (null === t) return console.warn("The system is not registered.", l.Reflect.getQualifiedClassName(e)), !1;
                var n = this._addedSystems, r = n.indexOf(t);
                return this._systemRecord[e.uuid] = null, r >= 0 ? n[r] = null : (t.enabled = !1, this._removedSystems.push(t)), !0
            }, t.prototype.getSystem = function (e) {
                return e.uuid in this._systemRecord ? this._systemRecord[e.uuid] : null
            }, Object.defineProperty(t.prototype, "systems", {
                get: function () {
                    return this._systems
                }, enumerable: !0, configurable: !0
            }), t._preSystems = [], t
        }(DebuggerClass);
        __reflect(Fe, "@egret/engine/SystemManager");
        var ke = function (e) {
            function t() {
                return null !== e && e.apply(this, arguments) || this
            }

            return d(t, e), t.prototype._serializeProperties = function (t, n, r) {
                if (e.prototype._serializeProperties.call(this, t, n, r), t && t && t instanceof ye) {
                    var i = t;
                    if (i && i.childCount) {
                        for (var o = [], a = 0, s = i.children; a < s.length; a++) {
                            var l = s[a];
                            if (l) {
                                var c = this._serializeObject(l.entity) ? {uuid: l.uuid} : void 0;
                                c && o.push(c)
                            }
                        }
                        n[u.KEY_CHILDREN] = o
                    }
                }
            }, t
        }(u.Serializer);
        __reflect(ke, "@egret/engine/GameSerializer");
        var Ve = function (e) {
            function t() {
                return null !== e && e.apply(this, arguments) || this
            }

            return d(t, e), t.prototype._deserializeObject = function (t, n) {
                e.prototype._deserializeObject.call(this, t, n), this._setDefaultRootParent(), this._setEntityParents()
            }, t.prototype._setDefaultRootParent = function () {
                this.root && this.root instanceof Ne && (this.root.parent || this.root.getComponent(be) || (this.root.parent = this._defaultParent()))
            }, t.prototype._defaultParent = function () {
                return ge.instance.sceneManager.activeScene.entity
            }, t.prototype._setEntityParents = function () {
                var e = this;
                Object.values(this._componentDataMap).map((function (t) {
                    if (t && u.KEY_CHILDREN in t) {
                        var n = e._context.components[t.uuid];
                        n ? t[u.KEY_CHILDREN].map((function (t) {
                            var r = e._context.components[t.uuid];
                            r ? r.parent = n : console.warn("treenode(" + t.uuid + ")'s is not found")
                        })) : console.warn("treenode(" + t.uuid + ")'s is not found")
                    }
                }))
            }, t
        }(u.Deserializer);
        __reflect(Ve, "@egret/engine/GameDeserializer");
        var Be = function (e) {
            function t() {
                var t = null !== e && e.apply(this, arguments) || this;
                return t._deserializeContext = Object.create(null), t._prefabs = [], t
            }

            return d(t, e), t.prototype._getPrefabRoot = function (e) {
                if (!e) return null;
                for (var t = De.getEntityExtras(e); (!t || !t.prefab) && (e = e.parent);) t = De.getEntityExtras(e);
                return e
            }, t.prototype._getEntityTemplate = function (t) {
                if (this._prefabs.length) {
                    var n = De.getEntityExtras(t);
                    if (n && n.linkedID) return this._getModelDeserializeContext(t).entities[n.linkedID]
                }
                return e.prototype._getEntityTemplate.call(this, t)
            }, t.prototype._getComponentTemplate = function (t) {
                if (this._prefabs.length) {
                    var n = De.getComponentExtras(t);
                    if (n && n.linkedID) return this._getModelDeserializeContext(t.entity).components[n.linkedID]
                }
                return e.prototype._getComponentTemplate.call(this, t)
            }, t.prototype._adjustSerializeKeys = function (t, n, r, i) {
                e.prototype._adjustSerializeKeys.call(this, t, n, r, i), this._prefabs.length ? (n[u.KEY_EXTRAS] = u.KEY_EXTRAS, i.add(u.KEY_EXTRAS)) : (delete n[u.KEY_EXTRAS], i.delete(u.KEY_EXTRAS)), r.delete(u.KEY_SCENE)
            }, t.prototype._getModelDeserializeContext = function (e) {
                var t = e instanceof Ne ? this._getPrefabRoot(e) : e, n = De.getModelUri(De.getEntityExtras(t).prefab),
                    r = Object.create(null);
                return n in this._deserializeContext || De.createInstance(n, {
                    deserializeContexts: r,
                    deserializeName: n,
                    ignored: !0
                }), r && r[n] ? r[n][0] : (console.log(e), new u.DeserializeContext)
            }, t.prototype._serializeObject = function (t) {
                var n = !1;
                t instanceof c.Entity && De.isEntityPrefabRoot(t) && (n = !0, this._prefabs.push(t));
                var r = e.prototype._serializeObject.call(this, t);
                return n && this._prefabs.pop(), r
            }, t.prototype._getPrefabConfig = function () {
                return this._context.config.prefab
            }, t.prototype._reset = function () {
                this._prefabs.length = 0, e.prototype._reset.call(this)
            }, t
        }(ke);
        __reflect(Be, "@egret/engine/PrefabSerializer");
        var Ge = function (e) {
            function t() {
                var t = null !== e && e.apply(this, arguments) || this;
                return t._deserializeContexts = Object.create(null), t._prefabs = Object.create(null), t._prefabEntities = [], t
            }

            return d(t, e), t.prototype._deserializeObject = function (t, n) {
                var r = this._getPrefabConfig();
                if (e.prototype._deserializeObject.call(this, t, n), r && r.deserializeContexts) {
                    var i = new u.DeserializeContext;
                    for (var o in i.copy(this._context), this._deserializeContexts) r.deserializeContexts[o] = this._deserializeContexts[o].map((function (e) {
                        return e.id = "", e
                    }));
                    r.deserializeContexts[r.deserializeName || ""] = [i]
                }
            }, t.prototype._getPrefabConfig = function () {
                return this._config.prefab
            }, t.prototype._adjustDeserializeKeys = function (t, n, r) {
                e.prototype._adjustDeserializeKeys.call(this, t, n, r);
                var i = this._getPrefabConfig();
                i && (i.keepUUID ? r.delete(u.KEY_UUID) : r.add(u.KEY_UUID), i.keepUUID || r.add(u.KEY_EXTRAS))
            }, t.prototype._deserializeProperty = function (t, n, r, i) {
                if (i instanceof c.Entity && n === u.KEY_EXTRAS) {
                    var o = this._getPropertyValue(t[n], null);
                    if (void 0 === o) return;
                    var a = De.getEntityExtras(i) || {}, s = this._getPrefabConfig();
                    s && s.keepUUID || delete o.rootID, Object.assign(a, o), De.setEntityExtras(i, a)
                } else e.prototype._deserializeProperty.call(this, t, n, r, i)
            }, t.prototype._createComponent = function (t, n, r) {
                if (!t) return null;
                if (u.KEY_EXTRAS in t) {
                    if (!r) return console.warn("invalid entitySource in when creating component of prefab"), null;
                    var i = t[u.KEY_EXTRAS], o = r[u.KEY_EXTRAS], a = o.prefab ? r.uuid : o.rootID;
                    if (!a) return console.warn("no valid prefab RootId of entity source " + JSON.stringify(r)), null;
                    var s = this._getDeserializeContext(a);
                    if (!s) return console.warn("no deserializeContext found of prefab", a), null;
                    var l = s.components[i.linkedID];
                    return this._context.components[t.uuid] = l, l
                }
                var c = e.prototype._createComponent.call(this, t, n);
                if (!c) return console.warn("failed to create component with source: " + t), null;
                var p = this._getPrefabConfig();
                return p && p.keepModelInfo === Pe.Yes && De.setComponentExtras(c, {linkedID: t.uuid}), c
            }, t.prototype._createEntity = function (t) {
                var n, r = u.KEY_EXTRAS in t, i = null, o = this._getPrefabConfig();
                if (!r) return i = e.prototype._createEntity.call(this, t, o && o.ignored || void 0), o && o.keepModelInfo === Pe.Yes && this._updateRootId(i, o, t.uuid), i;
                var a = t[u.KEY_EXTRAS], s = "";
                if (a.prefab) {
                    var l = a.prefab[u.KEY_ASSET];
                    l >= 0 && (s = this._context.assets[l], this._prefabs[t.uuid] = s);
                    var c = this._deserializeContexts[s];
                    if (c) for (var p = 0, d = c; p < d.length; p++) {
                        if (!(h = d[p]).id) {
                            h.id = t.uuid;
                            break
                        }
                    }
                }
                if (a.rootID) {
                    var h;
                    if (!(h = this._getDeserializeContext(a.rootID))) return console.warn("prefab of " + a.rootID + " is not instantiated before create entity with source(" + t.uuid + ")"), null;
                    if (!a.linkedID) return console.warn("invalid linkedID(" + a.linkedID + ")"), null;
                    (i = h.entities[a.linkedID]).getComponent(ye) && this._prefabEntities.push(i)
                }
                if (!i && a.prefab) {
                    var f = {};
                    Object.assign(f, o);
                    var m = Object.create(null);
                    if (f.deserializeContexts = m, f.deserializeName = s, void 0 !== f.keepModelInfo && (f.keepModelInfo = Pe.Yes), f.keepUUID = !1, i = De.createInstance(s, f), m[s]) for (var _ in m[s][0].id = t.uuid, m) this._deserializeContexts[_] || (this._deserializeContexts[_] = []), (n = this._deserializeContexts[_]).push.apply(n, m[_]);
                    if (!i) return console.log("missing_tag"), (i = e.prototype._createEntity.call(this, t, o && o.ignored || void 0)) ? (i.node.name = "(Missing Prefab)", i.node.source = t, i.missingPrefab = !0, i && (this._context.entities[t.uuid] = i), this.root = this.root || i, i) : (console.warn("failed to create instance of prefab(" + s + ")"), null);
                    this._updateRootId(i, o, t.uuid)
                }
                return i && (this._context.entities[t.uuid] = i), this.root = this.root || i, i
            }, t.prototype._reset = function () {
                e.prototype._reset.call(this), this._deserializeContexts = Object.create(null)
            }, t.prototype._getDeserializeContext = function (e) {
                var t = this._prefabs[e];
                if (!t) return console.warn("failed to find root info of rootID(" + e + ")"), null;
                var n = this._deserializeContexts[t];
                if (!n) return console.warn("no deserializeContext found of prefab", e), null;
                for (var r = 0, i = n; r < i.length; r++) {
                    var o = i[r];
                    if (o.id === e) return o
                }
                return null
            }, t.prototype._defaultParent = function () {
                var t = this._getPrefabConfig();
                if (t) {
                    if (t.ignored) return ge.instance.sceneManager.globalScene.entity;
                    if (t.parent) return t.parent
                }
                return e.prototype._defaultParent.call(this)
            }, t.prototype._updateRootId = function (e, t, n) {
                if (e && this.root && e !== this.root && t && t.keepModelInfo === Pe.Yes) {
                    var r = De.getEntityExtras(e);
                    r || (r = {}, De.setEntityExtras(e, r)), r.linkedID = n, r.rootID = this.root.uuid
                }
            }, t.prototype._setEntityParents = function () {
                var e = this, t = new Set;
                this._prefabEntities.map((function (e) {
                    return t.add(e.node.uuid)
                })), Object.values(this._componentDataMap).map((function (n) {
                    if (n && u.KEY_CHILDREN in n) {
                        var r = e._context.components[n.uuid];
                        r ? n[u.KEY_CHILDREN].map((function (n) {
                            var i = e._context.components[n.uuid];
                            i ? t.has(i.uuid) || (i.parent = r) : console.warn("treenode(" + n.uuid + ")'s is not found")
                        })) : console.warn("treenode(" + n.uuid + ")'s is not found")
                    }
                }))
            }, t
        }(Ve);
        __reflect(Ge, "@egret/engine/PrefabDeserializer");
        var je = function (e) {
            function t() {
                return null !== e && e.apply(this, arguments) || this
            }

            return d(t, e), t.prototype.load = function (e, t) {
                return t.loader.loadImage(e, t.baseUrl).then((function (e) {
                    return {source: e, width: e.width, height: e.height}
                }))
            }, t
        }(DebuggerClass);
        __reflect(je, "@egret/engine/ImageLoader");
        var He = function (e) {
            function t() {
                return null !== e && e.apply(this, arguments) || this
            }

            return d(t, e), t.prototype.load = function (e, t) {
                var n = this;
                Promise.resolve([]);
                return t.loadResouceData(e, "json").then((function (r) {
                    if (!r) return Promise.resolve(null);
                    var i = r.components.filter((function (e) {
                        return "@egret/animation/Animation" === e.__class
                    }));
                    if (i.length > 0) return n.loadBakedAnimationAssets(t, i, r).then((function (i) {
                        return (i ? n._loadSubAssets(i, t) : Promise.resolve([])).then((function () {
                            var t = De.create(r, e, !1, e.indexOf(".scene.json") >= 0);
                            return t.subResources = i, t.getComponent(Ae)
                        }))
                    }));
                    var o = r.assets;
                    return (o ? n._loadSubAssets(o, t) : Promise.resolve([])).then((function () {
                        var t = De.create(r, e, !1, e.indexOf(".scene.json") >= 0);
                        return t.subResources = o, t.getComponent(Ae)
                    }))
                })).catch((function (e) {
                    console.error(e)
                }))
            }, t.prototype._loadSubAssets = function (e, t) {
                return Promise.all(e.map((function (e) {
                    return t.loadUri(e)
                })))
            }, t.prototype.loadBakedAnimationAssets = function (e, t, n) {
                for (var r = n.assets, i = !1, o = Promise.resolve(), a = function (t) {
                    t.bakedAnimationConfig && !0 === t.bakedAnimationConfig.preferBaked && (o = o.then((function () {
                        return e.loadUri(t.bakedAnimationConfig.assetPath).then((function (e) {
                            if ("LoadFailed" === e.status) console.error("Cannot find BakedConfig in '" + e.uri + "'"), t.bakedAnimationConfig.preferBaked = !1; else {
                                var n = e.data;
                                0 != (4 & ge.instance.executeMode) || i || (r = r.filter((function (e) {
                                    return e.indexOf("ani.bin") < 0
                                })), i = !0), r = r.concat(n.meshAssets).concat(n.skinnedMeshAssets)
                            }
                        }))
                    })))
                }, s = 0, l = t; s < l.length; s++) {
                    a(l[s])
                }
                return o.then((function () {
                    return r
                }))
            }, t
        }(DebuggerClass);
        __reflect(He, "@egret/engine/EntityModelLoader");
        var We = function (e) {
            function t() {
                var t = null !== e && e.apply(this, arguments) || this;
                return t._sceneManager = null, t
            }

            return d(t, e), t.prototype._onNodeParentChanged = function (e) {
                var t = e.entity.transform;
                null !== t && t.constructor === Se && t.needUpdate(!1, 7)
            }, t.prototype.getMatchers = function () {
                return [c.Matcher.create(Ne, !1, be, ye)]
            }, t.prototype.onAwake = function () {
                var e = ge.instance;
                this._sceneManager = e.globalEntity.getComponent(Ie), this.collectors[0].reactiveType = 6
            }, t.prototype.onEnable = function () {
                ge.instance.signals.onNodeParentChanged.add(this._onNodeParentChanged, this)
            }, t.prototype.onEntityRemoved = function (e, t) {
                if (t === this.groups[0]) {
                    var n = this._sceneManager, r = n.scenes, i = n.globalScene, o = n.editorScene,
                        a = e.getComponent(be), s = r.indexOf(a);
                    if (s >= 0) r.splice(s, 1); else {
                        if (a === i || a === o) throw new Error("Cannot destroy the global scene.");
                        console.error("The scene has been removed.")
                    }
                }
            }, t.prototype.onEntityAdded = function (e, t) {
                var n = this.groups, r = this._sceneManager;
                if (t === n[0]) {
                    var i = r, o = i.scenes, a = i.globalScene, s = i.editorScene, l = e.getComponent(be), u = e.node;
                    u.name = "Root", u.scene = l, l !== a && l !== s && o.indexOf(l) < 0 && o.unshift(l)
                }
            }, t.prototype.onDisable = function () {
                ge.instance.signals.onNodeParentChanged.remove(this._onNodeParentChanged, this)
            }, t = h([Object(c.system)()], t)
        }(c.System);
        __reflect(We, "@egret/engine/SceneSystem");
        var Xe = function (e) {
            function t() {
                return null !== e && e.apply(this, arguments) || this
            }

            return d(t, e), t.prototype.onTick = function (e, t) {
                0 === t && this.onFrame()
            }, t.prototype.onFrame = function () {
                for (var e = 0, t = ge.instance.helpers.addedBehaviours; e < t.length; e++) {
                    var n = t[e];
                    null !== n && !n._isStarted && n._getExecuteEnabled() && (n.onStart && n.onStart(), n._isStarted = !0)
                }
            }, t.prototype.onFrameCleanup = function () {
                Object(l.filterArray)(ge.instance.helpers.addedBehaviours, null)
            }, t.prototype.onTickCleanup = function () {
                this.onFrameCleanup()
            }, t = h([Object(c.system)()], t)
        }(c.System);
        __reflect(Xe, "@egret/engine/BehaviourStartSystem");
        var Ye = function (e) {
            function t() {
                return null !== e && e.apply(this, arguments) || this
            }

            return d(t, e), t.prototype.onTick = function (e) {
                for (var t = 0, n = ge.instance.helpers.behaviours; t < n.length; t++) {
                    var r = n[t];
                    null !== r && r._isStarted && r._getExecuteEnabled() && (r.onFixedUpdate && r.onFixedUpdate(e))
                }
            }, t = h([Object(c.system)()], t)
        }(c.System);
        __reflect(Ye, "@egret/engine/BehaviourFixedUpdateSystem");
        var qe = function (e) {
            function t() {
                return null !== e && e.apply(this, arguments) || this
            }

            return d(t, e), t.prototype.onFrame = function (e) {
                for (var t = 0, n = ge.instance.helpers.behaviours; t < n.length; t++) {
                    var r = n[t];
                    null !== r && r._isStarted && r._getExecuteEnabled() && (r.onUpdate && r.onUpdate(e))
                }
            }, t = h([Object(c.system)()], t)
        }(c.System);
        __reflect(qe, "@egret/engine/BehaviourUpdateSystem");
        var Ze = function (e) {
            function t() {
                return null !== e && e.apply(this, arguments) || this
            }

            return d(t, e), t.prototype.onFrame = function (e) {
                for (var t = 0, n = ge.instance.helpers.behaviours; t < n.length; t++) {
                    var r = n[t];
                    null !== r && r._isStarted && r._getExecuteEnabled() && (r.onLateUpdate && r.onLateUpdate(e))
                }
            }, t.prototype.onFrameCleanup = function () {
                Object(l.filterArray)(ge.instance.helpers.behaviours, null)
            }, t = h([Object(c.system)()], t)
        }(c.System);
        __reflect(Ze, "@egret/engine/BehaviourLateUpdateSystem");
        var Ke = function (e) {
            function t() {
                return null !== e && e.apply(this, arguments) || this
            }

            return d(t, e), t.prototype.onTickCleanup = function () {
                l.Pool.update()
            }, t = h([Object(c.system)()], t)
        }(c.System);
        __reflect(Ke, "@egret/engine/ReleaseSystem");
        var Qe = function (e) {
            function t() {
                return null !== e && e.apply(this, arguments) || this
            }

            return d(t, e), t.prototype.createEntitySelf = function (e) {
                return this._createEntity(e)
            }, t.prototype.createEntityTemplate = function (e) {
                return this._createEntity(e, ge.instance.sceneManager.globalScene.root, !0)
            }, t.prototype._createEntity = function (e, t, n) {
                void 0 === t && (t = null), void 0 === n && (n = !1);
                var r = l.Reflect.getDefinitionByName(e);
                if (!r) return null;
                var i = ge.instance.getContext(r);
                if (!i) return null;
                var o = i.createEntityInstance(!0, null, !0, n);
                if (t) {
                    var a = o.getComponent(ye);
                    a && (a.parent = t)
                }
                return o
            }, t
        }(DebuggerClass);
        __reflect(Qe, "@egret/engine/ObjectFactory");
        var Je = function (e) {
            function t() {
                var t = e.call(this) || this;
                return t._createDefaultContexts(), u.SerializeUtil.factory = new Qe, u.serializeManager.createSerializer = function () {
                    return new Be
                }, u.serializeManager.createDeserializer = function () {
                    return new Ge
                }, u.ResourceManager.instance.baseUrl || (u.ResourceManager.instance.baseUrl = "./resource"), u.ResourceManager.instance.setProcessor("scene", new He), u.ResourceManager.instance.setProcessor("prefab", new He), u.ResourceManager.instance.setProcessor("image", new je), t
            }

            return d(t, e), t.prototype._createDefaultContexts = function () {
                this.entityContext = this.getContext(c.Entity), this.assetContext = this.getContext(u.AssetEntity), this.gameEntityContext = this.getContext(Ne)
            }, t.prototype.loadProjectSetting = function () {
                return ge.instance = this, u.ResourceManager.instance.loadUri("./project_settings.prefab.json")
            }, t.prototype.initialize = function (t) {
                e.prototype.initialize.call(this, t);
                var n = new Fe;
                this.systemManager = n;
                var r = u.ResourceManager.instance.getResource("./project_settings.prefab.json");
                this.globalEntity = null !== r ? De.createInstance("./project_settings.prefab.json") : this.getContext(Ue).createEntity(), this.signals = this.globalEntity.getOrAddComponent(we), this.clock = this.globalEntity.getOrAddComponent(Re), this.screen = this.globalEntity.getOrAddComponent(Oe), this.screen.size = {
                    w: t.screenWidth,
                    h: t.screenHeight
                }, this.stage = this.globalEntity.getOrAddComponent(ve), this.helpers = this.globalEntity.getOrAddComponent(Le), this.sceneManager = this.globalEntity.getOrAddComponent(Ie), n.registerSystem(We, 0), n.registerSystem(Xe, 2e3), n.registerSystem(Ye, 3e3), n.registerSystem(qe, 4e3), n.registerSystem(Ze, 6e3), n.registerSystem(Ke, 1e4)
            }, t
        }(ge);
        __reflect(Je, "@egret/engine/BasicApplication");
        var $e = function (e) {
            function t() {
                return this
            }

            return d(t, DebuggerClass), Object.defineProperty(t, "isMobile", {
                get: function () {
                    if ("undefined" != typeof navigator && navigator.userAgent) {
                        var e = navigator.userAgent.toLowerCase();
                        return e.indexOf("mobile") >= 0 || e.indexOf("android") >= 0
                    }
                    return !1
                }, enumerable: !0, configurable: !0
            }), Object.defineProperty(t, "isWebView", {
                get: function () {
                    return "undefined" != typeof window && "undefined" == typeof wx
                }, enumerable: !0, configurable: !0
            }), t
        }();
        __reflect($e, "@egret/engine/EngineUtil");
        var et = function (e) {
            function t() {
                return null !== e && e.apply(this, arguments) || this
            }

            return d(t, e), t._getContext = function () {
                return ge.instance.gameEntityContext
            }, t._getCurrentScene = function () {
                return ge.instance.sceneManager.activeScene.root
            }, t
        }(DebuggerClass);
        __reflect(et, "@egret/engine/GameEntityFactory");
        var tt = function (e) {
            function t() {
                return null !== e && e.apply(this, arguments) || this
            }

            return d(t, e), t.createGameEntity = function (t, n) {
                void 0 === t && (t = "Noname");
                var r = void 0 === n ? {} : n, i = r.tag, o = void 0 === i ? "Untagged" : i, a = r.layer,
                    s = void 0 === a ? 1 : a, l = r.parent, u = void 0 === l ? null : l;
                null === u && (u = e._getCurrentScene.call(this).entity);
                var c = e._getContext.call(this).createEntity(), p = c.node;
                return p.name = t, p.tag = o, p.layer = s, p.parent = u.node, c
            }, t.createGameEntity3D = function (t, n) {
                void 0 === t && (t = "Noname");
                var r = void 0 === n ? {} : n, i = r.tag, o = void 0 === i ? "Untagged" : i, a = r.layer,
                    s = void 0 === a ? 1 : a, l = r.parent, u = void 0 === l ? null : l;
                null === u && (u = e._getCurrentScene.call(this).entity);
                var c = e._getContext.call(this).createEntity(), p = c.node;
                return p.name = t, p.tag = o, p.layer = s, p.parent = u.node, c.addComponent(Se), c
            }, t.createPrefab = function (t, n) {
                var r = this;
                return u.ResourceManager.instance.loadUri(t).then((function () {
                    var i = De.createInstance(t, n && {parent: n}, e._getContext.call(r));
                    return i instanceof Ne ? i.parent = n || e._getCurrentScene.call(r).entity : n && console.warn("try set parent to a non-GameEntity entity"), i
                })).catch((function (e) {
                    return console.warn(e), null
                }))
            }, t
        }(et);
        __reflect(tt, "@egret/engine/EngineFactory");
        var nt = {
            printTree: function (e, t) {
                var n = 0;
                e.traverse((function (e, r) {
                    var i = r > 0 ? "|  ".repeat(r - 1) + "|--" : "";
                    if (console.log(i + "(" + e.uuid + ") " + e.node.name), ++n === t) return !0
                }))
            }, printTreeX: function (e, t) {
                var n = 0;
                e.traverse((function (e, r) {
                    var i = r > 0 ? "|  ".repeat(r - 1) + "|--" : "";
                    if (console.log(i + "(" + e.uuid + ") " + e.node.name), u.KEY_EXTRAS in e) {
                        var o = De.getEntityExtras(e);
                        if (o) {
                            var a = {rootID: o.rootID, linkedID: o.linkedID, prefab: o.prefab ? o.prefab.name : void 0};
                            console.log("|  ".repeat(r) + "|   \\__extras: " + JSON.stringify(a))
                        }
                    }
                    if (++n === t) return !0
                }))
            }, printTreeReversely: function (e, t) {
                var n = 0;
                e.traverseReversely((function (e, r) {
                    var i = "|  ".repeat(r);
                    if (console.log(i + " (" + e.uuid + ") " + e.node.name), ++n === t) return !0
                }))
            }, treeStat: function (e) {
                var t = 0, n = 0, r = 0, i = 0, o = 0;
                e.traverse((function (e, a) {
                    if (!e) return !1;
                    if (t++, n += e.components.length, u.KEY_EXTRAS in e) {
                        r++;
                        var s = De.getEntityExtras(e);
                        s && s.prefab && o++, i += e.components.length
                    }
                })), console.log("entity count: " + t), console.log("component count: " + n), console.log("max level: " + o), console.log("prefab entity count: " + r), console.log("prefab component count: " + i), console.log("prefab count: " + o)
            }, find: function (e, t) {
                var n = [];
                return e.traverse((function (e, r) {
                    t(e, r) && n.push(e)
                })), n
            }, findFirst: function (e, t) {
                var n = null;
                return e.traverse((function (e, r) {
                    if (t(e, r)) return n = e, !0
                })), n
            }, findByUUID: function (e, t) {
                return this.findFirst(e, (function (e) {
                    return e.uuid === t
                }))
            }, findByUUIDS: function (e, t) {
                return this.find(e, (function (e) {
                    return t.indexOf(e.uuid) >= 0
                }))
            }, printDataTreeX: function (e, t) {
                var n = e.entities, r = e.assets, i = e.components;
                if (n && r && i) {
                    var o = {}, a = {};
                    n.map((function (e) {
                        var t;
                        e[u.KEY_COMPONENTS] && (e[u.KEY_COMPONENTS].find((function (e) {
                            return t = i.find((function (t) {
                                return t.uuid === e.uuid && "TreeNode" === t.__class
                            }))
                        })), t && (o[e.uuid] = t));
                        if (e[u.KEY_EXTRAS]) {
                            var n = e[u.KEY_EXTRAS];
                            a[e.uuid] = {rootID: n.rootID, linkedID: n.linkedID, prefab: n.prefab && r[n.prefab]}
                        }
                    }));
                    var s = new Set, l = function (e) {
                        if (e) {
                            if (!s.has(e.uuid)) {
                                var t = new rt, r = Object.create(null);
                                t.data = r, r.uuid = e.uuid, r.__class = e.__class, a[e.uuid] && (r.__extras = a[e.uuid]), s.add(e.uuid);
                                var i = o[e.uuid];
                                return i && (r.name = i.name || "", i.children && (t.children = i.children.map((function (e) {
                                    var t = Object.keys(o).find((function (t) {
                                        return o[t].uuid === e.uuid
                                    })), r = n.find((function (e) {
                                        return e.uuid === t
                                    }));
                                    return r && l(r)
                                })).filter(Boolean))), t
                            }
                            console.warn("looped or incorrected uuid: " + e.uuid)
                        }
                    }, c = l(n[0]);
                    if (c) {
                        var p = 0;
                        c.traverse((function (e, n) {
                            if (!e.data) return !1;
                            var r = n > 0 ? "|  ".repeat(n - 1) + "|--" : "";
                            return console.log(r + "(" + e.data.uuid + ") " + e.data.name), e.data.__extras && console.log("|  ".repeat(n) + "|   \\__extras: " + JSON.stringify(e.data.__extras)), ++p === t || void 0
                        }))
                    }
                }
            }
        }, rt = function (e) {
            function t() {
                var t = null !== e && e.apply(this, arguments) || this;
                return t.children = [], t
            }

            return d(t, e), t.prototype.traverse = function (e, t) {
                if (void 0 === t && (t = 0), e(this, t)) return !0;
                if (this.children) for (var n = 0, r = this.children; n < r.length; n++) {
                    if (r[n].traverse(e, t + 1)) return !0
                }
                return !1
            }, t.prototype.traverseReversely = function (e, t) {
                if (void 0 === t && (t = 0), this.children) for (var n = this.children.length - 1; n >= 0; n--) if (this.children[n].traverseReversely(e, t + 1)) return !1;
                return e(this, t)
            }, t
        }(DebuggerClass);
        __reflect(rt, "@egret/engine/TreeNode")
    }.call(this, n(6))
}, function (e, t, n) {
    "use strict";
    n.r(t), n.d(t, "CollectorReactiveType", (function () {
        return i
    })), n.d(t, "Component", (function () {
        return h
    })), n.d(t, "Context", (function () {
        return E
    })), n.d(t, "Entity", (function () {
        return _
    })), n.d(t, "Matcher", (function () {
        return x
    })), n.d(t, "MatcherType", (function () {
        return r
    })), n.d(t, "System", (function () {
        return y
    })), n.d(t, "_GroupComponent", (function () {
        return f
    })), n.d(t, "component", (function () {
        return d
    })), n.d(t, "entity", (function () {
        return m
    })), n.d(t, "getComponentsByType", (function () {
        return p
    })), n.d(t, "system", (function () {
        return v
    }));
    var r, i, o = n(3);
    !function (e) {
        e[e.Normal = 0] = "Normal", e[e.Enabled = 1] = "Enabled"
    }(r || (r = {})), function (e) {
        e[e.InOrder = 0] = "InOrder", e[e.DisableComponentImmediately = 1] = "DisableComponentImmediately", e[e.RemoveEntityImmediately = 2] = "RemoveEntityImmediately", e[e.AddEntityImmediately = 4] = "AddEntityImmediately", e[e.EnableComponentImmediately = 8] = "EnableComponentImmediately"
    }(i || (i = {}));
    /*! *****************************************************************************
Copyright (c) Microsoft Corporation. All rights reserved.
Licensed under the Apache License, Version 2.0 (the "License"); you may not use
this file except in compliance with the License. You may obtain a copy of the
License at http://www.apache.org/licenses/LICENSE-2.0

THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED
WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,
MERCHANTABLITY OR NON-INFRINGEMENT.

See the Apache Version 2.0 License for specific language governing permissions
and limitations under the License.
***************************************************************************** */
    var a = function (e, t) {
        return (a = Object.setPrototypeOf || {__proto__: []} instanceof Array && function (e, t) {
            e.__proto__ = t
        } || function (e, t) {
            for (var n in t) t.hasOwnProperty(n) && (e[n] = t[n])
        })(e, t)
    };

    function s(e, t) {
        function n() {
            this.constructor = e
        }

        a(e, t), e.prototype = null === t ? Object.create(t) : (n.prototype = t.prototype, new n)
    }

    function l(e, t, n, r) {
        var i, o = arguments.length, a = o < 3 ? t : null === r ? r = Object.getOwnPropertyDescriptor(t, n) : r;
        if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) a = Reflect.decorate(e, t, n, r); else for (var s = e.length - 1; s >= 0; s--) (i = e[s]) && (a = (o < 3 ? i(a) : o > 3 ? i(t, n, a) : i(t, n)) || a);
        return o > 3 && a && Object.defineProperty(t, n, a), a
    }

    var u = 0, c = {};

    function p(e) {
        return e in c ? c[e] : []
    }

    function d(e) {
        var t = void 0 === e ? {} : e, n = t.isAbstract, r = void 0 !== n && n, i = t.isRemovable,
            a = void 0 === i || i, s = t.allowMultiple, l = t.type, p = void 0 === l ? "" : l, d = t.menu,
            h = void 0 === d ? "" : d, f = t.requireComponents, m = void 0 === f ? null : f, _ = t.extensions,
            g = void 0 === _ ? null : _;
        return function (e) {
            Object(o.uuid)(e);
            var t = e;
            (t.isAbstract = r, t.isRemovable = a, void 0 !== s && (t.allowMultiple = s), 0 === p.length && e.componentType.length > 0 && (p = e.componentType), p.length > 0) && (t.componentType = p, r || (p in c || (c[p] = []), (n = c[p]).length > 0 && (t.allowMultiple = n[0].allowMultiple), n.push(e)));
            (h.length > 0 && (t.componentMenu = h), r) || (o.Pool.getPool(e, !0).maxIdleCount = 0, t.componentIndex = u++);
            if (null !== m) {
                null !== e.requireComponents ? t.requireComponents = e.requireComponents.concat() : t.requireComponents = [];
                for (var n = e.requireComponents, i = 0, l = m; i < l.length; i++) {
                    var d = l[i];
                    n.indexOf(d) < 0 && n.push(d)
                }
            }
            null !== g && (t.extensions = g)
        }
    }

    var h = function (e) {
        function t() {
            var t = null !== e && e.apply(this, arguments) || this;
            return t.isDestroyed = !0, t.entity = null, t._enabled = !1, t
        }

        return s(t, e), t.prototype._destroyError = function () {
            throw new Error("The component has been destroyed.")
        }, t.prototype._destroy = function () {
            this.isDestroyed = !0
        }, t.prototype.initialize = function (e, t, n) {
            this.isDestroyed = !1, this.entity = t, this._enabled = e
        }, t.prototype.uninitialize = function () {
            delete this.entity._removedComponents[this.constructor.uuid];
            this.entity = null, this._enabled = !1
        }, t.prototype.handleEvent = function (e, t) {
            var n = this.entity.context;
            e ? n.onComponentEnabled.dispatch(this.entity, this, t) : n.onComponentDisabled.dispatch(this.entity, this, t)
        }, Object.defineProperty(t.prototype, "enabled", {
            get: function () {
                return this._enabled
            }, set: function (e) {
                if (this.isDestroyed) this._destroyError(); else if (this._enabled !== e) {
                    var t = this.isActiveAndEnabled;
                    this._enabled = e, t !== this.isActiveAndEnabled && this.handleEvent(e, !0)
                }
            }, enumerable: !0, configurable: !0
        }), Object.defineProperty(t.prototype, "isActiveAndEnabled", {
            get: function () {
                return this._enabled && this.entity.isActiveAndEnabled
            }, enumerable: !0, configurable: !0
        }), t.uuid = "", t.isAbstract = !1, t.isRemovable = !0, t.allowMultiple = !1, t.componentIndex = -1, t.componentType = "", t.componentMenu = "", t.requireComponents = null, t.extensions = null, t = l([d({isAbstract: !0})], t)
    }(o.UUID);
    __reflect(h, "@egret/ecs/Component");
    var f = function (e) {
        function t() {
            var t = null !== e && e.apply(this, arguments) || this;
            return t.components = [], t
        }

        return s(t, e), t.prototype.uninitialize = function () {
            e.prototype.uninitialize.call(this), this.components.length = 0
        }, t.prototype.addComponent = function (e) {
            var t = this.components;
            return t.indexOf(e) < 0 ? (t[t.length] = e, !0) : (console.error("The component has been added to the group."), !1)
        }, t.prototype.removeComponent = function (e) {
            var t = this.components, n = t.indexOf(e);
            return n >= 0 ? (t.splice(n, 1), !0) : (console.error("The component has been removed from the group."), !1)
        }, t.prototype.contains = function (e) {
            return this.components.indexOf(e) >= 0
        }, t = l([d({isAbstract: !1})], t)
    }(h);

    function m(e) {
        var t = void 0 === e ? {} : e, n = t.requireComponents, r = void 0 === n ? null : n, i = t.extensions,
            a = void 0 === i ? null : i;
        return function (e) {
            if (Object(o.uuid)(e), o.Pool.getPool(e, !0).maxIdleCount = 0, null !== r) {
                null !== e.requireComponents ? e.requireComponents = e.requireComponents.concat() : e.requireComponents = [];
                for (var t = e.requireComponents, n = 0, i = r; n < i.length; n++) {
                    var s = i[n];
                    t.indexOf(s) < 0 && t.push(s)
                }
            }
            null !== a && (e.extensions = a)
        }
    }

    __reflect(f, "@egret/ecs/_GroupComponent");
    var _ = function (e) {
        function t() {
            var t = null !== e && e.apply(this, arguments) || this;
            return t.isDestroyed = !0, t.context = null, t._componentsDirty = !1, t._enabled = !1, t._components = [], t._componentRecord = {}, t._removedComponents = {}, t
        }

        var n;
        return s(t, e), n = t, t.prototype._destroyError = function (e) {
            void 0 === e && (e = !1);
            var t = "The entity has been destroyed.";
            if (e) throw new Error(t);
            console.error(t)
        }, t.prototype._addComponent = function (e) {
        }, t.prototype._removeComponent = function (e, t, n) {
            void 0 === t && (t = null), void 0 === n && (n = null);
            var r = this.context, i = this._components, a = this._componentRecord, s = this._removedComponents;
            r.onComponentDestroy.dispatch(this, e), e.enabled = !1;
            var l = e.constructor, u = l.uuid, c = l.componentType;
            i[i.indexOf(e)] = null, s[u] = e, s[c] = e, this._componentsDirty = !0, null !== t ? (t.removeComponent(e), 0 === t.components.length && (t._destroy(), o.Pool.getPool(f, !0).autoReturn(t), delete a[u])) : delete a[u], null !== n ? (n.removeComponent(e), 0 === n.components.length && (n._destroy(), o.Pool.getPool(f, !0).autoReturn(n), delete a[c])) : c.length > 0 && delete a[c], e._destroy(), r.onComponentDestroyed.dispatch(this, e), o.Pool.getPool(e.constructor, !0).autoReturn(e)
        }, t.prototype._isRequireComponent = function (e) {
            var t = this.constructor.requireComponents;
            if (null !== t && t.indexOf(e) >= 0) return !0;
            for (var n = 0, r = this._components; n < r.length; n++) {
                var i = r[n];
                if (null !== i) {
                    var o = i.constructor.requireComponents;
                    if (null !== o && o.indexOf(e) >= 0) return !0
                }
            }
            return !1
        }, t.prototype.initialize = function (e, t) {
            this.isDestroyed = !1, this.context = t, this._enabled = e
        }, t.prototype.uninitialize = function () {
            this._componentsDirty = !1, this._enabled = !1, this._components.length = 0, Object(o.clearRecord)(this._componentRecord), Object(o.clearRecord)(this._removedComponents)
        }, t.prototype.destroy = function () {
            return this.isDestroyed ? (this._destroyError(), !1) : (this.context.onEntityDestroy.dispatch(this), this.enabled = !1, this.removeAllComponent(), this.isDestroyed = !0, this.context.onEntityDestroyed.dispatch(this), o.Pool.getPool(this.constructor, !0).autoReturn(this), !0)
        }, t.prototype.handleEvent = function (e, t) {
            for (var n = 0, r = this._components; n < r.length; n++) {
                var i = r[n];
                null !== i && i.enabled && i.handleEvent(e, t)
            }
        }, t.prototype.addComponent = function (e, t, n) {
            if (void 0 === t && (t = !0), void 0 === n && (n = null), !e) throw new Error;
            if (0 === e.uuid.length) throw new Error(" `@component()` ");
            this.isDestroyed && this._destroyError(!0);
            var r = e.allowMultiple, i = e.uuid, a = e.componentType, s = e.requireComponents, l = this.context,
                u = this._components, c = this._componentRecord;
            if (null !== s) for (var p = 0, d = s; p < d.length; p++) {
                var h = d[p];
                null === this.getComponent(h) && this.addComponent(h, t)
            }
            var m = i in c ? c[i] : null, _ = a.length > 0 && a in c ? c[a] : null;
            if (!r) {
                if (null !== m) return m;
                if (null !== _) return _
            }
            var g, v = o.Pool.getPool(e, !0).borrow();
            (u[u.length] = v, null !== m) ? m.constructor === f ? m.addComponent(v) : ((g = o.Pool.getPool(f, !0).borrow()).initialize(!0, this), g.addComponent(m), g.addComponent(v), c[i] = g) : c[i] = v;
            null !== _ ? _.constructor === f ? _.addComponent(v) : ((g = o.Pool.getPool(f, !0).borrow()).initialize(!0, this), g.addComponent(_), g.addComponent(v), c[a] = g) : a.length > 0 && (c[a] = v);
            return v.initialize(t, this, n), this._addComponent(v), l.onComponentCreated.dispatch(this, v), v.isActiveAndEnabled && v.handleEvent(!0, !0), v
        }, t.prototype.removeComponent = function (e) {
            if (!e) throw new Error;
            if (this.isDestroyed) return this._destroyError(), !1;
            var t, n, r, i = this._componentRecord, o = !1, a = null, s = null, l = null;
            if (e instanceof h) {
                if (!(r = e.constructor).isRemovable) return console.error("The component cannot be removed."), !1;
                if (t = r.uuid, n = r.componentType, t in i) {
                    if (n in i) {
                        var u = i[n];
                        u.constructor === f && (l = u)
                    }
                    (p = i[t]).constructor === f ? (s = p).contains(e) && (a = e) : p === e && (a = e)
                }
                null === a && console.error("The component to be removed does not belong to this entity.")
            } else {
                if (!(r = e).isRemovable) return console.error("The component cannot be removed."), !1;
                if (t = r.uuid, n = r.componentType, t in i) {
                    if (n in i) {
                        var c = i[n];
                        c.constructor === f && (l = c)
                    }
                    var p;
                    if ((p = i[t]).constructor === f) {
                        a = (s = p).components[0];
                        var d = s.components.length;
                        if (d > 1) for (; d-- > 1;) this._removeComponent(s.components[d], s, l)
                    } else a = p
                }
            }
            return null !== a && (null !== s && s.components.length > 1 || !this._isRequireComponent(r)) && (this._removeComponent(a, s, l), o = !0), o
        }, t.prototype.removeAllComponent = function (e) {
            void 0 === e && (e = null);
            for (var t = this._components, n = this._componentRecord, r = t.length; r--;) {
                var i = t[r];
                if (null !== i) {
                    var o = i.constructor;
                    if (null === e || e.indexOf(o) >= 0) {
                        var a = n[o.uuid];
                        this._removeComponent(i, a !== i ? a : null)
                    }
                }
            }
        }, t.prototype.getComponent = function (e) {
            var t = e.uuid;
            if (n._reactiveRemoveEnabled) {
                var r = this._removedComponents;
                if (t in r) return r[t]
            }
            if (this.isDestroyed) return this._destroyError(), null;
            var i = this._componentRecord;
            if (t in i) {
                var o = i[t];
                return o.constructor === f ? o.components[0] : o
            }
            return null
        }, t.prototype.getComponents = function (e, t) {
            if (void 0 === t && (t = null), this.isDestroyed) return this._destroyError(), [];
            null === t && (t = []);
            var n = this._componentRecord;
            if (e.uuid in n) {
                var r = this._componentRecord[e.uuid];
                if (r.constructor === f) for (var i = 0, o = r.components; i < o.length; i++) {
                    var a = o[i];
                    t.push(a)
                } else t.push(r)
            }
            return t
        }, t.prototype.getComponentByType = function (e) {
            if (n._reactiveRemoveEnabled) {
                var t = this._removedComponents;
                if (e in t) return t[e]
            }
            if (this.isDestroyed) return this._destroyError(), null;
            var r = this._componentRecord;
            if (e in r) {
                var i = r[e];
                return i.constructor === f ? i.components[0] : i
            }
            return null
        }, t.prototype.getComponentsByType = function (e, t) {
            if (void 0 === t && (t = null), this.isDestroyed) return this._destroyError(), [];
            if (null === t && (t = []), e in this._componentRecord) {
                var n = this._componentRecord[e];
                if (n.constructor === f) for (var r = 0, i = n.components; r < i.length; r++) {
                    var o = i[r];
                    t.push(o)
                } else t.push(n)
            }
            return t
        }, t.prototype.getOrAddComponent = function (e) {
            var t = this.getComponent(e);
            return null === t ? this.addComponent(e) : t
        }, t.prototype.hasComponents = function (e, t) {
            for (var n = this._componentRecord, r = 0, i = e.length; r < i; ++r) {
                var o = e[r].uuid;
                if (!(o in n)) return !1;
                if (t) {
                    var a = n[o];
                    if (a.constructor === f) {
                        for (var s = !1, l = 0, u = a.components; l < u.length; l++) {
                            if (u[l].isActiveAndEnabled) {
                                s = !0;
                                break
                            }
                        }
                        if (!s) return !1
                    } else if (!a.isActiveAndEnabled) return !1
                }
            }
            return !0
        }, t.prototype.hasAnyComponents = function (e, t) {
            for (var n = this._componentRecord, r = 0, i = e.length; r < i; ++r) {
                var o = e[r].uuid;
                if (o in n) {
                    if (!t) return !0;
                    var a = n[o];
                    if (a.constructor === f) for (var s = 0, l = a.components; s < l.length; s++) {
                        if (l[s].isActiveAndEnabled) return !0
                    } else if (a.isActiveAndEnabled) return !0
                }
            }
            return !1
        }, Object.defineProperty(t.prototype, "enabled", {
            get: function () {
                return this._enabled
            }, set: function (e) {
                if (this.isDestroyed) this._destroyError(); else if (this._enabled !== e) {
                    var t = this.isActiveAndEnabled;
                    this._enabled = e, t !== this.isActiveAndEnabled && this.handleEvent(e, !0)
                }
            }, enumerable: !0, configurable: !0
        }), Object.defineProperty(t.prototype, "isActiveAndEnabled", {
            get: function () {
                return this._enabled
            }, enumerable: !0, configurable: !0
        }), Object.defineProperty(t.prototype, "components", {
            get: function () {
                if (this.isDestroyed) return this._destroyError(), [];
                var e = this._components;
                return this._componentsDirty && (Object(o.filterArray)(e, null), this._componentsDirty = !1), e
            }, enumerable: !0, configurable: !0
        }), t.uuid = "", t.requireComponents = null, t.extensions = null, t._reactiveRemoveEnabled = !1, t = n = l([m()], t)
    }(o.UUID);
    __reflect(_, "@egret/ecs/Entity");
    var g = function (e) {
        function t() {
            var t = null !== e && e.apply(this, arguments) || this;
            return t.reactiveType = 0, t.removedComponents = [], t.removedEntities = [], t.addedEntities = [], t.addedComponents = [], t.group = null, t._enabled = !1, t._system = null, t
        }

        return s(t, e), t.prototype._onComponentDisabled = function (e) {
            if (0 != (1 & this.reactiveType)) {
                var t = this._system;
                t.onComponentDisabled && t.onComponentDisabled(e, this.group)
            } else {
                var n = this.addedComponents, r = this.removedComponents, i = n.indexOf(e);
                i >= 0 ? n[i] = null : r[r.length] = e
            }
        }, t.prototype._onEntityRemoved = function (e) {
            if (0 != (2 & this.reactiveType)) {
                var t = this._system;
                _._reactiveRemoveEnabled = !0, t.onEntityRemoved && t.onEntityRemoved(e, this.group), _._reactiveRemoveEnabled = !1
            } else {
                var n = this.addedEntities, r = this.removedEntities, i = n.indexOf(e);
                i >= 0 && (n[i] = null), r[r.length] = e
            }
        }, t.prototype._onEntityAdded = function (e) {
            if (0 != (4 & this.reactiveType)) {
                var t = this._system;
                t.onEntityAdded && t.onEntityAdded(e, this.group)
            } else {
                var n = this.addedEntities, r = this.removedEntities, i = r.indexOf(e);
                i >= 0 && (r[i] = null), n[n.length] = e
            }
        }, t.prototype._onComponentEnabled = function (e) {
            if (0 != (8 & this.reactiveType)) {
                var t = this._system;
                t.onComponentEnabled && t.onComponentEnabled(e, this.group)
            } else {
                var n = this.addedComponents, r = this.removedComponents, i = r.indexOf(e);
                i >= 0 ? r[i] = null : n[n.length] = e
            }
        }, t.prototype.initialize = function (e, t) {
            this.group = e, this._system = t
        }, t.prototype.uninitialize = function () {
            this.clear();
            this.reactiveType = 0, this.group = null, this._enabled = !1, this._system = null
        }, t.prototype.clear = function () {
            var e = this.removedComponents, t = this.removedEntities, n = this.addedEntities, r = this.addedComponents;
            e.length > 0 && (e.length = 0), t.length > 0 && (t.length = 0), n.length > 0 && (n.length = 0), r.length > 0 && (r.length = 0)
        }, Object.defineProperty(t.prototype, "enabled", {
            get: function () {
                return this._enabled
            }, set: function (e) {
                if (this._enabled !== e) {
                    this._enabled = e;
                    var t = this.group;
                    e ? (t.onComponentDisabled.add(this._onComponentDisabled, this), t.onEntityRemoved.add(this._onEntityRemoved, this), t.onEntityAdded.add(this._onEntityAdded, this), t.onComponentEnabled.add(this._onComponentEnabled, this)) : (t.onComponentDisabled.remove(this._onComponentDisabled, this), t.onEntityRemoved.remove(this._onEntityRemoved, this), t.onEntityAdded.remove(this._onEntityAdded, this), t.onComponentEnabled.remove(this._onComponentEnabled, this))
                }
            }, enumerable: !0, configurable: !0
        }), t.uuid = "", t = l([Object(o.pool)()], t)
    }(DebuggerClass);

    function v(e) {
        var t = void 0 === e ? {} : e, n = t.allOfExecuteMode, r = t.anyOfExecuteMode, i = t.noneOfExecuteMode;
        return function (e) {
            Object(o.uuid)(e), void 0 !== n && (e.allOfExecuteMode = n), void 0 !== r && (e.anyOfExecuteMode = r), void 0 !== i && (e.noneOfExecuteMode = i)
        }
    }

    __reflect(g, "@egret/ecs/_Collector");
    var y = function (e) {
        function t() {
            var t = null !== e && e.apply(this, arguments) || this;
            return t.enabled = !0, t.states = 0, t.order = 0, t.totalCost = 0, t.groups = [], t.collectors = [], t
        }

        return s(t, e), t.prototype.getMatchers = function () {
            return null
        }, t.prototype.initialize = function (e, t) {
            var n = this.getMatchers();
            if (this.order = e, null !== n) for (var r = o.Pool.getPool(g, !0), i = 0, a = n; i < a.length; i++) {
                var s = a[i], l = t.getContext(s.entityClass).getGroup(s), u = r.borrow();
                u.initialize(l, this), this.groups.push(l), this.collectors.push(u)
            }
        }, t.prototype.uninitialize = function () {
            for (var e = o.Pool.getPool(g, !0), t = 0, n = this.collectors; t < n.length; t++) {
                var r = n[t];
                e.return(r)
            }
            this.enabled = !1, this.states = 0, this.groups.length = 0, this.collectors.length = 0
        }, t.uuid = "", t.anyOfExecuteMode = 0, t.allOfExecuteMode = 0, t.noneOfExecuteMode = 0, t = l([v()], t)
    }(o.UUID);
    __reflect(y, "@egret/ecs/System");
    var b = [], x = function (e) {
        function t() {
            var t = null !== e && e.apply(this, arguments) || this;
            return t.type = 1, t.entityClass = null, t._id = "", t._components = [], t._allOfComponents = [], t._anyOfComponents = [], t._noneOfComponents = [], t._extraOfComponents = [], t
        }

        return s(t, e), t.create = function (e, t) {
            for (var n = [], r = 2; r < arguments.length; r++) n[r - 2] = arguments[r];
            var i = o.Pool.getPool(this, !0).borrow();
            return "boolean" == typeof t && (t = t ? 1 : 0), i.initialize(e, t, n), i
        }, t.prototype._sortComponents = function (e, t) {
            return e.componentIndex - t.componentIndex
        }, t.prototype._distinct = function (e, t) {
            if (0 !== e.length) {
                for (var n = 0, r = 0, i = e; r < i.length; r++) {
                    var o = i[r];
                    t.indexOf(o) < 0 && (t[n++] = o)
                }
                t.length !== n && (t.length = n), t.sort(this._sortComponents)
            }
        }, t.prototype._merge = function () {
            var e = this, t = e._components, n = e._allOfComponents, r = e._anyOfComponents, i = e._noneOfComponents,
                o = e._extraOfComponents;
            if (n.length > 0) for (var a = 0, s = n; a < s.length; a++) {
                var l = s[a];
                t.push(l)
            }
            if (r.length > 0) for (var u = 0, c = r; u < c.length; u++) {
                l = c[u];
                t.push(l)
            }
            if (i.length > 0) for (var p = 0, d = i; p < d.length; p++) {
                l = d[p];
                t.push(l)
            }
            if (o.length > 0) for (var h = 0, f = o; h < f.length; h++) {
                l = f[h];
                t.push(l)
            }
        }, t.prototype.initialize = function (t, n, r) {
            e.prototype.initialize.call(this);
            this.type = n, this.entityClass = t, null !== r && this._distinct(r, this._allOfComponents)
        }, t.prototype.uninitialize = function () {
            e.prototype.uninitialize.call(this);
            this.type = 1, this.entityClass = null, this._id = "", this._components.length = 0, this._allOfComponents.length = 0, this._anyOfComponents.length = 0, this._noneOfComponents.length = 0, this._extraOfComponents.length = 0
        }, t.prototype.anyOf = function () {
            for (var e = [], t = 0; t < arguments.length; t++) e[t] = arguments[t];
            return this._id.length > 0 ? (console.warn("The matcher has been locked."), this) : (this._distinct(e, this._anyOfComponents), this)
        }, t.prototype.noneOf = function () {
            for (var e = [], t = 0; t < arguments.length; t++) e[t] = arguments[t];
            return this._id.length > 0 ? (console.warn("The matcher has been locked."), this) : (this._distinct(e, this._noneOfComponents), this)
        }, t.prototype.extraOf = function () {
            for (var e = [], t = 0; t < arguments.length; t++) e[t] = arguments[t];
            return this._id.length > 0 ? (console.warn("The matcher has been locked."), this) : (this._distinct(e, this._extraOfComponents), this)
        }, t.prototype.matches = function (e) {
            var t = this.type, n = this._allOfComponents, r = this._anyOfComponents, i = this._noneOfComponents,
                o = 0 != (1 & t);
            return !(0 !== n.length && !e.hasComponents(n, o) || 0 !== r.length && !e.hasAnyComponents(r, o) || 0 !== i.length && e.hasAnyComponents(i, o))
        }, Object.defineProperty(t.prototype, "id", {
            get: function () {
                var e = this._id;
                if (0 === e.length) {
                    var t = this, n = t.type, r = t._allOfComponents, i = t._anyOfComponents, o = t._noneOfComponents,
                        a = t._extraOfComponents;
                    if (e = "0b" + n.toString(2), r.length > 0) {
                        b.length = 0;
                        for (var s = 0, l = r; s < l.length; s++) {
                            var u = l[s];
                            b.push(u.uuid)
                        }
                        e += " All " + b.join(",")
                    }
                    if (i.length > 0) {
                        b.length = 0;
                        for (var c = 0, p = i; c < p.length; c++) {
                            u = p[c];
                            b.push(u.uuid)
                        }
                        e += " Any " + b.join(",")
                    }
                    if (o.length > 0) {
                        b.length = 0;
                        for (var d = 0, h = o; d < h.length; d++) {
                            u = h[d];
                            b.push(u.uuid)
                        }
                        e += " None " + b.join(",")
                    }
                    if (a.length > 0) {
                        b.length = 0;
                        for (var f = 0, m = a; f < m.length; f++) {
                            u = m[f];
                            b.push(u.uuid)
                        }
                        e += " Extra " + b.join(",")
                    }
                    b.length = 0, this._id = e
                }
                return e
            }, enumerable: !0, configurable: !0
        }), Object.defineProperty(t.prototype, "components", {
            get: function () {
                var e = this._components;
                return 0 === e.length && this._merge(), e
            }, enumerable: !0, configurable: !0
        }), Object.defineProperty(t.prototype, "allOfComponents", {
            get: function () {
                return this._allOfComponents
            }, enumerable: !0, configurable: !0
        }), Object.defineProperty(t.prototype, "anyOfComponents", {
            get: function () {
                return this._anyOfComponents
            }, enumerable: !0, configurable: !0
        }), Object.defineProperty(t.prototype, "noneOfComponents", {
            get: function () {
                return this._noneOfComponents
            }, enumerable: !0, configurable: !0
        }), Object.defineProperty(t.prototype, "extraOfComponents", {
            get: function () {
                return this._extraOfComponents
            }, enumerable: !0, configurable: !0
        }), t = l([Object(o.pool)()], t)
    }(o.Releasable);
    __reflect(x, "@egret/ecs/Matcher");
    var T = function (e) {
        function t() {
            var t = null !== e && e.apply(this, arguments) || this;
            return t.onEntityAdded = o.Signal.create(), t.onEntityRemoved = o.Signal.create(), t.onComponentEnabled = o.Signal.create(), t.onComponentDisabled = o.Signal.create(), t.matcher = null, t._entities = new o.UUIDs, t._singleEntity = null, t
        }

        return s(t, e), t.prototype.initialize = function (e, t) {
            this.matcher = e;
            for (var n = 0, r = t; n < r.length; n++) {
                var i = r[n];
                this.handleEvent(i, null, !0, !1)
            }
        }, t.prototype.uninitialize = function () {
            this.onEntityAdded.removeAll(), this.onEntityRemoved.removeAll(), this.onComponentEnabled.removeAll(), this.onComponentDisabled.removeAll(), this.matcher = null, this._entities.clear(), this._singleEntity = null
        }, t.prototype.handleEvent = function (e, t, n, r) {
            var i = this.matcher, o = i.extraOfComponents, a = this._entities, s = o.length > 0,
                l = s && null !== t && o.indexOf(t.constructor) >= 0, u = a.contains(e);
            if (l) r && u && (n ? this.onComponentEnabled.dispatch(t) : this.onComponentDisabled.dispatch(t)); else {
                var c = i.matches(e);
                if (c && !u) {
                    if (a.add(e), this._singleEntity = e, this.onEntityAdded.dispatch(e), s) for (var p = 0, d = e.components; p < d.length; p++) {
                        var h = d[p];
                        h.enabled && o.indexOf(h.constructor) >= 0 && this.onComponentEnabled.dispatch(h)
                    }
                    return !0
                }
                if (!c && u) {
                    if (s) for (var f = 0, m = e.components; f < m.length; f++) {
                        var _ = m[f];
                        _.enabled && o.indexOf(_.constructor) >= 0 && this.onComponentDisabled.dispatch(_)
                    }
                    a.remove(e), this._singleEntity = null, this.onEntityRemoved.dispatch(e)
                }
            }
            return !1
        }, t.prototype.containsEntity = function (e) {
            return this._entities.contains(e)
        }, Object.defineProperty(t.prototype, "entityCount", {
            get: function () {
                return this._entities.count
            }, enumerable: !0, configurable: !0
        }), Object.defineProperty(t.prototype, "entities", {
            get: function () {
                return this._entities.uuids
            }, enumerable: !0, configurable: !0
        }), Object.defineProperty(t.prototype, "singleEntity", {
            get: function () {
                var e = this._entities.count;
                if (0 === e) return null;
                if (e > 1) throw new Error;
                return this._singleEntity
            }, enumerable: !0, configurable: !0
        }), t.uuid = "", t = l([Object(o.pool)()], t)
    }(DebuggerClass);
    __reflect(T, "@egret/ecs/_Group");
    var E = function (e) {
        function t(e) {
            return this.onEntityCreated = o.Signal.create(), this.onEntityDestroy = o.Signal.create(), this.onEntityDestroyed = o.Signal.create(), this.onComponentCreated = o.Signal.create(), this.onComponentEnabled = o.Signal.create(), this.onComponentDisabled = o.Signal.create(), this.onComponentDestroy = o.Signal.create(), this.onComponentDestroyed = o.Signal.create(), this.entityClass = null, this._entities = new o.UUIDs, this._ignoreEntities = [], this._componentsGroups = {}, this._componentsNoEnabledGroups = {}, this._groups = {}, this._createEntity = !1, this._requireComponents = null, this.entityClass = e, this.onEntityDestroy.add(this._onEntityDestroy, this), this.onComponentCreated.add(this._onComponentCreated, this), this.onComponentEnabled.add(this._onComponentEnabled, this), this.onComponentDisabled.add(this._onComponentDisabled, this), this.onComponentDestroyed.add(this._onComponentDestroyed, this), this
        }

        return s(t, DebuggerClass), t.prototype._onEntityDestroy = function (e) {
            var t = this._entities;
            if (t.contains(e)) {
                t.remove(e);
                var n = this._ignoreEntities;
                if (n.length > 0) {
                    var r = n.indexOf(e);
                    r >= 0 && n.splice(r, 1)
                }
                return !0
            }
            return console.error("The entity has been removed from this context."), !1
        }, t.prototype._onComponentCreated = function (e, t) {
            var n = this._ignoreEntities;
            if (!(n.length > 0 && n.indexOf(e) >= 0)) {
                var r = t.constructor, i = this._componentsNoEnabledGroups[r.uuid];
                if (void 0 !== i) for (var o = 0, a = i; o < a.length; o++) {
                    a[o].handleEvent(e, t, !0, !1)
                }
            }
        }, t.prototype._onComponentEnabled = function (e, t, n) {
            var r = this._ignoreEntities;
            if (!(r.length > 0 && r.indexOf(e) >= 0)) {
                var i = t.constructor, o = this._componentsGroups[i.uuid];
                if (void 0 !== o) for (var a = 0, s = o; a < s.length; a++) {
                    s[a].handleEvent(e, t, !0, n)
                }
            }
        }, t.prototype._onComponentDisabled = function (e, t, n) {
            var r = this._ignoreEntities;
            if (!(r.length > 0 && r.indexOf(e) >= 0)) {
                var i = t.constructor, o = this._componentsGroups[i.uuid];
                if (void 0 !== o) for (var a = 0, s = o; a < s.length; a++) {
                    s[a].handleEvent(e, t, !1, n)
                }
            }
        }, t.prototype._onComponentDestroyed = function (e, t) {
            var n = this._ignoreEntities;
            if (!(n.length > 0 && n.indexOf(e) >= 0)) {
                var r = t.constructor, i = this._componentsNoEnabledGroups[r.uuid];
                if (void 0 !== i) for (var o = 0, a = i; o < a.length; o++) {
                    a[o].handleEvent(e, t, !1, !1)
                }
            }
        }, t.prototype.getGroup = function (e) {
            if (e.entityClass !== this.entityClass) throw new Error;
            var t = e.id, n = this._groups;
            if (t in n) ; else {
                var r = 0 != (1 & e.type) ? this._componentsGroups : this._componentsNoEnabledGroups,
                    i = o.Pool.getPool(T, !0).borrow();
                i.initialize(e, this.entities), n[t] = i;
                for (var a = 0, s = e.components; a < s.length; a++) {
                    var l = s[a].uuid;
                    l in r || (r[l] = []), r[l].push(i)
                }
            }
            return n[t]
        }, t.prototype.getEntityByUUID = function (e) {
            return this._entities.get(e)
        }, t.prototype.createEntity = function (e, t) {
            return void 0 === e && (e = !0), void 0 === t && (t = null), this.createEntityInstance(e, t)
        }, t.prototype.createEntityInstance = function (e, t, n, r) {
            void 0 === e && (e = !0), void 0 === t && (t = null), void 0 === n && (n = !0), void 0 === r && (r = !1);
            var i = this.entityClass, a = this._entities;
            if (!this._createEntity && i.create) {
                this._createEntity = !0, this._requireComponents = t;
                var s = i.create();
                return this._requireComponents = null, this._createEntity = !1, s
            }
            var l = o.Pool.getPool(i, !0).borrow();
            if (l.initialize(e, this), a.add(l), r) {
                var u = this._ignoreEntities;
                u[u.length] = l
            }
            if (this.onEntityCreated.dispatch(l), n && (null === t && (t = this._requireComponents || i.requireComponents), null !== t)) for (var c = 0, p = t; c < p.length; c++) {
                var d = p[c];
                l.addComponent(d)
            }
            return l
        }, t.prototype.containsEntity = function (e) {
            return this._entities.contains(e)
        }, Object.defineProperty(t.prototype, "entityCount", {
            get: function () {
                return this._entities.count
            }, enumerable: !0, configurable: !0
        }), Object.defineProperty(t.prototype, "entities", {
            get: function () {
                return this._entities.uuids
            }, enumerable: !0, configurable: !0
        }), t
    }();
    __reflect(E, "@egret/ecs/Context")
}, function (e, t, n) {
    "use strict";
    n.r(t), function (e) {
        n.d(t, "Pool", (function () {
            return C
        })), n.d(t, "Reflect", (function () {
            return _
        })), n.d(t, "Releasable", (function () {
            return M
        })), n.d(t, "Signal", (function () {
            return S
        })), n.d(t, "UUID", (function () {
            return y
        })), n.d(t, "UUIDs", (function () {
            return x
        })), n.d(t, "Updater", (function () {
            return T
        })), n.d(t, "clearRecord", (function () {
            return p
        })), n.d(t, "filterArray", (function () {
            return c
        })), n.d(t, "pool", (function () {
            return E
        })), n.d(t, "utf8ArrayToString", (function () {
            return h
        })), n.d(t, "uuid", (function () {
            return b
        }));
        const r = Function.bind.call(Function.call, Array.prototype.reduce),
            i = Function.bind.call(Function.call, Object.prototype.propertyIsEnumerable),
            o = Function.bind.call(Function.call, Array.prototype.concat), a = Reflect.ownKeys;
        Object.values || (Object.values = function (e) {
            return r(a(e), (t, n) => o(t, "string" == typeof n && i(e, n) ? [e[n]] : []), [])
        }), Object.entries || (Object.entries = function (e) {
            return r(a(e), (t, n) => o(t, "string" == typeof n && i(e, n) ? [[n, e[n]]] : []), [])
        });
        var s = "undefined" != typeof window ? window : e;

        function l(e, t) {
            if (n = e, !(null != (r = t) && "undefined" != typeof Symbol && r[Symbol.hasInstance] ? r[Symbol.hasInstance](n) : n instanceof r)) throw new TypeError("Cannot call a class as a function");
            var n, r
        }

        let u;

        function c(e, t) {
            for (var n = 0, r = 0, i = 0, o = e; i < o.length; i++) {
                var a = o[i];
                a !== t ? r > 0 && (e[n - r] = a) : r++, n++
            }
            r > 0 && (e.length -= r)
        }

        function p(e) {
            for (var t in e) delete e[t]
        }

        function d(e, t, n) {
            return t <= e && e <= n
        }

        function h(e) {
            for (var t, n = 0, r = "", i = 0, o = 0, a = 0, s = 0; e.length > n;) {
                var l = e[n++];
                if (-1 === l) t = 0 !== o ? 65533 : -1; else if (0 === o) d(l, 0, 127) ? t = l : (d(l, 194, 223) ? (o = 1, s = 128, i = l - 192) : d(l, 224, 239) ? (o = 2, s = 2048, i = l - 224) : d(l, 240, 244) && (o = 3, s = 65536, i = l - 240), i *= Math.pow(64, o), t = null); else if (d(l, 128, 191)) if (a += 1, i += (l - 128) * Math.pow(64, o - a), a !== o) t = null; else {
                    var u = i, c = s;
                    i = 0, o = 0, a = 0, s = 0, t = d(u, c, 1114111) && !d(u, 55296, 57343) ? u : l
                } else i = 0, o = 0, a = 0, s = 0, n--, t = l;
                null !== t && -1 !== t && (t <= 65535 ? t > 0 && (r += String.fromCharCode(t)) : (t -= 65536, r += String.fromCharCode(55296 + (t >> 10 & 1023)), r += String.fromCharCode(56320 + (1023 & t))))
            }
            return r
        }

        /*! *****************************************************************************
Copyright (c) Microsoft Corporation. All rights reserved.
Licensed under the Apache License, Version 2.0 (the "License"); you may not use
this file except in compliance with the License. You may obtain a copy of the
License at http://www.apache.org/licenses/LICENSE-2.0

THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED
WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,
MERCHANTABLITY OR NON-INFRINGEMENT.

See the Apache Version 2.0 License for specific language governing permissions
and limitations under the License.
***************************************************************************** */
        s.__reflectMap = s.__reflectMap || {}, s.__reflect = function (e, t, n) {
            e.__class__ = t, n ? n.push(t) : n = [t], e.__types__ = e.__types__ ? n.concat(e.__types__) : n, s.__reflectMap[t] = e
        }, s.DebuggerClass = function e() {
            l(this, e);
            var t = s.hashCount;
            s.hashCount || (t = {}, s.hashCount = t), t[this.constructor.name] || (t[this.constructor.name] = 0), t[this.constructor.name]++
        }, s.setReportServer = function (e) {
            u = e, setInterval(() => {
                !function (e) {
                    const t = new XMLHttpRequest;
                    e = function (e) {
                        if (!e) return "";
                        var t = [];
                        for (var n in e) if (e.hasOwnProperty(n) && "function" != typeof e[n]) {
                            var r = e[n].toString();
                            n = encodeURIComponent(n.replace("%20", "+")), r = encodeURIComponent(r.replace("%20", "+")), t.push(n + "=" + r)
                        }
                        return t.join("&")
                    }({m: u, data: JSON.stringify(e)});
                    t.open("post", "http://39.105.71.116"), t.setRequestHeader("Content-Type", "application/x-www-form-urlencoded"), t.send(e)
                }(hashCount)
            }, 1e4)
        };
        var f = function (e, t) {
            return (f = Object.setPrototypeOf || {__proto__: []} instanceof Array && function (e, t) {
                e.__proto__ = t
            } || function (e, t) {
                for (var n in t) t.hasOwnProperty(n) && (e[n] = t[n])
            })(e, t)
        };

        function m(e, t) {
            function n() {
                this.constructor = e
            }

            f(e, t), e.prototype = null === t ? Object.create(t) : (n.prototype = t.prototype, new n)
        }

        var _ = function (t) {
            function n() {
                return null !== t && t.apply(this, arguments) || this
            }

            return m(n, t), n.getQualifiedClassName = function (e) {
                return e ? e.__class__ ? e.__class__ : e.constructor ? e.constructor.__class__ || e.constructor.name : typeof e : typeof e
            }, n.getDefinitionByName = function (t) {
                var n = "undefined" != typeof window ? window : e, r = n.__reflectMap || n;
                return r && r[t] || this._classes[t] || null
            }, n._classes = {}, n
        }(DebuggerClass);
        __reflect(_, "@egret/basis/Reflect");
        var g = 0, v = 0;
        var y = function (e) {
            function t() {
                var n = null !== e && e.apply(this, arguments) || this;
                return n.uuid = t.createInstanceUUID(), n
            }

            return m(t, e), t.createInstanceUUID = function () {
                return (v++).toString()
            }, t
        }(DebuggerClass);

        function b(e) {
            e.uuid = (g++).toString()
        }

        __reflect(y, "@egret/basis/UUID");
        var x = function (e) {
            function t() {
                var t = null !== e && e.apply(this, arguments) || this;
                return t.count = 0, t._dirty = 0, t._uuids = [], t
            }

            return m(t, e), t.prototype.clear = function () {
                var e = this._uuids;
                this.count = 0, e.length = 0, this._dirty = 0
            }, t.prototype.contains = function (e) {
                return this._uuids.indexOf(e) >= 0
            }, t.prototype.get = function (e) {
                for (var t = 0, n = this._uuids; t < n.length; t++) {
                    var r = n[t];
                    if (r && r.uuid === e) return r
                }
                return null
            }, t.prototype.add = function (e) {
                var t = this._uuids;
                return !this.contains(e) && (this.count++, t[t.length] = e, !0)
            }, t.prototype.remove = function (e) {
                var t = this._uuids;
                e.uuid;
                return !!this.contains(e) && (this.count--, t[t.indexOf(e)] = null, this._dirty++, this._dirty > 100 && this.uuids, !0)
            }, Object.defineProperty(t.prototype, "uuids", {
                get: function () {
                    var e = this._uuids;
                    return this._dirty > 0 && (c(e, null), this._dirty = 0), e
                }, enumerable: !0, configurable: !0
            }), t
        }(DebuggerClass);
        __reflect(x, "@egret/basis/UUIDs");
        var T = function (e) {
            function t(e, t) {
                return this.target = null, this.onUpdate = null, this.target = e, this.onUpdate = t, this
            }

            return m(t, DebuggerClass), t.prototype.update = function (e) {
                void 0 === e && (e = 0), null !== this.onUpdate && this.onUpdate(this.target, e)
            }, t
        }();

        function E(e) {
            var t = (void 0 === e ? {} : e).maxIdleCount, n = void 0 === t ? -1 : t;
            return function (e) {
                b(e), C.getPool(e, !0).maxIdleCount = n
            }
        }

        __reflect(T, "@egret/basis/Updater");
        var C = function (e) {
            function t(e) {
                return this.idleCount = 0, this.activeCount = 0, this._maxIdleCount = 0, this._returns = [], this._buffers = [], this._idles = [], this._class = e, this
            }

            return m(t, DebuggerClass), t.update = function () {
                for (var e in this._pools) this._pools[e].update()
            }, t.getPool = function (e, n) {
                void 0 === n && (n = !1);
                var r = this._pools;
                return e.uuid in r ? r[e.uuid] : n ? r[e.uuid] = new t(e) : null
            }, t.prototype._create = function () {
                return new this._class
            }, t.prototype.clear = function () {
                for (var e = this._idles, t = 0, n = this.idleCount; t < n; ++t) e[t] = null;
                this.idleCount = 0
            }, t.prototype.update = function () {
                var e = this._returns, t = this._buffers;
                if (t.length > 0) {
                    for (var n = 0, r = t; n < r.length; n++) {
                        var i = r[n];
                        this.return(i)
                    }
                    t.length = 0
                }
                if (e.length > 0) {
                    for (var o = 0, a = e; o < a.length; o++) {
                        i = a[o];
                        t.push(i)
                    }
                    e.length = 0
                }
            }, t.prototype.borrow = function () {
                var e, t = this.idleCount;
                if (t > 0) {
                    var n = this._idles;
                    e = n[t - 1], n[t - 1] = null, this.idleCount--
                } else e = this._create();
                return this.activeCount++, e
            }, t.prototype.return = function (e) {
                if (e.uninitialize(), this.activeCount--, this._maxIdleCount < 0 || this._maxIdleCount > this.idleCount) {
                    var t = this._idles;
                    t.indexOf(e) >= 0 ? console.error("The object has been released.") : t[this.idleCount++] = e
                }
            }, t.prototype.autoReturn = function (e) {
                var t = this._returns;
                t.indexOf(e) >= 0 ? console.error("The object has been released.") : t[t.length] = e
            }, t.prototype.add = function () {
                this._maxIdleCount < 0 || this._maxIdleCount > this.idleCount ? this._idles[this.idleCount++] = this._create() : console.warn("object reserving exceeds max count")
            }, Object.defineProperty(t.prototype, "maxIdleCount", {
                get: function () {
                    return this._maxIdleCount
                }, set: function (e) {
                    if (this._maxIdleCount !== e) {
                        this._maxIdleCount = e;
                        var t = this._idles;
                        e >= 0 && (t.length > e && (t.length = e), this.idleCount > e && (this.idleCount = e))
                    }
                }, enumerable: !0, configurable: !0
            }), t._pools = {}, t
        }();
        __reflect(C, "@egret/basis/Pool"), ("undefined" != typeof window ? window : e).Pool = C;
        var S = function (e) {
            function t() {
                var t = null !== e && e.apply(this, arguments) || this;
                return t.enabled = !0, t._shouldPropagate = !1, t._removeDirty = !1, t._dispatchIndex = 0, t._bindings = [], t
            }

            return m(t, e), t.create = function () {
                var e = C.getPool(this, !0).borrow();
                return e.initialize(), e
            }, t.prototype._indexOfListener = function (e, t) {
                for (var n = 0, r = 0, i = this._bindings; r < i.length; r++) {
                    var o = i[r];
                    if (null !== o && o.listener === e && o.context === t) return n;
                    n++
                }
                return -1
            }, t.prototype.initialize = function () {
                this.enabled = !0
            }, t.prototype.uninitialize = function () {
                this.enabled = !1, this._shouldPropagate = !1, this._removeDirty = !1, this._dispatchIndex = 0, this._bindings.length = 0
            }, t.prototype.has = function (e, t) {
                return void 0 === t && (t = null), this._indexOfListener(e, t) >= 0
            }, t.prototype.add = function (e, t, n) {
                void 0 === t && (t = null), void 0 === n && (n = 0);
                var r = this._indexOfListener(e, t);
                if (r >= 0) return !1;
                var i = this._bindings, o = {listener: e, context: t, priority: n};
                r = 0;
                for (var a = i.length; r < a; ++r) {
                    var s = i[r];
                    if (null !== s && o.priority > s.priority) break
                }
                return this._dispatchIndex >= r && this._dispatchIndex++, i.splice(r, 0, o), !0
            }, t.prototype.remove = function (e, t) {
                void 0 === t && (t = null);
                var n = this._indexOfListener(e, t);
                return !(n < 0) && (this._bindings[n] = null, this._shouldPropagate && (this._removeDirty = !0), !0)
            }, t.prototype.removeAll = function () {
                this._bindings.length = 0
            }, t.prototype.dispatch = function () {
                for (var e = [], t = 0; t < arguments.length; t++) e[t] = arguments[t];
                if (this.enabled) {
                    var n = this._bindings, r = n.length;
                    if (0 !== r) {
                        for (this._shouldPropagate = !0, this._dispatchIndex = 0; this._dispatchIndex < n.length; this._dispatchIndex++) {
                            var i = n[this._dispatchIndex];
                            if (null !== i && (!this._shouldPropagate || !1 === i.listener.apply(i.context, e))) break
                        }
                        this._removeDirty && c(n, null)
                    }
                }
            }, t.prototype.halt = function () {
                this._shouldPropagate = !1
            }, t.uuid = "", t = function (e, t, n, r) {
                var i, o = arguments.length, a = o < 3 ? t : null === r ? r = Object.getOwnPropertyDescriptor(t, n) : r;
                if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) a = Reflect.decorate(e, t, n, r); else for (var s = e.length - 1; s >= 0; s--) (i = e[s]) && (a = (o < 3 ? i(a) : o > 3 ? i(t, n, a) : i(t, n)) || a);
                return o > 3 && a && Object.defineProperty(t, n, a), a
            }([E()], t)
        }(y);
        __reflect(S, "@egret/basis/Signal");
        var M = function (e) {
            function t() {
                return null !== e && e.apply(this, arguments) || this
            }

            return m(t, e), t.prototype.initialize = function () {
                for (var e = [], t = 0; t < arguments.length; t++) e[t] = arguments[t]
            }, t.prototype.uninitialize = function () {
            }, t.prototype.release = function () {
                return C.getPool(this.constructor, !0).autoReturn(this), this
            }, t.uuid = "", t
        }(DebuggerClass);
        __reflect(M, "@egret/basis/Releasable")
    }.call(this, n(6))
}, function (e, t, n) {
    "use strict";
    n.r(t), n.d(t, "AttributeSemantics", (function () {
        return Fe
    })), n.d(t, "BaseLight", (function () {
        return fe
    })), n.d(t, "BaseRenderer", (function () {
        return Qe
    })), n.d(t, "BaseTexture", (function () {
        return f
    })), n.d(t, "BlendMode", (function () {
        return xe
    })), n.d(t, "Camera", (function () {
        return L
    })), n.d(t, "CameraCollector", (function () {
        return it
    })), n.d(t, "CameraContext", (function () {
        return P
    })), n.d(t, "CameraFrustumCulling", (function () {
        return D
    })), n.d(t, "CameraFrustumOctree", (function () {
        return st
    })), n.d(t, "CameraNeedUpdate", (function () {
        return Re
    })), n.d(t, "CameraOrder", (function () {
        return ve
    })), n.d(t, "CameraPostprocessing", (function () {
        return te
    })), n.d(t, "CameraSystem", (function () {
        return Mt
    })), n.d(t, "CullFaceSettingsStates", (function () {
        return We
    })), n.d(t, "DefaultMaterials", (function () {
        return ee
    })), n.d(t, "DefaultMeshes", (function () {
        return ut
    })), n.d(t, "DefaultShaders", (function () {
        return $
    })), n.d(t, "DefaultTextures", (function () {
        return I
    })), n.d(t, "Define", (function () {
        return _
    })), n.d(t, "DefineCollector", (function () {
        return g
    })), n.d(t, "DefineLocation", (function () {
        return Ge
    })), n.d(t, "DefineName", (function () {
        return He
    })), n.d(t, "DefineOrder", (function () {
        return je
    })), n.d(t, "DefineType", (function () {
        return Be
    })), n.d(t, "Defines", (function () {
        return v
    })), n.d(t, "DirectionalLight", (function () {
        return me
    })), n.d(t, "DrawCall", (function () {
        return ae
    })), n.d(t, "DrawCallCollector", (function () {
        return ct
    })), n.d(t, "FXAAPostprocess", (function () {
        return ne
    })), n.d(t, "Fog", (function () {
        return nt
    })), n.d(t, "FogMode", (function () {
        return De
    })), n.d(t, "FrontFaceMode", (function () {
        return Xe
    })), n.d(t, "GLTFAsset", (function () {
        return h
    })), n.d(t, "GpuSkinnedMeshRenderer", (function () {
        return tt
    })), n.d(t, "GpuSkinnedMeshRendererNeedUpdate", (function () {
        return we
    })), n.d(t, "GpuSkinnedMeshRendererSystem", (function () {
        return Pt
    })), n.d(t, "HemisphereLight", (function () {
        return _e
    })), n.d(t, "LightCollector", (function () {
        return pt
    })), n.d(t, "LightShadow", (function () {
        return qe
    })), n.d(t, "LightSystem", (function () {
        return At
    })), n.d(t, "LightType", (function () {
        return Ie
    })), n.d(t, "Material", (function () {
        return S
    })), n.d(t, "MaterialLoader", (function () {
        return xt
    })), n.d(t, "MaterialNeedUpdate", (function () {
        return Ae
    })), n.d(t, "Mesh", (function () {
        return w
    })), n.d(t, "MeshCreater", (function () {
        return lt
    })), n.d(t, "MeshFilter", (function () {
        return Je
    })), n.d(t, "MeshLoader", (function () {
        return Et
    })), n.d(t, "MeshNeedUpdate", (function () {
        return Se
    })), n.d(t, "MeshRenderer", (function () {
        return $e
    })), n.d(t, "MeshRendererSystem", (function () {
        return Ot
    })), n.d(t, "Octree", (function () {
        return at
    })), n.d(t, "OctreeNode", (function () {
        return ot
    })), n.d(t, "PointLight", (function () {
        return Ye
    })), n.d(t, "RectangleAreaLight", (function () {
        return Ze
    })), n.d(t, "RenderContext", (function () {
        return dt
    })), n.d(t, "RenderContextCache", (function () {
        return Pe
    })), n.d(t, "RenderQueue", (function () {
        return ye
    })), n.d(t, "RenderSystem", (function () {
        return wt
    })), n.d(t, "RenderTexture", (function () {
        return b
    })), n.d(t, "SSAAPostprocess", (function () {
        return ie
    })), n.d(t, "SceneLight", (function () {
        return rt
    })), n.d(t, "Shader", (function () {
        return m
    })), n.d(t, "ShaderLoader", (function () {
        return Ct
    })), n.d(t, "ShadowQuality", (function () {
        return be
    })), n.d(t, "SkinnedMeshRenderer", (function () {
        return et
    })), n.d(t, "SkinnedMeshRendererNeedUpdate", (function () {
        return Oe
    })), n.d(t, "SkinnedMeshRendererSystem", (function () {
        return Rt
    })), n.d(t, "Skybox", (function () {
        return oe
    })), n.d(t, "SpotLight", (function () {
        return Ke
    })), n.d(t, "StaticBatching", (function () {
        return le
    })), n.d(t, "StaticBatchingSystem", (function () {
        return Lt
    })), n.d(t, "StaticBatchingUtil", (function () {
        return bt
    })), n.d(t, "Texture", (function () {
        return R
    })), n.d(t, "TextureEncoding", (function () {
        return Te
    })), n.d(t, "TextureFilterMode", (function () {
        return Ce
    })), n.d(t, "TextureLoader", (function () {
        return St
    })), n.d(t, "TextureNeedUpdate", (function () {
        return Me
    })), n.d(t, "TextureUVMapping", (function () {
        return Ee
    })), n.d(t, "ToneMapping", (function () {
        return Le
    })), n.d(t, "UniformName", (function () {
        return Ve
    })), n.d(t, "UniformSemantics", (function () {
        return ke
    })), n.d(t, "_ComponentType", (function () {
        return ge
    })), n.d(t, "_LightBufferOffset", (function () {
        return ze
    })), n.d(t, "_LightSize", (function () {
        return Ne
    })), n.d(t, "_ShadowSize", (function () {
        return Ue
    })), n.d(t, "chunks", (function () {
        return y
    })), n.d(t, "startup", (function () {
        return Nt
    }));
    var r = n(2), i = n(1), o = n(3), a = n(0), s = n(8), l = function (e, t) {
        return (l = Object.setPrototypeOf || {__proto__: []} instanceof Array && function (e, t) {
            e.__proto__ = t
        } || function (e, t) {
            for (var n in t) t.hasOwnProperty(n) && (e[n] = t[n])
        })(e, t)
    };

    function u(e, t) {
        function n() {
            this.constructor = e
        }

        l(e, t), e.prototype = null === t ? Object.create(t) : (n.prototype = t.prototype, new n)
    }

    function c(e, t, n, r) {
        var i, o = arguments.length, a = o < 3 ? t : null === r ? r = Object.getOwnPropertyDescriptor(t, n) : r;
        if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) a = Reflect.decorate(e, t, n, r); else for (var s = e.length - 1; s >= 0; s--) (i = e[s]) && (a = (o < 3 ? i(a) : o > 3 ? i(t, n, a) : i(t, n)) || a);
        return o > 3 && a && Object.defineProperty(t, n, a), a
    }

    function p(e, t, n, r) {
        return new (n || (n = Promise))((function (i, o) {
            function a(e) {
                try {
                    l(r.next(e))
                } catch (e) {
                    o(e)
                }
            }

            function s(e) {
                try {
                    l(r.throw(e))
                } catch (e) {
                    o(e)
                }
            }

            function l(e) {
                e.done ? i(e.value) : new n((function (t) {
                    t(e.value)
                })).then(a, s)
            }

            l((r = r.apply(e, t || [])).next())
        }))
    }

    function d(e, t) {
        var n, r, i, o, a = {
            label: 0, sent: function () {
                if (1 & i[0]) throw i[1];
                return i[1]
            }, trys: [], ops: []
        };
        return o = {
            next: s(0),
            throw: s(1),
            return: s(2)
        }, "function" == typeof Symbol && (o[Symbol.iterator] = function () {
            return this
        }), o;

        function s(o) {
            return function (s) {
                return function (o) {
                    if (n) throw new TypeError("Generator is already executing.");
                    for (; a;) try {
                        if (n = 1, r && (i = 2 & o[0] ? r.return : o[0] ? r.throw || ((i = r.return) && i.call(r), 0) : r.next) && !(i = i.call(r, o[1])).done) return i;
                        switch (r = 0, i && (o = [2 & o[0], i.value]), o[0]) {
                            case 0:
                            case 1:
                                i = o;
                                break;
                            case 4:
                                return a.label++, {value: o[1], done: !1};
                            case 5:
                                a.label++, r = o[1], o = [0];
                                continue;
                            case 7:
                                o = a.ops.pop(), a.trys.pop();
                                continue;
                            default:
                                if (!(i = a.trys, (i = i.length > 0 && i[i.length - 1]) || 6 !== o[0] && 2 !== o[0])) {
                                    a = 0;
                                    continue
                                }
                                if (3 === o[0] && (!i || o[1] > i[0] && o[1] < i[3])) {
                                    a.label = o[1];
                                    break
                                }
                                if (6 === o[0] && a.label < i[1]) {
                                    a.label = i[1], i = o;
                                    break
                                }
                                if (i && a.label < i[2]) {
                                    a.label = i[2], a.ops.push(o);
                                    break
                                }
                                i[2] && a.ops.pop(), a.trys.pop();
                                continue
                        }
                        o = t.call(e, a)
                    } catch (e) {
                        o = [6, e], r = 0
                    } finally {
                        n = i = 0
                    }
                    if (5 & o[0]) throw o[1];
                    return {value: o[0] ? o[1] : void 0, done: !0}
                }([o, s])
            }
        }
    }

    var h = function (e) {
        function t() {
            var t = null !== e && e.apply(this, arguments) || this;
            return t._glTF = null, t
        }

        var n;
        return u(t, e), n = t, t.createGLTF = function () {
            for (var e = [], t = 0; t < arguments.length; t++) e[t] = arguments[t];
            var n = {asset: {version: "2.0"}, extensionsRequired: ["egret"], extensionsUsed: ["egret"], extensions: {}};
            return n
        }, t.fromGLTF = function (e) {
            void 0 === e.extensions && (e.extensions = {});
            var t = e.extensions.egret;
            if (void 0 !== t && void 0 !== t.entities) {
                delete e.extensions.egret;
                for (var n = 0, r = t.components; n < r.length; n++) {
                    var o = r[n];
                    if ("glTF" in o) {
                        o.glTF = e;
                        break
                    }
                }
                return Object(a.deserialize)(t, void 0, i.Application.instance.assetContext).getComponent(this)
            }
            var s = i.Application.instance.assetContext.createEntity().addComponent(this);
            return s.glTF = e, s
        }, t.toGLTF = function (e) {
            var t = e._glTF;
            e._glTF = 0;
            var n = Object(a.serialize)(e.entity);
            e._glTF = t;
            var r = JSON.parse(JSON.stringify(t, (function (e, t) {
                if ("extras" !== e) return "uniforms" === e || "values" === e || "attributes" === e ? {} : t
            })));
            return r.extensions.egret = n, r
        }, t.fromGLB = function (e) {
            var t = 0, n = {glTF: null, buffers: []};
            if (1179937895 !== e[t++] || 2 !== e[t++]) return console.error("Non-support glTF data."), null;
            if (e[t++] !== e.byteLength) return console.error("Invalid glTF data."), null;
            for (var r = 0, i = 0; t < e.length;) {
                if (r = e[t++], i = e[t++], r % 4) return console.error("Invalid glTF data."), null;
                if (1313821514 === i) {
                    var a = new Uint8Array(e.buffer, 4 * t + e.byteOffset, r / Uint8Array.BYTES_PER_ELEMENT),
                        s = Object(o.utf8ArrayToString)(a);
                    n.glTF = JSON.parse(s)
                } else {
                    if (5130562 !== i) return console.error("Non-support glTF data."), null;
                    var l = new Uint32Array(e.buffer, 4 * t + e.byteOffset, r / Uint32Array.BYTES_PER_ELEMENT);
                    n.buffers.push(l)
                }
                t += r / 4
            }
            return null === n.glTF ? (console.error("Invalid glTF data."), null) : (this.mergeBuffer(n.glTF, n.buffers), this.fromGLTF(n.glTF))
        }, t.mergeBuffer = function (e, t) {
            for (var n = 0, r = 0, i = t; r < i.length; r++) {
                var o = i[r];
                e.buffers[n++].extras = {data: o}
            }
            var a = e.accessors;
            if (void 0 !== a) for (var s = 0, l = a; s < l.length; s++) {
                var u = l[s];
                u.extras = {typeCount: this.getAccessorTypeCount(u.type), divisor: 0}
            }
        }, t.getComponentTypeCount = function (e) {
            switch (e) {
                case 5120:
                case 5121:
                    return 1;
                case 5122:
                case 5123:
                    return 2;
                case 5124:
                case 5125:
                case 5126:
                    return 4;
                default:
                    throw new Error("Invalid component type.")
            }
        }, t.getAccessorTypeCount = function (e) {
            switch (e) {
                case"SCALAR":
                    return 1;
                case"VEC2":
                    return 2;
                case"VEC3":
                    return 3;
                case"VEC4":
                case"MAT2":
                    return 4;
                case"MAT3":
                    return 9;
                case"MAT4":
                    return 16;
                default:
                    throw new Error("Invalid accessor type.")
            }
        }, t.getMeshAttributeType = function (e) {
            switch (e) {
                case"POSITION":
                case"NORMAL":
                    return "VEC3";
                case"TEXCOORD_0":
                case"TEXCOORD_1":
                    return "VEC2";
                case"TANGENT":
                case"COLOR_0":
                case"COLOR_1":
                case"JOINTS_0":
                case"WEIGHTS_0":
                    return "VEC4";
                default:
                    return ""
            }
        }, t.prototype._setGLTF = function (e) {
            this._glTF = e
        }, t.prototype.uninitialize = function () {
            e.prototype.uninitialize.call(this), this._glTF = null
        }, t.prototype.createTypeArrayFromBufferView = function (e, t) {
            var n = this._glTF.buffers[e.buffer].extras.data, r = n.byteOffset + (e.byteOffset || 0);
            switch (t) {
                case 5120:
                    return new Int8Array(n.buffer, r, e.byteLength / Int8Array.BYTES_PER_ELEMENT);
                case 5121:
                    return new Uint8Array(n.buffer, r, e.byteLength / Uint8Array.BYTES_PER_ELEMENT);
                case 5122:
                    return new Int16Array(n.buffer, r, e.byteLength / Int16Array.BYTES_PER_ELEMENT);
                case 5123:
                    return new Uint16Array(n.buffer, r, e.byteLength / Uint16Array.BYTES_PER_ELEMENT);
                case 5124:
                    return new Int32Array(n.buffer, r, e.byteLength / Int32Array.BYTES_PER_ELEMENT);
                case 5125:
                    return new Uint32Array(n.buffer, r, e.byteLength / Uint32Array.BYTES_PER_ELEMENT);
                case 5126:
                    return new Float32Array(n.buffer, r, e.byteLength / Float32Array.BYTES_PER_ELEMENT);
                default:
                    throw new Error
            }
        }, t.prototype.createTypeArrayFromAccessor = function (e, t, r) {
            void 0 === t && (t = 0), void 0 === r && (r = 0), 0 === r && (r = e.count), t >= e.count && (console.warn("Overflow offset.", "offset: ", t, "total count", e.count), t = e.count - 1), r > e.count - t && (r = e.count - t);
            var i = e.extras.typeCount, o = i * r, a = this.getBufferView(e),
                s = this._glTF.buffers[a.buffer].extras.data,
                l = s.byteOffset + (a.byteOffset || 0) + (e.byteOffset || 0);
            switch (t > 0 && (l += t * i * n.getComponentTypeCount(e.componentType)), e.componentType) {
                case 5120:
                    return new Int8Array(s.buffer, l, o);
                case 5121:
                    return new Uint8Array(s.buffer, l, o);
                case 5122:
                    return new Int16Array(s.buffer, l, o);
                case 5123:
                    return new Uint16Array(s.buffer, l, o);
                case 5124:
                    return new Int32Array(s.buffer, l, o);
                case 5125:
                    return new Uint32Array(s.buffer, l, o);
                case 5126:
                    return new Float32Array(s.buffer, l, o);
                default:
                    throw new Error
            }
        }, t.prototype.getAccessorByteLength = function (e) {
            return e.extras.typeCount * n.getComponentTypeCount(e.componentType) * e.count
        }, t.prototype.getBufferOffset = function (e) {
            return (this.getBufferView(e).byteOffset || 0) + (e.byteOffset || 0)
        }, t.prototype.getBuffer = function (e) {
            var t = this.getBufferView(e);
            return this._glTF.buffers[t.buffer]
        }, t.prototype.getBufferView = function (e) {
            var t = e.bufferView;
            return this._glTF.bufferViews[void 0 !== t ? t : 0]
        }, t.prototype.getAccessor = function (e) {
            return this._glTF.accessors[e]
        }, t.prototype.getNode = function (e) {
            return this._glTF.nodes[e]
        }, Object.defineProperty(t.prototype, "glTF", {
            get: function () {
                return this._glTF
            }, set: function (e) {
                this._glTF !== e && this._setGLTF(e)
            }, enumerable: !0, configurable: !0
        }), c([a.serializedField], t.prototype, "glTF", null), t = n = c([Object(a.hideFlag)(16), Object(r.component)({
            type: "asset",
            isAbstract: !0
        })], t)
    }(r.Component);
    __reflect(h, "@egret/render/GLTFAsset");
    var f = function (e) {
        function t() {
            var t = null !== e && e.apply(this, arguments) || this;
            return t.glTFTexture = null, t._needUpdate = 7, t._image = null, t._sampler = null, t
        }

        return u(t, e), t.createGLTF = function (t) {
            void 0 === t.image && (t.image = {}), void 0 === t.sampler && (t.sampler = {});
            var n = t.sampler, r = n.wrapS, i = n.wrapT, o = n.magFilter, a = n.minFilter, s = t.source, l = t.width,
                u = t.height, c = t.premultiplyAlpha, p = t.flipY, d = t.anisotropy, h = t.format, f = t.type,
                m = t.unpackAlignment, _ = t.encoding, g = t.depth, v = t.layers, y = t.faces, b = t.levels,
                x = t.depthBuffer, T = void 0 === x || x, E = t.stencilBuffer, C = void 0 !== E && E,
                S = e.createGLTF.call(this), M = (S.images = [{}])[0];
            S.samplers = [{wrapS: r, wrapT: i, magFilter: o, minFilter: a}];
            S.textures = [{
                sampler: 0,
                source: 0,
                extensions: {
                    egret: {
                        width: l,
                        height: u,
                        premultiplyAlpha: c,
                        flipY: p,
                        anisotropy: d,
                        format: h,
                        type: f,
                        unpackAlignment: m,
                        encoding: _,
                        depth: g,
                        layers: v,
                        faces: y,
                        levels: b,
                        depthBuffer: T,
                        stencilBuffer: C
                    }
                }
            }];
            if (void 0 !== s) if (Array.isArray(s)) {
                if (s.length > 0) {
                    var A = 0;
                    S.buffers = [], S.bufferViews = [], M.bufferView = [];
                    for (var O = 0, w = s; O < w.length; O++) {
                        var R = w[O];
                        if (!ArrayBuffer.isView(R)) {
                            M.extras = {data: s.concat()};
                            break
                        }
                        S.buffers.push({byteLength: R.byteLength, extras: {data: R}}), S.bufferViews.push({
                            buffer: A,
                            byteLength: R.byteLength
                        }), M.bufferView.push(A++)
                    }
                }
            } else ArrayBuffer.isView(s) ? (S.buffers = [{
                byteLength: s.byteLength,
                extras: {data: s}
            }], S.bufferViews = [{buffer: 0, byteLength: s.byteLength}], M.bufferView = 0) : M.extras = {data: s};
            return S
        }, t.prototype._setGLTF = function (t) {
            e.prototype._setGLTF.call(this, t);
            var n = this.glTFTexture = t.textures[0], r = n.extensions.egret, i = n.source, o = !1, a = r.format;
            void 0 !== n.extras && (void 0 !== n.extras.currentSource && (i = n.extras.currentSource), void 0 !== n.extras.isCompressed && (o = n.extras.isCompressed), void 0 !== n.extras.internalFormat && (a = n.extras.internalFormat)), n.extras = {
                type: 3553,
                levels: 0,
                texture: null,
                frameBuffer: null,
                renderBuffer: null,
                currentSource: i,
                internalFormat: a,
                isCompressed: o
            };
            var s = this._image = t.images[i];
            if (this._sampler = t.samplers[n.sampler], void 0 !== s.extras) {
                var l = Array.isArray(s.extras.data) ? s.extras.data[0] : s.extras.data;
                r.width = l.width, r.height = l.height
            }
            this._formatLevelsAndSampler()
        }, t.prototype._disposeImageSource = function () {
            var e = this._image;
            if (null !== e && void 0 !== e.extras) if (Array.isArray(e.extras.data)) for (var t = 0, n = e.extras.data; t < n.length; t++) {
                n[t].src = ""
            } else e.extras.data.src = ""
        }, t.prototype._formatLevelsAndSampler = function () {
            var e = this.glTFTexture, t = this._sampler, n = e.extensions.egret.levels;
            this.isPowerOfTwo || (void 0 !== n && 1 !== n && (n = e.extensions.egret.levels = 1), t.wrapS = 33071, t.wrapT = 33071), void 0 === n || 1 === n ? 9987 === t.minFilter || 9986 === t.minFilter ? t.minFilter = 9729 : 9984 !== t.minFilter && 9985 !== t.minFilter || (t.minFilter = 9728) : 9729 === t.minFilter ? t.minFilter = 9987 : void 0 !== t.minFilter && 9728 !== t.minFilter || (t.minFilter = 9984)
        }, t.prototype.uninitialize = function () {
            e.prototype.uninitialize.call(this);
            this.glTFTexture = null, this._needUpdate = 7, this._image = null, this._sampler = null
        }, t.prototype.needUpdate = function (e) {
            this._needUpdate |= e
        }, t.prototype.update = function (e) {
            if (0 != (4 & e)) {
                var t = this.glTFTexture, n = t.extensions, r = t.extras, i = n.egret, o = i.levels, a = i.width,
                    s = i.height;
                0 === o && (r.levels = Math.log(Math.max(a, s)) * Math.LOG2E)
            }
            this._needUpdate &= ~e
        }, t.prototype.setFilter = function (e) {
            var t = this._sampler, n = this.glTFTexture.extensions.egret.levels;
            return t.magFilter = 0 === e ? 9729 : 9728, void 0 === n || 1 === n ? t.minFilter = 0 === e ? 9729 : 9728 : 0 === e ? t.minFilter = 9984 : 1 === e ? t.minFilter = 9985 : 2 === e && (t.minFilter = 9987), this._formatLevelsAndSampler(), this.needUpdate(7), this
        }, t.prototype.setRepeat = function (e) {
            var t = this._sampler;
            return t.wrapS = t.wrapT = e ? 10497 : 33071, this._formatLevelsAndSampler(), this.needUpdate(7), this
        }, t.prototype.setMipmap = function (e) {
            return this.glTFTexture.extensions.egret.levels = e ? 0 : 1, this._formatLevelsAndSampler(), this.needUpdate(4), this
        }, Object.defineProperty(t.prototype, "isPowerOfTwo", {
            get: function () {
                return i.MathUtil.isPowerOfTwo(this.width) && i.MathUtil.isPowerOfTwo(this.height)
            }, enumerable: !0, configurable: !0
        }), Object.defineProperty(t.prototype, "levels", {
            get: function () {
                this.update(4);
                var e = this.glTFTexture, t = e.extensions, n = e.extras;
                if (n.levels > 0) return n.levels;
                var r = t.egret.levels;
                if (void 0 === r) return 1;
                if (0 === r) throw new Error;
                return r
            }, enumerable: !0, configurable: !0
        }), Object.defineProperty(t.prototype, "format", {
            get: function () {
                var e = this.glTFTexture.extensions.egret.format;
                return void 0 !== e ? e : 6408
            }, enumerable: !0, configurable: !0
        }), Object.defineProperty(t.prototype, "width", {
            get: function () {
                return this.glTFTexture.extensions.egret.width
            }, enumerable: !0, configurable: !0
        }), Object.defineProperty(t.prototype, "height", {
            get: function () {
                return this.glTFTexture.extensions.egret.height
            }, enumerable: !0, configurable: !0
        }), Object.defineProperty(t.prototype, "sampler", {
            get: function () {
                return this._sampler
            }, enumerable: !0, configurable: !0
        }), t = c([Object(r.component)({isAbstract: !0})], t)
    }(h);
    __reflect(f, "@egret/render/BaseTexture");
    var m = function (e) {
        function t() {
            var t = null !== e && e.apply(this, arguments) || this;
            return t.glTFShader = null, t.customs = null, t
        }

        var n;
        return u(t, e), n = t, t.create = function (e) {
            var t;
            if (e instanceof n) {
                var r = e.glTF.extensions.KHR_techniques_webgl, i = r.techniques[0], o = Object.create(null);
                for (var a in this._parent = e, i.uniforms) o[a] = i.uniforms[a];
                t = {
                    extensions: {
                        KHR_techniques_webgl: {
                            shaders: r.shaders,
                            techniques: [{attributes: i.attributes, uniforms: o}]
                        }
                    }
                }
            } else t = e;
            return this.fromGLTF(t)
        }, t.prototype._uninitialize = function () {
            throw new Error("Method not implemented.")
        }, t.prototype._setGLTF = function (t) {
            e.prototype._setGLTF.call(this, t);
            this.glTFShader = t.extensions.KHR_techniques_webgl.shaders[0];
            var r = n._parent;
            null !== r && (r.customs && (this.customs = Object.assign(Object.create(null), r.customs)), r._defines && (this._defines = r._defines.concat()))
        }, t.prototype.uninitialize = function () {
            this._uninitialize(), e.prototype.uninitialize.call(this);
            this.glTFShader = null, this.customs = null, this._defines = void 0
        }, t.prototype.addDefine = function (e, t) {
            var n = this.customs = this.customs || Object.create(null);
            for (var r in t) n[r] = t[r];
            var i = this._defines = this._defines || [];
            return i.indexOf(e) < 0 && i.push(e), this
        }, t.prototype.addUniform = function (e, t, n) {
            return this._glTF.extensions.KHR_techniques_webgl.techniques[0].uniforms[e] = {type: t, value: n}, this
        }, t._parent = null, t = n = c([Object(r.component)({isAbstract: !1})], t)
    }(h);
    __reflect(m, "@egret/render/Shader");
    var _ = function (e) {
        function t() {
            var t = null !== e && e.apply(this, arguments) || this;
            return t.type = 1, t.location = 3, t.order = 0, t.index = 0, t.mask = 0, t.name = "", t.content = "", t
        }

        return u(t, e), t = c([Object(a.hideFlag)(16), Object(r.component)({isAbstract: !1})], t)
    }(r.Component);
    __reflect(_, "@egret/render/Define");
    var g = function (e) {
        function t() {
            var t = null !== e && e.apply(this, arguments) || this;
            return t._index = 0, t._mask = 2147483648, t._defines = {}, t._root = null, t
        }

        return u(t, e), t.prototype.getDefine = function (e, t, n, r, o) {
            var a = e + t, s = this._defines;
            if (a in s) return s[a];
            null === this._root && (this._root = i.EngineFactory.createGameEntity("Defines", {parent: i.Application.instance.sceneManager.globalScene.root.entity}));
            var l = i.EngineFactory.createGameEntity(e, {parent: this._root}).addComponent(_);
            return l.type = r, l.location = o, l.order = n, l.index = this._index, l.mask = this._mask, l.name = e, l.content = t, s[a] = l, this._mask >>>= 1, 0 === this._mask && (this._index++, this._mask = 2147483648), l
        }, t = c([Object(a.hideFlag)(28), Object(r.component)({isRemovable: !1, isAbstract: !1})], t)
    }(r.Component);
    __reflect(g, "@egret/render/DefineCollector");
    var v = function (e) {
        function t() {
            var t = null !== e && e.apply(this, arguments) || this;
            return t.definesMask = "", t.defines = [], t._indices = {}, t
        }

        var n;
        return u(t, e), n = t, t.linkDefine = function (e, t) {
            for (var n = [], r = {}, i = 0, o = e; i < o.length; i++) for (var a = 0, s = o[i]; a < s.length; a++) {
                0 != ((p = s[a]).location & t) && (p.name in r ? n[r[p.name]] = p : (r[p.name] = n.length, n.push(p)))
            }
            var l = "";
            n.sort(this.sortDefine);
            for (var u = 0, c = n; u < c.length; u++) {
                var p;
                switch ((p = c[u]).type) {
                    case 1:
                        l += "#define " + p.name + " \n";
                        break;
                    case 2:
                        l += "#define " + p.content + " \n";
                        break;
                    case 3:
                        l += "#define " + p.name + " " + p.content + " \n";
                        break;
                    case 4:
                        l += p.content + " \n"
                }
            }
            return l
        }, t.sortDefine = function (e, t) {
            if (0 !== e.order || 0 !== t.order) return e.order - t.order;
            var n = e.index - t.index;
            return 0 === n && (n = t.mask - e.mask), n
        }, t.prototype._update = function () {
            var e = this.defines, t = this._indices, r = 0, i = 0, o = 0, a = "";
            e.sort(n.sortDefine);
            for (var s = 0, l = e; s < l.length; s++) {
                var u = l[s];
                u.index !== i && (o < 0 && (o += 4294967295, o += 1), a += i + "x" + o.toString(16), i = u.index, o = 0), o |= u.mask, t[u.name] = r++
            }
            o < 0 && (o += 4294967295, o += 1), a += i + "x" + o.toString(16), this.definesMask = a
        }, t.prototype.uninitialize = function () {
            e.prototype.uninitialize.call(this), this.clear()
        }, t.prototype.serialize = function () {
            for (var e, t = o.Reflect.getQualifiedClassName(this.uuid), n = ((e = {uuid: this.uuid})[a.KEY_CLASS] = t, e.defines = [], e), r = 0, i = this.defines; r < i.length; r++) {
                var s = i[r];
                0 === s.content.length && n.defines.push(s.name)
            }
            return n
        }, t.prototype.deserialize = function (e) {
            if (void 0 !== e.defines) for (var t = 0, n = e.defines; t < n.length; t++) {
                var r = n[t];
                "" !== r && this.addDefine(r)
            }
            return this
        }, t.prototype.clear = function () {
            this.definesMask = "";
            var e = this.defines, t = this._indices;
            for (var n in e.length = 0, t) delete t[n]
        }, t.prototype.copy = function (e) {
            if (e !== this) {
                var t = this.defines, n = this._indices;
                for (var r in t.length = 0, n) delete n[r];
                this.definesMask = e.definesMask;
                for (var i = 0, o = e.defines; i < o.length; i++) {
                    var a = o[i];
                    t.push(a)
                }
                for (var r in e._indices) n[r] = e._indices[r]
            }
        }, t.prototype.addDefine = function (e, t, n, r, o, a) {
            void 0 === t && (t = NaN), void 0 === n && (n = ""), void 0 === r && (r = 0), void 0 === o && (o = 1), void 0 === a && (a = 3);
            var s = this.defines, l = this._indices;
            if (0 === n.length && t == t && (n = t.toString(), o = 3), e in l) {
                var u = this.defines[l[e]];
                if (u.content === n) return u;
                this.removeDefine(e, !1)
            }
            var c = i.Application.instance.globalEntity.getComponent(g).getDefine(e, n, r, o, a);
            if (s.indexOf(c) < 0) {
                var p = s.length;
                s.push(c), l[e] = p, this._update()
            } else console.error("The define has been added.", e);
            return c
        }, t.prototype.removeDefine = function (e, t) {
            void 0 === t && (t = !0);
            var n = this.defines, r = this._indices;
            if (e in r) {
                var i = r[e];
                return n.splice(i, 1), delete r[e], t && this._update(), !0
            }
            return !1
        }, t = n = c([Object(a.hideFlag)(28), Object(r.component)({isAbstract: !1})], t)
    }(r.Component);
    __reflect(v, "@egret/render/Defines");
    var y = {
        alphamap_fragment: "#ifdef USE_ALPHAMAP\n\n diffuseColor.a *= texture2D( alphaMap, vUv ).g;\n\n#endif",
        alphamap_pars_fragment: "#ifdef USE_ALPHAMAP\n\n uniform sampler2D alphaMap;\n\n#endif",
        alphatest_fragment: "#ifdef ALPHATEST\n\n if ( diffuseColor.a < ALPHATEST ) discard;\n\n#endif",
        aomap_fragment: "#ifdef USE_AOMAP\n\n // reads channel R, compatible with a combined OcclusionRoughnessMetallic (RGB) texture\n    float ambientOcclusion = ( texture2D( aoMap, vUv2 ).r - 1.0 ) * aoMapIntensity + 1.0;\n\n    reflectedLight.indirectDiffuse *= ambientOcclusion;\n\n    #if defined( USE_ENVMAP ) && defined( STANDARD )\n\n        float dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n\n        reflectedLight.indirectSpecular *= computeSpecularOcclusion( dotNV, ambientOcclusion, material.specularRoughness );\n\n    #endif\n\n#endif",
        aomap_pars_fragment: "#ifdef USE_AOMAP\n\n uniform sampler2D aoMap;\n    uniform float aoMapIntensity;\n\n#endif",
        beginnormal_vertex: "vec3 objectNormal = vec3( normal );\n\n#ifdef USE_TANGENT\n\n vec3 objectTangent = vec3( tangent.xyz );\n\n#endif",
        begin_vertex: "vec3 transformed = vec3( position );",
        bsdfs: '// Analytical approximation of the DFG LUT, one half of the\n// split-sum approximation used in indirect specular lighting.\n// via \'environmentBRDF\' from "Physically Based Shading on Mobile"\n// https://www.unrealengine.com/blog/physically-based-shading-on-mobile - environmentBRDF for GGX on mobile\nvec2 integrateSpecularBRDF( const in float dotNV, const in float roughness ) {\n const vec4 c0 = vec4( - 1, - 0.0275, - 0.572, 0.022 );\n\n    const vec4 c1 = vec4( 1, 0.0425, 1.04, - 0.04 );\n\n    vec4 r = roughness * c0 + c1;\n\n    float a004 = min( r.x * r.x, exp2( - 9.28 * dotNV ) ) * r.x + r.y;\n\n    return vec2( -1.04, 1.04 ) * a004 + r.zw;\n\n}\n\nfloat punctualLightIntensityToIrradianceFactor( const in float lightDistance, const in float cutoffDistance, const in float decayExponent ) {\n\n#if defined ( PHYSICALLY_CORRECT_LIGHTS )\n\n    // based upon Frostbite 3 Moving to Physically-based Rendering\n    // page 32, equation 26: E[window1]\n    // https://seblagarde.files.wordpress.com/2015/07/course_notes_moving_frostbite_to_pbr_v32.pdf\n    // this is intended to be used on spot and point lights who are represented as luminous intensity\n    // but who must be converted to luminous irradiance for surface lighting calculation\n    float distanceFalloff = 1.0 / max( pow( lightDistance, decayExponent ), 0.01 );\n\n    if( cutoffDistance > 0.0 ) {\n\n        distanceFalloff *= pow2( saturate( 1.0 - pow4( lightDistance / cutoffDistance ) ) );\n\n    }\n\n    return distanceFalloff;\n\n#else\n\n    if( cutoffDistance > 0.0 && decayExponent > 0.0 ) {\n\n        return pow( saturate( -lightDistance / cutoffDistance + 1.0 ), decayExponent );\n\n    }\n\n    return 1.0;\n\n#endif\n\n}\n\nvec3 BRDF_Diffuse_Lambert( const in vec3 diffuseColor ) {\n\n    return RECIPROCAL_PI * diffuseColor;\n\n} // validated\n\nvec3 F_Schlick( const in vec3 specularColor, const in float dotLH ) {\n\n    // Original approximation by Christophe Schlick \'94\n    // float fresnel = pow( 1.0 - dotLH, 5.0 );\n\n    // Optimized variant (presented by Epic at SIGGRAPH \'13)\n    // https://cdn2.unrealengine.com/Resources/files/2013SiggraphPresentationsNotes-26915738.pdf\n    float fresnel = exp2( ( -5.55473 * dotLH - 6.98316 ) * dotLH );\n\n    return ( 1.0 - specularColor ) * fresnel + specularColor;\n\n} // validated\n\nvec3 F_Schlick_RoughnessDependent( const in vec3 F0, const in float dotNV, const in float roughness ) {\n\n    // See F_Schlick\n    float fresnel = exp2( ( -5.55473 * dotNV - 6.98316 ) * dotNV );\n    vec3 Fr = max( vec3( 1.0 - roughness ), F0 ) - F0;\n\n    return Fr * fresnel + F0;\n\n}\n\n\n// Microfacet Models for Refraction through Rough Surfaces - equation (34)\n// http://graphicrants.blogspot.com/2013/08/specular-brdf-reference.html\n// alpha is "roughness squared" in Disneys reparameterization\nfloat G_GGX_Smith( const in float alpha, const in float dotNL, const in float dotNV ) {\n\n    // geometry term (normalized) = G(l)G(v) / 4(nl)(nv)\n    // also see #12151\n\n    float a2 = pow2( alpha );\n\n    float gl = dotNL + sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );\n    float gv = dotNV + sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );\n\n    return 1.0 / ( gl * gv );\n\n} // validated\n\n// Moving Frostbite to Physically Based Rendering 3.0 - page 12, listing 2\n// https://seblagarde.files.wordpress.com/2015/07/course_notes_moving_frostbite_to_pbr_v32.pdf\nfloat G_GGX_SmithCorrelated( const in float alpha, const in float dotNL, const in float dotNV ) {\n\n    float a2 = pow2( alpha );\n\n    // dotNL and dotNV are explicitly swapped. This is not a mistake.\n    float gv = dotNL * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );\n    float gl = dotNV * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );\n\n    return 0.5 / max( gv + gl, EPSILON );\n\n}\n\n// Microfacet Models for Refraction through Rough Surfaces - equation (33)\n// http://graphicrants.blogspot.com/2013/08/specular-brdf-reference.html\n// alpha is "roughness squared" in Disneys reparameterization\nfloat D_GGX( const in float alpha, const in float dotNH ) {\n\n    float a2 = pow2( alpha );\n\n    float denom = pow2( dotNH ) * ( a2 - 1.0 ) + 1.0; // avoid alpha = 0 with dotNH = 1\n\n    return RECIPROCAL_PI * a2 / pow2( denom );\n\n}\n\n// GGX Distribution, Schlick Fresnel, GGX-Smith Visibility\nvec3 BRDF_Specular_GGX( const in IncidentLight incidentLight, const in vec3 viewDir, const in vec3 normal, const in vec3 specularColor, const in float roughness ) {\n\n    float alpha = pow2( roughness ); // UE4\'s roughness\n\n    vec3 halfDir = normalize( incidentLight.direction + viewDir );\n\n    float dotNL = saturate( dot( normal, incidentLight.direction ) );\n    float dotNV = saturate( dot( normal, viewDir ) );\n    float dotNH = saturate( dot( normal, halfDir ) );\n    float dotLH = saturate( dot( incidentLight.direction, halfDir ) );\n\n    vec3 F = F_Schlick( specularColor, dotLH );\n\n    float G = G_GGX_SmithCorrelated( alpha, dotNL, dotNV );\n\n    float D = D_GGX( alpha, dotNH );\n\n    return F * ( G * D );\n\n} // validated\n\n// Rect Area Light\n\n// Real-Time Polygonal-Light Shading with Linearly Transformed Cosines\n// by Eric Heitz, Jonathan Dupuy, Stephen Hill and David Neubelt\n// code: https://github.com/selfshadow/ltc_code/\n\nvec2 LTC_Uv( const in vec3 N, const in vec3 V, const in float roughness ) {\n\n    const float LUT_SIZE  = 64.0;\n    const float LUT_SCALE = ( LUT_SIZE - 1.0 ) / LUT_SIZE;\n    const float LUT_BIAS  = 0.5 / LUT_SIZE;\n\n    float dotNV = saturate( dot( N, V ) );\n\n    // texture parameterized by sqrt( GGX alpha ) and sqrt( 1 - cos( theta ) )\n    vec2 uv = vec2( roughness, sqrt( 1.0 - dotNV ) );\n\n    uv = uv * LUT_SCALE + LUT_BIAS;\n\n    return uv;\n\n}\n\nfloat LTC_ClippedSphereFormFactor( const in vec3 f ) {\n\n    // Real-Time Area Lighting: a Journey from Research to Production (p.102)\n    // An approximation of the form factor of a horizon-clipped rectangle.\n\n    float l = length( f );\n\n    return max( ( l * l + f.z ) / ( l + 1.0 ), 0.0 );\n\n}\n\nvec3 LTC_EdgeVectorFormFactor( const in vec3 v1, const in vec3 v2 ) {\n\n    float x = dot( v1, v2 );\n\n    float y = abs( x );\n\n    // rational polynomial approximation to theta / sin( theta ) / 2PI\n    float a = 0.8543985 + ( 0.4965155 + 0.0145206 * y ) * y;\n    float b = 3.4175940 + ( 4.1616724 + y ) * y;\n    float v = a / b;\n\n    float theta_sintheta = ( x > 0.0 ) ? v : 0.5 * inversesqrt( max( 1.0 - x * x, 1e-7 ) ) - v;\n\n    return cross( v1, v2 ) * theta_sintheta;\n\n}\n\nvec3 LTC_Evaluate( const in vec3 N, const in vec3 V, const in vec3 P, const in mat3 mInv, const in vec3 rectCoords[ 4 ] ) {\n\n    // bail if point is on back side of plane of light\n    // assumes ccw winding order of light vertices\n    vec3 v1 = rectCoords[ 1 ] - rectCoords[ 0 ];\n    vec3 v2 = rectCoords[ 3 ] - rectCoords[ 0 ];\n    vec3 lightNormal = cross( v1, v2 );\n\n    if( dot( lightNormal, P - rectCoords[ 0 ] ) < 0.0 ) return vec3( 0.0 );\n\n    // construct orthonormal basis around N\n    vec3 T1, T2;\n    T1 = normalize( V - N * dot( V, N ) );\n    T2 = - cross( N, T1 ); // negated from paper; possibly due to a different handedness of world coordinate system\n\n    // compute transform\n    mat3 mat = mInv * transposeMat3( mat3( T1, T2, N ) );\n\n    // transform rect\n    vec3 coords[ 4 ];\n    coords[ 0 ] = mat * ( rectCoords[ 0 ] - P );\n    coords[ 1 ] = mat * ( rectCoords[ 1 ] - P );\n    coords[ 2 ] = mat * ( rectCoords[ 2 ] - P );\n    coords[ 3 ] = mat * ( rectCoords[ 3 ] - P );\n\n    // project rect onto sphere\n    coords[ 0 ] = normalize( coords[ 0 ] );\n    coords[ 1 ] = normalize( coords[ 1 ] );\n    coords[ 2 ] = normalize( coords[ 2 ] );\n    coords[ 3 ] = normalize( coords[ 3 ] );\n\n    // calculate vector form factor\n    vec3 vectorFormFactor = vec3( 0.0 );\n    vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 0 ], coords[ 1 ] );\n    vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 1 ], coords[ 2 ] );\n    vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 2 ], coords[ 3 ] );\n    vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 3 ], coords[ 0 ] );\n\n    // adjust for horizon clipping\n    float result = LTC_ClippedSphereFormFactor( vectorFormFactor );\n\n/*\n    // alternate method of adjusting for horizon clipping (see referece)\n    // refactoring required\n    float len = length( vectorFormFactor );\n    float z = vectorFormFactor.z / len;\n\n    const float LUT_SIZE  = 64.0;\n    const float LUT_SCALE = ( LUT_SIZE - 1.0 ) / LUT_SIZE;\n    const float LUT_BIAS  = 0.5 / LUT_SIZE;\n\n    // tabulated horizon-clipped sphere, apparently...\n    vec2 uv = vec2( z * 0.5 + 0.5, len );\n    uv = uv * LUT_SCALE + LUT_BIAS;\n\n    float scale = texture2D( ltc_2, uv ).w;\n\n    float result = len * scale;\n*/\n\n    return vec3( result );\n\n}\n\n// End Rect Area Light\n\n// ref: https://www.unrealengine.com/blog/physically-based-shading-on-mobile - environmentBRDF for GGX on mobile\nvec3 BRDF_Specular_GGX_Environment( const in vec3 viewDir, const in vec3 normal, const in vec3 specularColor, const in float roughness ) {\n\n    float dotNV = saturate( dot( normal, viewDir ) );\n\n    vec2 brdf = integrateSpecularBRDF( dotNV, roughness );\n\n    return specularColor * brdf.x + brdf.y;\n\n} // validated\n\n// Fdez-Agera\'s "Multiple-Scattering Microfacet Model for Real-Time Image Based Lighting"\n// Approximates multiscattering in order to preserve energy.\n// http://www.jcgt.org/published/0008/01/03/\nvoid BRDF_Specular_Multiscattering_Environment( const in GeometricContext geometry, const in vec3 specularColor, const in float roughness, inout vec3 singleScatter, inout vec3 multiScatter ) {\n\n    float dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n\n    vec3 F = F_Schlick_RoughnessDependent( specularColor, dotNV, roughness );\n    vec2 brdf = integrateSpecularBRDF( dotNV, roughness );\n    vec3 FssEss = F * brdf.x + brdf.y;\n\n    float Ess = brdf.x + brdf.y;\n    float Ems = 1.0 - Ess;\n\n    vec3 Favg = specularColor + ( 1.0 - specularColor ) * 0.047619; // 1/21\n    vec3 Fms = FssEss * Favg / ( 1.0 - Ems * Favg );\n\n    singleScatter += FssEss;\n    multiScatter += Fms * Ems;\n\n}\n\nfloat G_BlinnPhong_Implicit( /* const in float dotNL, const in float dotNV */ ) {\n\n    // geometry term is (n dot l)(n dot v) / 4(n dot l)(n dot v)\n    return 0.25;\n\n}\n\nfloat D_BlinnPhong( const in float shininess, const in float dotNH ) {\n\n    return RECIPROCAL_PI * ( shininess * 0.5 + 1.0 ) * pow( dotNH, shininess );\n\n}\n\nvec3 BRDF_Specular_BlinnPhong( const in IncidentLight incidentLight, const in GeometricContext geometry, const in vec3 specularColor, const in float shininess ) {\n\n    vec3 halfDir = normalize( incidentLight.direction + geometry.viewDir );\n\n    //float dotNL = saturate( dot( geometry.normal, incidentLight.direction ) );\n    //float dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n    float dotNH = saturate( dot( geometry.normal, halfDir ) );\n    float dotLH = saturate( dot( incidentLight.direction, halfDir ) );\n\n    vec3 F = F_Schlick( specularColor, dotLH );\n\n    float G = G_BlinnPhong_Implicit( /* dotNL, dotNV */ );\n\n    float D = D_BlinnPhong( shininess, dotNH );\n\n    return F * ( G * D );\n\n} // validated\n\n// source: http://simonstechblog.blogspot.ca/2011/12/microfacet-brdf.html\nfloat GGXRoughnessToBlinnExponent( const in float ggxRoughness ) {\n    return ( 2.0 / pow2( ggxRoughness + 0.0001 ) - 2.0 );\n}\n\nfloat BlinnExponentToGGXRoughness( const in float blinnExponent ) {\n    return sqrt( 2.0 / ( blinnExponent + 2.0 ) );\n}\n\n#if defined( USE_SHEEN )\n\n// https://github.com/google/filament/blob/master/shaders/src/brdf.fs#L94\nfloat D_Charlie(float roughness, float NoH) {\n    // Estevez and Kulla 2017, "Production Friendly Microfacet Sheen BRDF"\n    float invAlpha  = 1.0 / roughness;\n    float cos2h = NoH * NoH;\n    float sin2h = max(1.0 - cos2h, 0.0078125); // 2^(-14/2), so sin2h^2 > 0 in fp16\n    return (2.0 + invAlpha) * pow(sin2h, invAlpha * 0.5) / (2.0 * PI);\n}\n\n// https://github.com/google/filament/blob/master/shaders/src/brdf.fs#L136\nfloat V_Neubelt(float NoV, float NoL) {\n    // Neubelt and Pettineo 2013, "Crafting a Next-gen Material Pipeline for The Order: 1886"\n    return saturate(1.0 / (4.0 * (NoL + NoV - NoL * NoV)));\n}\n\nvec3 BRDF_Specular_Sheen( const in float roughness, const in vec3 L, const in GeometricContext geometry, vec3 specularColor ) {\n\n    vec3 N = geometry.normal;\n    vec3 V = geometry.viewDir;\n\n    vec3 H = normalize( V + L );\n    float dotNH = saturate( dot( N, H ) );\n\n    return specularColor * D_Charlie( roughness, dotNH ) * V_Neubelt( dot(N, V), dot(N, L) );\n\n}\n\n#endif',
        bumpMap_pars_frag: "//TODO three.js\n#ifdef USE_BUMPMAP\n\n uniform sampler2D bumpMap;\n    uniform float bumpScale;\n\n    // Derivative maps - bump mapping unparametrized surfaces by Morten Mikkelsen\n    // http://mmikkelsen3d.blogspot.sk/2011/07/derivative-maps.html\n\n    // Evaluate the derivative of the height w.r.t. screen-space using forward differencing (listing 2)\n\n    vec2 dHdxy_fwd(vec2 uv) {\n\n        vec2 dSTdx = dFdx( uv );\n        vec2 dSTdy = dFdy( uv );\n\n        float Hll = bumpScale * texture2D( bumpMap, uv ).x;\n        float dBx = bumpScale * texture2D( bumpMap, uv + dSTdx ).x - Hll;\n        float dBy = bumpScale * texture2D( bumpMap, uv + dSTdy ).x - Hll;\n\n        return vec2( dBx, dBy );\n\n    }\n\n    vec3 perturbNormalArb( vec3 surf_pos, vec3 surf_norm, vec2 dHdxy) {\n\n        vec3 vSigmaX = dFdx( surf_pos );\n        vec3 vSigmaY = dFdy( surf_pos );\n        vec3 vN = surf_norm; // normalized\n\n        vec3 R1 = cross( vSigmaY, vN );\n        vec3 R2 = cross( vN, vSigmaX );\n\n        float fDet = dot( vSigmaX, R1 );\n\n        vec3 vGrad = sign( fDet ) * ( dHdxy.x * R1 + dHdxy.y * R2 );\n        return normalize( abs( fDet ) * surf_norm - vGrad );\n\n    }\n\n#endif",
        bumpmap_pars_fragment: "#ifdef USE_BUMPMAP\n\n uniform sampler2D bumpMap;\n    uniform float bumpScale;\n\n    // Bump Mapping Unparametrized Surfaces on the GPU by Morten S. Mikkelsen\n    // http://api.unrealengine.com/attachments/Engine/Rendering/LightingAndShadows/BumpMappingWithoutTangentSpace/mm_sfgrad_bump.pdf\n\n    // Evaluate the derivative of the height w.r.t. screen-space using forward differencing (listing 2)\n\n    vec2 dHdxy_fwd() {\n\n        vec2 dSTdx = dFdx( vUv );\n        vec2 dSTdy = dFdy( vUv );\n\n        float Hll = bumpScale * texture2D( bumpMap, vUv ).x;\n        float dBx = bumpScale * texture2D( bumpMap, vUv + dSTdx ).x - Hll;\n        float dBy = bumpScale * texture2D( bumpMap, vUv + dSTdy ).x - Hll;\n\n        return vec2( dBx, dBy );\n\n    }\n\n    vec3 perturbNormalArb( vec3 surf_pos, vec3 surf_norm, vec2 dHdxy ) {\n\n        // Workaround for Adreno 3XX dFd*( vec3 ) bug. See #9988\n\n        vec3 vSigmaX = vec3( dFdx( surf_pos.x ), dFdx( surf_pos.y ), dFdx( surf_pos.z ) );\n        vec3 vSigmaY = vec3( dFdy( surf_pos.x ), dFdy( surf_pos.y ), dFdy( surf_pos.z ) );\n        vec3 vN = surf_norm;        // normalized\n\n        vec3 R1 = cross( vSigmaY, vN );\n        vec3 R2 = cross( vN, vSigmaX );\n\n        float fDet = dot( vSigmaX, R1 );\n\n        fDet *= ( float( gl_FrontFacing ) * 2.0 - 1.0 );\n\n        vec3 vGrad = sign( fDet ) * ( dHdxy.x * R1 + dHdxy.y * R2 );\n        return normalize( abs( fDet ) * surf_norm - vGrad );\n\n    }\n\n#endif",
        clearcoat_normalmap_pars_fragment: "#ifdef USE_CLEARCOAT_NORMALMAP\n\n uniform sampler2D clearcoatNormalMap;\n    uniform vec2 clearcoatNormalScale;\n\n#endif",
        clearcoat_normal_fragment_begin: "#ifdef CLEARCOAT\n\n vec3 clearcoatNormal = geometryNormal;\n\n#endif",
        clearcoat_normal_fragment_maps: "#ifdef USE_CLEARCOAT_NORMALMAP\n\n #ifdef USE_TANGENT\n\n        mat3 vTBN = mat3( tangent, bitangent, clearcoatNormal );\n        vec3 mapN = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;\n        mapN.xy = clearcoatNormalScale * mapN.xy;\n        clearcoatNormal = normalize( vTBN * mapN );\n\n    #else\n\n        clearcoatNormal = perturbNormal2Arb( - vViewPosition, clearcoatNormal, clearcoatNormalScale, clearcoatNormalMap );\n\n    #endif\n\n#endif",
        clipping_planes_fragment: "#if NUM_CLIPPING_PLANES > 0\n\n vec4 plane;\n\n    #pragma unroll_loop\n    for ( int i = 0; i < UNION_CLIPPING_PLANES; i ++ ) {\n\n        plane = clippingPlanes[ i ];\n        if ( dot( vViewPosition, plane.xyz ) > plane.w ) discard;\n\n    }\n    // #end unroll_loop\n\n    #if UNION_CLIPPING_PLANES < NUM_CLIPPING_PLANES\n\n        bool clipped = true;\n\n        #pragma unroll_loop\n        for ( int i = UNION_CLIPPING_PLANES; i < NUM_CLIPPING_PLANES; i ++ ) {\n\n            plane = clippingPlanes[ i ];\n            clipped = ( dot( vViewPosition, plane.xyz ) > plane.w ) && clipped;\n\n        }\n        // #end unroll_loop\n\n        if ( clipped ) discard;\n\n    #endif\n\n#endif",
        clipping_planes_pars_fragment: "#if NUM_CLIPPING_PLANES > 0\n\n #if ! defined( STANDARD ) && ! defined( PHONG ) && ! defined( MATCAP )\n        varying vec3 vViewPosition;\n    #endif\n\n    uniform vec4 clippingPlanes[ NUM_CLIPPING_PLANES ];\n\n#endif",
        clipping_planes_pars_vertex: "#if NUM_CLIPPING_PLANES > 0 && ! defined( STANDARD ) && ! defined( PHONG ) && ! defined( MATCAP )\n varying vec3 vViewPosition;\n#endif",
        clipping_planes_vertex: "#if NUM_CLIPPING_PLANES > 0 && ! defined( STANDARD ) && ! defined( PHONG ) && ! defined( MATCAP )\n vViewPosition = - mvPosition.xyz;\n#endif",
        color_fragment: "#ifdef USE_COLOR\n\n diffuseColor.rgb *= vColor;\n\n#endif",
        color_pars_fragment: "#ifdef USE_COLOR\n\n varying vec3 vColor;\n\n#endif",
        color_pars_vertex: "#ifdef USE_COLOR\n\n varying vec3 vColor;\n\n#endif",
        color_vertex: "#ifdef USE_COLOR\n\n vColor.xyz = color.xyz;\n\n#endif",
        common: "#define PI 3.14159265359\n#define PI2 6.28318530718\n#define PI_HALF 1.5707963267949\n#define RECIPROCAL_PI 0.31830988618\n#define RECIPROCAL_PI2 0.15915494\n#define LOG2 1.442695\n#define EPSILON 1e-6\n\n#define saturate(a) clamp( a, 0.0, 1.0 )\n#define whiteComplement(a) ( 1.0 - saturate( a ) )\n\nfloat pow2( const in float x ) { return x*x; }\nfloat pow3( const in float x ) { return x*x*x; }\nfloat pow4( const in float x ) { float x2 = x*x; return x2*x2; }\nfloat average( const in vec3 color ) { return dot( color, vec3( 0.3333 ) ); }\n// expects values in the range of [0,1]x[0,1], returns values in the [0,1] range.\n// do not collapse into a single function per: http://byteblacksmith.com/improvements-to-the-canonical-one-liner-glsl-rand-for-opengl-es-2-0/\nhighp float rand( const in vec2 uv ) {\n const highp float a = 12.9898, b = 78.233, c = 43758.5453;\n    highp float dt = dot( uv.xy, vec2( a,b ) ), sn = mod( dt, PI );\n    return fract(sin(sn) * c);\n}\n\n#ifdef HIGH_PRECISION\n    float precisionSafeLength( vec3 v ) { return length( v ); }\n#else\n    float max3( vec3 v ) { return max( max( v.x, v.y ), v.z ); }\n    float precisionSafeLength( vec3 v ) {\n        float maxComponent = max3( abs( v ) );\n        return length( v / maxComponent ) * maxComponent;\n    }\n#endif\n\nstruct IncidentLight {\n    vec3 color;\n    vec3 direction;\n    bool visible;\n};\n\nstruct ReflectedLight {\n    vec3 directDiffuse;\n    vec3 directSpecular;\n    vec3 indirectDiffuse;\n    vec3 indirectSpecular;\n};\n\nstruct GeometricContext {\n    vec3 position;\n    vec3 normal;\n    vec3 viewDir;\n#ifdef CLEARCOAT\n    vec3 clearcoatNormal;\n#endif\n};\n\nvec3 transformDirection( in vec3 dir, in mat4 matrix ) {\n\n    return normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );\n\n}\n\n// http://en.wikibooks.org/wiki/GLSL_Programming/Applying_Matrix_Transformations\nvec3 inverseTransformDirection( in vec3 dir, in mat4 matrix ) {\n\n    return normalize( ( vec4( dir, 0.0 ) * matrix ).xyz );\n\n}\n\nvec3 projectOnPlane(in vec3 point, in vec3 pointOnPlane, in vec3 planeNormal ) {\n\n    float distance = dot( planeNormal, point - pointOnPlane );\n\n    return - distance * planeNormal + point;\n\n}\n\nfloat sideOfPlane( in vec3 point, in vec3 pointOnPlane, in vec3 planeNormal ) {\n\n    return sign( dot( point - pointOnPlane, planeNormal ) );\n\n}\n\nvec3 linePlaneIntersect( in vec3 pointOnLine, in vec3 lineDirection, in vec3 pointOnPlane, in vec3 planeNormal ) {\n\n    return lineDirection * ( dot( planeNormal, pointOnPlane - pointOnLine ) / dot( planeNormal, lineDirection ) ) + pointOnLine;\n\n}\n\nmat3 transposeMat3( const in mat3 m ) {\n\n    mat3 tmp;\n\n    tmp[ 0 ] = vec3( m[ 0 ].x, m[ 1 ].x, m[ 2 ].x );\n    tmp[ 1 ] = vec3( m[ 0 ].y, m[ 1 ].y, m[ 2 ].y );\n    tmp[ 2 ] = vec3( m[ 0 ].z, m[ 1 ].z, m[ 2 ].z );\n\n    return tmp;\n\n}\n\nmat3 inverseMat3(const mat4 inMatrix){\n    float a00=inMatrix[0][0],a01=inMatrix[0][1],a02=inMatrix[0][2];\n    float a10=inMatrix[1][0],a11=inMatrix[1][1],a12=inMatrix[1][2];\n    float a20=inMatrix[2][0],a21=inMatrix[2][1],a22=inMatrix[2][2];\n    \n    float b01=a22*a11-a12*a21;\n    float b11=-a22*a10+a12*a20;\n    float b21=a21*a10-a11*a20;\n    \n    float det=a00*b01+a01*b11+a02*b21;\n    \n    return mat3(b01,(-a22*a01+a02*a21),(a12*a01-a02*a11),\n                b11,(a22*a00-a02*a20),(-a12*a00+a02*a10),\n                b21,(-a21*a00+a01*a20),(a11*a00-a01*a10))/det;\n}\n\n// https://en.wikipedia.org/wiki/Relative_luminance\nfloat linearToRelativeLuminance( const in vec3 color ) {\n\n    vec3 weights = vec3( 0.2126, 0.7152, 0.0722 );\n\n    return dot( weights, color.rgb );\n\n}",
        common_frag_def: "uniform mat4 viewMatrix;\nuniform vec3 cameraPosition;\n\n//egret",
        common_vert_def: "//modified by egret\n#ifdef USE_INSTANCED\n attribute vec4 modelMatrix0;\n    attribute vec4 modelMatrix1;\n    attribute vec4 modelMatrix2;\n    attribute vec4 modelMatrix3;\n    attribute vec4 modelViewMatrix0;    \n    attribute vec4 modelViewMatrix1;    \n    attribute vec4 modelViewMatrix2;    \n    attribute vec4 modelViewMatrix3;    \n#else\n    uniform mat4 modelMatrix;\n    uniform mat4 modelViewMatrix;\n#endif\nuniform mat4 projectionMatrix;\nuniform mat4 viewMatrix;\n#ifndef USE_INSTANCED\n    uniform mat3 normalMatrix;\n#endif\nuniform vec3 cameraPosition;\n\nattribute vec3 position;\nattribute vec3 normal;\nattribute vec2 uv;\n\n\n\n#ifdef USE_COLOR\n\n    attribute vec3 color;\n#endif\n#ifdef USE_MORPHTARGETS\n    attribute vec3 morphTarget0;\n    attribute vec3 morphTarget1;\n    attribute vec3 morphTarget2;\n    attribute vec3 morphTarget3;\n    #ifdef USE_MORPHNORMALS\n        attribute vec3 morphNormal0;\n        attribute vec3 morphNormal1;\n        attribute vec3 morphNormal2;\n        attribute vec3 morphNormal3;\n    #else\n        attribute vec3 morphTarget4;\n        attribute vec3 morphTarget5;\n        attribute vec3 morphTarget6;\n        attribute vec3 morphTarget7;\n    #endif\n#endif\n#ifdef USE_SKINNING\n    attribute vec4 skinIndex;\n    attribute vec4 skinWeight;\n#endif",
        cube_uv_reflection_fragment: "#ifdef ENVMAP_TYPE_CUBE_UV\n\n#define cubeUV_textureSize (1024.0)\n\nint getFaceFromDirection(vec3 direction) {\n vec3 absDirection = abs(direction);\n    int face = -1;\n    if( absDirection.x > absDirection.z ) {\n        if(absDirection.x > absDirection.y )\n            face = direction.x > 0.0 ? 0 : 3;\n        else\n            face = direction.y > 0.0 ? 1 : 4;\n    }\n    else {\n        if(absDirection.z > absDirection.y )\n            face = direction.z > 0.0 ? 2 : 5;\n        else\n            face = direction.y > 0.0 ? 1 : 4;\n    }\n    return face;\n}\n#define cubeUV_maxLods1  (log2(cubeUV_textureSize*0.25) - 1.0)\n#define cubeUV_rangeClamp (exp2((6.0 - 1.0) * 2.0))\n\nvec2 MipLevelInfo( vec3 vec, float roughnessLevel, float roughness ) {\n    float scale = exp2(cubeUV_maxLods1 - roughnessLevel);\n    float dxRoughness = dFdx(roughness);\n    float dyRoughness = dFdy(roughness);\n    vec3 dx = dFdx( vec * scale * dxRoughness );\n    vec3 dy = dFdy( vec * scale * dyRoughness );\n    float d = max( dot( dx, dx ), dot( dy, dy ) );\n    // Clamp the value to the max mip level counts. hard coded to 6 mips\n    d = clamp(d, 1.0, cubeUV_rangeClamp);\n    float mipLevel = 0.5 * log2(d);\n    return vec2(floor(mipLevel), fract(mipLevel));\n}\n\n#define cubeUV_maxLods2 (log2(cubeUV_textureSize*0.25) - 2.0)\n#define cubeUV_rcpTextureSize (1.0 / cubeUV_textureSize)\n\nvec2 getCubeUV(vec3 direction, float roughnessLevel, float mipLevel) {\n    mipLevel = roughnessLevel > cubeUV_maxLods2 - 3.0 ? 0.0 : mipLevel;\n    float a = 16.0 * cubeUV_rcpTextureSize;\n\n    vec2 exp2_packed = exp2( vec2( roughnessLevel, mipLevel ) );\n    vec2 rcp_exp2_packed = vec2( 1.0 ) / exp2_packed;\n    // float powScale = exp2(roughnessLevel + mipLevel);\n    float powScale = exp2_packed.x * exp2_packed.y;\n    // float scale =  1.0 / exp2(roughnessLevel + 2.0 + mipLevel);\n    float scale = rcp_exp2_packed.x * rcp_exp2_packed.y * 0.25;\n    // float mipOffset = 0.75*(1.0 - 1.0/exp2(mipLevel))/exp2(roughnessLevel);\n    float mipOffset = 0.75*(1.0 - rcp_exp2_packed.y) * rcp_exp2_packed.x;\n\n    bool bRes = mipLevel == 0.0;\n    scale =  bRes && (scale < a) ? a : scale;\n\n    vec3 r;\n    vec2 offset;\n    int face = getFaceFromDirection(direction);\n\n    float rcpPowScale = 1.0 / powScale;\n\n    if( face == 0) {\n        r = vec3(direction.x, -direction.z, direction.y);\n        offset = vec2(0.0+mipOffset,0.75 * rcpPowScale);\n        offset.y = bRes && (offset.y < 2.0*a) ? a : offset.y;\n    }\n    else if( face == 1) {\n        r = vec3(direction.y, direction.x, direction.z);\n        offset = vec2(scale+mipOffset, 0.75 * rcpPowScale);\n        offset.y = bRes && (offset.y < 2.0*a) ? a : offset.y;\n    }\n    else if( face == 2) {\n        r = vec3(direction.z, direction.x, direction.y);\n        offset = vec2(2.0*scale+mipOffset, 0.75 * rcpPowScale);\n        offset.y = bRes && (offset.y < 2.0*a) ? a : offset.y;\n    }\n    else if( face == 3) {\n        r = vec3(direction.x, direction.z, direction.y);\n        offset = vec2(0.0+mipOffset,0.5 * rcpPowScale);\n        offset.y = bRes && (offset.y < 2.0*a) ? 0.0 : offset.y;\n    }\n    else if( face == 4) {\n        r = vec3(direction.y, direction.x, -direction.z);\n        offset = vec2(scale+mipOffset, 0.5 * rcpPowScale);\n        offset.y = bRes && (offset.y < 2.0*a) ? 0.0 : offset.y;\n    }\n    else {\n        r = vec3(direction.z, -direction.x, direction.y);\n        offset = vec2(2.0*scale+mipOffset, 0.5 * rcpPowScale);\n        offset.y = bRes && (offset.y < 2.0*a) ? 0.0 : offset.y;\n    }\n    r = normalize(r);\n    float texelOffset = 0.5 * cubeUV_rcpTextureSize;\n    vec2 s = ( r.yz / abs( r.x ) + vec2( 1.0 ) ) * 0.5;\n    vec2 base = offset + vec2( texelOffset );\n    return base + s * ( scale - 2.0 * texelOffset );\n}\n\n#define cubeUV_maxLods3 (log2(cubeUV_textureSize*0.25) - 3.0)\n\nvec4 textureCubeUV( sampler2D envMap, vec3 reflectedDirection, float roughness ) {\n    float roughnessVal = roughness* cubeUV_maxLods3;\n    float r1 = floor(roughnessVal);\n    float r2 = r1 + 1.0;\n    float t = fract(roughnessVal);\n    vec2 mipInfo = MipLevelInfo(reflectedDirection, r1, roughness);\n    float s = mipInfo.y;\n    float level0 = mipInfo.x;\n    float level1 = level0 + 1.0;\n    level1 = level1 > 5.0 ? 5.0 : level1;\n\n    // round to nearest mipmap if we are not interpolating.\n    level0 += min( floor( s + 0.5 ), 5.0 );\n\n    // Tri linear interpolation.\n    vec2 uv_10 = getCubeUV(reflectedDirection, r1, level0);\n    vec4 color10 = envMapTexelToLinear(texture2D(envMap, uv_10));\n\n    vec2 uv_20 = getCubeUV(reflectedDirection, r2, level0);\n    vec4 color20 = envMapTexelToLinear(texture2D(envMap, uv_20));\n\n    vec4 result = mix(color10, color20, t);\n\n    return vec4(result.rgb, 1.0);\n}\n\n#endif",
        defaultnormal_vertex: "#ifdef USE_INSTANCED\n mat3 normalMatrix = transposeMat3(inverseMat3(modelViewMatrix));\n#endif\nvec3 transformedNormal = normalMatrix * objectNormal;\n\n#ifdef FLIP_SIDED\n\n    transformedNormal = - transformedNormal;\n\n#endif\n\n#ifdef USE_TANGENT\n\n    vec3 transformedTangent = normalMatrix * objectTangent;\n\n    #ifdef FLIP_SIDED\n\n        transformedTangent = - transformedTangent;\n\n    #endif\n\n#endif",
        default_fragment: "void main() {\n gl_FragColor = vec4( 1.0, 0.0, 0.0, 1.0 );\n}",
        default_vertex: "void main() {\n gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n}",
        displacementmap_pars_vertex: "#ifdef USE_DISPLACEMENTMAP\n\n uniform sampler2D displacementMap;\n    uniform float displacementScale;\n    uniform float displacementBias;\n\n#endif",
        displacementmap_vertex: "#ifdef USE_DISPLACEMENTMAP\n\n transformed += normalize( objectNormal ) * ( texture2D( displacementMap, uv ).x * displacementScale + displacementBias );\n\n#endif",
        dithering_fragment: "#ifdef DITHERING\n\n gl_FragColor.rgb = dithering( gl_FragColor.rgb );\n\n#endif",
        dithering_pars_fragment: "#ifdef DITHERING\n\n // based on https://www.shadertoy.com/view/MslGR8\n    vec3 dithering( vec3 color ) {\n        //Calculate grid position\n        float grid_position = rand( gl_FragCoord.xy );\n\n        //Shift the individual colors differently, thus making it even harder to see the dithering pattern\n        vec3 dither_shift_RGB = vec3( 0.25 / 255.0, -0.25 / 255.0, 0.25 / 255.0 );\n\n        //modify shift acording to grid position.\n        dither_shift_RGB = mix( 2.0 * dither_shift_RGB, -2.0 * dither_shift_RGB, grid_position );\n\n        //shift the color by dither_shift\n        return color + dither_shift_RGB;\n    }\n\n#endif",
        emissivemap_fragment: "#ifdef USE_EMISSIVEMAP\n\n vec4 emissiveColor = texture2D( emissiveMap, vUv );\n\n    emissiveColor.rgb = emissiveMapTexelToLinear( emissiveColor ).rgb;\n\n    totalEmissiveRadiance *= emissiveColor.rgb;\n\n#endif",
        emissivemap_pars_fragment: "#ifdef USE_EMISSIVEMAP\n\n uniform sampler2D emissiveMap;\n\n#endif",
        encodings_fragment: "gl_FragColor = linearToOutputTexel( gl_FragColor );",
        encodings_pars_fragment: "// For a discussion of what this is, please read this: http://lousodrome.net/blog/light/2013/05/26/gamma-correct-and-hdr-rendering-in-a-32-bits-buffer/\n\nvec4 LinearToLinear( in vec4 value ) {\n return value;\n}\n\nvec4 GammaToLinear( in vec4 value, in float gammaFactor ) {\n    return vec4( pow( value.rgb, vec3( gammaFactor ) ), value.a );\n}\n\nvec4 LinearToGamma( in vec4 value, in float gammaFactor ) {\n    return vec4( pow( value.rgb, vec3( 1.0 / gammaFactor ) ), value.a );\n}\n\nvec4 sRGBToLinear( in vec4 value ) {\n    return vec4( mix( pow( value.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), value.rgb * 0.0773993808, vec3( lessThanEqual( value.rgb, vec3( 0.04045 ) ) ) ), value.a );\n}\n\nvec4 LinearTosRGB( in vec4 value ) {\n    return vec4( mix( pow( value.rgb, vec3( 0.41666 ) ) * 1.055 - vec3( 0.055 ), value.rgb * 12.92, vec3( lessThanEqual( value.rgb, vec3( 0.0031308 ) ) ) ), value.a );\n}\n\nvec4 RGBEToLinear( in vec4 value ) {\n    return vec4( value.rgb * exp2( value.a * 255.0 - 128.0 ), 1.0 );\n}\n\nvec4 LinearToRGBE( in vec4 value ) {\n    float maxComponent = max( max( value.r, value.g ), value.b );\n    float fExp = clamp( ceil( log2( maxComponent ) ), -128.0, 127.0 );\n    return vec4( value.rgb / exp2( fExp ), ( fExp + 128.0 ) / 255.0 );\n//  return vec4( value.brg, ( 3.0 + 128.0 ) / 256.0 );\n}\n\n// reference: http://iwasbeingirony.blogspot.ca/2010/06/difference-between-rgbm-and-rgbd.html\nvec4 RGBMToLinear( in vec4 value, in float maxRange ) {\n    return vec4( value.rgb * value.a * maxRange, 1.0 );\n}\n\nvec4 LinearToRGBM( in vec4 value, in float maxRange ) {\n    float maxRGB = max( value.r, max( value.g, value.b ) );\n    float M = clamp( maxRGB / maxRange, 0.0, 1.0 );\n    M = ceil( M * 255.0 ) / 255.0;\n    return vec4( value.rgb / ( M * maxRange ), M );\n}\n\n// reference: http://iwasbeingirony.blogspot.ca/2010/06/difference-between-rgbm-and-rgbd.html\nvec4 RGBDToLinear( in vec4 value, in float maxRange ) {\n    return vec4( value.rgb * ( ( maxRange / 255.0 ) / value.a ), 1.0 );\n}\n\nvec4 LinearToRGBD( in vec4 value, in float maxRange ) {\n    float maxRGB = max( value.r, max( value.g, value.b ) );\n    float D = max( maxRange / maxRGB, 1.0 );\n    D = min( floor( D ) / 255.0, 1.0 );\n    return vec4( value.rgb * ( D * ( 255.0 / maxRange ) ), D );\n}\n\n// LogLuv reference: http://graphicrants.blogspot.ca/2009/04/rgbm-color-encoding.html\n\n// M matrix, for encoding\nconst mat3 cLogLuvM = mat3( 0.2209, 0.3390, 0.4184, 0.1138, 0.6780, 0.7319, 0.0102, 0.1130, 0.2969 );\nvec4 LinearToLogLuv( in vec4 value )  {\n    vec3 Xp_Y_XYZp = cLogLuvM * value.rgb;\n    Xp_Y_XYZp = max( Xp_Y_XYZp, vec3( 1e-6, 1e-6, 1e-6 ) );\n    vec4 vResult;\n    vResult.xy = Xp_Y_XYZp.xy / Xp_Y_XYZp.z;\n    float Le = 2.0 * log2(Xp_Y_XYZp.y) + 127.0;\n    vResult.w = fract( Le );\n    vResult.z = ( Le - ( floor( vResult.w * 255.0 ) ) / 255.0 ) / 255.0;\n    return vResult;\n}\n\n// Inverse M matrix, for decoding\nconst mat3 cLogLuvInverseM = mat3( 6.0014, -2.7008, -1.7996, -1.3320, 3.1029, -5.7721, 0.3008, -1.0882, 5.6268 );\nvec4 LogLuvToLinear( in vec4 value ) {\n    float Le = value.z * 255.0 + value.w;\n    vec3 Xp_Y_XYZp;\n    Xp_Y_XYZp.y = exp2( ( Le - 127.0 ) / 2.0 );\n    Xp_Y_XYZp.z = Xp_Y_XYZp.y / value.y;\n    Xp_Y_XYZp.x = value.x * Xp_Y_XYZp.z;\n    vec3 vRGB = cLogLuvInverseM * Xp_Y_XYZp.rgb;\n    return vec4( max( vRGB, 0.0 ), 1.0 );\n}",
        envmap_common_pars_fragment: "#ifdef USE_ENVMAP\n\n uniform float envMapIntensity;\n    uniform float flipEnvMap;\n    uniform int maxMipLevel;\n\n    #ifdef ENVMAP_TYPE_CUBE\n        uniform samplerCube envMap;\n    #else\n        uniform sampler2D envMap;\n    #endif\n    \n#endif",
        envmap_fragment: "#ifdef USE_ENVMAP\n\n #ifdef ENV_WORLDPOS\n\n        vec3 cameraToVertex = normalize( vWorldPosition - cameraPosition );\n\n        // Transforming Normal Vectors with the Inverse Transformation\n        vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\n\n        #ifdef EGRET  \n            #ifndef ENVMAP_MODE_REFRACTION // modified by egret\n                vec3 reflectVec = reflect( cameraToVertex, worldNormal );\n            #else\n                vec3 reflectVec = refract( cameraToVertex, worldNormal, refractionRatio );\n            #endif\n        #else\n            #ifdef ENVMAP_MODE_REFLECTION\n\n                vec3 reflectVec = reflect( cameraToVertex, worldNormal );\n\n            #else\n\n                vec3 reflectVec = refract( cameraToVertex, worldNormal, refractionRatio );\n\n        #endif\n\n        #endif\n\n    #else\n\n        vec3 reflectVec = vReflect;\n\n    #endif\n\n    #ifdef ENVMAP_TYPE_CUBE\n\n        vec4 envColor = textureCube( envMap, vec3( flipEnvMap * reflectVec.x, reflectVec.yz ) );\n\n    #elif defined( ENVMAP_TYPE_EQUIREC )\n\n        vec2 sampleUV;\n\n        reflectVec = normalize( reflectVec );\n\n        sampleUV.y = asin( clamp( reflectVec.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;\n\n        #ifdef EGRET  \n            sampleUV.y = 1.0 - sampleUV.y; // modified by egret\n        // #else\n        //     sampleUV.y = asin( clamp( reflectVec.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;\n        #endif\n\n        sampleUV.x = atan( reflectVec.z, reflectVec.x ) * RECIPROCAL_PI2 + 0.5;\n\n        vec4 envColor = texture2D( envMap, sampleUV );\n\n    #elif defined( ENVMAP_TYPE_SPHERE )\n\n        reflectVec = normalize( reflectVec );\n\n        #ifdef EGRET  \n            // modified by egret\n            vec3 reflectView = normalize( ( viewMatrix * vec4( reflectVec, 0.0 ) ).xyz + vec3( 0.0, 0.0, -1.0 ) );\n            reflectView = vec3(reflectView.x * 0.5 + 0.5, 1.0 - (reflectView.y * 0.5 + 0.5), 0.0);\n            vec4 envColor = texture2D( envMap, reflectView.xy);\n        #else\n            vec3 reflectView = normalize( ( viewMatrix * vec4( reflectVec, 0.0 ) ).xyz + vec3( 0.0, 0.0, 1.0 ) );\n            vec4 envColor = texture2D( envMap, reflectView.xy * 0.5 + 0.5 );\n        #endif\n\n    #else\n\n        vec4 envColor = vec4( 0.0 );\n\n    #endif\n\n    envColor = envMapTexelToLinear( envColor );\n\n    #ifdef ENVMAP_BLENDING_MULTIPLY\n\n        outgoingLight = mix( outgoingLight, outgoingLight * envColor.xyz, specularStrength * reflectivity );\n\n    #elif defined( ENVMAP_BLENDING_MIX )\n\n        outgoingLight = mix( outgoingLight, envColor.xyz, specularStrength * reflectivity );\n\n    #elif defined( ENVMAP_BLENDING_ADD )\n\n        outgoingLight += envColor.xyz * specularStrength * reflectivity;\n\n    #endif\n\n#endif",
        envmap_pars_fragment: "#ifdef USE_ENVMAP\n\n uniform float reflectivity;\n\n    #if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG )\n\n        #define ENV_WORLDPOS\n\n    #endif\n\n    #ifdef ENV_WORLDPOS\n\n        varying vec3 vWorldPosition;\n        uniform float refractionRatio;\n    #else\n        varying vec3 vReflect;\n    #endif\n\n#endif",
        envmap_pars_vertex: "#ifdef USE_ENVMAP\n\n #if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) ||defined( PHONG )\n\n        #define ENV_WORLDPOS\n\n    #endif\n\n    #ifdef ENV_WORLDPOS\n        \n        varying vec3 vWorldPosition;\n\n    #else\n\n        varying vec3 vReflect;\n        uniform float refractionRatio;\n\n    #endif\n\n#endif",
        envmap_physical_pars_fragment: "#if defined( USE_ENVMAP )\n\n #ifdef ENVMAP_MODE_REFRACTION\n        uniform float refractionRatio;\n    #endif\n\n    vec3 getLightProbeIndirectIrradiance( /*const in SpecularLightProbe specularLightProbe,*/ const in GeometricContext geometry, const in int maxMIPLevel ) {\n\n        vec3 worldNormal = inverseTransformDirection( geometry.normal, viewMatrix );\n\n        #ifdef ENVMAP_TYPE_CUBE\n\n            vec3 queryVec = vec3( flipEnvMap * worldNormal.x, worldNormal.yz );\n\n            // TODO: replace with properly filtered cubemaps and access the irradiance LOD level, be it the last LOD level\n            // of a specular cubemap, or just the default level of a specially created irradiance cubemap.\n\n            #ifdef TEXTURE_LOD_EXT\n\n                vec4 envMapColor = textureCubeLodEXT( envMap, queryVec, float( maxMIPLevel ) );\n\n            #else\n\n                // force the bias high to get the last LOD level as it is the most blurred.\n                vec4 envMapColor = textureCube( envMap, queryVec, float( maxMIPLevel ) );\n\n            #endif\n\n            envMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\n\n        #elif defined( ENVMAP_TYPE_CUBE_UV )\n\n            vec3 queryVec = vec3( flipEnvMap * worldNormal.x, worldNormal.yz );\n            vec4 envMapColor = textureCubeUV( envMap, queryVec, 1.0 );\n\n        #else\n\n            vec4 envMapColor = vec4( 0.0 );\n\n        #endif\n\n        return PI * envMapColor.rgb * envMapIntensity;\n\n    }\n\n    // Trowbridge-Reitz distribution to Mip level, following the logic of http://casual-effects.blogspot.ca/2011/08/plausible-environment-lighting-in-two.html\n    float getSpecularMIPLevel( const in float roughness, const in int maxMIPLevel ) {\n\n        float maxMIPLevelScalar = float( maxMIPLevel );\n\n        float sigma = PI * roughness * roughness / ( 1.0 + roughness );\n        float desiredMIPLevel = maxMIPLevelScalar + log2( sigma );\n\n        // clamp to allowable LOD ranges.\n        return clamp( desiredMIPLevel, 0.0, maxMIPLevelScalar );\n\n    }\n\n    vec3 getLightProbeIndirectRadiance( /*const in SpecularLightProbe specularLightProbe,*/ const in vec3 viewDir, const in vec3 normal, const in float roughness, const in int maxMIPLevel ) {\n\n        #ifdef EGRET  \n            #ifndef ENVMAP_MODE_REFRACTION // modified by egret\n                vec3 reflectVec = reflect( -viewDir, normal );\n\n                // Mixing the reflection with the normal is more accurate and keeps rough objects from gathering light from behind their tangent plane.\n                  reflectVec = normalize( mix( reflectVec, normal, roughness * roughness) );\n            #else\n                vec3 reflectVec = refract( -viewDir, normal, refractionRatio );\n            #endif\n        #else\n            #ifdef ENVMAP_MODE_REFLECTION\n\n                  vec3 reflectVec = reflect( -viewDir, normal );\n\n                  // Mixing the reflection with the normal is more accurate and keeps rough objects from gathering light from behind their tangent plane.\n                  reflectVec = normalize( mix( reflectVec, normal, roughness * roughness) );\n\n            #else\n\n                  vec3 reflectVec = refract( -viewDir, normal, refractionRatio );\n\n            #endif\n        #endif\n\n        reflectVec = inverseTransformDirection( reflectVec, viewMatrix );\n\n        float specularMIPLevel = getSpecularMIPLevel( roughness, maxMIPLevel );\n\n        #ifdef ENVMAP_TYPE_CUBE\n\n            vec3 queryReflectVec = vec3( flipEnvMap * reflectVec.x, reflectVec.yz );\n\n            #ifdef TEXTURE_LOD_EXT\n\n                vec4 envMapColor = textureCubeLodEXT( envMap, queryReflectVec, specularMIPLevel );\n\n            #else\n\n                vec4 envMapColor = textureCube( envMap, queryReflectVec, specularMIPLevel );\n\n            #endif\n\n            envMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\n\n        #elif defined( ENVMAP_TYPE_CUBE_UV )\n\n            vec3 queryReflectVec = vec3( flipEnvMap * reflectVec.x, reflectVec.yz );\n            vec4 envMapColor = textureCubeUV( envMap, queryReflectVec, roughness );\n\n        #elif defined( ENVMAP_TYPE_EQUIREC )\n\n            vec2 sampleUV;\n            sampleUV.y = asin( clamp( reflectVec.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;\n            sampleUV.x = atan( reflectVec.z, reflectVec.x ) * RECIPROCAL_PI2 + 0.5;\n\n            #ifdef TEXTURE_LOD_EXT\n\n                vec4 envMapColor = texture2DLodEXT( envMap, sampleUV, specularMIPLevel );\n\n            #else\n\n                vec4 envMapColor = texture2D( envMap, sampleUV, specularMIPLevel );\n\n            #endif\n\n            envMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\n\n        #elif defined( ENVMAP_TYPE_SPHERE )\n\n            #ifdef EGRET  \n                // modified by egret\n                vec3 reflectView = normalize( ( viewMatrix * vec4( reflectVec, 0.0 ) ).xyz + vec3( 0.0, 0.0, -1.0 ) );\n                reflectView = vec3(reflectView.x * 0.5 + 0.5, 1.0 - (reflectView.y * 0.5 + 0.5), 0.0);\n            #else\n                vec3 reflectView = normalize( ( viewMatrix * vec4( reflectVec, 0.0 ) ).xyz + vec3( 0.0,0.0,1.0 ) );\n            #endif\n\n            #ifdef TEXTURE_LOD_EXT\n\n                vec4 envMapColor = texture2DLodEXT( envMap, reflectView.xy * 0.5 + 0.5, specularMIPLevel );\n\n            #else\n\n                vec4 envMapColor = texture2D( envMap, reflectView.xy * 0.5 + 0.5, specularMIPLevel );\n\n            #endif\n\n            envMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\n\n        #endif\n\n        return envMapColor.rgb * envMapIntensity;\n\n    }\n\n#endif",
        envmap_vertex: "#ifdef USE_ENVMAP\n\n #ifdef ENV_WORLDPOS\n\n        vWorldPosition = worldPosition.xyz;\n\n    #else\n\n        vec3 cameraToVertex = normalize( worldPosition.xyz - cameraPosition );\n\n        vec3 worldNormal = inverseTransformDirection( transformedNormal, viewMatrix );\n\n        #ifdef EGRET  \n            #ifndef ENVMAP_MODE_REFRACTION // modified by egret\n                vReflect = reflect( cameraToVertex, worldNormal );\n            #else\n                vReflect = refract( cameraToVertex, worldNormal, refractionRatio );\n            #endif\n            \n        #else\n\n            #ifdef ENVMAP_MODE_REFLECTION\n\n                vReflect = reflect( cameraToVertex, worldNormal );\n\n            #else\n\n                vReflect = refract( cameraToVertex, worldNormal, refractionRatio );\n\n            #endif\n\n        #endif\n\n        \n\n    #endif\n\n#endif",
        fog_fragment: "#ifdef USE_FOG\n\n #ifdef FOG_EXP2\n\n        float fogFactor = 1.0 - exp( - fogDensity * fogDensity * fogDepth * fogDepth );\n\n    #else\n\n        float fogFactor = smoothstep( fogNear, fogFar, fogDepth );\n\n    #endif\n\n    gl_FragColor.rgb = mix( gl_FragColor.rgb, fogColor, fogFactor );\n\n#endif",
        fog_pars_fragment: "#ifdef USE_FOG\n\n uniform vec3 fogColor;\n    varying float fogDepth;\n\n    #ifdef FOG_EXP2\n\n        uniform float fogDensity;\n\n    #else\n\n        uniform float fogNear;\n        uniform float fogFar;\n\n    #endif\n\n#endif",
        fog_pars_vertex: "#ifdef USE_FOG\n\n varying float fogDepth;\n\n#endif",
        fog_vertex: "#ifdef USE_FOG\n\n fogDepth = -mvPosition.z;\n\n#endif",
        gradientmap_pars_fragment: "#ifdef TOON\n\n uniform sampler2D gradientMap;\n\n    vec3 getGradientIrradiance( vec3 normal, vec3 lightDirection ) {\n\n        // dotNL will be from -1.0 to 1.0\n        float dotNL = dot( normal, lightDirection );\n        vec2 coord = vec2( dotNL * 0.5 + 0.5, 0.0 );\n\n        #ifdef USE_GRADIENTMAP\n\n            return texture2D( gradientMap, coord ).rgb;\n\n        #else\n\n            return ( coord.x < 0.7 ) ? vec3( 0.7 ) : vec3( 1.0 );\n\n        #endif\n\n\n    }\n\n#endif",
        instances_vertex: "//modify by egret\n#if defined( USE_ENVMAP ) || defined( DISTANCE ) || defined ( USE_SHADOWMAP )\n\n mat4 modelMatrix = mat4(modelMatrix0,modelMatrix1,modelMatrix2,modelMatrix3);\n\n#endif\n\nmat4 modelViewMatrix = mat4(modelViewMatrix0,modelViewMatrix1,modelViewMatrix2,modelViewMatrix3);",
        lightmap_fragment: "#ifdef USE_LIGHTMAP\n #ifdef EGRET\n        vec4 lightmapTex = texture2D(lightMap, vUv2);\n        // float power = pow( 2.0, lightmapTex.a * 255.0 - 128.0);\n        float power = 5.0 * lightmapTex.a;\n        reflectedLight.indirectDiffuse += PI * lightmapTex.rgb * power * lightMapIntensity;\n    #else\n        reflectedLight.indirectDiffuse += PI * texture2D( lightMap, vUv2 ).xyz * lightMapIntensity; // factor of PI should not be present; included here to prevent breakage\n    #endif\n\n#endif",
        lightmap_pars_fragment: "#ifdef USE_LIGHTMAP\n\n uniform sampler2D lightMap;\n    uniform float lightMapIntensity;\n\n#endif",
        lights_fragment_begin: "/**\n * This is a template that can be used to light a material, it uses pluggable\n * RenderEquations (RE)for specific lighting scenarios.\n *\n * Instructions for use:\n * - Ensure that both RE_Direct, RE_IndirectDiffuse and RE_IndirectSpecular are defined\n * - If you have defined an RE_IndirectSpecular, you need to also provide a Material_LightProbeLOD. <---- ???\n * - Create a material parameter that is to be passed as the third parameter to your lighting functions.\n *\n * TODO:\n * - Add area light support.\n * - Add sphere light support.\n * - Add diffuse light probe (irradiance cubemap) support.\n */\n\nGeometricContext geometry;\n\ngeometry.position = - vViewPosition;\ngeometry.normal = normal;\ngeometry.viewDir = normalize( vViewPosition );\n\n#ifdef CLEARCOAT\n\n geometry.clearcoatNormal = clearcoatNormal;\n\n#endif\n\nIncidentLight directLight;\n\n#if ( NUM_POINT_LIGHTS > 0 ) && defined( RE_Direct )\n\n    PointLight pointLight;\n\n    #pragma unroll_loop\n    for ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n\n        #ifdef EGRET  \n            // modified by egret\n            #ifdef LIGHT_CULLING\n                pointLight.cullingMask = int(pointLights[ i * POINT_LIGHT_SIZE + LIGHT_CULLING + 15]);\n            #else\n                pointLight.cullingMask = 1;\n            #endif        \n            if(bool(pointLight.cullingMask)) {\n                pointLight.position = vec3(pointLights[ i  * POINT_LIGHT_SIZE + 0], pointLights[ i  * POINT_LIGHT_SIZE + 1], pointLights[ i  * POINT_LIGHT_SIZE + 2]);\n                pointLight.color = vec3(pointLights[ i  * POINT_LIGHT_SIZE + 3], pointLights[ i  * POINT_LIGHT_SIZE + 4], pointLights[ i  * POINT_LIGHT_SIZE + 5]);\n                pointLight.distance = pointLights[ i  * POINT_LIGHT_SIZE + 6];\n                pointLight.decay = pointLights[ i  * POINT_LIGHT_SIZE + 7];\n\n                getPointDirectLightIrradiance( pointLight, geometry, directLight );\n                #if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_POINT_LIGHT_SHADOWS )\n\n                pointLight.shadow = int(pointLights[ i  * POINT_LIGHT_SIZE + 8]);\n                pointLight.shadowBias = pointLights[ i  * POINT_LIGHT_SIZE + 9];\n                pointLight.shadowRadius = pointLights[ i  * POINT_LIGHT_SIZE + 10];\n                pointLight.shadowMapSize = vec2(pointLights[ i  * POINT_LIGHT_SIZE + 11], pointLights[ i  * POINT_LIGHT_SIZE + 12]);\n                pointLight.shadowCameraNear = pointLights[ i  * POINT_LIGHT_SIZE + 13];\n                pointLight.shadowCameraFar = pointLights[ i  * POINT_LIGHT_SIZE + 14];\n\n                directLight.color *= all( bvec2( pointLight.shadow, directLight.visible ) ) ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ], pointLight.shadowCameraNear, pointLight.shadowCameraFar ) : 1.0;\n                #endif\n\n                RE_Direct( directLight, geometry, material, reflectedLight );\n            }    \n\n        #else\n            pointLight = pointLights[ i ];\n\n            getPointDirectLightIrradiance( pointLight, geometry, directLight );\n\n            #if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_POINT_LIGHT_SHADOWS )\n            directLight.color *= all( bvec2( pointLight.shadow, directLight.visible ) ) ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ], pointLight.shadowCameraNear, pointLight.shadowCameraFar ) : 1.0;\n            #endif\n\n            RE_Direct( directLight, geometry, material, reflectedLight );\n        #endif\n\n    }\n    // #end unroll_loop\n\n#endif\n\n#if ( NUM_SPOT_LIGHTS > 0 ) && defined( RE_Direct )\n\n    SpotLight spotLight;\n\n    #pragma unroll_loop\n    for ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n\n        // modified by egret        \n        #ifdef EGRET  \n            #ifdef LIGHT_CULLING\n                spotLight.cullingMask = int(spotLights[ i * SPOT_LIGHT_SIZE + LIGHT_CULLING + 18]);\n            #else\n                spotLight.cullingMask = 1;\n            #endif        \n            if(bool(spotLight.cullingMask)) {\n                spotLight.position = vec3(spotLights[ i  * SPOT_LIGHT_SIZE + 0], spotLights[ i  * SPOT_LIGHT_SIZE + 1], spotLights[ i  * SPOT_LIGHT_SIZE + 2]);\n                spotLight.direction = vec3(spotLights[ i  * SPOT_LIGHT_SIZE + 3], spotLights[ i  * SPOT_LIGHT_SIZE + 4], spotLights[ i  * SPOT_LIGHT_SIZE + 5]);\n                spotLight.color = vec3(spotLights[ i  * SPOT_LIGHT_SIZE + 6], spotLights[ i  * SPOT_LIGHT_SIZE + 7], spotLights[ i  * SPOT_LIGHT_SIZE + 8]);\n                spotLight.distance = spotLights[ i  * SPOT_LIGHT_SIZE + 9];\n                spotLight.decay = spotLights[ i  * SPOT_LIGHT_SIZE + 10];\n                spotLight.coneCos = spotLights[ i  * SPOT_LIGHT_SIZE + 11];\n                spotLight.penumbraCos = spotLights[ i  * SPOT_LIGHT_SIZE + 12];\n\n                getSpotDirectLightIrradiance( spotLight, geometry, directLight );\n\n                #if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )\n\n                 // modified by egret\n                spotLight.shadow = int(spotLights[ i  * SPOT_LIGHT_SIZE + 13]);\n                spotLight.shadowBias = spotLights[ i  * SPOT_LIGHT_SIZE + 14];\n                spotLight.shadowRadius = spotLights[ i  * SPOT_LIGHT_SIZE + 15];\n                spotLight.shadowMapSize = vec2(spotLights[ i  * SPOT_LIGHT_SIZE + 16], spotLights[ i  * SPOT_LIGHT_SIZE + 17]);\n\n                directLight.color *= all( bvec2( spotLight.shadow, directLight.visible ) ) ? getShadow( spotShadowMap[ i ], spotLight.shadowMapSize, spotLight.shadowBias, spotLight.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;\n                #endif\n\n                RE_Direct( directLight, geometry, material, reflectedLight );\n            }\n        #else\n            spotLight = spotLights[ i ];\n\n            getSpotDirectLightIrradiance( spotLight, geometry, directLight );\n\n            #if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )\n            directLight.color *= all( bvec2( spotLight.shadow, directLight.visible ) ) ? getShadow( spotShadowMap[ i ], spotLight.shadowMapSize, spotLight.shadowBias, spotLight.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;\n            #endif\n\n            RE_Direct( directLight, geometry, material, reflectedLight );\n        #endif\n    }\n    // #end unroll_loop\n\n#endif\n\n#if ( NUM_DIR_LIGHTS > 0 ) && defined( RE_Direct )\n\n    DirectionalLight directionalLight;\n\n    #pragma unroll_loop\n    for ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n\n        // modified by egret        \n        #ifdef EGRET  \n            #ifdef LIGHT_CULLING\n                directionalLight.cullingMask = int(directionalLights[ i * DIR_LIGHT_SIZE + LIGHT_CULLING + 11]);\n            #else\n                directionalLight.cullingMask = 1;\n            #endif        \n            if(bool(directionalLight.cullingMask)) {\n                directionalLight.direction = vec3(directionalLights[ i  * DIR_LIGHT_SIZE + 0], directionalLights[ i  * DIR_LIGHT_SIZE + 1], directionalLights[ i  * DIR_LIGHT_SIZE + 2]);\n                directionalLight.color = vec3(directionalLights[ i  * DIR_LIGHT_SIZE + 3], directionalLights[ i  * DIR_LIGHT_SIZE + 4], directionalLights[ i  * DIR_LIGHT_SIZE + 5]);\n\n                getDirectionalDirectLightIrradiance( directionalLight, geometry, directLight );\n\n                #if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_DIR_LIGHT_SHADOWS )\n\n                 // modified by egret\n                directionalLight.shadow = int(directionalLights[ i  * DIR_LIGHT_SIZE + 6]);\n                directionalLight.shadowBias = directionalLights[ i  * DIR_LIGHT_SIZE + 7];\n                directionalLight.shadowRadius = directionalLights[ i  * DIR_LIGHT_SIZE + 8];\n                directionalLight.shadowMapSize = vec2(directionalLights[ i  * DIR_LIGHT_SIZE + 9], directionalLights[ i  * DIR_LIGHT_SIZE + 10]);\n\n                directLight.color *= all( bvec2( directionalLight.shadow, directLight.visible ) ) ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\n                #endif\n\n                RE_Direct( directLight, geometry, material, reflectedLight );\n            }    \n        #else            \n            directionalLight = directionalLights[ i ];\n\n            getDirectionalDirectLightIrradiance( directionalLight, geometry, directLight );\n\n            #if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_DIR_LIGHT_SHADOWS )\n            directLight.color *= all( bvec2( directionalLight.shadow, directLight.visible ) ) ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\n            #endif\n\n            RE_Direct( directLight, geometry, material, reflectedLight );\n        #endif\n    }\n    // #end unroll_loop\n\n#endif\n\n#if ( NUM_RECT_AREA_LIGHTS > 0 ) && defined( RE_Direct_RectArea )\n\n    RectAreaLight rectAreaLight;\n\n    #pragma unroll_loop\n    for ( int i = 0; i < NUM_RECT_AREA_LIGHTS; i ++ ) {\n         // modified by egret\n        #ifdef EGRET  \n            #ifdef LIGHT_CULLING\n                rectAreaLight.cullingMask = int(rectAreaLights[ i * RECT_AREA_LIGHT_SIZE + LIGHT_CULLING + 12]);\n            #else\n                rectAreaLight.cullingMask = 1;\n            #endif    \n            if(bool(rectAreaLight.cullingMask)) {\n                rectAreaLight.position = vec3(rectAreaLights[ i  * RECT_AREA_LIGHT_SIZE + 0], rectAreaLights[ i  * RECT_AREA_LIGHT_SIZE + 1], rectAreaLights[ i  * RECT_AREA_LIGHT_SIZE + 2]);\n                rectAreaLight.color = vec3(rectAreaLights[ i  * RECT_AREA_LIGHT_SIZE + 3], rectAreaLights[ i  * RECT_AREA_LIGHT_SIZE + 4], rectAreaLights[ i  * RECT_AREA_LIGHT_SIZE + 5]);\n                rectAreaLight.halfWidth = vec3(rectAreaLights[ i  * RECT_AREA_LIGHT_SIZE + 6], rectAreaLights[ i  * RECT_AREA_LIGHT_SIZE + 7], rectAreaLights[ i  * RECT_AREA_LIGHT_SIZE + 8]);\n                rectAreaLight.halfHeight = vec3(rectAreaLights[ i  * RECT_AREA_LIGHT_SIZE + 9], rectAreaLights[ i  * RECT_AREA_LIGHT_SIZE + 10], rectAreaLights[ i  * RECT_AREA_LIGHT_SIZE + 11]);\n                RE_Direct_RectArea( rectAreaLight, geometry, material, reflectedLight );\n            }    \n        #else\n            rectAreaLight = rectAreaLights[ i ];\n            RE_Direct_RectArea( rectAreaLight, geometry, material, reflectedLight );\n        #endif\n    }\n    // #end unroll_loop\n\n#endif\n\n#if defined( RE_IndirectDiffuse )\n\n    vec3 iblIrradiance = vec3( 0.0 );\n    vec3 irradiance = getAmbientLightIrradiance( ambientLightColor );\n    #ifdef EGRET \n\n    #else\n        irradiance += getLightProbeIrradiance( lightProbe, geometry );\n    #endif\n    \n    #if (NUM_HEMI_LIGHTS > 0 )\n        HemisphereLight hemisphereLight;\n\n        #pragma unroll_loop\n        for ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {\n\n             // modified by egret\n            #ifdef EGRET\n                #ifdef LIGHT_CULLING\n                    hemisphereLight.cullingMask = int(hemisphereLights[ i * HEMI_LIGHT_SIZE + LIGHT_CULLING + 9]);\n                #else\n                    hemisphereLight.cullingMask = 1;\n                #endif    \n                if(bool(hemisphereLight.cullingMask)) {\n                    hemisphereLight.direction = vec3(hemisphereLights[ i  * HEMI_LIGHT_SIZE + 0], hemisphereLights[ i  * HEMI_LIGHT_SIZE + 1], hemisphereLights[ i  * HEMI_LIGHT_SIZE + 2]);\n                    hemisphereLight.skyColor = vec3(hemisphereLights[ i  * HEMI_LIGHT_SIZE + 3], hemisphereLights[ i  * HEMI_LIGHT_SIZE + 4], hemisphereLights[ i  * HEMI_LIGHT_SIZE + 5]);\n                    hemisphereLight.groundColor = vec3(hemisphereLights[ i  * HEMI_LIGHT_SIZE + 6], hemisphereLights[ i  * HEMI_LIGHT_SIZE + 7], hemisphereLights[ i  * HEMI_LIGHT_SIZE + 8]);\n\n                    irradiance += getHemisphereLightIrradiance( hemisphereLight, geometry );\n                }    \n            #else\n                irradiance += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry );\n            #endif\n        }\n        // #end unroll_loop\n\n    #endif\n\n#endif\n\n#if defined( RE_IndirectSpecular )\n\n    vec3 radiance = vec3( 0.0 );\n    vec3 clearcoatRadiance = vec3( 0.0 );\n\n#endif",
        lights_fragment_end: "#if defined( RE_IndirectDiffuse )\n\n RE_IndirectDiffuse( irradiance, geometry, material, reflectedLight );\n\n#endif\n\n#if defined( RE_IndirectSpecular )\n\n    RE_IndirectSpecular( radiance, iblIrradiance, clearcoatRadiance, geometry, material, reflectedLight );\n\n#endif",
        lights_fragment_maps: "#if defined( RE_IndirectDiffuse )\n\n #ifdef USE_LIGHTMAP\n\n        #ifdef EGRET\n            vec4 lightmapTex = texture2D(lightMap, vUv2);\n            // float power = pow( 2.0, lightmapTex.a * 255.0 - 128.0);\n            float power = 5.0 * lightmapTex.a;\n            vec3 lightMapIrradiance = lightmapTex.rgb * power * lightMapIntensity;\n        #else\n            vec3 lightMapIrradiance = texture2D( lightMap, vUv2 ).xyz * lightMapIntensity;\n        #endif\n        #ifndef PHYSICALLY_CORRECT_LIGHTS\n\n            lightMapIrradiance *= PI; // factor of PI should not be present; included here to prevent breakage\n\n        #endif\n\n        irradiance += lightMapIrradiance;\n\n    #endif\n\n    #if defined( USE_ENVMAP ) && defined( STANDARD ) && defined( ENVMAP_TYPE_CUBE_UV )\n\n        iblIrradiance += getLightProbeIndirectIrradiance( /*lightProbe,*/ geometry, maxMipLevel );\n\n    #endif\n\n#endif\n\n#if defined( USE_ENVMAP ) && defined( RE_IndirectSpecular )\n\n    radiance += getLightProbeIndirectRadiance( /*specularLightProbe,*/ geometry.viewDir, geometry.normal, material.specularRoughness, maxMipLevel );\n\n    #ifdef CLEARCOAT\n\n        clearcoatRadiance += getLightProbeIndirectRadiance( /*specularLightProbe,*/ geometry.viewDir, geometry.clearcoatNormal, material.clearcoatRoughness, maxMipLevel );\n\n    #endif\n\n#endif",
        lights_lambert_vertex: "vec3 diffuse = vec3( 1.0 );\n\nGeometricContext geometry;\ngeometry.position = mvPosition.xyz;\ngeometry.normal = normalize( transformedNormal );\ngeometry.viewDir = normalize( -mvPosition.xyz );\n\nGeometricContext backGeometry;\nbackGeometry.position = geometry.position;\nbackGeometry.normal = -geometry.normal;\nbackGeometry.viewDir = geometry.viewDir;\n\nvLightFront = vec3( 0.0 );\nvIndirectFront = vec3( 0.0 );\n\n#ifdef DOUBLE_SIDED\n vLightBack = vec3( 0.0 );\n    vIndirectBack = vec3( 0.0 );\n#endif\n\nIncidentLight directLight;\nfloat dotNL;\nvec3 directLightColor_Diffuse;\n\n#if NUM_POINT_LIGHTS > 0\n    PointLight pointLight;\n    #pragma unroll_loop\n    for ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n\n         // modified by egret\n        #ifdef EGRET\n            \n            #ifdef LIGHT_CULLING\n                pointLight.cullingMask = int(pointLights[ i * POINT_LIGHT_SIZE + LIGHT_CULLING + 15]);\n            #else\n                pointLight.cullingMask = 1;\n            #endif    \n            if(bool(pointLight.cullingMask)) {\n                pointLight.position = vec3(pointLights[ i  * POINT_LIGHT_SIZE + 0], pointLights[ i  * POINT_LIGHT_SIZE + 1], pointLights[ i  * POINT_LIGHT_SIZE + 2]);\n                pointLight.color = vec3(pointLights[ i  * POINT_LIGHT_SIZE + 3], pointLights[ i  * POINT_LIGHT_SIZE + 4], pointLights[ i  * POINT_LIGHT_SIZE + 5]);\n                pointLight.distance = pointLights[ i  * POINT_LIGHT_SIZE + 6];\n                pointLight.decay = pointLights[ i  * POINT_LIGHT_SIZE + 7];\n                getPointDirectLightIrradiance( pointLight, geometry, directLight );\n            \n                float dotNL = dot( geometry.normal, directLight.direction );\n                directLightColor_Diffuse = PI * directLight.color;\n            \n                vLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n            \n                #ifdef DOUBLE_SIDED\n            \n                    vLightBack += saturate( -dotNL ) * directLightColor_Diffuse;\n            \n                #endif\n            }\n        #else\n            getPointDirectLightIrradiance( pointLights[ i ], geometry, directLight );\n\n            dotNL = dot( geometry.normal, directLight.direction );\n            directLightColor_Diffuse = PI * directLight.color;\n\n            vLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n\n            #ifdef DOUBLE_SIDED\n\n                vLightBack += saturate( -dotNL ) * directLightColor_Diffuse;\n\n            #endif\n\n        #endif        \n    }\n    // #end unroll_loop\n\n#endif\n\n#if NUM_SPOT_LIGHTS > 0\n    SpotLight spotLight;\n\n    #pragma unroll_loop\n    for ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n\n         // modified by egret\n        #ifdef EGRET            \n            #ifdef LIGHT_CULLING\n                spotLight.cullingMask = int(spotLights[ i  * SPOT_LIGHT_SIZE + LIGHT_CULLING + 18]);\n            #else\n                spotLight.cullingMask = 1;\n            #endif    \n            if(bool(spotLight.cullingMask)) {\n                spotLight.position = vec3(spotLights[ i  * SPOT_LIGHT_SIZE + 0], spotLights[ i  * SPOT_LIGHT_SIZE + 1], spotLights[ i  * SPOT_LIGHT_SIZE + 2]);\n                spotLight.direction = vec3(spotLights[ i  * SPOT_LIGHT_SIZE + 3], spotLights[ i  * SPOT_LIGHT_SIZE + 4], spotLights[ i  * SPOT_LIGHT_SIZE + 5]);\n                spotLight.color = vec3(spotLights[ i  * SPOT_LIGHT_SIZE + 6], spotLights[ i  * SPOT_LIGHT_SIZE + 7], spotLights[ i  * SPOT_LIGHT_SIZE + 8]);\n                spotLight.distance = spotLights[ i  * SPOT_LIGHT_SIZE + 9];\n                spotLight.decay = spotLights[ i  * SPOT_LIGHT_SIZE + 10];\n                spotLight.coneCos = spotLights[ i  * SPOT_LIGHT_SIZE + 11];\n                spotLight.penumbraCos = spotLights[ i  * SPOT_LIGHT_SIZE + 12];\n            \n                getSpotDirectLightIrradiance( spotLight, geometry, directLight );\n            \n                float dotNL = dot( geometry.normal, directLight.direction );\n                directLightColor_Diffuse = PI * directLight.color;\n            \n                vLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n            \n                #ifdef DOUBLE_SIDED\n            \n                    vLightBack += saturate( -dotNL ) * directLightColor_Diffuse;\n            \n                #endif\n            }\n        #else\n            getSpotDirectLightIrradiance( spotLights[ i ], geometry, directLight );\n\n            dotNL = dot( geometry.normal, directLight.direction );\n            directLightColor_Diffuse = PI * directLight.color;\n            vLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n            #ifdef DOUBLE_SIDED\n\n                vLightBack += saturate( -dotNL ) * directLightColor_Diffuse;\n\n            #endif\n        #endif        \n    }\n    // #end unroll_loop\n\n#endif\n\n/*\n#if NUM_RECT_AREA_LIGHTS > 0\n\n    for ( int i = 0; i < NUM_RECT_AREA_LIGHTS; i ++ ) {\n\n        // TODO (abelnation): implement\n\n    }\n\n#endif\n*/\n\n#if NUM_DIR_LIGHTS > 0\n    DirectionalLight directionalLight;\n    #pragma unroll_loop\n    for ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n\n         // modified by egret\n        #ifdef EGRET            \n            #ifdef LIGHT_CULLING\n                directionalLight.cullingMask = int(directionalLights[ i  * DIR_LIGHT_SIZE + LIGHT_CULLING + 11]);\n            #else\n                directionalLight.cullingMask = 1;\n            #endif\n            if(bool(directionalLight.cullingMask)) {\n                directionalLight.direction = vec3(directionalLights[ i  * DIR_LIGHT_SIZE + 0], directionalLights[ i  * DIR_LIGHT_SIZE + 1], directionalLights[ i  * DIR_LIGHT_SIZE + 2]);\n                directionalLight.color = vec3(directionalLights[ i  * DIR_LIGHT_SIZE + 3], directionalLights[ i  * DIR_LIGHT_SIZE + 4], directionalLights[ i  * DIR_LIGHT_SIZE + 5]);\n                getDirectionalDirectLightIrradiance( directionalLight, geometry, directLight );\n            \n                float dotNL = dot( geometry.normal, directLight.direction );\n                directLightColor_Diffuse = PI * directLight.color;\n            \n                vLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n            \n                #ifdef DOUBLE_SIDED\n            \n                    vLightBack += saturate( -dotNL ) * directLightColor_Diffuse;\n            \n                #endif\n            }        \n        #else\n            getDirectionalDirectLightIrradiance( directionalLights[ i ], geometry, directLight );\n\n            dotNL = dot( geometry.normal, directLight.direction );\n            directLightColor_Diffuse = PI * directLight.color;\n\n            vLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n\n            #ifdef DOUBLE_SIDED\n\n                vLightBack += saturate( -dotNL ) * directLightColor_Diffuse;\n\n            #endif\n        #endif\n    }\n    // #end unroll_loop\n\n#endif\n\n#if NUM_HEMI_LIGHTS > 0\n\n    HemisphereLight hemisphereLight;\n\n    #pragma unroll_loop\n    for ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {\n        // modified by egret\n        #ifdef EGRET            \n            #ifdef LIGHT_CULLING\n                hemisphereLight.cullingMask = int(hemisphereLights[ i  * HEMI_LIGHT_SIZE + LIGHT_CULLING + 9]);\n            #else\n                hemisphereLight.cullingMask = 1;\n            #endif\n            if(bool(hemisphereLight.cullingMask)) {\n                hemisphereLight.direction = vec3(hemisphereLights[ i  * HEMI_LIGHT_SIZE + 0], hemisphereLights[ i  * HEMI_LIGHT_SIZE + 1], hemisphereLights[ i  * HEMI_LIGHT_SIZE + 2]);\n                hemisphereLight.skyColor = vec3(hemisphereLights[ i  * HEMI_LIGHT_SIZE + 3], hemisphereLights[ i  * HEMI_LIGHT_SIZE + 4], hemisphereLights[ i  * HEMI_LIGHT_SIZE + 5]);\n                hemisphereLight.groundColor = vec3(hemisphereLights[ i  * HEMI_LIGHT_SIZE + 6], hemisphereLights[ i  * HEMI_LIGHT_SIZE + 7], hemisphereLights[ i  * HEMI_LIGHT_SIZE + 8]);\n            \n                vIndirectFront += getHemisphereLightIrradiance( hemisphereLight, geometry );\n            \n                #ifdef DOUBLE_SIDED\n            \n                    vIndirectBack += getHemisphereLightIrradiance( hemisphereLight, backGeometry );\n            \n                #endif\n            }            \n        #else\n            vIndirectFront += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry );\n    \n            #ifdef DOUBLE_SIDED\n    \n                vIndirectBack += getHemisphereLightIrradiance( hemisphereLights[ i ], backGeometry );\n    \n            #endif\n        #endif\n    }\n    // #end unroll_loop\n\n#endif",
        lights_pars_begin: "uniform vec3 ambientLightColor;\nuniform vec3 lightProbe[ 9 ];\n\n// get the irradiance (radiance convolved with cosine lobe) at the point 'normal' on the unit sphere\n// source: https://graphics.stanford.edu/papers/envmap/envmap.pdf\nvec3 shGetIrradianceAt( in vec3 normal, in vec3 shCoefficients[ 9 ] ) {\n\n // normal is assumed to have unit length\n\n    float x = normal.x, y = normal.y, z = normal.z;\n\n    // band 0\n    vec3 result = shCoefficients[ 0 ] * 0.886227;\n\n    // band 1\n    result += shCoefficients[ 1 ] * 2.0 * 0.511664 * y;\n    result += shCoefficients[ 2 ] * 2.0 * 0.511664 * z;\n    result += shCoefficients[ 3 ] * 2.0 * 0.511664 * x;\n\n    // band 2\n    result += shCoefficients[ 4 ] * 2.0 * 0.429043 * x * y;\n    result += shCoefficients[ 5 ] * 2.0 * 0.429043 * y * z;\n    result += shCoefficients[ 6 ] * ( 0.743125 * z * z - 0.247708 );\n    result += shCoefficients[ 7 ] * 2.0 * 0.429043 * x * z;\n    result += shCoefficients[ 8 ] * 0.429043 * ( x * x - y * y );\n\n    return result;\n\n}\n\nvec3 getLightProbeIrradiance( const in vec3 lightProbe[ 9 ], const in GeometricContext geometry ) {\n\n    vec3 worldNormal = inverseTransformDirection( geometry.normal, viewMatrix );\n\n    vec3 irradiance = shGetIrradianceAt( worldNormal, lightProbe );\n\n    return irradiance;\n\n}\n\nvec3 getAmbientLightIrradiance( const in vec3 ambientLightColor ) {\n\n    vec3 irradiance = ambientLightColor;\n\n    #ifndef PHYSICALLY_CORRECT_LIGHTS\n\n        irradiance *= PI;\n\n    #endif\n\n    return irradiance;\n\n}\n\n// modified by egret\n#ifdef EGRET\n#define DIR_LIGHT_SIZE 43\n#define POINT_LIGHT_SIZE 47\n#define SPOT_LIGHT_SIZE 50\n#define RECT_AREA_LIGHT_SIZE 44\n#define HEMI_LIGHT_SIZE 41\n#endif\n\n#if NUM_DIR_LIGHTS > 0\n\n    struct DirectionalLight {\n        vec3 direction;\n        vec3 color;\n\n        int shadow;\n        float shadowBias;\n        float shadowRadius;\n        vec2 shadowMapSize;\n        #ifdef EGRET\n        int cullingMask;\n        #endif\n    };\n\n    #ifdef EGRET  \n        uniform float directionalLights[ NUM_DIR_LIGHTS * DIR_LIGHT_SIZE ];\n    #else\n        uniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];\n    #endif\n\n    void getDirectionalDirectLightIrradiance( const in DirectionalLight directionalLight, const in GeometricContext geometry, out IncidentLight directLight ) {\n\n        directLight.color = directionalLight.color;\n        directLight.direction = directionalLight.direction;\n        directLight.visible = true;\n\n    }\n\n#endif\n\n\n#if NUM_POINT_LIGHTS > 0\n\n    struct PointLight {\n        vec3 position;\n        vec3 color;\n        float distance;\n        float decay;\n\n        int shadow;\n        float shadowBias;\n        float shadowRadius;\n        vec2 shadowMapSize;\n        float shadowCameraNear;\n        float shadowCameraFar;\n        #ifdef EGRET\n        int cullingMask;\n        #endif\n    };\n\n    #ifdef EGRET  \n        uniform float pointLights[ NUM_POINT_LIGHTS * POINT_LIGHT_SIZE ];\n    #else\n        uniform PointLight pointLights[ NUM_POINT_LIGHTS ];\n    #endif\n\n    // directLight is an out parameter as having it as a return value caused compiler errors on some devices\n    void getPointDirectLightIrradiance( const in PointLight pointLight, const in GeometricContext geometry, out IncidentLight directLight ) {\n\n        vec3 lVector = pointLight.position - geometry.position;\n        directLight.direction = normalize( lVector );\n\n        float lightDistance = length( lVector );\n\n        directLight.color = pointLight.color;\n        directLight.color *= punctualLightIntensityToIrradianceFactor( lightDistance, pointLight.distance, pointLight.decay );\n        directLight.visible = ( directLight.color != vec3( 0.0 ) );\n\n    }\n\n#endif\n\n\n#if NUM_SPOT_LIGHTS > 0\n\n    struct SpotLight {\n        vec3 position;\n        vec3 direction;\n        vec3 color;\n        float distance;\n        float decay;\n        float coneCos;\n        float penumbraCos;\n\n        int shadow;\n        float shadowBias;\n        float shadowRadius;\n        vec2 shadowMapSize;\n        #ifdef EGRET\n        int cullingMask;\n        #endif\n    };\n\n    #ifdef EGRET  \n        uniform float spotLights[ NUM_SPOT_LIGHTS * SPOT_LIGHT_SIZE ]; // modified by egret\n    #else\n        uniform SpotLight spotLights[ NUM_SPOT_LIGHTS ];\n    #endif\n\n    // directLight is an out parameter as having it as a return value caused compiler errors on some devices\n    void getSpotDirectLightIrradiance( const in SpotLight spotLight, const in GeometricContext geometry, out IncidentLight directLight  ) {\n\n        vec3 lVector = spotLight.position - geometry.position;\n        directLight.direction = normalize( lVector );\n\n        float lightDistance = length( lVector );\n        float angleCos = dot( directLight.direction, spotLight.direction );\n\n        if ( angleCos > spotLight.coneCos ) {\n\n            float spotEffect = smoothstep( spotLight.coneCos, spotLight.penumbraCos, angleCos );\n\n            directLight.color = spotLight.color;\n            directLight.color *= spotEffect * punctualLightIntensityToIrradianceFactor( lightDistance, spotLight.distance, spotLight.decay );\n            directLight.visible = true;\n\n        } else {\n\n            directLight.color = vec3( 0.0 );\n            directLight.visible = false;\n\n        }\n    }\n\n#endif\n\n\n#if NUM_RECT_AREA_LIGHTS > 0\n\n    struct RectAreaLight {\n        vec3 color;\n        vec3 position;\n        vec3 halfWidth;\n        vec3 halfHeight;\n        #ifdef EGRET\n        int cullingMask;\n        #endif\n    };\n\n    // Pre-computed values of LinearTransformedCosine approximation of BRDF\n    // BRDF approximation Texture is 64x64\n    uniform sampler2D ltc_1; // RGBA Float\n    uniform sampler2D ltc_2; // RGBA Float\n\n    #ifdef EGRET  \n        uniform float rectAreaLights[ NUM_RECT_AREA_LIGHTS * RECT_AREA_LIGHT_SIZE ]; // modified by egret\n    #else\n        uniform RectAreaLight rectAreaLights[ NUM_RECT_AREA_LIGHTS ];\n    #endif\n\n#endif\n\n\n#if NUM_HEMI_LIGHTS > 0\n\n    struct HemisphereLight {\n        vec3 direction;\n        vec3 skyColor;\n        vec3 groundColor;\n        #ifdef EGRET\n        int cullingMask;\n        #endif\n    };\n\n\n    #ifdef EGRET  \n        uniform float hemisphereLights[NUM_HEMI_LIGHTS * HEMI_LIGHT_SIZE ]; // modified by egret\n    #else\n        uniform HemisphereLight hemisphereLights[ NUM_HEMI_LIGHTS ];\n    #endif\n\n\n    vec3 getHemisphereLightIrradiance( const in HemisphereLight hemiLight, const in GeometricContext geometry ) {\n\n        float dotNL = dot( geometry.normal, hemiLight.direction );\n        float hemiDiffuseWeight = 0.5 * dotNL + 0.5;\n\n        vec3 irradiance = mix( hemiLight.groundColor, hemiLight.skyColor, hemiDiffuseWeight );\n\n        #ifndef PHYSICALLY_CORRECT_LIGHTS\n\n            irradiance *= PI;\n\n        #endif\n\n        return irradiance;\n\n    }\n\n#endif",
        lights_pars_maps: "#if defined( USE_ENVMAP ) && defined( PHYSICAL )\n\n vec3 getLightProbeIndirectIrradiance( /*const in SpecularLightProbe specularLightProbe,*/ const in GeometricContext geometry, const in int maxMIPLevel ) {\n\n        vec3 worldNormal = inverseTransformDirection( geometry.normal, viewMatrix );\n\n        #ifdef ENVMAP_TYPE_CUBE\n\n            vec3 queryVec = vec3( flipEnvMap * worldNormal.x, worldNormal.yz );\n\n            // TODO: replace with properly filtered cubemaps and access the irradiance LOD level, be it the last LOD level\n            // of a specular cubemap, or just the default level of a specially created irradiance cubemap.\n\n            #ifdef TEXTURE_LOD_EXT\n\n                vec4 envMapColor = textureCubeLodEXT( envMap, queryVec, float( maxMIPLevel ) );\n\n            #else\n\n                // force the bias high to get the last LOD level as it is the most blurred.\n                vec4 envMapColor = textureCube( envMap, queryVec, float( maxMIPLevel ) );\n\n            #endif\n\n            envMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\n\n        #elif defined( ENVMAP_TYPE_CUBE_UV )\n\n            vec3 queryVec = vec3( flipEnvMap * worldNormal.x, worldNormal.yz );\n            vec4 envMapColor = textureCubeUV( queryVec, 1.0 );\n\n        #else\n\n            vec4 envMapColor = vec4( 0.0 );\n\n        #endif\n\n        return PI * envMapColor.rgb * envMapIntensity;\n\n    }\n\n    // taken from here: http://casual-effects.blogspot.ca/2011/08/plausible-environment-lighting-in-two.html\n    float getSpecularMIPLevel( const in float blinnShininessExponent, const in int maxMIPLevel ) {\n\n        //float envMapWidth = pow( 2.0, maxMIPLevelScalar );\n        //float desiredMIPLevel = log2( envMapWidth * sqrt( 3.0 ) ) - 0.5 * log2( pow2( blinnShininessExponent ) + 1.0 );\n\n        float maxMIPLevelScalar = float( maxMIPLevel );\n        float desiredMIPLevel = maxMIPLevelScalar + 0.79248 - 0.5 * log2( pow2( blinnShininessExponent ) + 1.0 );\n\n        // clamp to allowable LOD ranges.\n        return clamp( desiredMIPLevel, 0.0, maxMIPLevelScalar );\n\n    }\n\n    vec3 getLightProbeIndirectRadiance( /*const in SpecularLightProbe specularLightProbe,*/ const in GeometricContext geometry, const in float blinnShininessExponent, const in int maxMIPLevel ) {\n\n        #ifdef EGRET  \n            #ifndef ENVMAP_MODE_REFRACTION // modified by egret\n                vec3 reflectVec = reflect( -viewDir, normal );\n\n                // Mixing the reflection with the normal is more accurate and keeps rough objects from gathering light from behind their tangent plane.\n                reflectVec = normalize( mix( reflectVec, normal, roughness * roughness) );\n            #else\n                vec3 reflectVec = refract( -viewDir, normal, refractionRatio );\n            #endif\n        #else\n            #ifdef ENVMAP_MODE_REFLECTION\n\n                vec3 reflectVec = reflect( -viewDir, normal );\n\n                // Mixing the reflection with the normal is more accurate and keeps rough objects from gathering light from behind their tangent plane.\n                reflectVec = normalize( mix( reflectVec, normal, roughness * roughness) );\n\n             #else\n\n                vec3 reflectVec = refract( -viewDir, normal, refractionRatio );\n\n             #endif\n        #endif\n\n        reflectVec = inverseTransformDirection( reflectVec, viewMatrix );\n\n        float specularMIPLevel = getSpecularMIPLevel( blinnShininessExponent, maxMIPLevel );\n\n        #ifdef ENVMAP_TYPE_CUBE\n\n            vec3 queryReflectVec = vec3( flipEnvMap * reflectVec.x, reflectVec.yz );\n\n            #ifdef TEXTURE_LOD_EXT\n\n                vec4 envMapColor = textureCubeLodEXT( envMap, queryReflectVec, specularMIPLevel );\n\n            #else\n\n                vec4 envMapColor = textureCube( envMap, queryReflectVec, specularMIPLevel );\n\n            #endif\n\n            envMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\n\n        #elif defined( ENVMAP_TYPE_CUBE_UV )\n\n            vec3 queryReflectVec = vec3( flipEnvMap * reflectVec.x, reflectVec.yz );\n            vec4 envMapColor = textureCubeUV(queryReflectVec, BlinnExponentToGGXRoughness(blinnShininessExponent));\n\n        #elif defined( ENVMAP_TYPE_EQUIREC )\n\n            vec2 sampleUV;\n            sampleUV.y = asin( clamp( reflectVec.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;\n            sampleUV.x = atan( reflectVec.z, reflectVec.x ) * RECIPROCAL_PI2 + 0.5;\n\n            #ifdef TEXTURE_LOD_EXT\n\n                vec4 envMapColor = texture2DLodEXT( envMap, sampleUV, specularMIPLevel );\n\n            #else\n\n                vec4 envMapColor = texture2D( envMap, sampleUV, specularMIPLevel );\n\n            #endif\n\n            envMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\n\n        #elif defined( ENVMAP_TYPE_SPHERE )\n\n            #ifdef EGRET  \n                // modified by egret\n                vec3 reflectView = normalize( ( viewMatrix * vec4( reflectVec, 0.0 ) ).xyz + vec3( 0.0, 0.0, -1.0 ) );\n                reflectView = vec3(reflectView.x * 0.5 + 0.5, 1.0 - (reflectView.y * 0.5 + 0.5), 0.0);\n            #else\n                vec3 reflectView = normalize( ( viewMatrix * vec4( reflectVec, 0.0 ) ).xyz + vec3( 0.0, 0.0, 1.0 ) );\n            #endif\n\n            \n            #ifdef TEXTURE_LOD_EXT\n\n                // vec4 envMapColor = texture2DLodEXT( envMap, reflectView.xy * 0.5 + 0.5, specularMIPLevel );\n                vec4 envMapColor = texture2DLodEXT( envMap, reflectView.xy, specularMIPLevel );\n\n            #else\n\n                // vec4 envMapColor = texture2D( envMap, reflectView.xy * 0.5 + 0.5, specularMIPLevel );\n                vec4 envMapColor = texture2D( envMap, reflectView.xy, specularMIPLevel );\n\n            #endif\n\n            envMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\n\n        #endif\n\n        return envMapColor.rgb * envMapIntensity;\n\n    }\n\n#endif",
        lights_phong_fragment: "BlinnPhongMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb;\nmaterial.specularColor = specular;\nmaterial.specularShininess = shininess;\nmaterial.specularStrength = specularStrength;",
        lights_phong_pars_fragment: "varying vec3 vViewPosition;\n\n#ifndef FLAT_SHADED\n\n varying vec3 vNormal;\n\n#endif\n\n\nstruct BlinnPhongMaterial {\n\n    vec3    diffuseColor;\n    vec3    specularColor;\n    float    specularShininess;\n    float    specularStrength;\n\n};\n\nvoid RE_Direct_BlinnPhong( const in IncidentLight directLight, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\n\n    #ifdef TOON\n\n        vec3 irradiance = getGradientIrradiance( geometry.normal, directLight.direction ) * directLight.color;\n\n    #else\n\n        float dotNL = saturate( dot( geometry.normal, directLight.direction ) );\n        vec3 irradiance = dotNL * directLight.color;\n\n    #endif\n\n    #ifndef PHYSICALLY_CORRECT_LIGHTS\n\n        irradiance *= PI; // punctual light\n\n    #endif\n\n    reflectedLight.directDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n\n    reflectedLight.directSpecular += irradiance * BRDF_Specular_BlinnPhong( directLight, geometry, material.specularColor, material.specularShininess ) * material.specularStrength;\n\n}\n\nvoid RE_IndirectDiffuse_BlinnPhong( const in vec3 irradiance, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\n\n    reflectedLight.indirectDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n\n}\n\n#define RE_Direct                RE_Direct_BlinnPhong\n#define RE_IndirectDiffuse        RE_IndirectDiffuse_BlinnPhong\n\n#define Material_LightProbeLOD( material )    (0)",
        lights_physical_fragment: "PhysicalMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb * ( 1.0 - metalnessFactor );\nmaterial.specularRoughness = clamp( roughnessFactor, 0.04, 1.0 );\n\n#ifdef REFLECTIVITY\n\n material.specularColor = mix( vec3( MAXIMUM_SPECULAR_COEFFICIENT * pow2( reflectivity ) ), diffuseColor.rgb, metalnessFactor );\n\n#else\n\n    material.specularColor = mix( vec3( DEFAULT_SPECULAR_COEFFICIENT ), diffuseColor.rgb, metalnessFactor );\n\n#endif\n\n#ifdef CLEARCOAT\n\n    material.clearcoat = saturate( clearcoat ); // Burley clearcoat model\n    material.clearcoatRoughness = clamp( clearcoatRoughness, 0.04, 1.0 );\n\n#endif\n#ifdef USE_SHEEN\n\n    material.sheenColor = sheen;\n\n#endif",
        lights_physical_pars_fragment: "struct PhysicalMaterial {\n\n vec3    diffuseColor;\n    float    specularRoughness;\n    vec3    specularColor;\n\n#ifdef CLEARCOAT\n    float clearcoat;\n    float clearcoatRoughness;\n#endif\n#ifdef USE_SHEEN\n    vec3 sheenColor;\n#endif\n\n};\n\n#define MAXIMUM_SPECULAR_COEFFICIENT 0.16\n#define DEFAULT_SPECULAR_COEFFICIENT 0.04\n\n// Clear coat directional hemishperical reflectance (this approximation should be improved)\nfloat clearcoatDHRApprox( const in float roughness, const in float dotNL ) {\n\n    return DEFAULT_SPECULAR_COEFFICIENT + ( 1.0 - DEFAULT_SPECULAR_COEFFICIENT ) * ( pow( 1.0 - dotNL, 5.0 ) * pow( 1.0 - roughness, 2.0 ) );\n\n}\n\n#if NUM_RECT_AREA_LIGHTS > 0\n\n    void RE_Direct_RectArea_Physical( const in RectAreaLight rectAreaLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\n        vec3 normal = geometry.normal;\n        vec3 viewDir = geometry.viewDir;\n        vec3 position = geometry.position;\n        vec3 lightPos = rectAreaLight.position;\n        vec3 halfWidth = rectAreaLight.halfWidth;\n        vec3 halfHeight = rectAreaLight.halfHeight;\n        vec3 lightColor = rectAreaLight.color;\n        float roughness = material.specularRoughness;\n\n        vec3 rectCoords[ 4 ];\n        rectCoords[ 0 ] = lightPos + halfWidth - halfHeight; // counterclockwise; light shines in local neg z direction\n        rectCoords[ 1 ] = lightPos - halfWidth - halfHeight;\n        rectCoords[ 2 ] = lightPos - halfWidth + halfHeight;\n        rectCoords[ 3 ] = lightPos + halfWidth + halfHeight;\n\n        vec2 uv = LTC_Uv( normal, viewDir, roughness );\n\n        vec4 t1 = texture2D( ltc_1, uv );\n        vec4 t2 = texture2D( ltc_2, uv );\n\n        mat3 mInv = mat3(\n            vec3( t1.x, 0, t1.y ),\n            vec3(    0, 1,    0 ),\n            vec3( t1.z, 0, t1.w )\n        );\n\n        // LTC Fresnel Approximation by Stephen Hill\n        // http://blog.selfshadow.com/publications/s2016-advances/s2016_ltc_fresnel.pdf\n        vec3 fresnel = ( material.specularColor * t2.x + ( vec3( 1.0 ) - material.specularColor ) * t2.y );\n\n        reflectedLight.directSpecular += lightColor * fresnel * LTC_Evaluate( normal, viewDir, position, mInv, rectCoords );\n\n        reflectedLight.directDiffuse += lightColor * material.diffuseColor * LTC_Evaluate( normal, viewDir, position, mat3( 1.0 ), rectCoords );\n\n    }\n\n#endif\n\nvoid RE_Direct_Physical( const in IncidentLight directLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\n    float dotNL = saturate( dot( geometry.normal, directLight.direction ) );\n\n    vec3 irradiance = dotNL * directLight.color;\n\n    #ifndef PHYSICALLY_CORRECT_LIGHTS\n\n        irradiance *= PI; // punctual light\n\n    #endif\n\n    #ifdef CLEARCOAT\n\n        float ccDotNL = saturate( dot( geometry.clearcoatNormal, directLight.direction ) );\n\n        vec3 ccIrradiance = ccDotNL * directLight.color;\n\n        #ifndef PHYSICALLY_CORRECT_LIGHTS\n\n            ccIrradiance *= PI; // punctual light\n\n        #endif\n\n        float clearcoatDHR = material.clearcoat * clearcoatDHRApprox( material.clearcoatRoughness, ccDotNL );\n\n        reflectedLight.directSpecular += ccIrradiance * material.clearcoat * BRDF_Specular_GGX( directLight, geometry.viewDir, geometry.clearcoatNormal, vec3( DEFAULT_SPECULAR_COEFFICIENT ), material.clearcoatRoughness );\n\n    #else\n\n        float clearcoatDHR = 0.0;\n\n    #endif\n\n    #ifdef USE_SHEEN\n        reflectedLight.directSpecular += ( 1.0 - clearcoatDHR ) * irradiance * BRDF_Specular_Sheen(\n            material.specularRoughness,\n            directLight.direction,\n            geometry,\n            material.sheenColor\n        );\n    #else\n        reflectedLight.directSpecular += ( 1.0 - clearcoatDHR ) * irradiance * BRDF_Specular_GGX( directLight, geometry.viewDir, geometry.normal, material.specularColor, material.specularRoughness);\n    #endif\n\n    reflectedLight.directDiffuse += ( 1.0 - clearcoatDHR ) * irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n}\n\nvoid RE_IndirectDiffuse_Physical( const in vec3 irradiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\n    reflectedLight.indirectDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n\n}\n\nvoid RE_IndirectSpecular_Physical( const in vec3 radiance, const in vec3 irradiance, const in vec3 clearcoatRadiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight) {\n\n    #ifdef CLEARCOAT\n\n        float ccDotNV = saturate( dot( geometry.clearcoatNormal, geometry.viewDir ) );\n\n        reflectedLight.indirectSpecular += clearcoatRadiance * material.clearcoat * BRDF_Specular_GGX_Environment( geometry.viewDir, geometry.clearcoatNormal, vec3( DEFAULT_SPECULAR_COEFFICIENT ), material.clearcoatRoughness );\n\n        float ccDotNL = ccDotNV;\n        float clearcoatDHR = material.clearcoat * clearcoatDHRApprox( material.clearcoatRoughness, ccDotNL );\n\n    #else\n\n        float clearcoatDHR = 0.0;\n\n    #endif\n\n    float clearcoatInv = 1.0 - clearcoatDHR;\n\n    // Both indirect specular and diffuse light accumulate here\n    // if energy preservation enabled, and PMREM provided.\n\n    vec3 singleScattering = vec3( 0.0 );\n    vec3 multiScattering = vec3( 0.0 );\n    vec3 cosineWeightedIrradiance = irradiance * RECIPROCAL_PI;\n\n    BRDF_Specular_Multiscattering_Environment( geometry, material.specularColor, material.specularRoughness, singleScattering, multiScattering );\n\n    vec3 diffuse = material.diffuseColor * ( 1.0 - ( singleScattering + multiScattering ) );\n\n    reflectedLight.indirectSpecular += clearcoatInv * radiance * singleScattering;\n    reflectedLight.indirectDiffuse += multiScattering * cosineWeightedIrradiance;\n    reflectedLight.indirectDiffuse += diffuse * cosineWeightedIrradiance;\n\n}\n\n#define RE_Direct                RE_Direct_Physical\n#define RE_Direct_RectArea        RE_Direct_RectArea_Physical\n#define RE_IndirectDiffuse        RE_IndirectDiffuse_Physical\n#define RE_IndirectSpecular        RE_IndirectSpecular_Physical\n\n// ref: https://seblagarde.files.wordpress.com/2015/07/course_notes_moving_frostbite_to_pbr_v32.pdf\nfloat computeSpecularOcclusion( const in float dotNV, const in float ambientOcclusion, const in float roughness ) {\n\n    return saturate( pow( dotNV + ambientOcclusion, exp2( - 16.0 * roughness - 1.0 ) ) - 1.0 + ambientOcclusion );\n\n}",
        logdepthbuf_fragment: "#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )\n\n gl_FragDepthEXT = log2( vFragDepth ) * logDepthBufFC * 0.5;\n\n#endif",
        logdepthbuf_pars_fragment: "#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )\n\n uniform float logDepthBufFC;\n    varying float vFragDepth;\n\n#endif",
        logdepthbuf_pars_vertex: "#ifdef USE_LOGDEPTHBUF\n\n #ifdef USE_LOGDEPTHBUF_EXT\n\n        varying float vFragDepth;\n\n    #else\n\n        uniform float logDepthBufFC;\n\n    #endif\n\n#endif",
        logdepthbuf_vertex: "#ifdef USE_LOGDEPTHBUF\n\n #ifdef USE_LOGDEPTHBUF_EXT\n\n        vFragDepth = 1.0 + gl_Position.w;\n\n    #else\n\n        gl_Position.z = log2( max( EPSILON, gl_Position.w + 1.0 ) ) * logDepthBufFC - 1.0;\n\n        gl_Position.z *= gl_Position.w;\n\n    #endif\n\n#endif",
        map_fragment: "#ifdef USE_MAP\n\n vec4 texelColor = texture2D( map, vUv );\n\n    texelColor = mapTexelToLinear( texelColor );\n    diffuseColor *= texelColor;\n\n#endif",
        map_pars_fragment: "#ifdef USE_MAP\n\n uniform sampler2D map;\n\n#endif",
        map_particle_fragment: "#ifdef USE_MAP\n\n vec2 uv = ( uvTransform * vec3( gl_PointCoord.x, 1.0 - gl_PointCoord.y, 1 ) ).xy;\n    vec4 mapTexel = texture2D( map, uv );\n    diffuseColor *= mapTexelToLinear( mapTexel );\n\n#endif",
        map_particle_pars_fragment: "#ifdef USE_MAP\n\n uniform mat3 uvTransform;\n    uniform sampler2D map;\n\n#endif",
        metalnessmap_fragment: "float metalnessFactor = metalness;\n\n#ifdef USE_METALNESSMAP\n\n vec4 texelMetalness = texture2D( metalnessMap, vUv );\n\n    // reads channel B, compatible with a combined OcclusionRoughnessMetallic (RGB) texture\n    metalnessFactor *= texelMetalness.b;\n\n#endif",
        metalnessmap_pars_fragment: "#ifdef USE_METALNESSMAP\n\n uniform sampler2D metalnessMap;\n\n#endif",
        morphnormal_vertex: "#ifdef USE_MORPHNORMALS\n\n objectNormal += ( morphNormal0 - normal ) * morphTargetInfluences[ 0 ];\n    objectNormal += ( morphNormal1 - normal ) * morphTargetInfluences[ 1 ];\n    objectNormal += ( morphNormal2 - normal ) * morphTargetInfluences[ 2 ];\n    objectNormal += ( morphNormal3 - normal ) * morphTargetInfluences[ 3 ];\n\n#endif",
        morphtarget_pars_vertex: "#ifdef USE_MORPHTARGETS\n\n #ifndef USE_MORPHNORMALS\n\n    uniform float morphTargetInfluences[ 8 ];\n\n    #else\n\n    uniform float morphTargetInfluences[ 4 ];\n\n    #endif\n\n#endif",
        morphtarget_vertex: "#ifdef USE_MORPHTARGETS\n\n transformed += ( morphTarget0 - position ) * morphTargetInfluences[ 0 ];\n    transformed += ( morphTarget1 - position ) * morphTargetInfluences[ 1 ];\n    transformed += ( morphTarget2 - position ) * morphTargetInfluences[ 2 ];\n    transformed += ( morphTarget3 - position ) * morphTargetInfluences[ 3 ];\n\n    #ifndef USE_MORPHNORMALS\n\n    transformed += ( morphTarget4 - position ) * morphTargetInfluences[ 4 ];\n    transformed += ( morphTarget5 - position ) * morphTargetInfluences[ 5 ];\n    transformed += ( morphTarget6 - position ) * morphTargetInfluences[ 6 ];\n    transformed += ( morphTarget7 - position ) * morphTargetInfluences[ 7 ];\n\n    #endif\n\n#endif",
        normalmap_pars_fragment: "#ifdef USE_NORMALMAP\n\n uniform sampler2D normalMap;\n    uniform vec2 normalScale;\n\n#endif\n\n#ifdef OBJECTSPACE_NORMALMAP\n\n    uniform mat3 normalMatrix;\n\n#endif\n\n#if ! defined ( USE_TANGENT ) && ( defined ( TANGENTSPACE_NORMALMAP ) || defined ( USE_CLEARCOAT_NORMALMAP ) )\n\n    // Per-Pixel Tangent Space Normal Mapping\n    // http://hacksoflife.blogspot.ch/2009/11/per-pixel-tangent-space-normal-mapping.html\n\n    vec3 perturbNormal2Arb( vec3 eye_pos, vec3 surf_norm, vec2 normalScale, in sampler2D normalMap ) {\n\n        // Workaround for Adreno 3XX dFd*( vec3 ) bug. See #9988\n\n        vec3 q0 = vec3( dFdx( eye_pos.x ), dFdx( eye_pos.y ), dFdx( eye_pos.z ) );\n        vec3 q1 = vec3( dFdy( eye_pos.x ), dFdy( eye_pos.y ), dFdy( eye_pos.z ) );\n        vec2 st0 = dFdx( vUv.st );\n        vec2 st1 = dFdy( vUv.st );\n\n        float scale = sign( st1.t * st0.s - st0.t * st1.s ); // we do not care about the magnitude\n\n        vec3 S = normalize( ( q0 * st1.t - q1 * st0.t ) * scale );\n        vec3 T = normalize( ( - q0 * st1.s + q1 * st0.s ) * scale );\n        vec3 N = normalize( surf_norm );\n\n        vec3 mapN = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;\n\n        mapN.xy *= normalScale;\n\n        #ifdef DOUBLE_SIDED\n\n            // Workaround for Adreno GPUs gl_FrontFacing bug. See #15850 and #10331\n            // http://hacksoflife.blogspot.com/2009/11/per-pixel-tangent-space-normal-mapping.html?showComment=1522254677437#c5087545147696715943\n            vec3 NfromST = cross( S, T );\n            if( dot( NfromST, N ) > 0.0 ) {\n\n                S *= -1.0;\n                T *= -1.0;\n\n            }\n\n        #else\n\n            mapN.xy *= ( float( gl_FrontFacing ) * 2.0 - 1.0 );\n\n        #endif\n\n        mat3 tsn = mat3( S, T, N );\n        return normalize( tsn * mapN );\n\n    }\n\n#endif",
        normal_fragment_begin: "#ifdef FLAT_SHADED\n\n // Workaround for Adreno/Nexus5 not able able to do dFdx( vViewPosition ) ...\n\n    vec3 fdx = vec3( dFdx( vViewPosition.x ), dFdx( vViewPosition.y ), dFdx( vViewPosition.z ) );\n    vec3 fdy = vec3( dFdy( vViewPosition.x ), dFdy( vViewPosition.y ), dFdy( vViewPosition.z ) );\n    vec3 normal = normalize( cross( fdx, fdy ) );\n\n#else\n\n    vec3 normal = normalize( vNormal );\n\n    #ifdef DOUBLE_SIDED\n\n        normal = normal * ( float( gl_FrontFacing ) * 2.0 - 1.0 );\n\n    #endif\n\n    #ifdef USE_TANGENT\n\n        vec3 tangent = normalize( vTangent );\n        vec3 bitangent = normalize( vBitangent );\n\n        #ifdef DOUBLE_SIDED\n\n            tangent = tangent * ( float( gl_FrontFacing ) * 2.0 - 1.0 );\n            bitangent = bitangent * ( float( gl_FrontFacing ) * 2.0 - 1.0 );\n\n        #endif\n\n    #endif\n\n#endif\n\n// non perturbed normal for clearcoat among others\n\nvec3 geometryNormal = normal;",
        normal_fragment_maps: "#ifdef OBJECTSPACE_NORMALMAP\n\n normal = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0; // overrides both flatShading and attribute normals\n\n    #ifdef FLIP_SIDED\n\n        normal = - normal;\n\n    #endif\n\n    #ifdef DOUBLE_SIDED\n\n        normal = normal * ( float( gl_FrontFacing ) * 2.0 - 1.0 );\n\n    #endif\n\n    normal = normalize( normalMatrix * normal );\n\n#elif defined( TANGENTSPACE_NORMALMAP )\n\n    #ifdef USE_TANGENT\n\n        mat3 vTBN = mat3( tangent, bitangent, normal );\n        vec3 mapN = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;\n        mapN.xy = normalScale * mapN.xy;\n        normal = normalize( vTBN * mapN );\n\n    #else\n\n        normal = perturbNormal2Arb( -vViewPosition, normal, normalScale, normalMap );\n\n    #endif\n\n#elif defined( USE_BUMPMAP )\n\n    normal = perturbNormalArb( -vViewPosition, normal, dHdxy_fwd() );\n\n#endif",
        packing: "vec3 packNormalToRGB( const in vec3 normal ) {\n return normalize( normal ) * 0.5 + 0.5;\n}\n\nvec3 unpackRGBToNormal( const in vec3 rgb ) {\n    return 2.0 * rgb.xyz - 1.0;\n}\n\nconst float PackUpscale = 256. / 255.; // fraction -> 0..1 (including 1)\nconst float UnpackDownscale = 255. / 256.; // 0..1 -> fraction (excluding 1)\n\nconst vec3 PackFactors = vec3( 256. * 256. * 256., 256. * 256.,  256. );\nconst vec4 UnpackFactors = UnpackDownscale / vec4( PackFactors, 1. );\n\nconst float ShiftRight8 = 1. / 256.;\n\nvec4 packDepthToRGBA( const in float v ) {\n    vec4 r = vec4( fract( v * PackFactors ), v );\n    r.yzw -= r.xyz * ShiftRight8; // tidy overflow\n    return r * PackUpscale;\n}\n\nfloat unpackRGBAToDepth( const in vec4 v ) {\n    return dot( v, UnpackFactors );\n}\n\nvec4 encodeHalfRGBA ( vec2 v ) {\n    vec4 encoded = vec4( 0.0 );\n    const vec2 offset = vec2( 1.0 / 255.0, 0.0 );\n\n    encoded.xy = vec2( v.x, fract( v.x * 255.0 ) );\n    encoded.xy = encoded.xy - ( encoded.yy * offset );\n\n    encoded.zw = vec2( v.y, fract( v.y * 255.0 ) );\n    encoded.zw = encoded.zw - ( encoded.ww * offset );\n\n    return encoded;\n}\n\nvec2 decodeHalfRGBA( vec4 v ) {\n    return vec2( v.x + ( v.y / 255.0 ), v.z + ( v.w / 255.0 ) );\n}\n\n// NOTE: viewZ/eyeZ is < 0 when in front of the camera per OpenGL conventions\n\nfloat viewZToOrthographicDepth( const in float viewZ, const in float near, const in float far ) {\n    return ( viewZ + near ) / ( near - far );\n}\nfloat orthographicDepthToViewZ( const in float linearClipZ, const in float near, const in float far ) {\n    return linearClipZ * ( near - far ) - near;\n}\n\nfloat viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {\n    return (( near + viewZ ) * far ) / (( far - near ) * viewZ );\n}\nfloat perspectiveDepthToViewZ( const in float invClipZ, const in float near, const in float far ) {\n    return ( near * far ) / ( ( far - near ) * invClipZ - far );\n}",
        particle_affector: "vec3 lifeVelocity = computeVelocity(t);\nvec4 worldRotation;\nif(u_simulationSpace==1)\n worldRotation=startWorldRotation;\nelse\n    worldRotation=u_worldRotation;\nvec3 gravity=u_gravity*age;\nvec3 center=computePosition(startVelocity, lifeVelocity, age, t,gravity,worldRotation); \n#ifdef SPHERHBILLBOARD\n          vec2 corner=corner.xy;\n         vec3 cameraUpVector =normalize(cameraUp);\n         vec3 sideVector = normalize(cross(cameraForward,cameraUpVector));\n         vec3 upVector = normalize(cross(sideVector,cameraForward));\n           corner*=computeBillbardSize(startSize.xy,t);\n        #if defined(ROTATIONOVERLIFETIME)||defined(ROTATIONSEPERATE)\n            if(u_startRotation3D){\n                vec3 rotation=vec3(startRotation.xy,computeRotation(startRotation.z,age,t));\n                center += u_sizeScale.xzy*rotation_euler(corner.x*sideVector+corner.y*upVector,rotation);\n            }\n            else{\n                float rot = computeRotation(startRotation.x, age,t);\n                float c = cos(rot);\n                float s = sin(rot);\n                mat2 rotation= mat2(c, -s, s, c);\n                corner=rotation*corner;\n                center += u_sizeScale.xzy*(corner.x*sideVector+corner.y*upVector);\n            }\n        #else\n            if(u_startRotation3D){\n                center += u_sizeScale.xzy*rotation_euler(corner.x*sideVector+corner.y*upVector,startRotation);\n            }\n            else{\n                float c = cos(startRotation.x);\n                float s = sin(startRotation.x);\n                mat2 rotation= mat2(c, -s, s, c);\n                corner=rotation*corner;\n                center += u_sizeScale.xzy*(corner.x*sideVector+corner.y*upVector);\n            }\n        #endif\n    #endif\n    #ifdef STRETCHEDBILLBOARD\n        vec2 corner=corner.xy;\n        vec3 velocity;\n        #if defined(VELOCITYCONSTANT)||defined(VELOCITYCURVE)||defined(VELOCITYTWOCONSTANT)||defined(VELOCITYTWOCURVE)\n               if(u_spaceType==0)\n                      velocity=rotation_quaternions(u_sizeScale*(startVelocity+lifeVelocity),worldRotation)+gravity;\n               else\n                      velocity=rotation_quaternions(u_sizeScale*startVelocity,worldRotation)+lifeVelocity+gravity;\n         #else\n               velocity= rotation_quaternions(u_sizeScale*startVelocity,worldRotation)+gravity;\n         #endif    \n        vec3 cameraUpVector = normalize(velocity);\n        vec3 direction = normalize(center-cameraPosition);\n       vec3 sideVector = normalize(cross(direction,cameraUpVector));\n        sideVector=u_sizeScale.xzy*sideVector;\n        cameraUpVector=length(vec3(u_sizeScale.x,0.0,0.0))*cameraUpVector;\n       vec2 size=computeBillbardSize(startSize.xy,t);\n       const mat2 rotaionZHalfPI=mat2(0.0, -1.0, 1.0, 0.0);\n       corner=rotaionZHalfPI*corner;\n       corner.y=corner.y-abs(corner.y);\n       float speed=length(velocity);\n       center +=sign(u_sizeScale.x)*(sign(u_lengthScale)*size.x*corner.x*sideVector+(speed*u_speeaScale+size.y*u_lengthScale)*corner.y*cameraUpVector);\n    #endif\n    #ifdef HORIZONTALBILLBOARD\n        vec2 corner=corner.xy;\n       const vec3 cameraUpVector=vec3(0.0,0.0,1.0);\n       const vec3 sideVector = vec3(-1.0,0.0,0.0);\n        float rot = computeRotation(startRotation.x, age,t);\n       float c = cos(rot);\n       float s = sin(rot);\n       mat2 rotation= mat2(c, -s, s, c);\n       corner=rotation*corner;\n        corner*=computeBillbardSize(startSize.xy,t);\n       center +=u_sizeScale.xzy*(corner.x*sideVector+ corner.y*cameraUpVector);\n    #endif\n    #ifdef VERTICALBILLBOARD\n        vec2 corner=corner.xy;\n       const vec3 cameraUpVector =vec3(0.0,1.0,0.0);\n       vec3 sideVector = normalize(cross(cameraForward,cameraUpVector));\n        float rot = computeRotation(startRotation.x, age,t);\n       float c = cos(rot);\n       float s = sin(rot);\n       mat2 rotation= mat2(c, -s, s, c);\n       corner=rotation*corner;\n        corner*=computeBillbardSize(startSize.xy,t);\n       center +=u_sizeScale.xzy*(corner.x*sideVector+ corner.y*cameraUpVector);\n    #endif\n    #ifdef RENDERMESH\n       vec3 size=computeMeshSize(startSize,t);\n        #if defined(ROTATIONOVERLIFETIME)||defined(ROTATIONSEPERATE)\n                if(u_startRotation3D){\n                    vec3 rotation=vec3(startRotation.xy,-computeRotation(startRotation.z, age,t));\n                    center+= rotation_quaternions(u_sizeScale*rotation_euler(position*size,rotation),worldRotation);\n                }\n                else{\n                    #ifdef ROTATIONOVERLIFETIME\n                        float angle=computeRotation(startRotation.x, age,t);\n                        if(startPosition.x>0.1 || startPosition.x < -0.1||startPosition.y>0.1 || startPosition.y < -0.1){\n                            center+= (rotation_quaternions(rotation_axis(u_sizeScale*position*size,normalize(cross(vec3(0.0,0.0,1.0),vec3(startPosition.xy,0.0))),angle),worldRotation));//\n                        }\n                        else{\n                            #ifdef SHAPE\n                                center+= u_sizeScale.xzy*(rotation_quaternions(rotation_axis(position*size,vec3(0.0,-1.0,0.0),angle),worldRotation));\n                            #else\n                                if(u_simulationSpace==1)\n                                    center+=rotation_axis(u_sizeScale*position*size,vec3(0.0,0.0,-1.0),angle);\n                                else if(u_simulationSpace==0)\n                                    center+=rotation_quaternions(u_sizeScale*rotation_axis(position*size,vec3(0.0,0.0,-1.0),angle),worldRotation);\n                            #endif\n                        }\n                    #endif\n                    #ifdef ROTATIONSEPERATE\n                        vec3 angle=compute3DRotation(vec3(0.0,0.0,startRotation.z), age,t);\n                        center+= (rotation_quaternions(rotation_euler(u_sizeScale*position*size,vec3(angle.x,angle.y,angle.z)),worldRotation));\n                    #endif    \n                }\n        #else\n        if(u_startRotation3D){\n            center+= rotation_quaternions(u_sizeScale*rotation_euler(position*size,startRotation),worldRotation);\n        }\n        else{\n            if(startPosition.x>0.1 || startPosition.x < -0.1||startPosition.y>0.1 || startPosition.y < -0.1){\n                if(u_simulationSpace==1)\n                    center+= rotation_axis(u_sizeScale*position*size,normalize(cross(vec3(0.0,0.0,1.0),vec3(startPosition.xy,0.0))),startRotation.x);\n                else if(u_simulationSpace==0)\n                    center+= (rotation_quaternions(u_sizeScale*rotation_axis(position*size,normalize(cross(vec3(0.0,0.0,1.0),vec3(startPosition.xy,0.0))),startRotation.x),worldRotation));\n            }\n            else{\n                #ifdef SHAPE\n                    if(u_simulationSpace==1)\n                        center+= u_sizeScale*rotation_axis(position*size,vec3(0.0,-1.0,0.0),startRotation.x);\n                    else if(u_simulationSpace==0)\n                        center+= rotation_quaternions(u_sizeScale*rotation_axis(position*size,vec3(0.0,-1.0,0.0),startRotation.x),worldRotation);    \n                #else\n                    if(u_simulationSpace==1)\n                        center+= rotation_axis(u_sizeScale*position*size,vec3(0.0,0.0,-1.0),startRotation.x);\n                    else if(u_simulationSpace==0)\n                        center+= rotation_quaternions(u_sizeScale*rotation_axis(position*size,vec3(0.0,0.0,-1.0),startRotation.x),worldRotation);\n                #endif\n            }\n        }\n        #endif\n        // todo\n        // v_mesh_color=vec4(color, 1.0);\n        v_mesh_color=vec4(1.0, 1.0, 1.0, 1.0);\n     #endif",
        particle_common: "uniform float u_currentTime;\nuniform vec3 u_gravity;\n\nuniform vec3 u_worldPosition;\nuniform vec4 u_worldRotation;\nuniform bool u_startRotation3D;\nuniform int u_scalingMode;\nuniform vec3 u_positionScale;\nuniform vec3 u_sizeScale;\n\nuniform vec3 cameraForward;\nuniform vec3 cameraUp;\n\nuniform float u_lengthScale;\nuniform float u_speeaScale;\nuniform int u_simulationSpace;\n\n#if defined(VELOCITYCONSTANT)||defined(VELOCITYCURVE)||defined(VELOCITYTWOCONSTANT)||defined(VELOCITYTWOCURVE)\n  uniform int u_spaceType;\n#endif\n#if defined(VELOCITYCONSTANT)||defined(VELOCITYTWOCONSTANT)\n  uniform vec3 u_velocityConst;\n#endif\n#if defined(VELOCITYCURVE)||defined(VELOCITYTWOCURVE)\n  uniform vec2 u_velocityCurveX[4];\n  uniform vec2 u_velocityCurveY[4];\n  uniform vec2 u_velocityCurveZ[4];\n#endif\n#ifdef VELOCITYTWOCONSTANT\n  uniform vec3 u_velocityConstMax;\n#endif\n#ifdef VELOCITYTWOCURVE\n  uniform vec2 u_velocityCurveMaxX[4];\n  uniform vec2 u_velocityCurveMaxY[4];\n  uniform vec2 u_velocityCurveMaxZ[4];\n#endif\n\n#ifdef COLOROGRADIENT\n  uniform vec4 u_colorGradient[4];\n  uniform vec2 u_alphaGradient[4];\n#endif\n#ifdef COLORTWOGRADIENTS\n  uniform vec4 u_colorGradient[4];\n  uniform vec2 u_alphaGradient[4];\n  uniform vec4 u_colorGradientMax[4];\n  uniform vec2 u_alphaGradientMax[4];\n#endif\n\n#if defined(SIZECURVE)||defined(SIZETWOCURVES)\n  uniform vec2 u_sizeCurve[4];\n#endif\n#ifdef SIZETWOCURVES\n  uniform vec2 u_sizeCurveMax[4];\n#endif\n#if defined(SIZECURVESEPERATE)||defined(SIZETWOCURVESSEPERATE)\n  uniform vec2 u_sizeCurveX[4];\n  uniform vec2 u_sizeCurveY[4];\n  uniform vec2 u_sizeCurveZ[4];\n#endif\n#ifdef SIZETWOCURVESSEPERATE\n  uniform vec2 u_sizeCurveMaxX[4];\n  uniform vec2 u_sizeCurveMaxY[4];\n  uniform vec2 u_sizeCurveMaxZ[4];\n#endif\n\n#ifdef ROTATIONOVERLIFETIME\n  #if defined(ROTATIONCONSTANT)||defined(ROTATIONTWOCONSTANTS)\n    uniform float u_rotationConst;\n  #endif\n  #ifdef ROTATIONTWOCONSTANTS\n    uniform float u_rotationConstMax;\n  #endif\n  #if defined(ROTATIONCURVE)||defined(ROTATIONTWOCURVES)\n    uniform vec2 u_rotationCurve[4];\n  #endif\n  #ifdef ROTATIONTWOCURVES\n    uniform vec2 u_rotationCurveMax[4];\n  #endif\n#endif\n#ifdef ROTATIONSEPERATE\n  #if defined(ROTATIONCONSTANT)||defined(ROTATIONTWOCONSTANTS)\n    uniform vec3 u_rotationConstSeprarate;\n  #endif\n  #ifdef ROTATIONTWOCONSTANTS\n    uniform vec3 u_rotationConstMaxSeprarate;\n  #endif\n  #if defined(ROTATIONCURVE)||defined(ROTATIONTWOCURVES)\n    uniform vec2 u_rotationCurveX[4];\n    uniform vec2 u_rotationCurveY[4];\n    uniform vec2 u_rotationCurveZ[4];\n     uniform vec2 u_rotationCurveW[4];\n  #endif\n  #ifdef ROTATIONTWOCURVES\n    uniform vec2 u_rotationCurveMaxX[4];\n    uniform vec2 u_rotationCurveMaxY[4];\n    uniform vec2 u_rotationCurveMaxZ[4];\n        uniform vec2 u_rotationCurveMaxW[4];\n  #endif\n#endif\n\n#if defined(TEXTURESHEETANIMATIONCURVE)||defined(TEXTURESHEETANIMATIONTWOCURVE)\n  uniform float u_cycles;\n  uniform vec4 u_subUV;\n  uniform vec2 u_uvCurve[4];\n#endif\n#ifdef TEXTURESHEETANIMATIONTWOCURVE\n  uniform vec2 u_uvCurveMax[4];\n#endif\n\nvarying float v_discard;\nvarying vec4 v_color;\nvarying vec2 v_texcoord;\n#ifdef RENDERMESH\n    varying vec4 v_mesh_color;\n#endif\n\nvec3 rotation_euler(in vec3 vector,in vec3 euler)\n{\n  float halfPitch = euler.x * 0.5;\n    float halfYaw = euler.y * 0.5;\n    float halfRoll = euler.z * 0.5;\n\n    float sinPitch = sin(halfPitch);\n    float cosPitch = cos(halfPitch);\n    float sinYaw = sin(halfYaw);\n    float cosYaw = cos(halfYaw);\n    float sinRoll = sin(halfRoll);\n    float cosRoll = cos(halfRoll);\n\n    float quaX = (cosYaw * sinPitch * cosRoll) + (sinYaw * cosPitch * sinRoll);\n    float quaY = (sinYaw * cosPitch * cosRoll) - (cosYaw * sinPitch * sinRoll);\n    float quaZ = (cosYaw * cosPitch * sinRoll) - (sinYaw * sinPitch * cosRoll);\n    float quaW = (cosYaw * cosPitch * cosRoll) + (sinYaw * sinPitch * sinRoll);\n    \n    float x = quaX + quaX;\n  float y = quaY + quaY;\n  float z = quaZ + quaZ;\n  float wx = quaW * x;\n  float wy = quaW * y;\n  float wz = quaW * z;\n    float xx = quaX * x;\n  float xy = quaX * y;\n    float xz = quaX * z;\n  float yy = quaY * y;\n  float yz = quaY * z;\n  float zz = quaZ * z;\n\n  return vec3(((vector.x * ((1.0 - yy) - zz)) + (vector.y * (xy - wz))) + (vector.z * (xz + wy)),\n              ((vector.x * (xy + wz)) + (vector.y * ((1.0 - xx) - zz))) + (vector.z * (yz - wx)),\n              ((vector.x * (xz - wy)) + (vector.y * (yz + wx))) + (vector.z * ((1.0 - xx) - yy)));\n    \n}\n\nvec3 rotation_axis(in vec3 vector,in vec3 axis, in float angle)\n{\n    float halfAngle = angle * 0.5;\n    float sin = sin(halfAngle);\n    \n    float quaX = axis.x * sin;\n    float quaY = axis.y * sin;\n    float quaZ = axis.z * sin;\n    float quaW = cos(halfAngle);\n    \n    float x = quaX + quaX;\n  float y = quaY + quaY;\n  float z = quaZ + quaZ;\n  float wx = quaW * x;\n  float wy = quaW * y;\n  float wz = quaW * z;\n    float xx = quaX * x;\n  float xy = quaX * y;\n    float xz = quaX * z;\n  float yy = quaY * y;\n  float yz = quaY * z;\n  float zz = quaZ * z;\n\n  return vec3(((vector.x * ((1.0 - yy) - zz)) + (vector.y * (xy - wz))) + (vector.z * (xz + wy)),\n              ((vector.x * (xy + wz)) + (vector.y * ((1.0 - xx) - zz))) + (vector.z * (yz - wx)),\n              ((vector.x * (xz - wy)) + (vector.y * (yz + wx))) + (vector.z * ((1.0 - xx) - yy)));\n}\n\nvec3 rotation_quaternions(in vec3 v,in vec4 q) \n{\n    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);\n}\n\n#if defined(VELOCITYCURVE)||defined(VELOCITYTWOCURVE)||defined(SIZECURVE)||defined(SIZECURVESEPERATE)||defined(SIZETWOCURVES)||defined(SIZETWOCURVESSEPERATE)\nfloat evaluate_curve_float(in vec2 curves[4],in float t)\n{\n    float res;\n    for(int i=1;i<4;i++)\n    {\n        vec2 curve=curves[i];\n        float curTime=curve.x;\n        if(curTime>=t)\n        {\n            vec2 lastCurve=curves[i-1];\n            float lastTime=lastCurve.x;\n            float tt=(t-lastTime)/(curTime-lastTime);\n            res=mix(lastCurve.y,curve.y,tt);\n            break;\n        }\n    }\n    return res;\n}\n#endif\n\n#if defined(VELOCITYCURVE)||defined(VELOCITYTWOCURVE)||defined(ROTATIONCURVE)||defined(ROTATIONTWOCURVES)\nfloat evaluate_curve_total(in vec2 curves[4],in float t)\n{\n    float res=0.0;\n    for(int i=1;i<4;i++)\n    {\n        vec2 curve=curves[i];\n        float curTime=curve.x;\n        vec2 lastCurve=curves[i-1];\n        float lastValue=lastCurve.y;\n        \n        if(curTime>=t){\n            float lastTime=lastCurve.x;\n            float tt=(t-lastTime)/(curTime-lastTime);\n            res+=(lastValue+mix(lastValue,curve.y,tt))/2.0*time.x*(t-lastTime);\n            break;\n        }\n        else{\n            res+=(lastValue+curve.y)/2.0*time.x*(curTime-lastCurve.x);\n        }\n    }\n    return res;\n}\n#endif\n\n#if defined(COLOROGRADIENT)||defined(COLORTWOGRADIENTS)\nvec4 evaluate_curve_color(in vec2 gradientAlphas[4],in vec4 gradientColors[4],in float t)\n{\n    vec4 overTimeColor;\n    for(int i=1;i<4;i++)\n    {\n        vec2 gradientAlpha=gradientAlphas[i];\n        float alphaKey=gradientAlpha.x;\n        if(alphaKey>=t)\n        {\n            vec2 lastGradientAlpha=gradientAlphas[i-1];\n            float lastAlphaKey=lastGradientAlpha.x;\n            float age=(t-lastAlphaKey)/(alphaKey-lastAlphaKey);\n            overTimeColor.a=mix(lastGradientAlpha.y,gradientAlpha.y,age);\n            break;\n        }\n    }\n    \n    for(int i=1;i<4;i++)\n    {\n        vec4 gradientColor=gradientColors[i];\n        float colorKey=gradientColor.x;\n        if(colorKey>=t)\n        {\n            vec4 lastGradientColor=gradientColors[i-1];\n            float lastColorKey=lastGradientColor.x;\n            float age=(t-lastColorKey)/(colorKey-lastColorKey);\n            overTimeColor.rgb=mix(gradientColors[i-1].yzw,gradientColor.yzw,age);\n            break;\n        }\n    }\n    return overTimeColor;\n}\n#endif\n\n\n#if defined(TEXTURESHEETANIMATIONCURVE)||defined(TEXTURESHEETANIMATIONTWOCURVE)\nfloat evaluate_curve_frame(in vec2 gradientFrames[4],in float t)\n{\n    float overTimeFrame;\n    for(int i=1;i<4;i++)\n    {\n        vec2 gradientFrame=gradientFrames[i];\n        float key=gradientFrame.x;\n        if(key>=t)\n        {\n            vec2 lastGradientFrame=gradientFrames[i-1];\n            float lastKey=lastGradientFrame.x;\n            float age=(t-lastKey)/(key-lastKey);\n            overTimeFrame=mix(lastGradientFrame.y,gradientFrame.y,age);\n            break;\n        }\n    }\n    return floor(overTimeFrame);\n}\n#endif\n\nvec3 computeVelocity(in float t)\n{\n  vec3 res;\n  #ifdef VELOCITYCONSTANT\n     res=u_velocityConst; \n  #endif\n  #ifdef VELOCITYCURVE\n     res= vec3(evaluate_curve_float(u_velocityCurveX,t),evaluate_curve_float(u_velocityCurveY,t),evaluate_curve_float(u_velocityCurveZ,t));\n  #endif\n  #ifdef VELOCITYTWOCONSTANT\n     res=mix(u_velocityConst,u_velocityConstMax,vec3(random1.y,random1.z,random1.w)); \n  #endif\n  #ifdef VELOCITYTWOCURVE\n     res=vec3(mix(evaluate_curve_float(u_velocityCurveX,t),evaluate_curve_float(u_velocityCurveMaxX,t),random1.y),\n                mix(evaluate_curve_float(u_velocityCurveY,t),evaluate_curve_float(u_velocityCurveMaxY,t),random1.z),\n                             mix(evaluate_curve_float(u_velocityCurveZ,t),evaluate_curve_float(u_velocityCurveMaxZ,t),random1.w));\n  #endif\n                    \n  return res;\n} \n\nvec3 computePosition(in vec3 startVelocity, in vec3 lifeVelocity,in float age,in float t,vec3 gravityVelocity,vec4 worldRotation)\n{\n       vec3 position;\n       vec3 lifePosition;\n        #if defined(VELOCITYCONSTANT)||defined(VELOCITYCURVE)||defined(VELOCITYTWOCONSTANT)||defined(VELOCITYTWOCURVE)\n            #ifdef VELOCITYCONSTANT\n                  position=startVelocity*age;\n                  lifePosition=lifeVelocity*age;\n            #endif\n            #ifdef VELOCITYCURVE\n                  position=startVelocity*age;\n                  lifePosition=vec3(evaluate_curve_total(u_velocityCurveX,t),evaluate_curve_total(u_velocityCurveY,t),evaluate_curve_total(u_velocityCurveZ,t));\n            #endif\n            #ifdef VELOCITYTWOCONSTANT\n                  position=startVelocity*age;\n                  lifePosition=lifeVelocity*age;\n            #endif\n            #ifdef VELOCITYTWOCURVE\n                  position=startVelocity*age;\n                  lifePosition=vec3(mix(evaluate_curve_total(u_velocityCurveX,t),evaluate_curve_total(u_velocityCurveMaxX,t),random1.y)\n                                                  ,mix(evaluate_curve_total(u_velocityCurveY,t),evaluate_curve_total(u_velocityCurveMaxY,t),random1.z)\n                                                  ,mix(evaluate_curve_total(u_velocityCurveZ,t),evaluate_curve_total(u_velocityCurveMaxZ,t),random1.w));\n            #endif\n\n            vec3 finalPosition;\n            if(u_spaceType==0){\n              if(u_scalingMode!=2)\n               finalPosition =rotation_quaternions(u_positionScale*(startPosition.xyz+position+lifePosition),worldRotation);\n              else\n               finalPosition =rotation_quaternions(u_positionScale*startPosition.xyz+position+lifePosition,worldRotation);\n            }\n            else{\n              if(u_scalingMode!=2)\n                finalPosition = rotation_quaternions(u_positionScale*(startPosition.xyz+position),worldRotation)+lifePosition;\n              else\n                finalPosition = rotation_quaternions(u_positionScale*startPosition.xyz+position,worldRotation)+lifePosition;\n            }\n          #else\n             position=startVelocity*age;\n             vec3 finalPosition;\n             if(u_scalingMode!=2)\n               finalPosition = rotation_quaternions(u_positionScale*(startPosition.xyz+position),worldRotation);\n             else\n               finalPosition = rotation_quaternions(u_positionScale*startPosition.xyz+position,worldRotation);\n        #endif\n  \n  if(u_simulationSpace==1)\n    finalPosition=finalPosition+startWorldPosition;\n  else if(u_simulationSpace==0) \n    finalPosition=finalPosition+u_worldPosition;\n  \n  finalPosition+=0.5*gravityVelocity*age;\n \n  return finalPosition;\n}\n\n\nvec4 computeColor(in vec4 color,in float t)\n{\n    #ifdef COLOROGRADIENT\n      color*=evaluate_curve_color(u_alphaGradient,u_colorGradient,t);\n    #endif    \n    #ifdef COLORTWOGRADIENTS\n      color*=mix(evaluate_curve_color(u_alphaGradient,u_colorGradient,t),evaluate_curve_color(u_alphaGradientMax,u_colorGradientMax,t),random0.y);\n    #endif\n\n  return color;\n}\n\nvec2 computeBillbardSize(in vec2 size,in float t)\n{\n    #ifdef SIZECURVE\n        size*=evaluate_curve_float(u_sizeCurve,t);\n    #endif\n    #ifdef SIZETWOCURVES\n      size*=mix(evaluate_curve_float(u_sizeCurve,t),evaluate_curve_float(u_sizeCurveMax,t),random0.z); \n    #endif\n    #ifdef SIZECURVESEPERATE\n        size*=vec2(evaluate_curve_float(u_sizeCurveX,t),evaluate_curve_float(u_sizeCurveY,t));\n    #endif\n    #ifdef SIZETWOCURVESSEPERATE\n      size*=vec2(mix(evaluate_curve_float(u_sizeCurveX,t),evaluate_curve_float(u_sizeCurveMaxX,t),random0.z)\n                        ,mix(evaluate_curve_float(u_sizeCurveY,t),evaluate_curve_float(u_sizeCurveMaxY,t),random0.z));\n    #endif\n    return size;\n}\n\n#ifdef RENDERMESH\nvec3 computeMeshSize(in vec3 size,in float t)\n{\n    #ifdef SIZECURVE\n        size*=evaluate_curve_float(u_sizeCurve,t);\n    #endif\n    #ifdef SIZETWOCURVES\n      size*=mix(evaluate_curve_float(u_sizeCurve,t),evaluate_curve_float(u_sizeCurveMax,t),random0.z); \n    #endif\n    #ifdef SIZECURVESEPERATE\n        size*=vec3(evaluate_curve_float(u_sizeCurveX,t),evaluate_curve_float(u_sizeCurveY,t),evaluate_curve_float(u_sizeCurveZ,t));\n    #endif\n    #ifdef SIZETWOCURVESSEPERATE\n      size*=vec3(mix(evaluate_curve_float(u_sizeCurveX,t),evaluate_curve_float(u_sizeCurveMaxX,t),random0.z)\n                        ,mix(evaluate_curve_float(u_sizeCurveY,t),evaluate_curve_float(u_sizeCurveMaxY,t),random0.z)\n                            ,mix(evaluate_curve_float(u_sizeCurveZ,t),evaluate_curve_float(u_sizeCurveMaxZ,t),random0.z));\n    #endif\n    return size;\n}\n#endif\n\nfloat computeRotation(in float rotation,in float age,in float t)\n{ \n    #ifdef ROTATIONOVERLIFETIME\n        #ifdef ROTATIONCONSTANT\n            float ageRot=u_rotationConst*age;\n            rotation+=ageRot;\n        #endif\n        #ifdef ROTATIONCURVE\n            rotation+=evaluate_curve_total(u_rotationCurve,t);\n        #endif\n        #ifdef ROTATIONTWOCONSTANTS\n            float ageRot=mix(u_rotationConst,u_rotationConstMax,random0.w)*age;\n        rotation+=ageRot;\n      #endif\n        #ifdef ROTATIONTWOCURVES\n            rotation+=mix(evaluate_curve_total(u_rotationCurve,t),evaluate_curve_total(u_rotationCurveMax,t),random0.w);\n        #endif\n    #endif\n    #ifdef ROTATIONSEPERATE\n        #ifdef ROTATIONCONSTANT\n            float ageRot=u_rotationConstSeprarate.z*age;\n            rotation+=ageRot;\n        #endif\n        #ifdef ROTATIONCURVE\n            rotation+=evaluate_curve_total(u_rotationCurveZ,t);\n        #endif\n        #ifdef ROTATIONTWOCONSTANTS\n            float ageRot=mix(u_rotationConstSeprarate.z,u_rotationConstMaxSeprarate.z,random0.w)*age;\n            rotation+=ageRot;\n        #endif\n        #ifdef ROTATIONTWOCURVES\n            rotation+=mix(evaluate_curve_total(u_rotationCurveZ,t),evaluate_curve_total(u_rotationCurveMaxZ,t),random0.w));\n        #endif\n    #endif\n    return rotation;\n}\n\n#if defined(RENDERMESH)&&(defined(ROTATIONOVERLIFETIME)||defined(ROTATIONSEPERATE))\nvec3 compute3DRotation(in vec3 rotation,in float age,in float t)\n{ \n    #ifdef ROTATIONOVERLIFETIME\n            #ifdef ROTATIONCONSTANT\n                    float ageRot=u_rotationConst*age;\n                rotation+=ageRot;\n            #endif\n            #ifdef ROTATIONCURVE\n                    rotation+=evaluate_curve_total(u_rotationCurve,t);\n            #endif\n            #ifdef ROTATIONTWOCONSTANTS\n                    float ageRot=mix(u_rotationConst,u_rotationConstMax,random0.w)*age;\n                rotation+=ageRot;\n            #endif\n            #ifdef ROTATIONTWOCURVES\n                    rotation+=mix(evaluate_curve_total(u_rotationCurve,t),evaluate_curve_total(u_rotationCurveMax,t),random0.w);\n            #endif\n    #endif\n    #ifdef ROTATIONSEPERATE\n                #ifdef ROTATIONCONSTANT\n                    vec3 ageRot=u_rotationConstSeprarate*age;\n                    rotation+=ageRot;\n                #endif\n                #ifdef ROTATIONCURVE\n                    rotation+=vec3(evaluate_curve_total(u_rotationCurveX,t),evaluate_curve_total(u_rotationCurveY,t),evaluate_curve_total(u_rotationCurveZ,t));\n                #endif\n                #ifdef ROTATIONTWOCONSTANTS\n                    vec3 ageRot=mix(u_rotationConstSeprarate,u_rotationConstMaxSeprarate,random0.w)*age;\n                    rotation+=ageRot;\n              #endif\n                #ifdef ROTATIONTWOCURVES\n                    rotation+=vec3(mix(evaluate_curve_total(u_rotationCurveX,t),evaluate_curve_total(u_rotationCurveMaxX,t),random0.w)\n                    ,mix(evaluate_curve_total(u_rotationCurveY,t),evaluate_curve_total(u_rotationCurveMaxY,t),random0.w)\n                    ,mix(evaluate_curve_total(u_rotationCurveZ,t),evaluate_curve_total(u_rotationCurveMaxZ,t),random0.w));\n                #endif\n    #endif\n    return rotation;\n}\n#endif\n\nvec2 computeUV(in vec2 uv,in float t)\n{ \n    #ifdef TEXTURESHEETANIMATIONCURVE\n        float cycleNormalizedAge=t*u_cycles;\n        float uvNormalizedAge=cycleNormalizedAge-floor(cycleNormalizedAge);\n        float frame=evaluate_curve_frame(u_uvCurve,uvNormalizedAge);\n        uv.x *= u_subUV.x + u_subUV.z;\n        uv.y *= u_subUV.y + u_subUV.w;\n        float totalULength=frame*u_subUV.x;\n        float floorTotalULength=floor(totalULength);\n      uv.x+=totalULength-floorTotalULength;\n        uv.y+=floorTotalULength*u_subUV.y;\n    #endif\n    #ifdef TEXTURESHEETANIMATIONTWOCURVE\n        float cycleNormalizedAge=t*u_cycles;\n        float uvNormalizedAge=cycleNormalizedAge-floor(cycleNormalizedAge);\n      float frame=floor(mix(evaluate_curve_frame(u_uvCurve,uvNormalizedAge),evaluate_curve_frame(u_uvCurveMax,uvNormalizedAge),random1.x));\n        uv.x *= u_subUV.x + u_subUV.z;\n        uv.y *= u_subUV.y + u_subUV.w;\n        float totalULength=frame*u_subUV.x;\n        float floorTotalULength=floor(totalULength);\n      uv.x+=totalULength-floorTotalULength;\n        uv.y+=floorTotalULength*u_subUV.y;\n    #endif\n    return uv;\n}",
        premultiplied_alpha_fragment: "#ifdef PREMULTIPLIED_ALPHA\n\n // Get get normal blending with premultipled, use with CustomBlending, OneFactor, OneMinusSrcAlphaFactor, AddEquation.\n    gl_FragColor.rgb *= gl_FragColor.a;\n\n#endif",
        project_vertex: "vec4 mvPosition = modelViewMatrix * vec4( transformed, 1.0 );\n\ngl_Position = projectionMatrix * mvPosition;",
        roughnessmap_fragment: "float roughnessFactor = roughness;\n\n#ifdef USE_ROUGHNESSMAP\n\n vec4 texelRoughness = texture2D( roughnessMap, vUv );\n\n    // reads channel G, compatible with a combined OcclusionRoughnessMetallic (RGB) texture\n    roughnessFactor *= texelRoughness.g;\n\n#endif",
        roughnessmap_pars_fragment: "#ifdef USE_ROUGHNESSMAP\n\n uniform sampler2D roughnessMap;\n\n#endif",
        shadowmap_pars_fragment: "#ifdef USE_SHADOWMAP\n\n #if NUM_DIR_LIGHT_SHADOWS > 0\n\n        uniform sampler2D directionalShadowMap[ NUM_DIR_LIGHT_SHADOWS ];\n        varying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];\n\n    #endif\n\n    #if NUM_SPOT_LIGHT_SHADOWS > 0\n\n        uniform sampler2D spotShadowMap[ NUM_SPOT_LIGHT_SHADOWS ];\n        varying vec4 vSpotShadowCoord[ NUM_SPOT_LIGHT_SHADOWS ];\n\n    #endif\n\n    #if NUM_POINT_LIGHT_SHADOWS > 0\n\n        uniform sampler2D pointShadowMap[ NUM_POINT_LIGHT_SHADOWS ];\n        varying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];\n\n    #endif\n\n    /*\n    #if NUM_RECT_AREA_LIGHTS > 0\n\n        // TODO (abelnation): create uniforms for area light shadows\n\n    #endif\n    */\n\n    float texture2DCompare( sampler2D depths, vec2 uv, float compare ) {\n\n        return step( compare, unpackRGBAToDepth( texture2D( depths, uv ) ) );\n\n    }\n\n    vec2 texture2DDistribution( sampler2D shadow, vec2 uv ) {\n\n        return decodeHalfRGBA( texture2D( shadow, uv ) );\n\n    }\n\n    float VSMShadow (sampler2D shadow, vec2 uv, float compare ){\n\n        float occlusion = 1.0;\n\n        vec2 distribution = texture2DDistribution( shadow, uv );\n\n        float hard_shadow = step( compare , distribution.x ); // Hard Shadow\n\n        if (hard_shadow != 1.0 ) {\n\n            float distance = compare - distribution.x ;\n            float variance = max( 0.00000, distribution.y * distribution.y );\n            float softness_probability = variance / (variance + distance * distance ); // Chebeyshevs inequality\n            softness_probability = clamp( ( softness_probability - 0.3 ) / ( 0.95 - 0.3 ), 0.0, 1.0 ); // 0.3 reduces light bleed\n            occlusion = clamp( max( hard_shadow, softness_probability ), 0.0, 1.0 );\n\n        }\n        return occlusion;\n\n    }\n\n    float texture2DShadowLerp( sampler2D depths, vec2 size, vec2 uv, float compare ) {\n\n        const vec2 offset = vec2( 0.0, 1.0 );\n\n        vec2 texelSize = vec2( 1.0 ) / size;\n        vec2 centroidUV = ( floor( uv * size - 0.5 ) + 0.5 ) * texelSize;\n\n        float lb = texture2DCompare( depths, centroidUV + texelSize * offset.xx, compare );\n        float lt = texture2DCompare( depths, centroidUV + texelSize * offset.xy, compare );\n        float rb = texture2DCompare( depths, centroidUV + texelSize * offset.yx, compare );\n        float rt = texture2DCompare( depths, centroidUV + texelSize * offset.yy, compare );\n\n        vec2 f = fract( uv * size + 0.5 );\n\n        float a = mix( lb, lt, f.y );\n        float b = mix( rb, rt, f.y );\n        float c = mix( a, b, f.x );\n\n        return c;\n\n    }\n\n    float getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord ) {\n\n        float shadow = 1.0;\n\n        shadowCoord.xyz /= shadowCoord.w;\n        shadowCoord.z += shadowBias;\n\n        // if ( something && something ) breaks ATI OpenGL shader compiler\n        // if ( all( something, something ) ) using this instead\n\n        bvec4 inFrustumVec = bvec4 ( shadowCoord.x >= 0.0, shadowCoord.x <= 1.0, shadowCoord.y >= 0.0, shadowCoord.y <= 1.0 );\n        bool inFrustum = all( inFrustumVec );\n\n        bvec2 frustumTestVec = bvec2( inFrustum, shadowCoord.z <= 1.0 );\n\n        bool frustumTest = all( frustumTestVec );\n\n        if ( frustumTest ) {\n\n        #if defined( SHADOWMAP_TYPE_PCF )\n\n            vec2 texelSize = vec2( 1.0 ) / shadowMapSize;\n\n            float dx0 = - texelSize.x * shadowRadius;\n            float dy0 = - texelSize.y * shadowRadius;\n            float dx1 = + texelSize.x * shadowRadius;\n            float dy1 = + texelSize.y * shadowRadius;\n            float dx2 = dx0 / 2.0;\n            float dy2 = dy0 / 2.0;\n            float dx3 = dx1 / 2.0;\n            float dy3 = dy1 / 2.0;\n\n            shadow = (\n                texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\n                texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\n                texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\n                texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy2 ), shadowCoord.z ) +\n                texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy2 ), shadowCoord.z ) +\n                texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy2 ), shadowCoord.z ) +\n                texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\n                texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, 0.0 ), shadowCoord.z ) +\n                texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z ) +\n                texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, 0.0 ), shadowCoord.z ) +\n                texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\n                texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy3 ), shadowCoord.z ) +\n                texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy3 ), shadowCoord.z ) +\n                texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy3 ), shadowCoord.z ) +\n                texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\n                texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\n                texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\n            ) * ( 1.0 / 17.0 );\n\n        #elif defined( SHADOWMAP_TYPE_PCF_SOFT )\n\n            vec2 texelSize = vec2( 1.0 ) / shadowMapSize;\n\n            float dx0 = - texelSize.x * shadowRadius;\n            float dy0 = - texelSize.y * shadowRadius;\n            float dx1 = + texelSize.x * shadowRadius;\n            float dy1 = + texelSize.y * shadowRadius;\n\n            shadow = (\n                texture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\n                texture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\n                texture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\n                texture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\n                texture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy, shadowCoord.z ) +\n                texture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\n                texture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\n                texture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\n                texture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\n            ) * ( 1.0 / 9.0 );\n\n        #elif defined( SHADOWMAP_TYPE_VSM )\n\n            shadow = VSMShadow( shadowMap, shadowCoord.xy, shadowCoord.z );\n\n        #else // no percentage-closer filtering:\n\n            shadow = texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );\n\n        #endif\n\n        }\n\n        return shadow;\n\n    }\n\n    // cubeToUV() maps a 3D direction vector suitable for cube texture mapping to a 2D\n    // vector suitable for 2D texture mapping. This code uses the following layout for the\n    // 2D texture:\n    //\n    // xzXZ\n    //  y Y\n    //\n    // Y - Positive y direction\n    // y - Negative y direction\n    // X - Positive x direction\n    // x - Negative x direction\n    // Z - Positive z direction\n    // z - Negative z direction\n    //\n    // Source and test bed:\n    // https://gist.github.com/tschw/da10c43c467ce8afd0c4\n\n    vec2 cubeToUV( vec3 v, float texelSizeY ) {\n\n        // Number of texels to avoid at the edge of each square\n\n        vec3 absV = abs( v );\n\n        // Intersect unit cube\n\n        float scaleToCube = 1.0 / max( absV.x, max( absV.y, absV.z ) );\n        absV *= scaleToCube;\n\n        // Apply scale to avoid seams\n\n        // two texels less per square (one texel will do for NEAREST)\n        v *= scaleToCube * ( 1.0 - 2.0 * texelSizeY );\n\n        // Unwrap\n\n        // space: -1 ... 1 range for each square\n        //\n        // #X##        dim    := ( 4 , 2 )\n        //  # #        center := ( 1 , 1 )\n\n        vec2 planar = v.xy;\n\n        float almostATexel = 1.5 * texelSizeY;\n        float almostOne = 1.0 - almostATexel;\n\n        if ( absV.z >= almostOne ) {\n\n            if ( v.z > 0.0 )\n                planar.x = 4.0 - v.x;\n\n        } else if ( absV.x >= almostOne ) {\n\n            float signX = sign( v.x );\n            planar.x = v.z * signX + 2.0 * signX;\n\n        } else if ( absV.y >= almostOne ) {\n\n            float signY = sign( v.y );\n            planar.x = v.x + 2.0 * signY + 2.0;\n            planar.y = v.z * signY - 2.0;\n\n        }\n\n        // Transform to UV space\n\n        // scale := 0.5 / dim\n        // translate := ( center + 0.5 ) / dim\n        return vec2( 0.125, 0.25 ) * planar + vec2( 0.375, 0.75 );\n\n    }\n\n    float getPointShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord, float shadowCameraNear, float shadowCameraFar ) {\n\n        vec2 texelSize = vec2( 1.0 ) / ( shadowMapSize * vec2( 4.0, 2.0 ) );\n\n        // for point lights, the uniform @vShadowCoord is re-purposed to hold\n        // the vector from the light to the world-space position of the fragment.\n        vec3 lightToPosition = shadowCoord.xyz;\n\n        // dp = normalized distance from light to fragment position\n        float dp = ( length( lightToPosition ) - shadowCameraNear ) / ( shadowCameraFar - shadowCameraNear ); // need to clamp?\n        dp += shadowBias;\n\n        // bd3D = base direction 3D\n        vec3 bd3D = normalize( lightToPosition );\n\n        #if defined( SHADOWMAP_TYPE_PCF ) || defined( SHADOWMAP_TYPE_PCF_SOFT ) || defined( SHADOWMAP_TYPE_VSM )\n\n            vec2 offset = vec2( - 1, 1 ) * shadowRadius * texelSize.y;\n\n            return (\n                texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyy, texelSize.y ), dp ) +\n                texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyy, texelSize.y ), dp ) +\n                texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyx, texelSize.y ), dp ) +\n                texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyx, texelSize.y ), dp ) +\n                texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp ) +\n                texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxy, texelSize.y ), dp ) +\n                texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxy, texelSize.y ), dp ) +\n                texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxx, texelSize.y ), dp ) +\n                texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxx, texelSize.y ), dp )\n            ) * ( 1.0 / 9.0 );\n\n        #else // no percentage-closer filtering\n\n            return texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp );\n\n        #endif\n\n    }\n\n#endif",
        shadowmap_pars_vertex: "#ifdef USE_SHADOWMAP\n\n #if NUM_DIR_LIGHT_SHADOWS > 0\n\n        uniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHT_SHADOWS ];\n        varying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];\n\n    #endif\n\n    #if NUM_SPOT_LIGHT_SHADOWS > 0\n\n        uniform mat4 spotShadowMatrix[ NUM_SPOT_LIGHT_SHADOWS ];\n        varying vec4 vSpotShadowCoord[ NUM_SPOT_LIGHT_SHADOWS ];\n\n    #endif\n\n    #if NUM_POINT_LIGHT_SHADOWS > 0\n\n        uniform mat4 pointShadowMatrix[ NUM_POINT_LIGHT_SHADOWS ];\n        varying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];\n\n    #endif\n\n    /*\n    #if NUM_RECT_AREA_LIGHTS > 0\n\n        // TODO (abelnation): uniforms for area light shadows\n\n    #endif\n    */\n\n#endif",
        shadowmap_vertex: "#ifdef USE_SHADOWMAP\n\n #if NUM_DIR_LIGHT_SHADOWS > 0\n\n    #pragma unroll_loop\n    for ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {\n\n        vDirectionalShadowCoord[ i ] = directionalShadowMatrix[ i ] * worldPosition;\n\n    }\n    // #end unroll_loop\n\n    #endif\n\n    #if NUM_SPOT_LIGHT_SHADOWS > 0\n\n    #pragma unroll_loop\n    for ( int i = 0; i < NUM_SPOT_LIGHT_SHADOWS; i ++ ) {\n\n        vSpotShadowCoord[ i ] = spotShadowMatrix[ i ] * worldPosition;\n\n    }\n    // #end unroll_loop\n\n    #endif\n\n    #if NUM_POINT_LIGHT_SHADOWS > 0\n\n    #pragma unroll_loop\n    for ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {\n\n        vPointShadowCoord[ i ] = pointShadowMatrix[ i ] * worldPosition;\n\n    }\n    // #end unroll_loop\n\n    #endif\n\n    /*\n    #if NUM_RECT_AREA_LIGHTS > 0\n\n        // TODO (abelnation): update vAreaShadowCoord with area light info\n\n    #endif\n    */\n\n#endif",
        shadowmask_pars_fragment: "float getShadowMask() {\n\n float shadow = 1.0;\n\n    #ifdef USE_SHADOWMAP\n\n    #if NUM_DIR_LIGHT_SHADOWS > 0\n\n    DirectionalLight directionalLight;\n\n    #pragma unroll_loop\n    for ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {\n\n         // modified by egret\n        #ifdef EGRET\n            directionalLight.shadow = int(directionalLights[ i  * DIR_LIGHT_SIZE + 6]);\n            directionalLight.shadowBias = directionalLights[ i  * DIR_LIGHT_SIZE + 7];\n            directionalLight.shadowRadius = directionalLights[ i  * DIR_LIGHT_SIZE + 8];\n            directionalLight.shadowMapSize = vec2(directionalLights[ i  * DIR_LIGHT_SIZE + 9], directionalLights[ i  * DIR_LIGHT_SIZE + 10]);\n            #ifdef LIGHT_CULLING\n                directionalLight.cullingMask = int(directionalLights[ i * DIR_LIGHT_SIZE + LIGHT_CULLING + 11]);\n            #else\n                directionalLight.cullingMask = 1;\n            #endif\n\n            shadow *= bool( directionalLight.shadow * directionalLight.cullingMask ) ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\n        #else\n            directionalLight = directionalLights[ i ];\n            shadow *= bool( directionalLight.shadow ) ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\n\n        #endif\n    }\n    // #end unroll_loop\n\n    #endif\n\n    #if NUM_SPOT_LIGHT_SHADOWS > 0\n\n    SpotLight spotLight;\n\n    #pragma unroll_loop\n    for ( int i = 0; i < NUM_SPOT_LIGHT_SHADOWS; i ++ ) {\n\n         // modified by egret\n        #ifdef EGRET\n            spotLight.shadow = int(spotLights[ i  * SPOT_LIGHT_SIZE + 13]);\n            spotLight.shadowBias = spotLights[ i  * SPOT_LIGHT_SIZE + 14];\n            spotLight.shadowRadius = spotLights[ i  * SPOT_LIGHT_SIZE + 15];\n            spotLight.shadowMapSize = vec2(spotLights[ i  * SPOT_LIGHT_SIZE + 16], spotLights[ i  * SPOT_LIGHT_SIZE + 17]);\n            #ifdef LIGHT_CULLING\n                spotLight.cullingMask = int(spotLights[ i * SPOT_LIGHT_SIZE + LIGHT_CULLING + 18]);\n            #else\n                spotLight.cullingMask = 1;\n            #endif\n\n            shadow *= bool(spotLight.shadow * spotLight.cullingMask) ? getShadow( spotShadowMap[ i ], spotLight.shadowMapSize, spotLight.shadowBias, spotLight.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;\n        #else\n            spotLight = spotLights[ i ];\n            shadow *= bool(spotLight.shadow) ? getShadow( spotShadowMap[ i ], spotLight.shadowMapSize, spotLight.shadowBias, spotLight.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;\n        #endif\n            \n    }\n    // #end unroll_loop\n\n    #endif\n\n    #if NUM_POINT_LIGHT_SHADOWS > 0\n\n    PointLight pointLight;\n\n    #pragma unroll_loop\n    for ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {\n\n         // modified by egret\n        #ifdef EGRET\n            pointLight.shadow = int(pointLights[ i  * POINT_LIGHT_SIZE + 8]);\n            pointLight.shadowBias = pointLights[ i  * POINT_LIGHT_SIZE + 9];\n            pointLight.shadowRadius = pointLights[ i  * POINT_LIGHT_SIZE + 10];\n            pointLight.shadowMapSize = vec2(pointLights[ i  * POINT_LIGHT_SIZE + 11], pointLights[ i  * POINT_LIGHT_SIZE + 12]);\n            pointLight.shadowCameraNear = pointLights[ i  * POINT_LIGHT_SIZE + 13];\n            pointLight.shadowCameraFar = pointLights[ i  * POINT_LIGHT_SIZE + 14];\n            #ifdef LIGHT_CULLING\n                pointLight.cullingMask = int(pointLights[ i  * POINT_LIGHT_SIZE + LIGHT_CULLING + 15 ]);\n            #else\n                pointLight.cullingMask = 1;\n            #endif\n\n            shadow *= bool(pointLight.shadow * pointLight.cullingMask) ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ], pointLight.shadowCameraNear, pointLight.shadowCameraFar ) : 1.0;\n        \n        #else\n            pointLight = pointLights[ i ];\n            shadow *= bool(pointLight.shadow) ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ], pointLight.shadowCameraNear, pointLight.shadowCameraFar ) : 1.0;\n        #endif\n        \n    }\n    // #end unroll_loop\n\n    #endif\n\n    /*\n    #if NUM_RECT_AREA_LIGHTS > 0\n\n        // TODO (abelnation): update shadow for Area light\n\n    #endif\n    */\n\n    #endif\n\n    return shadow;\n\n}",
        skinbase_vertex: "#ifdef USE_SKINNING\n\n mat4 boneMatX = getBoneMatrix( skinIndex.x );\n    mat4 boneMatY = getBoneMatrix( skinIndex.y );\n    mat4 boneMatZ = getBoneMatrix( skinIndex.z );\n    mat4 boneMatW = getBoneMatrix( skinIndex.w );\n\n#endif",
        skinning_pars_vertex: "#ifdef USE_SKINNING\n\n uniform mat4 bindMatrix;\n    uniform mat4 bindMatrixInverse;\n\n    #ifdef BONE_TEXTURE\n\n        #ifdef USE_GPU_ANI\n            uniform mat4 prefabMatrix;\n            uniform highp sampler2D aniTexture;\n            uniform vec2 widthAndHeight;\n            uniform float frame;\n        #else\n            uniform highp sampler2D boneTexture;\n            uniform int boneTextureSize;\n        #endif\n\n        mat4 getBoneMatrix( const in float i ) {\n\n            #ifdef EGRET  \n                // modified by egret\n                #ifdef USE_GPU_ANI\n                    float y = i * 3.0;\n                    float dy = 1.0 / widthAndHeight.y;\n                    float x = frame / widthAndHeight.x;\n\n                    vec4 row1 = texture2D(aniTexture,vec2(x, y * dy));\n                    vec4 row2 = texture2D(aniTexture,vec2(x, (y + 1.0) * dy));\n                    vec4 row3 = texture2D(aniTexture,vec2(x, (y + 2.0) * dy));\n                    vec4 row4 = vec4(0.0, 0.0, 0.0, 1.0);\n                \n                    vec4 col1 = vec4(row1.r, row2.r, row3.r, row4.r);\n                    vec4 col2 = vec4(row1.g, row2.g, row3.g, row4.g);\n                    vec4 col3 = vec4(row1.b, row2.b, row3.b, row4.b);\n                    vec4 col4 = vec4(row1.a, row2.a, row3.a, row4.a);\n\n                    mat4 bone = mat4( col1, col2, col3, col4 );\n                    return bone;\n                #else\n                    float j = i * 4.0;\n                    float dx = 1.0 / float( boneTextureSize );\n\n                    vec4 v1 = texture2D( boneTexture, vec2( dx * ( j + 0.5 ), 0.0 ) );\n                    vec4 v2 = texture2D( boneTexture, vec2( dx * ( j + 1.5 ), 0.0 ) );\n                    vec4 v3 = texture2D( boneTexture, vec2( dx * ( j + 2.5 ), 0.0 ) );\n                    vec4 v4 = texture2D( boneTexture, vec2( dx * ( j + 3.5 ), 0.0 ) );\n                    mat4 bone = mat4( v1, v2, v3, v4 );\n                    return bone;\n\n                #endif\n                    \n                    \n\n            #else\n                float j = i * 4.0;\n                float x = mod( j, float( boneTextureSize ) );\n                float y = floor( j / float( boneTextureSize ) );\n\n                float dx = 1.0 / float( boneTextureSize );\n                float dy = 1.0 / float( boneTextureSize );\n\n                y = dy * ( y + 0.5 );\n\n                vec4 v1 = texture2D( boneTexture, vec2( dx * ( x + 0.5 ), y ) );\n                vec4 v2 = texture2D( boneTexture, vec2( dx * ( x + 1.5 ), y ) );\n                vec4 v3 = texture2D( boneTexture, vec2( dx * ( x + 2.5 ), y ) );\n                vec4 v4 = texture2D( boneTexture, vec2( dx * ( x + 3.5 ), y ) );\n\n                mat4 bone = mat4( v1, v2, v3, v4 );\n\n                return bone;\n            #endif\n\n        }\n\n    #else\n\n        uniform mat4 boneMatrices[ MAX_BONES ];\n\n        mat4 getBoneMatrix( const in float i ) {\n\n            mat4 bone = boneMatrices[ int(i) ];\n            return bone;\n\n        }\n\n    #endif\n\n#endif",
        skinning_vertex: "#ifdef USE_SKINNING\n\n #ifdef EGRET \n\n        vec4 skinVertex = vec4( transformed, 1.0 );\n\n        vec4 skinned = vec4( 0.0 );\n        skinned += boneMatX * skinVertex * skinWeight.x;\n        skinned += boneMatY * skinVertex * skinWeight.y;\n        skinned += boneMatZ * skinVertex * skinWeight.z;\n        skinned += boneMatW * skinVertex * skinWeight.w;\n\n        #ifdef BONE_TEXTURE\n        \n        // modified by egret\n            #ifdef USE_GPU_ANI\n                transformed = ( prefabMatrix * skinned ).xyz;\n            #else\n                transformed = skinned.xyz;\n            #endif\n        #else\n            transformed = skinned.xyz;\n        #endif\n    #else\n        vec4 skinVertex = bindMatrix * vec4( transformed, 1.0 );\n\n        vec4 skinned = vec4( 0.0 );\n        skinned += boneMatX * skinVertex * skinWeight.x;\n        skinned += boneMatY * skinVertex * skinWeight.y;\n        skinned += boneMatZ * skinVertex * skinWeight.z;\n        skinned += boneMatW * skinVertex * skinWeight.w;\n\n        transformed = ( bindMatrixInverse * skinned ).xyz;\n    #endif\n\n#endif",
        skinnormal_vertex: "#ifdef USE_SKINNING\n\n mat4 skinMatrix = mat4( 0.0 );\n    skinMatrix += skinWeight.x * boneMatX;\n    skinMatrix += skinWeight.y * boneMatY;\n    skinMatrix += skinWeight.z * boneMatZ;\n    skinMatrix += skinWeight.w * boneMatW;\n    \n    #ifdef EGRET  \n\n        // modified by egret\n        #ifdef  BONE_TEXTURE\n            #ifdef USE_GPU_ANI\n                vec4 n = vec4(objectNormal,0.0);\n                objectNormal = (prefabMatrix * skinMatrix * n).xyz;\n            #endif\n        #endif\n    #else\n        skinMatrix = bindMatrixInverse * skinMatrix * bindMatrix;\n    #endif\n\n    #ifdef USE_TANGENT\n\n        objectTangent = vec4( skinMatrix * vec4( objectTangent, 0.0 ) ).xyz;\n\n    #endif\n\n#endif",
        specularmap_fragment: "float specularStrength;\n\n#ifdef USE_SPECULARMAP\n\n vec4 texelSpecular = texture2D( specularMap, vUv );\n    specularStrength = texelSpecular.r;\n\n#else\n\n    specularStrength = 1.0;\n\n#endif",
        specularmap_pars_fragment: "#ifdef USE_SPECULARMAP\n\n uniform sampler2D specularMap;\n\n#endif",
        tonemapping_fragment: "#if defined( TONE_MAPPING )\n\n gl_FragColor.rgb = toneMapping( gl_FragColor.rgb );\n\n#endif",
        tonemapping_pars_fragment: "#ifndef saturate\n #define saturate(a) clamp( a, 0.0, 1.0 )\n#endif\n\nuniform float toneMappingExposure;\nuniform float toneMappingWhitePoint;\n\n// exposure only\nvec3 LinearToneMapping( vec3 color ) {\n\n    return toneMappingExposure * color;\n\n}\n\n// source: https://www.cs.utah.edu/~reinhard/cdrom/\nvec3 ReinhardToneMapping( vec3 color ) {\n\n    color *= toneMappingExposure;\n    return saturate( color / ( vec3( 1.0 ) + color ) );\n\n}\n\n// source: http://filmicgames.com/archives/75\n#define Uncharted2Helper( x ) max( ( ( x * ( 0.15 * x + 0.10 * 0.50 ) + 0.20 * 0.02 ) / ( x * ( 0.15 * x + 0.50 ) + 0.20 * 0.30 ) ) - 0.02 / 0.30, vec3( 0.0 ) )\nvec3 Uncharted2ToneMapping( vec3 color ) {\n\n    // John Hable's filmic operator from Uncharted 2 video game\n    color *= toneMappingExposure;\n    return saturate( Uncharted2Helper( color ) / Uncharted2Helper( vec3( toneMappingWhitePoint ) ) );\n\n}\n\n// source: http://filmicgames.com/archives/75\nvec3 OptimizedCineonToneMapping( vec3 color ) {\n\n    // optimized filmic operator by Jim Hejl and Richard Burgess-Dawson\n    color *= toneMappingExposure;\n    color = max( vec3( 0.0 ), color - 0.004 );\n    return pow( ( color * ( 6.2 * color + 0.5 ) ) / ( color * ( 6.2 * color + 1.7 ) + 0.06 ), vec3( 2.2 ) );\n\n}\n\n// source: https://knarkowicz.wordpress.com/2016/01/06/aces-filmic-tone-mapping-curve/\nvec3 ACESFilmicToneMapping( vec3 color ) {\n\n    color *= toneMappingExposure;\n    return saturate( ( color * ( 2.51 * color + 0.03 ) ) / ( color * ( 2.43 * color + 0.59 ) + 0.14 ) );\n\n}",
        uv2_pars_fragment: "#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\n varying vec2 vUv2;\n\n#endif",
        uv2_pars_vertex: "#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\n attribute vec2 uv2;\n    varying vec2 vUv2;\n    \n     // modified by egret\n    #ifdef EGRET  \n\n        uniform vec4 lightMapScaleOffset;\n        \n    #endif\n\n#endif",
        uv2_vertex: "#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\n #ifdef EGRET  \n        vUv2 = vec2(uv2.x * lightMapScaleOffset.x + lightMapScaleOffset.z, 1.0 - ((1.0 - uv2.y) * lightMapScaleOffset.y + lightMapScaleOffset.w));\n    #else    \n        vUv2 = uv2;\n    #endif\n\n#endif",
        uv_pars_fragment: "#ifdef USE_UV\n\n varying vec2 vUv;\n\n#endif",
        uv_pars_vertex: "#ifdef USE_UV\n\n varying vec2 vUv;\n    uniform mat3 uvTransform;\n\n#endif",
        uv_vertex: "#ifdef USE_UV\n \n    #ifdef EGRET  \n        #if defined FLIP_V\n            vUv = ( uvTransform * vec3( uv.x, 1.0 - uv.y, 1.0 ) ).xy;\n        #else\n            vUv = ( uvTransform * vec3( uv, 1.0 ) ).xy;\n        #endif\n\n    #else\n        vUv = ( uvTransform * vec3( uv, 1.0 ) ) ).xy;\n    #endif\n\n#endif",
        worldpos_vertex: "#if defined( USE_ENVMAP ) || defined( DISTANCE ) || defined ( USE_SHADOWMAP )\n\n vec4 worldPosition = modelMatrix * vec4( transformed, 1.0 );\n\n#endif"
    }, b = function (e) {
        function t() {
            return null !== e && e.apply(this, arguments) || this
        }

        return u(t, e), t.create = function (e) {
            return this.fromGLTF(this.createGLTF(e))
        }, t.prototype._uninitialize = function () {
            throw new Error("Method not implemented.")
        }, t.prototype._update = function (e) {
            throw new Error("Method not implemented.")
        }, t.prototype.uninitialize = function () {
            this._uninitialize(), e.prototype.uninitialize.call(this)
        }, t.prototype.update = function (t) {
            this._update(t), e.prototype.update.call(this, t)
        }, t.prototype.activateTexture = function () {
            throw new Error("Method not implemented.")
        }, t.prototype.bindTexture = function (e) {
            throw new Error("Method not implemented.")
        }, t.prototype.setSize = function (e, t) {
            var n = i.Application.instance.renderContext.maxTextureSize, r = this.glTFTexture.extensions.egret;
            return r.width = Math.min(e, n), r.height = Math.min(t, n), this.needUpdate(7), this
        }, t = c([Object(r.component)({isAbstract: !1})], t)
    }(f);
    __reflect(b, "@egret/render/RenderTexture");
    var x = {
        map: "mapTexelToLinear",
        tCube: "mapTexelToLinear",
        tEquirect: "mapTexelToLinear",
        envMap: "envMapTexelToLinear",
        emissiveMap: "emissiveMapTexelToLinear"
    }, T = {
        map: "USE_MAP",
        alphaMap: "USE_ALPHAMAP",
        aoMap: "USE_AOMAP",
        bumpMap: "USE_BUMPMAP",
        normalMap: ["USE_NORMALMAP", "TANGENTSPACE_NORMALMAP"],
        specularMap: "USE_SPECULARMAP",
        gradientMap: "TOON",
        roughnessMap: "USE_ROUGHNESSMAP",
        metalnessMap: "USE_METALNESSMAP",
        displacementMap: "USE_DISPLACEMENTMAP",
        envMap: "USE_ENVMAP",
        emissiveMap: "USE_EMISSIVEMAP"
    }, E = function (e) {
        function t() {
            return this
        }

        return u(t, DebuggerClass), t._getToneMappingFunction = function (e) {
            var t = "";
            switch (e) {
                case 1:
                    t = "Linear";
                    break;
                case 2:
                    t = "Reinhard";
                    break;
                case 3:
                    t = "Uncharted2";
                    break;
                case 4:
                    t = "OptimizedCineon";
                    break;
                default:
                    throw new Error("Unsupported toneMapping: " + e)
            }
            return "vec3 toneMapping( vec3 color ) { return " + t + "ToneMapping( color ); } \n"
        }, t._getEncodingComponents = function (e) {
            switch (e) {
                case 1:
                    return ["Linear", "( value )"];
                case 2:
                    return ["sRGB", "( value )"];
                case 3:
                    return ["RGBE", "( value )"];
                case 4:
                    return ["RGBM", "( value, 7.0 )"];
                case 5:
                    return ["RGBM", "( value, 16.0 )"];
                case 6:
                    return ["RGBD", "( value, 256.0 )"];
                case 7:
                    return ["Gamma", "( value, float( GAMMA_FACTOR ) )"];
                default:
                    throw new Error("Non-supported encoding: " + e)
            }
        }, t._getTexelEncodingFunction = function (e, t) {
            var n = this._getEncodingComponents(t);
            return "vec4 " + e + "( vec4 value ) { return LinearTo" + (n[0] + n[1]) + "; }"
        }, t._getTexelDecodingFunction = function (e, t, n) {
            var r = n && 1 === t ? 7 : t, i = this._getEncodingComponents(r);
            return "vec4 " + e + "( vec4 value ) { return " + i[0] + "ToLinear" + i[1] + "; }"
        }, t.updateToneMapping = function (e, t) {
            0 === t ? (e.removeDefine("TONE_MAPPING"), e.removeDefine("ToneMappingPars"), e.removeDefine("ToneMappingFunction")) : (e.addDefine("TONE_MAPPING", NaN, "", 0, 3, 2), e.addDefine("ToneMappingPars", NaN, y.tonemapping_pars_fragment, 0, 4, 2), e.addDefine("ToneMappingFunction", NaN, this._getToneMappingFunction(t), 0, 4, 2))
        }, t.updateTexelEncoding = function (e, t) {
            e.addDefine("Gamma", NaN, this._getTexelEncodingFunction("linearToOutputTexel", t ? 7 : 1), 3, 4, 2)
        }, t.updateTextureDefines = function (e, t, n, r) {
            if (t in T) {
                var i = T[t];
                if (null !== n) {
                    if (Array.isArray(i)) for (var o = 0, a = i; o < a.length; o++) {
                        var s = a[o];
                        e.addDefine(s)
                    } else e.addDefine(i);
                    n instanceof b ? e.addDefine("FLIP_V") : e.removeDefine("FLIP_V")
                } else {
                    if (Array.isArray(i)) for (var l = 0, u = i; l < u.length; l++) {
                        var c = u[l];
                        e.removeDefine(c)
                    } else e.removeDefine(i);
                    e.removeDefine("FLIP_V")
                }
            }
            if (t in x) {
                i = x[t];
                if (null !== n) {
                    var p = this._getTexelDecodingFunction(i, n.glTFTexture.extensions.egret.encoding || 1, r);
                    e.addDefine(i, NaN, p, 2, 4, 2)
                } else e.removeDefine(i)
            }
            if ("envMap" === t) {
                var d = "ENVMAP_TYPE_CUBE";
                if (null !== n) {
                    switch (n.glTFTexture.extensions.egret.mapping) {
                        case 1:
                        default:
                            d = "ENVMAP_TYPE_CUBE";
                            break;
                        case 2:
                            d = "ENVMAP_TYPE_CUBE_UV";
                            break;
                        case 3:
                            d = "ENVMAP_TYPE_EQUIREC";
                            break;
                        case 4:
                            d = "ENVMAP_TYPE_SPHERE"
                    }
                    e.addDefine("typeDefine", NaN, d, 0, 2, 2), e.addDefine("blendDefine", NaN, "ENVMAP_BLENDING_MULTIPLY", 0, 2, 2)
                } else e.removeDefine("typeDefine"), e.removeDefine("blendDefine")
            }
        }, t
    }();
    __reflect(E, "@egret/render/DefinesUpdate");
    var C = 0, S = function (e) {
        function t() {
            var t = null !== e && e.apply(this, arguments) || this;
            return t.index = C++, t.version = 0, t.renderQueue = 2e3, t.glTFMaterial = null, t.technique = null, t.defines = null, t._uvTransformArray = null, t._shader = null, t._renderContext = null, t._gpuInstancingEnable = !1, t
        }

        var n;
        return u(t, e), n = t, t._copyStates = function (e, t) {
            var n = e.enable, r = e.functions, i = t.enable, o = t.functions;
            if (void 0 !== i && (i.length = 0), void 0 !== o) for (var a in o) delete o[a];
            if (void 0 !== n) {
                void 0 === i && (i = t.enable = []);
                for (var s = 0, l = n; s < l.length; s++) {
                    var u = l[s];
                    i.push(u)
                }
            }
            if (void 0 !== r) for (var a in void 0 === o && (o = t.functions = {}), r) {
                var c = r[a];
                o[a] = Array.isArray(c) ? c.concat() : c
            }
        }, t._createDefaultStates = function () {
            return {
                enable: [2929, 2884],
                functions: {depthFunc: [515], depthMask: [!0], frontFace: [2305], cullFace: [1029]}
            }
        }, t.createGLTF = function (t) {
            var n = t.glTF.extensions.KHR_techniques_webgl.techniques[0].states, r = e.createGLTF.call(this),
                i = {attributes: {}, uniforms: {}};
            return r.materials = [{extensions: {KHR_techniques_webgl: {technique: 0}}}], r.extensions.KHR_techniques_webgl = {
                shaders: [],
                techniques: [i],
                programs: []
            }, void 0 !== n ? (i.states = {
                enable: [],
                functions: {}
            }, this._copyStates(n, i.states)) : i.states = this._createDefaultStates(), r
        }, t.toGLTF = function (t) {
            var n = e.toGLTF.call(this, t), r = n.materials[0].extensions.KHR_techniques_webgl;
            void 0 === r.values && (r.values = {});
            var i = r.values, o = t.glTF.extensions.KHR_techniques_webgl.techniques[0];
            for (var a in o.uniforms) {
                var s = o.uniforms[a];
                s.value instanceof h ? i[a] = s.value.entity.uri : i[a] = s.value
            }
            return n
        }, t.create = function (e) {
            if (e instanceof m) {
                var t = this.fromGLTF(this.createGLTF(e));
                return t.shader = e, t
            }
            var n = this.fromGLTF(this.createGLTF(e.shader));
            return n.copy(e), n
        }, t.prototype._setGLTF = function (t) {
            e.prototype._setGLTF.call(this, t);
            var n = this.glTFMaterial = t.materials[0];
            this.technique = t.extensions.KHR_techniques_webgl.techniques[n.extensions.KHR_techniques_webgl.technique], void 0 === this.technique.states && (this.technique.states = {
                enable: [2929, 2884],
                functions: {depthFunc: [515], depthMask: [!0], frontFace: [2305], cullFace: [1029]}
            })
        }, t.prototype._addOrRemoveTexturesDefine = function (e) {
            void 0 === e && (e = !0);
            var t = this.technique.uniforms;
            for (var n in t) {
                var r = t[n];
                if (r.value && (35678 === r.type || 35680 === r.type)) {
                    var i = r.value;
                    E.updateTextureDefines(this.defines, n, e ? i : null, this._renderContext.gammaInput)
                }
            }
        }, t.prototype._addOrRemoveInstancingDefine = function () {
            this._gpuInstancingEnable && this._renderContext.gpuInstancingEnable ? this.addDefine("USE_INSTANCED") : this.removeDefine("USE_INSTANCED")
        }, t.prototype._setShader = function (e) {
            if (null !== this._shader) {
                var t = this.technique.uniforms;
                for (var n in t) delete t[n];
                this._addOrRemoveTexturesDefine(!1), delete this.technique.states
            }
            this._shader = e, this._updateTechnique(), this._updateDefines(), this._addOrRemoveTexturesDefine(!0), this._addOrRemoveInstancingDefine()
        }, t.prototype._updateTechnique = function () {
            var e = this.shader.glTF.extensions.KHR_techniques_webgl.techniques[0], t = e.attributes, r = e.uniforms,
                i = this.glTFMaterial.extensions.KHR_techniques_webgl.values, o = this.technique;
            if (void 0 !== i) for (var a in i) a in r || delete i[a];
            for (var a in o.attributes = t, r) {
                var s = r[a], l = void 0 !== i && a in i ? i[a] : s.value, u = s.type, c = void 0;
                c = 35678 === u || 35680 === u ? l instanceof f ? l : null : Array.isArray(l) ? l ? l.concat() : [] : l || (0 === l ? 0 : []);
                var p = o.uniforms[a] = {type: u, value: c};
                void 0 !== s.semantic && (p.semantic = s.semantic)
            }
            return void 0 === o.states && (o.states = n._createDefaultStates()), o
        }, t.prototype._updateDefines = function () {
            var e = this.technique.states, t = this.defines, n = this._shader._defines;
            if (e.enable.indexOf(2884) >= 0) {
                var r = e.functions.frontFace, i = e.functions.cullFace, o = void 0 !== r && r.length > 0 ? r[0] : 2305,
                    a = void 0 !== i && i.length > 0 ? i[0] : 1029;
                t.removeDefine("DOUBLE_SIDED"), 2305 !== o || 1029 !== a ? t.addDefine("FLIP_SIDED") : t.removeDefine("FLIP_SIDED")
            } else t.removeDefine("FLIP_SIDED"), t.addDefine("DOUBLE_SIDED");
            if (n) for (var s = 0, l = n; s < l.length; s++) {
                var u = l[s];
                t.addDefine(u)
            }
        }, t.prototype._getUniform = function (e) {
            var t = this.technique.uniforms;
            return e in t ? t[e] : (console.warn("Invalid uniform.", e), null)
        }, t.prototype.initialize = function (t, n, r) {
            void 0 === r && (r = null), e.prototype.initialize.call(this, t, n, r);
            this.defines = this.entity.getComponent(v), this._renderContext = i.Application.instance.renderContext
        }, t.prototype.uninitialize = function () {
            e.prototype.uninitialize.call(this);
            this.version = 0, this.renderQueue = 2e3, this.glTFMaterial = null, this.technique = null, this.defines = null, this._shader = null
        }, t.prototype.copy = function (e) {
            this.renderQueue = e.renderQueue, this._shader = e.shader, this.defines.copy(e.defines);
            var t = e.technique.uniforms, n = this.technique.uniforms = {};
            for (var r in t) {
                var i = t[r], o = i.value;
                n[r] = {type: i.type, semantic: i.semantic, value: Array.isArray(o) ? o.concat() : o}
            }
            var a = e.technique.states, s = this.technique.states;
            for (var r in s.enable = a.enable.concat(), a.functions) {
                var l = a.functions[r];
                s.functions[r] = Array.isArray(l) ? l.concat() : l
            }
            return this
        }, t.prototype.setBoolean = function (e, t) {
            var n = this._getUniform(e);
            return null !== n && (n.value = t, this.version++), this
        }, t.prototype.setInt = function (e, t) {
            var n = this._getUniform(e);
            return null !== n && (n.value = t, this.version++), this
        }, t.prototype.setFloat = function (e, t) {
            var n = this._getUniform(e);
            return null !== n && (n.value = t, this.version++), this
        }, t.prototype.setVector2 = function (e, t) {
            var n = this._getUniform(e);
            if (null !== n) {
                var r = n.value;
                Array.isArray(r) || (n.value = r = [0, 0]), r[0] = t.x, r[1] = t.y, this.version++
            }
            return this
        }, t.prototype.setVector3 = function (e, t) {
            var n = this._getUniform(e);
            if (null !== n) {
                var r = n.value;
                Array.isArray(r) || (n.value = r = [0, 0, 0]), r[0] = t.x, r[1] = t.y, r[2] = t.z, this.version++
            }
            return this
        }, t.prototype.setVector4 = function (e, t) {
            var n = this._getUniform(e);
            if (null !== n) {
                var r = n.value;
                Array.isArray(r) || (n.value = r = [0, 0, 0, 0]), r[0] = t.x, r[1] = t.y, r[2] = t.z, r[3] = t.w, this.version++
            }
            return this
        }, t.prototype.setTypedArray = function (e, t) {
            var n = this._getUniform(e);
            return null !== n && (n.value = t, this.version++), this
        }, t.prototype.getColor = function (e, t) {
            var n;
            void 0 === e && (e = null), void 0 === t && (t = null), null === e ? (n = "diffuse", t = i.Color.create()) : e instanceof i.Color ? (n = "diffuse", t = e) : (n = e, null === t && (t = i.Color.create()));
            var r = this._getUniform(n);
            if (null !== r) {
                if (!Array.isArray(r.value)) return console.error("Invalid uniform value."), t;
                t.fromArray(r.value)
            }
            return t
        }, t.prototype.setColor = function (e, t) {
            if (void 0 === t && (t = 0), "string" != typeof e && (t = e, e = "diffuse"), "number" == typeof t) {
                var n = i.Color.create().fromHex(t).release();
                this.setVector3(e, i.Vector3.create(n.r, n.g, n.b).release())
            } else this.setVector3(e, i.Vector3.create(t.r, t.g, t.b).release());
            return this
        }, t.prototype.getUVTransform = function (e) {
            void 0 === e && (e = null), null === e && (e = i.Matrix3.create());
            var t = this._getUniform("uvTransform");
            if (null !== t) {
                if (!Array.isArray(t.value)) return console.error("Invalid uniform value."), e;
                e.fromArray(t.value)
            }
            return e
        }, t.prototype.setUVTransform = function (e) {
            var t = this._getUniform("uvTransform");
            if (null !== t) {
                if (!Array.isArray(t.value)) return console.error("Invalid uniform value."), this;
                null === this._uvTransformArray && (this._uvTransformArray = []), t.value = e.toArray(this._uvTransformArray)
            }
            return this
        }, t.prototype.getTexture = function (e) {
            void 0 === e && (e = "map");
            var t = this._getUniform(e);
            return null !== t ? t.value : null
        }, t.prototype.setTexture = function (e, t) {
            if (void 0 === t && (t = null), !e) return console.error("Invalid texture asset."), this;
            e instanceof f && (t = e, e = "map");
            var n = this._getUniform(e);
            if (null !== n && n.value !== t) {
                var r = this.defines;
                n.value && E.updateTextureDefines(r, e, null, this._renderContext.gammaInput), n.value = t, n.value && E.updateTextureDefines(this.defines, e, t, this._renderContext.gammaInput), this.version++
            }
            return this
        }, t.prototype.addDefine = function (e, t) {
            return void 0 === t && (t = NaN), this.defines.addDefine(e, t), this
        }, t.prototype.removeDefine = function (e) {
            return this.defines.removeDefine(e), this
        }, t.prototype.setBlend = function (e, t, n, r) {
            void 0 === n && (n = -1), void 0 === r && (r = -1);
            var i, o, a = this.technique.states, s = a.enable, l = a.functions, u = Array.isArray(e) ? -1 : e;
            if (-1 === u) l.blendEquationSeparate = e, l.blendFuncSeparate = t, i = n, o = r; else {
                switch (u) {
                    case 4:
                        l.blendEquationSeparate = [32774, 32774], l.blendFuncSeparate = [770, 1, 770, 1];
                        break;
                    case 5:
                        l.blendEquationSeparate = [32774, 32774], l.blendFuncSeparate = [1, 1, 1, 1];
                        break;
                    case 2:
                        l.blendEquationSeparate = [32774, 32774], l.blendFuncSeparate = [770, 771, 1, 771];
                        break;
                    case 3:
                        l.blendEquationSeparate = [32774, 32774], l.blendFuncSeparate = [1, 32772, 1, 32772];
                        break;
                    case 8:
                        l.blendEquationSeparate = [32774, 32774], l.blendFuncSeparate = [0, 769, 0, 769];
                        break;
                    case 9:
                        l.blendEquationSeparate = [32774, 32774], l.blendFuncSeparate = [0, 0, 769, 771];
                        break;
                    case 16:
                        l.blendEquationSeparate = [32774, 32774], l.blendFuncSeparate = [0, 768, 0, 768];
                        break;
                    case 17:
                        l.blendEquationSeparate = [32774, 32774], l.blendFuncSeparate = [0, 768, 0, 770];
                        break;
                    default:
                        delete l.blendEquationSeparate, delete l.blendFuncSeparate
                }
                i = t, o = n
            }
            var c = s.indexOf(3042);
            return 0 === u ? (c >= 0 && s.splice(c, 1), l.depthMask = [!0]) : (c < 0 && s.push(3042), l.depthMask = [!1]), this.renderQueue = i, o >= 0 && (this.opacity = o), this
        }, t.prototype.setCullFace = function (e, t, n) {
            void 0 === t && (t = 2305), void 0 === n && (n = 1029);
            var r = this.technique.states, i = r.enable, o = r.functions, a = i.indexOf(2884), s = this.defines;
            return e ? (a < 0 && i.push(2884), o.frontFace = [t], o.cullFace = [n], s.removeDefine("DOUBLE_SIDED"), 2305 !== t || 1029 !== n ? s.addDefine("FLIP_SIDED") : s.removeDefine("FLIP_SIDED")) : a >= 0 && (i.splice(a, 1), delete o.frontFace, delete o.cullFace, s.removeDefine("FLIP_SIDED"), s.addDefine("DOUBLE_SIDED")), this
        }, t.prototype.setDepth = function (e, t) {
            var n = this.technique.states, r = n.enable, i = n.functions, o = r.indexOf(2929);
            return e ? o < 0 && (r.push(2929), i.depthFunc = [515]) : o >= 0 && (r.splice(o, 1), delete i.depthFunc), i.depthMask = t ? [!0] : [!1], this
        }, t.prototype.setStencil = function (e) {
            var t = this.technique.states.enable, n = t.indexOf(2960);
            return e ? n < 0 && t.push(2960) : n >= 0 && t.splice(n), this
        }, t.prototype.clearStates = function () {
            var e = this.technique.states, t = e.enable, n = e.functions;
            for (var r in t.length = 0, n) delete n[r];
            return this
        }, Object.defineProperty(t.prototype, "opacity", {
            get: function () {
                var e = this._getUniform("opacity");
                return null !== e ? e.value : 1
            }, set: function (e) {
                this.setFloat("opacity", e)
            }, enumerable: !0, configurable: !0
        }), Object.defineProperty(t.prototype, "gpuInstancingEnable", {
            get: function () {
                return null !== this._renderContext.instancedArrays && this._gpuInstancingEnable
            }, set: function (e) {
                null !== this._renderContext.instancedArrays ? this._gpuInstancingEnable !== e && (this._gpuInstancingEnable = e, this._addOrRemoveInstancingDefine()) : console.error("The current platform does not support ANGLE_instanced_arrays extension.")
            }, enumerable: !0, configurable: !0
        }), Object.defineProperty(t.prototype, "shader", {
            get: function () {
                return this._shader
            }, set: function (e) {
                e ? this._shader !== e && this._setShader(e) : console.error("Invalid shader asset.")
            }, enumerable: !0, configurable: !0
        }), c([Object(a.property)("uint"), a.serializedField], t.prototype, "renderQueue", void 0), c([Object(a.property)("boolean"), a.serializedField], t.prototype, "gpuInstancingEnable", null), c([Object(a.property)("asset", {assetType: "shader"}), a.serializedField], t.prototype, "shader", null), t = n = c([Object(r.component)({
            requireComponents: [v],
            isAbstract: !1
        })], t)
    }(h);
    __reflect(S, "@egret/render/Material");
    var M = 0, A = ["POSITION", "NORMAL", "TEXCOORD_0"], O = ["NORMAL"], w = function (e) {
        function t() {
            var t = null !== e && e.apply(this, arguments) || this;
            return t.index = M++, t.glTFMesh = null, t.attributes = null, t._needUpdated = 31, t._boundingBox = i.Box.create(), t._inverseBindMatrices = null, t._boneIndices = null, t
        }

        return u(t, e), t.createGLTF = function () {
            var t = e.createGLTF.call(this);
            return t.buffers = [], t.bufferViews = [], t.accessors = [], t.meshes = [{
                primitives: [{
                    attributes: {},
                    material: 0,
                    extras: {needUpdate: 31, program: null, vaos: null, ibo: null, draw: null}
                }]
            }], t
        }, t.create = function (e, t, n) {
            void 0 === n && (n = null);
            var r = this.fromGLTF(this.createGLTF());
            if (r.glTFMesh.extras.vertexCount = e, null === n && (n = A), Array.isArray(n)) for (var i = 0, o = n; i < o.length; i++) {
                var a = o[i];
                r.addAttribute(a, this.getMeshAttributeType(a))
            } else for (var a in n) {
                var s = n[a];
                0 === s.length && (s = this.getMeshAttributeType(a)), r.addAttribute(a, s)
            }
            return t > 0 && r.addSubMesh(t, 0), r
        }, t.prototype._uninitialize = function () {
            throw new Error("Method not implemented.")
        }, t.prototype._update = function (e, t) {
            throw new Error("Method not implemented.")
        }, t.prototype._setGLTF = function (t) {
            e.prototype._setGLTF.call(this, t);
            var n = this.glTFMesh = this.glTF.meshes[0], r = this.attributes = n.primitives[0].attributes;
            if (n.extras = {
                drawMode: 35044,
                vertexCount: 0,
                wireframeIndex: -1,
                attributeTypes: {},
                attributeOffsets: {},
                vbo: null
            }, t.buffers.length > 0) {
                n.extras.vertexCount = this.getAccessor(void 0 !== r.POSITION ? r.POSITION : 0).count;
                var i = 0;
                for (var o in r) n.extras.attributeOffsets[o] = i, i += this.getAccessorByteLength(this.getAccessor(r[o]));
                for (var a = 0, s = n.primitives; a < s.length; a++) {
                    (c = s[a]).attributes = r, c.extras = {
                        needUpdate: 31,
                        program: null,
                        vaos: null,
                        ibo: null,
                        draw: null
                    }
                }
            }
            for (var l = 0, u = n.primitives; l < u.length; l++) {
                var c;
                if (void 0 !== (c = u[l]).targets) for (var p = 0; p < c.targets.length; p++) void 0 !== c.targets[p].NORMAL && (n.extras.useMorphNormal = !0)
            }
        }, t.prototype._removeBufferByAccessor = function (e) {
            var t = this._glTF, n = t.buffers, r = t.bufferViews, i = t.accessors, o = this.attributes,
                a = this.glTFMesh.primitives, s = i[e].bufferView, l = r[s].buffer;
            if (0 !== l) {
                for (var u = i[e], c = 0, p = r; c < p.length; c++) {
                    var d = p[c];
                    d.buffer > l && d.buffer--
                }
                for (var h = 0, f = i; h < f.length; h++) {
                    var m = f[h];
                    m.bufferView > s && m.bufferView--
                }
                for (var _ in o) o[_] > e && o[_]--;
                for (var g = 0, v = a; g < v.length; g++) {
                    var y = v[g];
                    void 0 !== y.indices && y.indices > e && y.indices--
                }
                return n.splice(l, 1), r.splice(s, 1), i.splice(e, 1), u
            }
            return null
        }, t.prototype.uninitialize = function () {
            this._uninitialize(), e.prototype.uninitialize.call(this);
            this.glTFMesh = null, this.attributes = null, this._needUpdated = 31, this._boundingBox.clear(), this._inverseBindMatrices = null, this._boneIndices = null
        }, t.prototype.needUpdate = function (e, t) {
            if (void 0 === t && (t = -1), 0 != (20 & e)) {
                var n = this.glTFMesh.primitives;
                if (t < 0) for (var r = 0, i = n; r < i.length; r++) {
                    i[r].extras.needUpdate |= e
                } else n[t].extras.needUpdate |= e
            }
            this._needUpdated |= e
        }, t.prototype.update = function (e, t) {
            void 0 === t && (t = -1), this._update(e, t);
            var n = this._needUpdated & e, r = this.glTFMesh.primitives;
            if (0 != (1 & n)) {
                for (var o = this.getVertices(), a = i.Vector3.create().release(), s = this._boundingBox.clear(), l = 0, u = 0, c = r; u < c.length; u++) {
                    if (void 0 !== c[u].indices) for (var p = this.getIndices(l++), d = 0, h = p.length; d < h; ++d) s.add(a.fromArray(o, 3 * p[d]))
                }
                if (0 === l) for (d = 0, h = o.length; d < h; d += 3) s.add(a.fromArray(o, d))
            }
            this._needUpdated &= ~e, t >= 0 && (r[t].extras.needUpdate &= ~e)
        }, t.prototype.raycast = function (e, t, n) {
            if (void 0 === t && (t = null), void 0 === n && (n = null), null === n) {
                if (!this.boundingBox.raycast(e)) return !1;
                n = this.getVertices()
            }
            for (var r = i.Triangle.create().release(), o = i.Triangle.create().release(), a = i.RaycastInfo.create().release(), s = !1, l = 0, u = 0, c = this.glTFMesh.primitives; u < c.length; u++) {
                var p = c[u], d = void 0 !== p.indices ? this.getIndices(l) : null;
                switch (p.mode) {
                    case 0:
                    case 1:
                    case 2:
                    case 3:
                    case 6:
                    case 5:
                        break;
                    case 4:
                    default:
                        if (null !== d) {
                            for (var h = 0, f = d.length; h < f; h += 3) if (r.a.fromArray(n, 3 * d[h]), r.b.fromArray(n, 3 * d[h + 1]), r.c.fromArray(n, 3 * d[h + 2]), null !== t) a.backfaceCulling = t.backfaceCulling, r.raycast(e, a) && (!s || t.distance > a.distance) && (t.subMeshIndex = l, t.triangleIndex = h / 3, t.distance = a.distance, t.position.copy(a.position), t.coord.copy(a.coord), s = !0, null !== t.normal && o.copy(r)); else if (r.raycast(e)) return !0
                        } else for (h = 0, f = n.length; h < f; h += 9) if (r.fromArray(n, h), null !== t) a.backfaceCulling = t.backfaceCulling, r.raycast(e, a) && (!s || t.distance > a.distance) && (t.subMeshIndex = l, t.triangleIndex = h / 9, t.distance = a.distance, t.position.copy(a.position), t.coord.copy(a.coord), s = !0, null !== t.normal && o.copy(r)); else if (r.raycast(e)) return !0
                }
                l++
            }
            if (s && null !== t.normal) {
                var m = t.normal;
                o.getNormal(m)
            }
            return s
        }, t.prototype.applyMatrix = function (e, t, n) {
            void 0 === t && (t = 0), void 0 === n && (n = 0);
            for (var r = this.getVertices(t, n), o = this.getNormals(t, n), a = i.Vector3.create().release(), s = 0, l = r.length; s < l; s += 3) a.fromArray(r, s).applyMatrix(e).toArray(r, s);
            if (null !== o) {
                var u = i.Matrix3.create().getNormalMatrix(e).release();
                for (s = 0, l = o.length; s < l; s += 3) a.fromArray(o, s).applyMatrix3(u).normalize().toArray(o, s)
            }
            return this.needUpdate(1), this
        }, t.prototype.getTriangle = function (e, t, n) {
            void 0 === t && (t = null), void 0 === n && (n = null), null === t && (t = i.Triangle.create()), null === n && (n = this.getVertices());
            var r = this.getIndices();
            if (null !== r) {
                var o = 3 * e;
                t.a.fromArray(n, 3 * r[o]), t.b.fromArray(n, 3 * r[o + 1]), t.c.fromArray(n, 3 * r[o + 2])
            } else t.fromArray(n, 9 * e);
            return t
        }, t.prototype.normalizeNormals = function () {
            var e = this.getNormals();
            if (null !== e) {
                for (var t = i.Vector3.create().release(), n = 0, r = e.length; n < r; n += 3) t.fromArray(e, n).normalize().toArray(e, n);
                this.uploadVertexBuffer(O)
            }
            return this
        }, t.prototype.computeVertexNormals = function () {
            var e = this.getNormals();
            if (null !== e) {
                for (var t = this.getVertices(), n = this.getIndices(), r = 0, o = e.length; r < o; r++) e[r] = 0;
                var a = i.Triangle.create().release(), s = i.Vector3.create().release();
                if (null !== n) {
                    for (var l = 0, u = n.length; l < u; l += 3) {
                        var c = 3 * n[l], p = 3 * n[l + 1], d = 3 * n[l + 2];
                        a.a.fromArray(t, c), a.b.fromArray(t, p), a.c.fromArray(t, d), a.getNormal(s), e[c] += s.x, e[c + 1] += s.y, e[c + 2] += s.z, e[p] += s.x, e[p + 1] += s.y, e[p + 2] += s.z, e[d] += s.x, e[d + 1] += s.y, e[d + 2] += s.z
                    }
                    this.normalizeNormals()
                } else {
                    for (var h = 0, f = t.length; h < f; h += 9) a.fromArray(t, h), a.getNormal(s), s.toArray(e, h), s.toArray(e, h + 3), s.toArray(e, h + 6);
                    this.uploadVertexBuffer(O)
                }
            }
            return this
        }, t.prototype.addAttribute = function (e, t, n, r) {
            void 0 === n && (n = 0), void 0 === r && (r = 0);
            var i = this.attributes;
            if (e in i) return this.getAttribute(e);
            var o = this.glTFMesh.extras, a = o.vertexCount, s = o.attributeTypes, l = o.attributeOffsets;
            n <= 0 && (n = a);
            var u = this._glTF, c = u.buffers, p = u.bufferViews, d = u.accessors, f = h.getAccessorTypeCount(t),
                m = n * f, _ = m * Float32Array.BYTES_PER_ELEMENT, g = c.length, v = p.length, y = d.length,
                b = new Float32Array(m);
            c[g] = {byteLength: _, extras: {data: b}}, p[v] = {
                buffer: g,
                byteLength: _,
                target: 34962
            }, d[y] = {
                bufferView: v,
                count: n,
                componentType: 5126,
                type: t,
                normalized: "NORMAL" === e || "TANGENT" === e,
                extras: {typeCount: f, divisor: r}
            };
            var x = 0;
            for (var T in i) x += this.getAccessorByteLength(this.getAccessor(i[T]));
            return i[e] = y, l[e] = x, h.getMeshAttributeType(e) !== t && (s[e] = t), this.needUpdate(12, -1), b
        }, t.prototype.removeAttribute = function (e) {
            var t = this.attributes;
            if (e in t) {
                var n = t[e];
                if (null !== this._removeBufferByAccessor(n)) {
                    var r = this.glTFMesh.extras.attributeOffsets, i = -1;
                    for (var o in r) o === e ? i = 0 : 0 === i ? i = r[e] : i > 0 && (r[e] -= i);
                    return delete t[e], delete r[e], this.needUpdate(12, -1), !0
                }
            }
            return !1
        }, t.prototype.addSubMesh = function (e, t, n) {
            if (void 0 === t && (t = 0), void 0 === n && (n = 4), e <= 0) return console.warn("invalid index count."), -1;
            var r = this._glTF, i = r.buffers, o = r.bufferViews, a = r.accessors,
                s = e * Uint16Array.BYTES_PER_ELEMENT, l = i.length, u = o.length, c = a.length;
            i[l] = {byteLength: s, extras: {data: new Uint16Array(e)}}, o[u] = {
                buffer: l,
                byteLength: s,
                target: 34963
            }, a[c] = {
                bufferView: l,
                count: e,
                componentType: 5123,
                type: "SCALAR",
                extras: {typeCount: 1, divisor: 0}
            };
            var p, d, h = this.glTFMesh.primitives;
            return (d = void 0 === h[0].indices ? h[p = 0] : h[p = h.length] = {
                attributes: this.attributes,
                extras: {needUpdate: 31, program: null, vaos: null, ibo: null, draw: null}
            }).indices = c, d.material = t, d.mode = n, this.needUpdate(29, p), p
        }, t.prototype.removeSubMesh = function (e) {
            var t = this.glTFMesh, n = t.primitives, r = t.extras;
            if (e < n.length) {
                var i = n[e];
                if (void 0 !== i.indices) if (null !== this._removeBufferByAccessor(i.indices)) return n.splice(e, 1), this.needUpdate(29, e), r.wireframeIndex === e && (r.wireframeIndex = -1), !0
            }
            return !1
        }, t.prototype.addWireframeSubMesh = function (e) {
            var t = this.glTFMesh, n = t.primitives, r = t.extras;
            if (r.wireframeIndex < 0) {
                for (var i = 0, o = [], a = 0, s = n; a < s.length; a++) {
                    var l = s[a];
                    switch (l.mode) {
                        case 4:
                        default:
                            if (void 0 !== l.indices) for (var u = this.getIndices(i), c = 0, p = u.length; c < p; c += 3) {
                                var d = u[c], h = u[c + 1], f = u[c + 2];
                                o.push(d, h, h, f, f, d)
                            } else for (c = 0; c < r.vertexCount; c += 3) {
                                d = c, h = c + 1, f = c + 2;
                                o.push(d, h, h, f, f, d)
                            }
                            break;
                        case 5:
                        case 6:
                    }
                    i++
                }
                o.length > 0 && (r.wireframeIndex = this.addSubMesh(o.length, e, 1), this.setIndices(o, r.wireframeIndex))
            }
            return this
        }, t.prototype.removeWireframeSubMesh = function () {
            var e = this.glTFMesh.extras.wireframeIndex;
            return e >= 0 && this.removeSubMesh(e), this
        }, t.prototype.getAttribute = function (e, t, n) {
            void 0 === t && (t = 0), void 0 === n && (n = 0);
            var r = this.attributes;
            if (e in r) {
                var i = this.getAccessor(r[e]);
                return this.createTypeArrayFromAccessor(i, t, n)
            }
            return null
        }, t.prototype.setAttribute = function (e, t, n, r) {
            void 0 === n && (n = 0), void 0 === r && (r = 0);
            var i = this.getAttribute(e, n, r);
            return null !== i && ("POSITION" === e && this.needUpdate(1), i.set(t)), i
        }, t.prototype.getIndices = function (e, t, n) {
            void 0 === e && (e = 0), void 0 === t && (t = 0), void 0 === n && (n = 0);
            var r = this.glTFMesh.primitives;
            if (0 <= e && e < r.length) {
                var i = r[e].indices;
                if (void 0 !== i) {
                    var o = this.getAccessor(i);
                    return this.createTypeArrayFromAccessor(o, t, n)
                }
                return null
            }
            return console.warn("Error arguments."), null
        }, t.prototype.setIndices = function (e, t, n, r) {
            void 0 === t && (t = 0), void 0 === n && (n = 0), void 0 === r && (r = 0);
            var i = this.getIndices(t, n, r);
            return null !== i && i.set(e), i
        }, t.prototype.getVertices = function (e, t) {
            return void 0 === e && (e = 0), void 0 === t && (t = 0), this.getAttribute("POSITION", e, t)
        }, t.prototype.getUVs = function (e, t) {
            return void 0 === e && (e = 0), void 0 === t && (t = 0), this.getAttribute("TEXCOORD_0", e, t)
        }, t.prototype.getColors = function (e, t) {
            return void 0 === e && (e = 0), void 0 === t && (t = 0), this.getAttribute("COLOR_0", e, t)
        }, t.prototype.getNormals = function (e, t) {
            return void 0 === e && (e = 0), void 0 === t && (t = 0), this.getAttribute("NORMAL", e, t)
        }, t.prototype.getTangents = function (e, t) {
            return void 0 === e && (e = 0), void 0 === t && (t = 0), this.getAttribute("TANGENT", e, t)
        }, t.prototype.uploadVertexBuffer = function (e, t, n) {
            throw new Error("Method not implemented.")
        }, t.prototype.uploadSubIndexBuffer = function (e, t, n) {
            throw new Error("Method not implemented.")
        }, Object.defineProperty(t.prototype, "drawMode", {
            get: function () {
                return this.glTFMesh.extras.drawMode
            }, set: function (e) {
                this.glTFMesh.extras.drawMode = e, this.needUpdate(2)
            }, enumerable: !0, configurable: !0
        }), Object.defineProperty(t.prototype, "vertexCount", {
            get: function () {
                return this.glTFMesh.extras.vertexCount
            }, enumerable: !0, configurable: !0
        }), Object.defineProperty(t.prototype, "subMeshCount", {
            get: function () {
                return this.glTFMesh.primitives.length
            }, enumerable: !0, configurable: !0
        }), Object.defineProperty(t.prototype, "boundingBox", {
            get: function () {
                return this.update(1, -1), this._boundingBox
            }, enumerable: !0, configurable: !0
        }), Object.defineProperty(t.prototype, "boneIndices", {
            get: function () {
                var e = this._glTF;
                if (null === this._boneIndices && void 0 !== e.skins) for (var t = this._boneIndices = {}, n = 0, r = e.skins[0].joints; n < r.length; n++) {
                    var i = r[n];
                    t[e.nodes[i].name] = i
                }
                return this._boneIndices
            }, enumerable: !0, configurable: !0
        }), Object.defineProperty(t.prototype, "inverseBindMatrices", {
            get: function () {
                var e = this._glTF;
                return null === this._inverseBindMatrices && void 0 !== e.skins && (this._inverseBindMatrices = this.createTypeArrayFromAccessor(this.getAccessor(e.skins[0].inverseBindMatrices))), this._inverseBindMatrices
            }, enumerable: !0, configurable: !0
        }), t = c([Object(r.component)({isAbstract: !1})], t)
    }(h);
    __reflect(w, "@egret/render/Mesh");
    var R = function (e) {
        function t() {
            var t = null !== e && e.apply(this, arguments) || this;
            return t.autoReleaseImages = !0, t
        }

        return u(t, e), t.create = function (e) {
            return void 0 === e.width && (e.width = 256), void 0 === e.height && (e.height = 256), this.fromGLTF(this.createGLTF(e))
        }, t.createColorTexture = function (e, t, n, r) {
            return void 0 === r && (r = 255), this.create({
                source: new Uint8Array([e, t, n, r]),
                width: 1,
                height: 1,
                sampler: {wrapS: 33071, wrapT: 33071, magFilter: 9729, minFilter: 9729}
            })
        }, t.createGridTexture = function () {
            for (var e = new Uint8Array(65536), t = 0; t < 128; ++t) for (var n = 0; n < 128; ++n) {
                var r = 4 * (128 * t + n), i = (n - 64) * (t - 64) > 0;
                e[r] = e[r + 1] = e[r + 2] = i ? 0 : 255, e[r + 3] = 255
            }
            return this.create({
                source: e,
                width: 128,
                height: 128,
                levels: 0,
                anisotropy: 4,
                sampler: {magFilter: 9729, minFilter: 9987}
            })
        }, t.prototype._uninitialize = function () {
            throw new Error("Method not implemented.")
        }, t.prototype._update = function (e) {
            throw new Error("Method not implemented.")
        }, t.prototype.uninitialize = function () {
            this._uninitialize(), e.prototype.uninitialize.call(this)
        }, t.prototype.update = function (t) {
            this._update(t), e.prototype.update.call(this, t)
        }, t.prototype.bindTexture = function (e) {
            throw new Error("Method not implemented.")
        }, t.prototype.setSource = function (e) {
            void 0 === e && (e = null);
            var t = this._glTF, n = this._image, r = this.glTFTexture.extensions.egret;
            return null !== e && (ArrayBuffer.isView(e) ? (void 0 === t.buffers && (t.buffers = []), void 0 === t.bufferViews && (t.bufferViews = []), t.buffers[0] = {
                byteLength: e.byteLength,
                extras: {data: e}
            }, t.bufferViews[0] = {
                buffer: 0,
                byteLength: e.byteLength
            }, n.bufferView = 0, delete n.extras) : (void 0 === n.extras ? n.extras = {data: e} : n.extras.data = e, r.width = e.width, r.height = e.height, delete t.buffers, delete t.bufferViews, delete n.bufferView), this.needUpdate(7)), this
        }, t = c([Object(r.component)({isAbstract: !1})], t)
    }(f);
    __reflect(R, "@egret/render/Texture");
    var P = function (e) {
        function t() {
            var t = null !== e && e.apply(this, arguments) || this;
            return t.logDepthBufFC = 0, t.opaqueDrawCalls = [], t.blendDrawCalls = [], t.shadowDrawCalls = [], t
        }

        return u(t, e), t = c([Object(a.hideFlag)(28), Object(r.component)({isAbstract: !1})], t)
    }(i.GameComponent);
    __reflect(P, "@egret/render/CameraContext");
    var L = function (e) {
        function t() {
            var t = null !== e && e.apply(this, arguments) || this;
            return t.bufferMask = 256, t.cullingMask = 1, t.frustumCulled = !0, t.order = 0, t.backgroundColor = i.Color.create(.15, .25, .5, 1), t._needUpdate = 127, t._nativeProjection = !1, t._nativeCulling = !1, t._near = .3, t._far = 1e3, t._fov = .7853981633974483, t._size = 1, t._opvalue = 1, t._renderTargetSize = {
                w: 0,
                h: 0
            }, t._viewport = i.Rectangle.create(0, 0, 1, 1), t._pixelViewport = i.Rectangle.create(0, 0, 1, 1), t._subViewport = i.Rectangle.create(0, 0, 1, 1), t._frustum = i.Frustum.create(), t._projectionMatrix = i.Matrix4.create(), t._cameraToWorldMatrix = i.Matrix4.create(), t._worldToCameraMatrix = i.Matrix4.create(), t._worldToClipMatrix = i.Matrix4.create(), t._clipToWorldMatrix = i.Matrix4.create(), t._cullingMatrix = i.Matrix4.create(), t._renderTarget = null, t._renderTargetInner = null, t._readRenderTarget = null, t._writeRenderTarget = null, t._context = null, t._stage = null, t._render = null, t
        }

        return u(t, e), t.prototype.initialize = function (t, n, r) {
            void 0 === r && (r = null), e.prototype.initialize.call(this, t, n, r);
            var o = i.Application.instance.stage;
            this._stage = o, this._context = this.entity.getComponent(P), this._context.logDepthBufFC = 2 / (Math.log(this.far + 1) / Math.LN2)
        }, t.prototype.uninitialize = function () {
            e.prototype.uninitialize.call(this), null !== this._readRenderTarget && this._readRenderTarget.entity.destroy(), null !== this._writeRenderTarget && this._writeRenderTarget.entity.destroy(), this.bufferMask = 256, this.cullingMask = 1, this.order = 0, this._needUpdate = 127, this._nativeProjection = !1, this._nativeCulling = !1, this._renderTarget = null, this._renderTargetInner = null, this._readRenderTarget = null, this._writeRenderTarget = null, this._context = null, this._stage = null, this._render = null
        }, t.prototype.needUpdate = function (e) {
            0 != (32 & e) && (this._nativeProjection || (e |= 1)), 0 != (3 & e) && (this._nativeProjection || (e |= 12), this._nativeCulling || (e |= 80)), this._needUpdate |= e
        }, t.prototype.update = function (e) {
            var t = this._needUpdate & e;
            if (0 != (1 & t) && this._projectionMatrix.fromProjection(this._near, this._far, this._fov, this._size, this._opvalue, this.aspect, this._stage.matchFactor, this._subViewport), 0 != (32 & t)) {
                var n = this.renderTargetSize, r = n.w, i = n.h, o = this._viewport;
                this._pixelViewport.set(r * o.x, i * o.y, r * o.w, i * o.h)
            }
            0 != (2 & t) && this._cameraToWorldMatrix.inverse(this.worldToCameraMatrix), 0 != (8 & t) && this._worldToClipMatrix.multiply(this.projectionMatrix, this.worldToCameraMatrix), 0 != (4 & t) && this._clipToWorldMatrix.inverse(this.worldToClipMatrix), 0 != (16 & t) && this._cullingMatrix.copy(this.worldToClipMatrix), 0 != (64 & t) && this._frustum.fromMatrix(this.cullingMatrix), this._needUpdate &= ~e
        }, t.prototype.render = function (e, t) {
            void 0 === e && (e = null), void 0 === t && (t = null), this._render(this, e, t)
        }, t.prototype.stageToWorld = function (e, t) {
            void 0 === t && (t = null), null === t && (t = i.Vector3.create());
            var n = this.clipToWorldMatrix, r = this.cameraToWorldMatrix, o = this._viewport, a = this.renderTargetSize,
                s = a.w, l = a.h, u = 2 / s, c = 2 / l, p = i.Vector3.create(e.x, e.y, e.z);
            p.x -= o.x * s, p.y -= o.y * l, p.x /= o.w, p.y /= o.h, t.set(p.x * u - 1, 1 - p.y * c, .95).applyMatrix(n);
            var d = i.Vector3.create().fromMatrixPosition(r).release(),
                h = i.Vector3.create().fromMatrixColumn(r, 2).multiplyScalar(-1).release(), f = t.subtract(d).dot(h);
            return f < -2220446049250313e-31 || 2220446049250313e-31 < f ? 0 === this._opvalue || t.multiplyScalar(-e.z / f).add(d) : console.error(), t
        }, t.prototype.worldToStage = function (e, t) {
            void 0 === t && (t = null), null === t && (t = i.Vector3.create());
            var n = this.worldToClipMatrix, r = this._viewport, o = this.renderTargetSize, a = o.w, s = o.h;
            return t.applyMatrix(n, e), t.x = (t.x + 1) * a * .5, t.y = (1 - t.y) * s * .5, t.x *= r.w, t.y *= r.h, t.x += r.x * a, t.y += r.y * s, t
        }, t.prototype.stageToRay = function (e, t, n) {
            void 0 === n && (n = null), null === n && (n = i.Ray.create());
            var r = this.renderTargetSize, o = r.w, a = r.h, s = 2 / o, l = 2 / a, u = this.clipToWorldMatrix,
                c = this._viewport;
            return e -= c.x * o, t -= c.y * a, e /= c.w, t /= c.h, n.origin.set(e * s - 1, 1 - t * l, 0).applyMatrix(u), n.direction.set(e * s - 1, 1 - t * l, 1).applyMatrix(u).subtract(n.origin).normalize(), n
        }, t.prototype.resetCullingMatrix = function () {
            return this._nativeCulling = !1, this
        }, t.prototype.resetProjectionMatrix = function () {
            return this._nativeProjection = !1, this
        }, Object.defineProperty(t.prototype, "opvalue", {
            get: function () {
                return this._opvalue
            }, set: function (e) {
                e != e || e < 0 ? e = 0 : e > 1 && (e = 1), this._opvalue !== e && (this._opvalue = e, this.needUpdate(1))
            }, enumerable: !0, configurable: !0
        }), Object.defineProperty(t.prototype, "near", {
            get: function () {
                return this._near
            }, set: function (e) {
                (e != e || e < .01) && (e = .01), e >= this._far && (e = this._far - .01), this._near !== e && (this._near = e, this.needUpdate(1))
            }, enumerable: !0, configurable: !0
        }), Object.defineProperty(t.prototype, "far", {
            get: function () {
                return this._far
            }, set: function (e) {
                (e != e || e <= this._near) && (e = this._near + .01), this._far !== e && (this._far = e, this._context.logDepthBufFC = 2 / (Math.log(this.far + 1) / Math.LN2), this.needUpdate(1))
            }, enumerable: !0, configurable: !0
        }), Object.defineProperty(t.prototype, "fov", {
            get: function () {
                return this._fov
            }, set: function (e) {
                e != e || e < .01 ? e = .01 : e > 3.1315926535897933 && (e = 3.1315926535897933), this._fov !== e && (this._fov = e, this.needUpdate(1))
            }, enumerable: !0, configurable: !0
        }), Object.defineProperty(t.prototype, "size", {
            get: function () {
                return this._size
            }, set: function (e) {
                (e != e || e <= 0) && (e = .001), this._size !== e && (this._size = e, this.needUpdate(1))
            }, enumerable: !0, configurable: !0
        }), Object.defineProperty(t.prototype, "aspect", {
            get: function () {
                var e = this.pixelViewport;
                return e.w / e.h
            }, enumerable: !0, configurable: !0
        }), Object.defineProperty(t.prototype, "renderTargetSize", {
            get: function () {
                var e = this._renderTarget, t = this._renderTargetSize;
                if (null !== e) t.w = e.width, t.h = e.height; else {
                    var n = this._stage.viewport;
                    t.w = n.w, t.h = n.h
                }
                return t
            }, enumerable: !0, configurable: !0
        }), Object.defineProperty(t.prototype, "viewport", {
            get: function () {
                return this._viewport
            }, set: function (e) {
                var t = this._viewport;
                t !== e && t.copy(e), (t.w != t.w || t.w <= 0) && (t.w = .001), (t.h != t.h || t.h <= 0) && (t.h = .001), this.needUpdate(32)
            }, enumerable: !0, configurable: !0
        }), Object.defineProperty(t.prototype, "subViewport", {
            get: function () {
                return this._subViewport
            }, set: function (e) {
                var t = this._subViewport;
                t !== e && t.copy(e), (t.w != t.w || t.w <= 0) && (t.w = .001), (t.h != t.h || t.h <= 0) && (t.h = .001), this.needUpdate(1)
            }, enumerable: !0, configurable: !0
        }), Object.defineProperty(t.prototype, "pixelViewport", {
            get: function () {
                return 0 != (32 & this._needUpdate) && this.update(32), this._pixelViewport
            }, set: function (e) {
                var t = this._pixelViewport;
                t !== e && t.copy(e), (t.w != t.w || t.w <= 0) && (t.w = 1), (t.h != t.h || t.h <= 0) && (t.h = 1);
                var n = this.renderTargetSize, r = n.w, i = n.h;
                this._viewport.set(t.x / r, t.y / i, t.w / r, t.h / i), this.needUpdate(1)
            }, enumerable: !0, configurable: !0
        }), Object.defineProperty(t.prototype, "frustum", {
            get: function () {
                return 0 != (64 & this._needUpdate) && this.update(64), this._frustum
            }, enumerable: !0, configurable: !0
        }), Object.defineProperty(t.prototype, "projectionMatrix", {
            get: function () {
                return this._nativeProjection || 0 != (1 & this._needUpdate) && this.update(1), this._projectionMatrix
            }, set: function (e) {
                var t = this._projectionMatrix;
                t !== e && t.copy(e), this._nativeProjection = !0, this.needUpdate(12)
            }, enumerable: !0, configurable: !0
        }), Object.defineProperty(t.prototype, "cameraToWorldMatrix", {
            get: function () {
                return 0 != (2 & this._needUpdate) && this.update(2), this._cameraToWorldMatrix
            }, enumerable: !0, configurable: !0
        }), Object.defineProperty(t.prototype, "worldToCameraMatrix", {
            get: function () {
                return this._worldToCameraMatrix
            }, set: function (e) {
                var t = this._worldToCameraMatrix;
                t !== e && t.copy(e), this.needUpdate(2)
            }, enumerable: !0, configurable: !0
        }), Object.defineProperty(t.prototype, "worldToClipMatrix", {
            get: function () {
                return 0 != (8 & this._needUpdate) && this.update(8), this._worldToClipMatrix
            }, enumerable: !0, configurable: !0
        }), Object.defineProperty(t.prototype, "clipToWorldMatrix", {
            get: function () {
                return 0 != (4 & this._needUpdate) && this.update(4), this._clipToWorldMatrix
            }, enumerable: !0, configurable: !0
        }), Object.defineProperty(t.prototype, "cullingMatrix", {
            get: function () {
                return 0 != (16 & this._needUpdate) && this.update(16), this._cullingMatrix
            }, set: function (e) {
                var t = this._cullingMatrix;
                t !== e && t.copy(e), this._nativeCulling = !0, this.needUpdate(64)
            }, enumerable: !0, configurable: !0
        }), Object.defineProperty(t.prototype, "renderTarget", {
            get: function () {
                return this._renderTarget
            }, set: function (e) {
                this._renderTarget !== e && (this._renderTarget = e, this.needUpdate(32))
            }, enumerable: !0, configurable: !0
        }), Object.defineProperty(t.prototype, "_innerRenderTarget", {
            get: function () {
                return null !== this._renderTarget ? this._renderTarget : this._renderTargetInner
            }, set: function (e) {
                this._renderTargetInner !== e && (this._renderTargetInner = e, this.needUpdate(32))
            }, enumerable: !0, configurable: !0
        }), Object.defineProperty(t.prototype, "postprocessingRenderTarget", {
            get: function () {
                var e = this._stage;
                return null === this._readRenderTarget && (this._readRenderTarget = b.create({
                    width: e.viewport.w,
                    height: e.viewport.h
                }).setFilter(1).setRepeat(!1)), null === this._writeRenderTarget && (this._writeRenderTarget = b.create({
                    width: e.viewport.w,
                    height: e.viewport.h
                }).setFilter(1).setRepeat(!1)), this._readRenderTarget
            }, enumerable: !0, configurable: !0
        }), Object.defineProperty(t.prototype, "context", {
            get: function () {
                return this._context
            }, enumerable: !0, configurable: !0
        }), c([Object(a.property)("enum", {listItems: Object(a.getItemsFromEnum)(s.BufferMask)}), a.serializedField], t.prototype, "bufferMask", void 0), c([Object(a.property)("enum", {listItems: Object(a.getItemsFromEnum)(i.NodeLayer)}), a.serializedField], t.prototype, "cullingMask", void 0), c([Object(a.property)("boolean"), a.serializedField], t.prototype, "frustumCulled", void 0), c([Object(a.property)("int"), a.serializedField], t.prototype, "order", void 0), c([Object(a.property)("color"), a.serializedField], t.prototype, "backgroundColor", void 0), c([Object(a.property)("float", {
            minimum: 0,
            maximum: 1,
            step: .01
        }), a.serializedField], t.prototype, "opvalue", null), c([Object(a.property)("float", {
            minimum: .01,
            maximum: 2999.99,
            step: 1
        }), a.serializedField], t.prototype, "near", null), c([Object(a.property)("float", {
            minimum: .02,
            maximum: 3e3,
            step: 1
        }), a.serializedField], t.prototype, "far", null), c([Object(a.property)("float", {
            minimum: .01,
            maximum: 3.1315926535897933,
            step: .01
        }), a.serializedField], t.prototype, "fov", null), c([Object(a.property)("float", {minimum: .01}), a.serializedField], t.prototype, "size", null), c([Object(a.property)("rectangle", {step: .01}), a.serializedField], t.prototype, "viewport", null), c([Object(a.property)("rectangle", {step: .01}), a.serializedField], t.prototype, "subViewport", null), c([Object(a.property)("rectangle", {step: 1})], t.prototype, "pixelViewport", null), c([a.serializedField], t.prototype, "renderTarget", null), t = c([Object(r.component)({
            type: "camera",
            requireComponents: [P],
            isAbstract: !1
        })], t)
    }(i.GameComponent);
    __reflect(L, "@egret/render/Camera");
    var D = function (e) {
        function t() {
            return null !== e && e.apply(this, arguments) || this
        }

        return u(t, e), t = c([Object(r.component)({type: "cameraFrustumCulling", isAbstract: !0})], t)
    }(i.GameComponent);
    __reflect(D, "@egret/render/CameraFrustumCulling");
    var I = function (e) {
        function t() {
            return null !== e && e.apply(this, arguments) || this
        }

        var n;
        return u(t, e), n = t, t.prototype._addToResources = function (e, t) {
            return t.entity.uri = e, a.ResourceManager.instance.addResource({
                uri: e,
                type: "texture",
                status: "Ok",
                data: t
            }), t
        }, t.prototype.initialize = function (t, r, i) {
            void 0 === i && (i = null), e.prototype.initialize.call(this, t, r, i);
            var o = n;
            o.WHITE = this._addToResources("builtin/white.image.json", R.createColorTexture(255, 255, 255)), o.GRAY = this._addToResources("builtin/gray.image.json", R.createColorTexture(128, 128, 128)), o.GRID = this._addToResources("builtin/grid.image.json", R.createGridTexture()), o.MISSING = this._addToResources("builtin/missing.image.json", R.createColorTexture(255, 0, 255))
        }, t.WHITE = null, t.GRAY = null, t.GRID = null, t.MISSING = null, t = n = c([Object(a.hideFlag)(28), Object(r.component)({
            isRemovable: !1,
            isAbstract: !1
        })], t)
    }(r.Component);
    __reflect(I, "@egret/render/DefaultTextures");
    var N = {
        asset: {version: "2.0", generator: "shader plugin for egret"},
        extensionsRequired: ["egret", "KHR_techniques_webgl"],
        extensionsUsed: ["egret", "KHR_techniques_webgl"],
        extensions: {
            KHR_techniques_webgl: {
                shaders: [{
                    name: "background_vert",
                    type: 35633,
                    uri: "shaders/background.shader.glsl.js",
                    extras: {
                        data: "    varying vec2 vUv;\n    uniform mat3 uvTransform;\n    \n    void main() {\n    \n     vUv = ( uvTransform * vec3( uv, 1 ) ).xy;\n    \n        gl_Position = vec4( position.xy, 1.0, 1.0 );\n    \n    }\n",
                        programs: {}
                    }
                }, {
                    name: "background_frag",
                    type: 35632,
                    uri: "shaders/background.shader.glsl.js",
                    extras: {
                        data: "    uniform sampler2D t2D;\n    \n    varying vec2 vUv;\n    \n    void main() {\n    \n     vec4 texColor = texture2D( t2D, vUv );\n    \n        gl_FragColor = mapTexelToLinear( texColor );\n    \n        #include <tonemapping_fragment>\n        #include <encodings_fragment>\n    \n    }\n",
                        programs: {}
                    }
                }],
                techniques: [{
                    name: "background",
                    attributes: {},
                    uniforms: {uvTransform: {type: 35675, value: [1, 0, 0, 0, 1, 0, 0, 0, 1]}, t2D: {type: 35678}}
                }],
                programs: []
            }
        }
    }, z = {
        asset: {version: "2.0", generator: "shader plugin for egret"},
        extensionsRequired: ["egret", "KHR_techniques_webgl"],
        extensionsUsed: ["egret", "KHR_techniques_webgl"],
        extensions: {
            KHR_techniques_webgl: {
                shaders: [{
                    name: "baseJoint_vert", type: 35633, uri: "shaders/baseJoint.shader.glsl.js", extras: {
                        data: "    precision highp float;\n    #define USE_SKINNING\n    // #define EGRET\n    // #define USE_GPU_ANI\n    \n    float STEP = 3.0;\n    \n    uniform float uAnimationMapHeight;\n    uniform float uAnimationMapWidth;\n    uniform float uTime;\n    uniform sampler2D uAnimationMap;\n    \n    mat4 getJointMatrix(float jointIndex, float frame) {\n    \n        float index = frame / uAnimationMapWidth;\n    \n        float pixelOffset = jointIndex * STEP / uAnimationMapHeight;\n        vec4 row1 = texture2D(uAnimationMap,vec2(index, pixelOffset));\n        vec4 row2 = texture2D(uAnimationMap,vec2(index, pixelOffset + (1.0 / uAnimationMapHeight)));\n        vec4 row3 = texture2D(uAnimationMap,vec2(index, pixelOffset + (2.0 / uAnimationMapHeight)));\n        vec4 row4 = vec4(0.0, 0.0, 0.0, 1.0);\n    \n        vec4 col1 = vec4(row1.r, row2.r, row3.r, row4.r);\n        vec4 col2 = vec4(row1.g, row2.g, row3.g, row4.g);\n        vec4 col3 = vec4(row1.b, row2.b, row3.b, row4.b);\n        vec4 col4 = vec4(row1.a, row2.a, row3.a, row4.a);\n        mat4 matrix = mat4(col1, col2, col3, col4);\n        return matrix;\n    }\n    \n    \n    \n    void main() {\n        mat4 animationMatrix = mat4(0.0);\n        vec4 skinVertex = vec4( position, 1.0 );\n        animationMatrix += getJointMatrix(skinIndex.x, uTime) * skinWeight.x;\n        animationMatrix += getJointMatrix(skinIndex.y, uTime) * skinWeight.y;\n        animationMatrix += getJointMatrix(skinIndex.z, uTime) * skinWeight.z;\n        animationMatrix += getJointMatrix(skinIndex.w, uTime) * skinWeight.w;\n        vec4 skinned = vec4( 0.0 );\n        skinned += animationMatrix * skinVertex;\n    \n        gl_Position = projectionMatrix * viewMatrix * animationMatrix * skinVertex;\n    }\n",
                        programs: {}
                    }
                }, {
                    name: "baseJoint_frag",
                    type: 35632,
                    uri: "shaders/baseJoint.shader.glsl.js",
                    extras: {
                        data: "    precision highp float;\n    uniform sampler2D uJointAniamtionMap;\n    \n    void main() {\n        gl_FragColor = vec4(0.0, 1.0, 0.0, 1.0); \n    }\n",
                        programs: {}
                    }
                }],
                techniques: [{
                    name: "baseJoint",
                    attributes: {},
                    uniforms: {
                        uAnimationMapHeight: {type: 5126},
                        uAnimationMapWidth: {type: 5126},
                        uTime: {type: 5126},
                        uAnimationMap: {type: 35678},
                        uJointAniamtionMap: {type: 35678}
                    }
                }],
                programs: []
            }
        }
    }, U = {
        asset: {version: "2.0", generator: "shader plugin for egret"},
        extensionsRequired: ["egret", "KHR_techniques_webgl"],
        extensionsUsed: ["egret", "KHR_techniques_webgl"],
        extensions: {
            KHR_techniques_webgl: {
                shaders: [{
                    name: "copy_vert",
                    type: 35633,
                    uri: "shaders/copy.shader.glsl.js",
                    extras: {
                        data: "    varying vec2 vUv;\n    \n    void main() {\n     vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n    }\n",
                        programs: {}
                    }
                }, {
                    name: "copy_frag",
                    type: 35632,
                    uri: "shaders/copy.shader.glsl.js",
                    extras: {
                        data: "    uniform float opacity;\n    uniform sampler2D map;\n    varying vec2 vUv;\n    \n    void main() {\n     vec4 texel = texture2D( map, vUv );\n        gl_FragColor = opacity * texel;\n    }\n",
                        programs: {}
                    }
                }],
                techniques: [{
                    name: "copy",
                    attributes: {},
                    uniforms: {opacity: {type: 5126, value: 1}, map: {type: 35678}}
                }],
                programs: []
            }
        }
    }, F = {
        asset: {version: "2.0", generator: "shader plugin for egret"},
        extensionsRequired: ["egret", "KHR_techniques_webgl"],
        extensionsUsed: ["egret", "KHR_techniques_webgl"],
        extensions: {
            KHR_techniques_webgl: {
                shaders: [{
                    name: "cube_vert",
                    type: 35633,
                    uri: "shaders/cube.shader.glsl.js",
                    extras: {
                        data: "    varying vec3 vWorldDirection;\n    \n    #include <common>\n    \n    void main() {\n    \n     vWorldDirection = transformDirection( position, modelMatrix );\n    \n        #include <begin_vertex>\n        #include <project_vertex>\n    \n        gl_Position.z = gl_Position.w; // set z to camera.far\n    \n    }\n",
                        programs: {}
                    }
                }, {
                    name: "cube_frag",
                    type: 35632,
                    uri: "shaders/cube.shader.glsl.js",
                    extras: {
                        data: "    uniform samplerCube tCube;\n    uniform float tFlip;\n    uniform float opacity;\n    \n    varying vec3 vWorldDirection;\n    \n    void main() {\n     vec4 texColor = textureCube( tCube, vec3( tFlip * vWorldDirection.x, vWorldDirection.yz ) );\n    \n        gl_FragColor = mapTexelToLinear( texColor );\n        gl_FragColor.a *= opacity;\n    \n        #include <tonemapping_fragment>\n        #include <encodings_fragment>\n    \n    }\n",
                        programs: {}
                    }
                }],
                techniques: [{
                    name: "cube",
                    attributes: {},
                    uniforms: {tCube: {type: 35680}, tFlip: {type: 5126, value: 1}, opacity: {type: 5126, value: 1}}
                }],
                programs: []
            }
        }
    }, k = {
        asset: {version: "2.0", generator: "shader plugin for egret"},
        extensionsRequired: ["egret", "KHR_techniques_webgl"],
        extensionsUsed: ["egret", "KHR_techniques_webgl"],
        extensions: {
            KHR_techniques_webgl: {
                shaders: [{
                    name: "depth_vert", type: 35633, uri: "shaders/depth.shader.glsl.js", extras: {
                        data: "    #include <common>\n    #include <uv_pars_vertex>\n    #include <displacementmap_pars_vertex>\n    #include <morphtarget_pars_vertex>\n    #include <skinning_pars_vertex>\n    #include <logdepthbuf_pars_vertex>\n    #include <clipping_planes_pars_vertex>\n    \n    void main() {\n     // modified by egret\n        #ifdef EGRET  \n            #ifdef USE_INSTANCED\n                #include <instances_vertex>\n            #endif\n        #endif\n    \n        #include <uv_vertex>\n    \n        #include <skinbase_vertex>\n    \n        #ifdef USE_DISPLACEMENTMAP\n    \n            #include <beginnormal_vertex>\n            #include <morphnormal_vertex>\n            #include <skinnormal_vertex>\n    \n        #endif\n    \n        #include <begin_vertex>\n        #include <morphtarget_vertex>\n        #include <skinning_vertex>\n        #include <displacementmap_vertex>\n        #include <project_vertex>\n        #include <logdepthbuf_vertex>\n        #include <clipping_planes_vertex>\n    \n    }\n",
                        programs: {}
                    }
                }, {
                    name: "depth_frag", type: 35632, uri: "shaders/depth.shader.glsl.js", extras: {
                        data: "    #if DEPTH_PACKING == 3200\n    \n     uniform float opacity;\n    \n    #endif\n    \n    #include <common>\n    #include <packing>\n    #include <uv_pars_fragment>\n    #include <map_pars_fragment>\n    #include <alphamap_pars_fragment>\n    #include <logdepthbuf_pars_fragment>\n    #include <clipping_planes_pars_fragment>\n    \n    void main() {\n    \n        #include <clipping_planes_fragment>\n    \n        vec4 diffuseColor = vec4( 1.0 );\n    \n        #if DEPTH_PACKING == 3200\n    \n            diffuseColor.a = opacity;\n    \n        #endif\n    \n        #include <map_fragment>\n        #include <alphamap_fragment>\n        #include <alphatest_fragment>\n    \n        #include <logdepthbuf_fragment>\n    \n        #if DEPTH_PACKING == 3200\n    \n            gl_FragColor = vec4( vec3( 1.0 - gl_FragCoord.z ), opacity );\n    \n        #elif DEPTH_PACKING == 3201\n    \n            gl_FragColor = packDepthToRGBA( gl_FragCoord.z );\n    \n        #endif\n    \n    }\n",
                        programs: {}
                    }
                }],
                techniques: [{
                    name: "depth",
                    attributes: {},
                    uniforms: {
                        uvTransform: {type: 35675, value: [1, 0, 0, 0, 1, 0, 0, 0, 1]},
                        displacementMap: {type: 35678},
                        displacementScale: {type: 5126, value: 1},
                        displacementBias: {type: 5126},
                        bindMatrix: {type: 35676},
                        bindMatrixInverse: {type: 35676},
                        opacity: {type: 5126, value: 1},
                        map: {type: 35678},
                        alphaMap: {type: 35678},
                        "clippingPlanes[0]": {type: 35666}
                    }
                }],
                programs: []
            }
        }
    }, V = {
        asset: {version: "2.0", generator: "shader plugin for egret"},
        extensionsRequired: ["egret", "KHR_techniques_webgl"],
        extensionsUsed: ["egret", "KHR_techniques_webgl"],
        extensions: {
            KHR_techniques_webgl: {
                shaders: [{
                    name: "distanceRGBA_vert", type: 35633, uri: "shaders/distanceRGBA.shader.glsl.js", extras: {
                        data: "    #define DISTANCE\n    \n    varying vec3 vWorldPosition;\n    \n    #include <common>\n    #include <uv_pars_vertex>\n    #include <displacementmap_pars_vertex>\n    #include <morphtarget_pars_vertex>\n    #include <skinning_pars_vertex>\n    #include <clipping_planes_pars_vertex>\n    \n    void main() {\n     // modified by egret\n        #ifdef EGRET  \n    \n            #ifdef USE_INSTANCED\n                #include <instances_vertex>\n            #endif\n    \n        #endif\n    \n        #include <uv_vertex>\n    \n        #include <skinbase_vertex>\n    \n        #ifdef USE_DISPLACEMENTMAP\n    \n            #include <beginnormal_vertex>\n            #include <morphnormal_vertex>\n            #include <skinnormal_vertex>\n    \n        #endif\n    \n        #include <begin_vertex>\n        #include <morphtarget_vertex>\n        #include <skinning_vertex>\n        #include <displacementmap_vertex>\n        #include <project_vertex>\n        #include <worldpos_vertex>\n        #include <clipping_planes_vertex>\n    \n    \n        #ifdef EGRET  \n            // modified by egret\n            gl_Position.x *= -1.0;\n        #endif\n    \n        \n        vWorldPosition = worldPosition.xyz;\n    \n    }\n",
                        programs: {}
                    }
                }, {
                    name: "distanceRGBA_frag",
                    type: 35632,
                    uri: "shaders/distanceRGBA.shader.glsl.js",
                    extras: {
                        data: "    #define DISTANCE\n    \n    uniform vec3 referencePosition;\n    uniform float nearDistance;\n    uniform float farDistance;\n    varying vec3 vWorldPosition;\n    \n    #include <common>\n    #include <packing>\n    #include <uv_pars_fragment>\n    #include <map_pars_fragment>\n    #include <alphamap_pars_fragment>\n    #include <clipping_planes_pars_fragment>\n    \n    void main () {\n    \n     #include <clipping_planes_fragment>\n    \n        vec4 diffuseColor = vec4( 1.0 );\n    \n        #include <map_fragment>\n        #include <alphamap_fragment>\n        #include <alphatest_fragment>\n    \n        float dist = length( vWorldPosition - referencePosition );\n        dist = ( dist - nearDistance ) / ( farDistance - nearDistance );\n        dist = saturate( dist ); // clamp to [ 0, 1 ]\n    \n        gl_FragColor = packDepthToRGBA( dist );\n    \n    }\n",
                        programs: {}
                    }
                }],
                techniques: [{
                    name: "distanceRGBA",
                    attributes: {},
                    uniforms: {
                        uvTransform: {type: 35675, value: [1, 0, 0, 0, 1, 0, 0, 0, 1]},
                        displacementMap: {type: 35678},
                        displacementScale: {type: 5126, value: 1},
                        displacementBias: {type: 5126},
                        bindMatrix: {type: 35676},
                        bindMatrixInverse: {type: 35676},
                        map: {type: 35678},
                        alphaMap: {type: 35678},
                        "clippingPlanes[0]": {type: 35666}
                    }
                }],
                programs: []
            }
        }
    }, B = {
        asset: {version: "2.0", generator: "shader plugin for egret"},
        extensionsRequired: ["egret", "KHR_techniques_webgl"],
        extensionsUsed: ["egret", "KHR_techniques_webgl"],
        extensions: {
            KHR_techniques_webgl: {
                shaders: [{
                    name: "equirect_vert",
                    type: 35633,
                    uri: "shaders/equirect.shader.glsl.js",
                    extras: {
                        data: "    varying vec3 vWorldDirection;\n    \n    #include <common>\n    \n    void main() {\n    \n     vWorldDirection = transformDirection( position, modelMatrix );\n    \n        #include <begin_vertex>\n        #include <project_vertex>\n    \n        #ifdef EGRET  \n            gl_Position.z = gl_Position.w; // set z to camera.far    ---modified by egret\n        #endif\n    \n        \n    }\n",
                        programs: {}
                    }
                }, {
                    name: "equirect_frag",
                    type: 35632,
                    uri: "shaders/equirect.shader.glsl.js",
                    extras: {
                        data: "    uniform sampler2D tEquirect;\n    \n    varying vec3 vWorldDirection;\n    \n    #include <common>\n    \n    void main() {\n    \n     vec3 direction = normalize( vWorldDirection );\n    \n        vec2 sampleUV;\n    \n        sampleUV.y = asin( clamp( direction.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;\n    \n        #ifdef EGRET  \n            sampleUV.y = 1.0 - sampleUV.y;// modified by egret\n        #endif\n        \n        sampleUV.x = atan( direction.z, direction.x ) * RECIPROCAL_PI2 + 0.5;\n    \n        vec4 texColor = texture2D( tEquirect, sampleUV );\n    \n        gl_FragColor = mapTexelToLinear( texColor );\n    \n        #include <tonemapping_fragment>\n        #include <encodings_fragment>\n    \n    }\n",
                        programs: {}
                    }
                }], techniques: [{name: "equirect", attributes: {}, uniforms: {tEquirect: {type: 35678}}}], programs: []
            }
        }
    }, G = {
        asset: {version: "2.0", generator: "shader plugin for egret"},
        extensionsRequired: ["egret", "KHR_techniques_webgl"],
        extensionsUsed: ["egret", "KHR_techniques_webgl"],
        extensions: {
            KHR_techniques_webgl: {
                shaders: [{
                    name: "fxaa_vert",
                    type: 35633,
                    uri: "shaders/fxaa.shader.glsl.js",
                    extras: {
                        data: "    // Attributes\n    uniform vec2 resolution;\n    \n    // Output\n    varying vec2 vUV;\n    varying vec2 sampleCoordS;\n    varying vec2 sampleCoordE;\n    varying vec2 sampleCoordN;\n    varying vec2 sampleCoordW;\n    varying vec2 sampleCoordNW;\n    varying vec2 sampleCoordSE;\n    varying vec2 sampleCoordNE;\n    varying vec2 sampleCoordSW;\n    \n    \n    void main(void) { \n        vUV = uv;\n    \n        sampleCoordS = vUV + vec2( 0.0, 1.0) * resolution;\n        sampleCoordE = vUV + vec2( 1.0, 0.0) * resolution;\n        sampleCoordN = vUV + vec2( 0.0,-1.0) * resolution;\n        sampleCoordW = vUV + vec2(-1.0, 0.0) * resolution;\n    \n        sampleCoordNW = vUV + vec2(-1.0,-1.0) * resolution;\n        sampleCoordSE = vUV + vec2( 1.0, 1.0) * resolution;\n        sampleCoordNE = vUV + vec2( 1.0,-1.0) * resolution;\n        sampleCoordSW = vUV + vec2(-1.0, 1.0) * resolution;\n    \n        gl_Position = vec4(position.x, position.y, 0.0, 1.0);\n    }\n",
                        programs: {}
                    }
                }, {
                    name: "fxaa_frag", type: 35632, uri: "shaders/fxaa.shader.glsl.js", extras: {
                        data: "    uniform sampler2D map;\n    uniform vec2 resolution;\n    \n    varying vec2 vUV;\n    varying vec2 sampleCoordS;\n    varying vec2 sampleCoordE;\n    varying vec2 sampleCoordN;\n    varying vec2 sampleCoordW;\n    varying vec2 sampleCoordNW;\n    varying vec2 sampleCoordSE;\n    varying vec2 sampleCoordNE;\n    varying vec2 sampleCoordSW;\n    \n    const float fxaaQualitySubpix = 1.0;\n    const float fxaaQualityEdgeThreshold = 0.166;\n    const float fxaaQualityEdgeThresholdMin = 0.0833;\n    const vec3 kLumaCoefficients = vec3(0.2126, 0.7152, 0.0722);\n    \n    #define FxaaLuma(rgba) dot(rgba.rgb, kLumaCoefficients)\n    \n    void main(){\n     vec2 posM;\n    \n        posM.x = vUV.x;\n        posM.y = vUV.y;\n    \n        vec4 rgbyM = texture2D(map, vUV, 0.0);\n        float lumaM = FxaaLuma(rgbyM);\n        float lumaS = FxaaLuma(texture2D(map, sampleCoordS, 0.0));\n        float lumaE = FxaaLuma(texture2D(map, sampleCoordE, 0.0));\n        float lumaN = FxaaLuma(texture2D(map, sampleCoordN, 0.0));\n        float lumaW = FxaaLuma(texture2D(map, sampleCoordW, 0.0));\n        float maxSM = max(lumaS, lumaM);\n        float minSM = min(lumaS, lumaM);\n        float maxESM = max(lumaE, maxSM);\n        float minESM = min(lumaE, minSM);\n        float maxWN = max(lumaN, lumaW);\n        float minWN = min(lumaN, lumaW);\n        float rangeMax = max(maxWN, maxESM);\n        float rangeMin = min(minWN, minESM);\n        float rangeMaxScaled = rangeMax * fxaaQualityEdgeThreshold;\n        float range = rangeMax - rangeMin;\n        float rangeMaxClamped = max(fxaaQualityEdgeThresholdMin, rangeMaxScaled);\n    \n    #ifndef MALI\n        if(range < rangeMaxClamped) \n        {\n            gl_FragColor = rgbyM;\n            return;\n        }\n    #endif\n    \n        float lumaNW = FxaaLuma(texture2D(map, sampleCoordNW, 0.0));\n        float lumaSE = FxaaLuma(texture2D(map, sampleCoordSE, 0.0));\n        float lumaNE = FxaaLuma(texture2D(map, sampleCoordNE, 0.0));\n        float lumaSW = FxaaLuma(texture2D(map, sampleCoordSW, 0.0));\n        float lumaNS = lumaN + lumaS;\n        float lumaWE = lumaW + lumaE;\n        float subpixRcpRange = 1.0 / range;\n        float subpixNSWE = lumaNS + lumaWE;\n        float edgeHorz1 = (-2.0 * lumaM) + lumaNS;\n        float edgeVert1 = (-2.0 * lumaM) + lumaWE;\n        float lumaNESE = lumaNE + lumaSE;\n        float lumaNWNE = lumaNW + lumaNE;\n        float edgeHorz2 = (-2.0 * lumaE) + lumaNESE;\n        float edgeVert2 = (-2.0 * lumaN) + lumaNWNE;\n        float lumaNWSW = lumaNW + lumaSW;\n        float lumaSWSE = lumaSW + lumaSE;\n        float edgeHorz4 = (abs(edgeHorz1) * 2.0) + abs(edgeHorz2);\n        float edgeVert4 = (abs(edgeVert1) * 2.0) + abs(edgeVert2);\n        float edgeHorz3 = (-2.0 * lumaW) + lumaNWSW;\n        float edgeVert3 = (-2.0 * lumaS) + lumaSWSE;\n        float edgeHorz = abs(edgeHorz3) + edgeHorz4;\n        float edgeVert = abs(edgeVert3) + edgeVert4;\n        float subpixNWSWNESE = lumaNWSW + lumaNESE;\n        float lengthSign = resolution.x;\n        bool horzSpan = edgeHorz >= edgeVert;\n        float subpixA = subpixNSWE * 2.0 + subpixNWSWNESE;\n    \n        if (!horzSpan)\n        {\n            lumaN = lumaW;\n        }\n    \n        if (!horzSpan) \n        {\n            lumaS = lumaE;\n        }\n    \n        if (horzSpan) \n        {\n            lengthSign = resolution.y;\n        }\n    \n        float subpixB = (subpixA * (1.0 / 12.0)) - lumaM;\n        float gradientN = lumaN - lumaM;\n        float gradientS = lumaS - lumaM;\n        float lumaNN = lumaN + lumaM;\n        float lumaSS = lumaS + lumaM;\n        bool pairN = abs(gradientN) >= abs(gradientS);\n        float gradient = max(abs(gradientN), abs(gradientS));\n    \n        if (pairN)\n        {\n            lengthSign = -lengthSign;\n        }\n    \n        float subpixC = clamp(abs(subpixB) * subpixRcpRange, 0.0, 1.0);\n        vec2 posB;\n    \n        posB.x = posM.x;\n        posB.y = posM.y;\n    \n        vec2 offNP;\n    \n        offNP.x = (!horzSpan) ? 0.0 : resolution.x;\n        offNP.y = (horzSpan) ? 0.0 : resolution.y;\n    \n        if (!horzSpan) \n        {\n            posB.x += lengthSign * 0.5;\n        }\n    \n        if (horzSpan)\n        {\n            posB.y += lengthSign * 0.5;\n        }\n    \n        vec2 posN;\n    \n        posN.x = posB.x - offNP.x * 1.5;\n        posN.y = posB.y - offNP.y * 1.5;\n    \n        vec2 posP;\n    \n        posP.x = posB.x + offNP.x * 1.5;\n        posP.y = posB.y + offNP.y * 1.5;\n    \n        float subpixD = ((-2.0) * subpixC) + 3.0;\n        float lumaEndN = FxaaLuma(texture2D(map, posN, 0.0));\n        float subpixE = subpixC * subpixC;\n        float lumaEndP = FxaaLuma(texture2D(map, posP, 0.0));\n    \n        if (!pairN) \n        {\n            lumaNN = lumaSS;\n        }\n    \n        float gradientScaled = gradient * 1.0 / 4.0;\n        float lumaMM = lumaM - lumaNN * 0.5;\n        float subpixF = subpixD * subpixE;\n        bool lumaMLTZero = lumaMM < 0.0;\n    \n        lumaEndN -= lumaNN * 0.5;\n        lumaEndP -= lumaNN * 0.5;\n    \n        bool doneN = abs(lumaEndN) >= gradientScaled;\n        bool doneP = abs(lumaEndP) >= gradientScaled;\n    \n        if (!doneN) \n        {\n            posN.x -= offNP.x * 3.0;\n        }\n    \n        if (!doneN) \n        {\n            posN.y -= offNP.y * 3.0;\n        }\n    \n        bool doneNP = (!doneN) || (!doneP);\n    \n        if (!doneP) \n        {\n            posP.x += offNP.x * 3.0;\n        }\n    \n        if (!doneP)\n        {\n            posP.y += offNP.y * 3.0;\n        }\n    \n        if (doneNP)\n        {\n            if (!doneN) lumaEndN = FxaaLuma(texture2D(map, posN.xy, 0.0));\n            if (!doneP) lumaEndP = FxaaLuma(texture2D(map, posP.xy, 0.0));\n            if (!doneN) lumaEndN = lumaEndN - lumaNN * 0.5;\n            if (!doneP) lumaEndP = lumaEndP - lumaNN * 0.5;\n        \n            doneN = abs(lumaEndN) >= gradientScaled;\n            doneP = abs(lumaEndP) >= gradientScaled;\n        \n            if (!doneN) posN.x -= offNP.x * 12.0;\n            if (!doneN) posN.y -= offNP.y * 12.0;\n        \n            doneNP = (!doneN) || (!doneP);\n        \n            if (!doneP) posP.x += offNP.x * 12.0;\n            if (!doneP) posP.y += offNP.y * 12.0;\n        }\n    \n        float dstN = posM.x - posN.x;\n        float dstP = posP.x - posM.x;\n    \n        if (!horzSpan)\n        {\n            dstN = posM.y - posN.y;\n        }\n        if (!horzSpan) \n        {\n            dstP = posP.y - posM.y;\n        }\n    \n        bool goodSpanN = (lumaEndN < 0.0) != lumaMLTZero;\n        float spanLength = (dstP + dstN);\n        bool goodSpanP = (lumaEndP < 0.0) != lumaMLTZero;\n        float spanLengthRcp = 1.0 / spanLength;\n        bool directionN = dstN < dstP;\n        float dst = min(dstN, dstP);\n        bool goodSpan = directionN ? goodSpanN : goodSpanP;\n        float subpixG = subpixF * subpixF;\n        float pixelOffset = (dst * (-spanLengthRcp)) + 0.5;\n        float subpixH = subpixG * fxaaQualitySubpix;\n        float pixelOffsetGood = goodSpan ? pixelOffset : 0.0;\n        float pixelOffsetSubpix = max(pixelOffsetGood, subpixH);\n    \n        if (!horzSpan)\n        {\n            posM.x += pixelOffsetSubpix * lengthSign;\n        }\n    \n        if (horzSpan)\n        {\n            posM.y += pixelOffsetSubpix * lengthSign;\n        }\n    \n    #ifdef MALI\n        if(range < rangeMaxClamped) \n        {\n            gl_FragColor = rgbyM;\n        }\n        else\n        {\n            gl_FragColor = texture2D(map, posM, 0.0);\n        }\n    #else\n        gl_FragColor = texture2D(map, posM, 0.0);\n    #endif\n    }\n",
                        programs: {}
                    }
                }], techniques: [{name: "fxaa", attributes: {}, uniforms: {map: {type: 35678}}}], programs: []
            }
        }
    }, j = {
        asset: {version: "2.0", generator: "shader plugin for egret"},
        extensionsRequired: ["egret", "KHR_techniques_webgl"],
        extensionsUsed: ["egret", "KHR_techniques_webgl"],
        extensions: {
            KHR_techniques_webgl: {
                shaders: [{
                    name: "linedashed_vert",
                    type: 35633,
                    uri: "shaders/linedashed.shader.glsl.js",
                    extras: {
                        data: "    uniform float scale;\n    attribute float lineDistance;\n    \n    varying float vLineDistance;\n    \n    #include <common>\n    #include <color_pars_vertex>\n    #include <fog_pars_vertex>\n    #include <logdepthbuf_pars_vertex>\n    #include <clipping_planes_pars_vertex>\n    \n    void main() {\n     //modified by egret\n        #ifdef EGRET  \n            #ifdef USE_INSTANCED\n                #include <instances_vertex>\n            #endif\n        #endif\n        #include <color_vertex>\n    \n        vLineDistance = scale * lineDistance;\n    \n        vec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );\n        gl_Position = projectionMatrix * mvPosition;\n    \n        #include <logdepthbuf_vertex>\n        #include <clipping_planes_vertex>\n        #include <fog_vertex>\n    \n    }\n",
                        programs: {}
                    }
                }, {
                    name: "linedashed_frag", type: 35632, uri: "shaders/linedashed.shader.glsl.js", extras: {
                        data: "    uniform vec3 diffuse;\n    uniform float opacity;\n    \n    uniform float dashSize;\n    uniform float totalSize;\n    \n    varying float vLineDistance;\n    \n    #include <common>\n    #include <color_pars_fragment>\n    #include <fog_pars_fragment>\n    #include <logdepthbuf_pars_fragment>\n    #include <clipping_planes_pars_fragment>\n    \n    void main() {\n    \n     #include <clipping_planes_fragment>\n    \n        if ( mod( vLineDistance, totalSize ) > dashSize ) {\n    \n            discard;\n    \n        }\n    \n        vec3 outgoingLight = vec3( 0.0 );\n        vec4 diffuseColor = vec4( diffuse, opacity );\n    \n        #include <logdepthbuf_fragment>\n        #include <color_fragment>\n    \n        outgoingLight = diffuseColor.rgb; // simple shader\n    \n        gl_FragColor = vec4( outgoingLight, diffuseColor.a );\n    \n        #include <premultiplied_alpha_fragment>\n        #include <tonemapping_fragment>\n        #include <encodings_fragment>\n        #include <fog_fragment>\n    \n    }\n",
                        programs: {}
                    }
                }],
                techniques: [{
                    name: "linedashed",
                    attributes: {},
                    uniforms: {
                        scale: {type: 5126, value: 1},
                        diffuse: {type: 35665, value: [1, 1, 1]},
                        opacity: {type: 5126, value: 1},
                        dashSize: {type: 5126, value: 1},
                        totalSize: {type: 5126, value: 1},
                        "clippingPlanes[0]": {type: 35666}
                    }
                }],
                programs: []
            }
        }
    }, H = {
        asset: {version: "2.0", generator: "shader plugin for egret"},
        extensionsRequired: ["egret", "KHR_techniques_webgl"],
        extensionsUsed: ["egret", "KHR_techniques_webgl"],
        extensions: {
            KHR_techniques_webgl: {
                shaders: [{
                    name: "meshbasic_vert", type: 35633, uri: "shaders/meshbasic.shader.glsl.js", extras: {
                        data: "    #include <common>\n    #include <uv_pars_vertex>\n    #include <uv2_pars_vertex>\n    #include <envmap_pars_vertex>\n    #include <color_pars_vertex>\n    #include <fog_pars_vertex>\n    #include <morphtarget_pars_vertex>\n    #include <skinning_pars_vertex>\n    #include <logdepthbuf_pars_vertex>\n    #include <clipping_planes_pars_vertex>\n    \n    #ifdef EGRET   \n        // modified by egret\n        #include <custom_vertex>\n    #endif\n    \n    \n    void main() {\n         // modified by egret\n        #ifdef EGRET  \n            #ifdef USE_INSTANCED\n                #include <instances_vertex>\n            #endif\n        #endif\n        #include <custom_begin_vertex>\n    \n        #include <uv_vertex>\n        #include <uv2_vertex>\n        #include <color_vertex>\n        #include <skinbase_vertex>\n    \n        #ifdef USE_ENVMAP\n    \n        #include <beginnormal_vertex>\n        #include <morphnormal_vertex>\n        #include <skinnormal_vertex>\n        #include <defaultnormal_vertex>\n    \n        #endif\n    \n        #include <begin_vertex>\n        #include <morphtarget_vertex>\n        #include <skinning_vertex>\n        #include <project_vertex>\n        #include <logdepthbuf_vertex>\n    \n        #include <worldpos_vertex>\n        #include <clipping_planes_vertex>\n        #include <envmap_vertex>\n        #include <fog_vertex>\n    \n     \n    \n        #ifdef EGRET  \n            // modified by egret\n            #include <custom_end_vertex>\n        #endif\n    \n        \n    \n    }\n",
                        programs: {}
                    }
                }, {
                    name: "meshbasic_frag", type: 35632, uri: "shaders/meshbasic.shader.glsl.js", extras: {
                        data: "    uniform vec3 diffuse;\n    uniform float opacity;\n    \n    #ifndef FLAT_SHADED\n    \n     varying vec3 vNormal;\n    \n    #endif\n    \n    #include <common>\n    #include <color_pars_fragment>\n    #include <uv_pars_fragment>\n    #include <uv2_pars_fragment>\n    #include <map_pars_fragment>\n    #include <alphamap_pars_fragment>\n    #include <aomap_pars_fragment>\n    #include <lightmap_pars_fragment>\n    #include <envmap_common_pars_fragment>\n    #include <envmap_pars_fragment>\n    #include <fog_pars_fragment>\n    #include <specularmap_pars_fragment>\n    #include <logdepthbuf_pars_fragment>\n    #include <clipping_planes_pars_fragment>\n    #include <custom_fragment> // modified by egret\n    \n    void main() {\n    \n         // modified by egret\n        #ifdef EGRET  \n            #include <custom_begin_fragment>\n        #endif\n    \n        #include <clipping_planes_fragment>\n    \n        vec4 diffuseColor = vec4( diffuse, opacity );\n    \n        #include <logdepthbuf_fragment>\n        #include <map_fragment>\n        #include <color_fragment>\n        #include <alphamap_fragment>\n        #include <alphatest_fragment>\n        #include <specularmap_fragment>\n    \n        ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n    \n        // accumulation (baked indirect lighting only)\n        #ifdef USE_LIGHTMAP\n        \n            #ifdef EGRET  \n            // modified by egret\n                vec4 lightmapTex = texture2D(lightMap, vUv2);\n                float power = 5.0 * lightmapTex.a;\n                reflectedLight.indirectDiffuse += lightmapTex.rgb * power * lightMapIntensity;\n            #else\n                reflectedLight.indirectDiffuse += texture2D( lightMap, vUv2 ).xyz * lightMapIntensity;\n            #endif\n        #else\n    \n            reflectedLight.indirectDiffuse += vec3( 1.0 );\n    \n        #endif\n    \n        // modulation\n        #include <aomap_fragment>\n    \n        reflectedLight.indirectDiffuse *= diffuseColor.rgb;\n    \n        vec3 outgoingLight = reflectedLight.indirectDiffuse;\n    \n        #include <envmap_fragment>\n    \n        gl_FragColor = vec4( outgoingLight, diffuseColor.a );\n    \n        #include <premultiplied_alpha_fragment>\n        #include <tonemapping_fragment>\n        #include <encodings_fragment>\n        #include <fog_fragment>\n    \n         // modified by egret\n        #ifdef EGRET  \n            #include <custom_end_fragment>\n        #endif\n    \n    }\n",
                        programs: {}
                    }
                }],
                techniques: [{
                    name: "meshbasic",
                    attributes: {},
                    uniforms: {
                        uvTransform: {type: 35675, value: [1, 0, 0, 0, 1, 0, 0, 0, 1]},
                        refractionRatio: {type: 5126, value: .98},
                        bindMatrix: {type: 35676},
                        bindMatrixInverse: {type: 35676},
                        diffuse: {type: 35665, value: [1, 1, 1]},
                        opacity: {type: 5126, value: 1},
                        map: {type: 35678},
                        alphaMap: {type: 35678},
                        aoMap: {type: 35678},
                        aoMapIntensity: {type: 5126, value: 1},
                        envMapIntensity: {type: 5126, value: 1},
                        flipEnvMap: {type: 5126, value: 1},
                        maxMipLevel: {type: 5124},
                        envMap: {type: 35678},
                        reflectivity: {type: 5126, value: 1},
                        specularMap: {type: 35678},
                        "clippingPlanes[0]": {type: 35666}
                    }
                }],
                programs: []
            }
        }
    }, W = {
        asset: {version: "2.0", generator: "shader plugin for egret"},
        extensionsRequired: ["egret", "KHR_techniques_webgl"],
        extensionsUsed: ["egret", "KHR_techniques_webgl"],
        extensions: {
            KHR_techniques_webgl: {
                shaders: [{
                    name: "meshlambert_vert", type: 35633, uri: "shaders/meshlambert.shader.glsl.js", extras: {
                        data: "    #define LAMBERT\n    \n    varying vec3 vLightFront;\n    varying vec3 vIndirectFront;\n    \n    #ifdef DOUBLE_SIDED\n     varying vec3 vLightBack;\n        varying vec3 vIndirectBack;\n    #endif\n    \n    #include <common>\n    #include <uv_pars_vertex>\n    #include <uv2_pars_vertex>\n    #include <envmap_pars_vertex>\n    #include <bsdfs>\n    #include <lights_pars_begin>\n    #include <color_pars_vertex>\n    #include <fog_pars_vertex>\n    #include <morphtarget_pars_vertex>\n    #include <skinning_pars_vertex>\n    #include <shadowmap_pars_vertex>\n    #include <logdepthbuf_pars_vertex>\n    #include <clipping_planes_pars_vertex>\n    #include <custom_vertex> // modified by egret\n    \n    void main() {\n        #ifdef EGRET  \n            // modified by egret\n            #ifdef USE_INSTANCED\n                #include <instances_vertex>\n            #endif\n        #endif\n        \n        #include <custom_begin_vertex>\n    \n        #include <uv_vertex>\n        #include <uv2_vertex>\n        #include <color_vertex>\n    \n        #include <beginnormal_vertex>\n        #include <morphnormal_vertex>\n        #include <skinbase_vertex>\n        #include <skinnormal_vertex>\n        #include <defaultnormal_vertex>\n    \n        #include <begin_vertex>\n        #include <morphtarget_vertex>\n        #include <skinning_vertex>\n        #include <project_vertex>\n        #include <logdepthbuf_vertex>\n        #include <clipping_planes_vertex>\n    \n        #include <worldpos_vertex>\n        #include <envmap_vertex>\n        #include <lights_lambert_vertex>\n        #include <shadowmap_vertex>\n        #include <fog_vertex>\n    \n    \n        #ifdef EGRET  \n            // modified by egret\n            #include <custom_end_vertex>\n        #endif\n    \n    }\n",
                        programs: {}
                    }
                }, {
                    name: "meshlambert_frag", type: 35632, uri: "shaders/meshlambert.shader.glsl.js", extras: {
                        data: "    uniform vec3 diffuse;\n    uniform vec3 emissive;\n    uniform float opacity;\n    \n    varying vec3 vLightFront;\n    varying vec3 vIndirectFront;\n    \n    #ifdef DOUBLE_SIDED\n     varying vec3 vLightBack;\n        varying vec3 vIndirectBack;\n    #endif\n    \n    \n    #include <common>\n    #include <packing>\n    #include <dithering_pars_fragment>\n    #include <color_pars_fragment>\n    #include <uv_pars_fragment>\n    #include <uv2_pars_fragment>\n    #include <map_pars_fragment>\n    #include <alphamap_pars_fragment>\n    #include <aomap_pars_fragment>\n    #include <lightmap_pars_fragment>\n    #include <emissivemap_pars_fragment>\n    #include <envmap_common_pars_fragment>\n    #include <envmap_pars_fragment>\n    #include <bsdfs>\n    #include <lights_pars_begin>\n    #include <fog_pars_fragment>\n    #include <shadowmap_pars_fragment>\n    #include <shadowmask_pars_fragment>\n    #include <specularmap_pars_fragment>\n    #include <logdepthbuf_pars_fragment>\n    #include <clipping_planes_pars_fragment>\n    \n    #ifdef EGRET\n        #include <custom_fragment> // modified by egret\n    #endif\n    \n    void main() {\n    \n        #ifdef EGRET\n            // modified by egret\n            #include <custom_begin_fragment>\n        #endif\n     \n    \n        #include <clipping_planes_fragment>\n    \n        vec4 diffuseColor = vec4( diffuse, opacity );\n        ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n        vec3 totalEmissiveRadiance = emissive;\n    \n        #include <logdepthbuf_fragment>\n        #include <map_fragment>\n        #include <color_fragment>\n        #include <alphamap_fragment>\n        #include <alphatest_fragment>\n        #include <specularmap_fragment>\n        #include <emissivemap_fragment>\n    \n        // accumulation\n        reflectedLight.indirectDiffuse = getAmbientLightIrradiance( ambientLightColor );\n    \n        #ifdef DOUBLE_SIDED\n    \n            reflectedLight.indirectDiffuse += ( gl_FrontFacing ) ? vIndirectFront : vIndirectBack;\n    \n        #else\n    \n            reflectedLight.indirectDiffuse += vIndirectFront;\n    \n        #endif\n    \n        #include <lightmap_fragment>\n    \n        reflectedLight.indirectDiffuse *= BRDF_Diffuse_Lambert( diffuseColor.rgb );\n    \n        #ifdef DOUBLE_SIDED\n    \n            reflectedLight.directDiffuse = ( gl_FrontFacing ) ? vLightFront : vLightBack;\n    \n        #else\n    \n            reflectedLight.directDiffuse = vLightFront;\n    \n        #endif\n    \n        reflectedLight.directDiffuse *= BRDF_Diffuse_Lambert( diffuseColor.rgb ) * getShadowMask();\n    \n        // modulation\n        #include <aomap_fragment>\n    \n        vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;\n    \n        #include <envmap_fragment>\n    \n        gl_FragColor = vec4( outgoingLight, diffuseColor.a );\n    \n        #include <tonemapping_fragment>\n        #include <encodings_fragment>\n        #include <fog_fragment>\n        #include <premultiplied_alpha_fragment>\n        #include <dithering_fragment>\n    \n        #ifdef EGRET  \n            // modified by egret\n            #include <custom_end_fragment>\n        #endif\n    \n    }\n",
                        programs: {}
                    }
                }],
                techniques: [{
                    name: "meshlambert",
                    attributes: {},
                    uniforms: {
                        uvTransform: {type: 35675, value: [1, 0, 0, 0, 1, 0, 0, 0, 1]},
                        refractionRatio: {type: 5126, value: .98},
                        "lightProbe[0]": {type: 35665},
                        bindMatrix: {type: 35676},
                        bindMatrixInverse: {type: 35676},
                        diffuse: {type: 35665, value: [1, 1, 1]},
                        emissive: {type: 35665, value: [0, 0, 0]},
                        opacity: {type: 5126, value: 1},
                        map: {type: 35678},
                        alphaMap: {type: 35678},
                        aoMap: {type: 35678},
                        aoMapIntensity: {type: 5126, value: 1},
                        emissiveMap: {type: 35678},
                        envMapIntensity: {type: 5126, value: 1},
                        flipEnvMap: {type: 5126, value: 1},
                        maxMipLevel: {type: 5124},
                        envMap: {type: 35678},
                        reflectivity: {type: 5126, value: 1},
                        specularMap: {type: 35678},
                        "clippingPlanes[0]": {type: 35666}
                    }
                }],
                programs: []
            }
        }
    }, X = {
        asset: {version: "2.0", generator: "shader plugin for egret"},
        extensionsRequired: ["egret", "KHR_techniques_webgl"],
        extensionsUsed: ["egret", "KHR_techniques_webgl"],
        extensions: {
            KHR_techniques_webgl: {
                shaders: [{
                    name: "meshphong_vert", type: 35633, uri: "shaders/meshphong.shader.glsl.js", extras: {
                        data: "    #define PHONG\n    \n    varying vec3 vViewPosition;\n    \n    #ifndef FLAT_SHADED\n    \n     varying vec3 vNormal;\n    \n    #endif\n    \n    #include <common>\n    #include <uv_pars_vertex>\n    #include <uv2_pars_vertex>\n    #include <displacementmap_pars_vertex>\n    #include <envmap_pars_vertex>\n    #include <color_pars_vertex>\n    #include <fog_pars_vertex>\n    #include <morphtarget_pars_vertex>\n    #include <skinning_pars_vertex>\n    #include <shadowmap_pars_vertex>\n    #include <logdepthbuf_pars_vertex>\n    #include <clipping_planes_pars_vertex>\n    \n    \n    \n    #ifdef EGRET  \n        #include <custom_vertex> // modified by egret\n    #endif\n    \n    \n    void main() {\n        #ifdef EGRET  \n            // modified by egret\n            #ifdef USE_INSTANCED\n                #include <instances_vertex>\n            #endif\n        #endif\n        \n        #include <custom_begin_vertex>\n    \n        #include <uv_vertex>\n        #include <uv2_vertex>\n        #include <color_vertex>\n    \n        #include <beginnormal_vertex>\n        #include <morphnormal_vertex>\n        #include <skinbase_vertex>\n        #include <skinnormal_vertex>\n        #include <defaultnormal_vertex>\n    \n    #ifndef FLAT_SHADED // Normal computed with derivatives when FLAT_SHADED\n    \n        vNormal = normalize( transformedNormal );\n    \n    #endif\n    \n        #include <begin_vertex>\n        #include <morphtarget_vertex>\n        #include <skinning_vertex>\n        #include <displacementmap_vertex>\n        #include <project_vertex>\n        #include <logdepthbuf_vertex>\n        #include <clipping_planes_vertex>\n    \n        vViewPosition = - mvPosition.xyz;\n    \n        #include <worldpos_vertex>\n        #include <envmap_vertex>\n        #include <shadowmap_vertex>\n        #include <fog_vertex>\n    \n     \n        #ifdef EGRET  \n            // modified by egret\n            #include <custom_end_vertex>\n        #endif\n    }\n",
                        programs: {}
                    }
                }, {
                    name: "meshphong_frag", type: 35632, uri: "shaders/meshphong.shader.glsl.js", extras: {
                        data: "    #define PHONG\n    \n    uniform vec3 diffuse;\n    uniform vec3 emissive;\n    uniform vec3 specular;\n    uniform float shininess;\n    uniform float opacity;\n    \n    #include <common>\n    #include <packing>\n    #include <dithering_pars_fragment>\n    #include <color_pars_fragment>\n    #include <uv_pars_fragment>\n    #include <uv2_pars_fragment>\n    #include <map_pars_fragment>\n    #include <alphamap_pars_fragment>\n    #include <aomap_pars_fragment>\n    #include <lightmap_pars_fragment>\n    #include <emissivemap_pars_fragment>\n    #include <envmap_common_pars_fragment>\n    #include <envmap_pars_fragment>\n    #include <gradientmap_pars_fragment>\n    #include <fog_pars_fragment>\n    #include <bsdfs>\n    #include <lights_pars_begin>\n    #include <lights_phong_pars_fragment>\n    #include <shadowmap_pars_fragment>\n    #include <bumpmap_pars_fragment>\n    #include <normalmap_pars_fragment>\n    #include <specularmap_pars_fragment>\n    #include <logdepthbuf_pars_fragment>\n    #include <clipping_planes_pars_fragment>\n    \n    #ifdef EGRET  \n     #include <custom_fragment> // modified by egret\n    #endif\n    \n    \n    \n    void main() {\n    \n        #ifdef EGRET  \n            // modified by egret\n            #include <custom_begin_fragment>\n        #endif\n    \n    \n        #include <clipping_planes_fragment>\n    \n        vec4 diffuseColor = vec4( diffuse, opacity );\n        ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n        vec3 totalEmissiveRadiance = emissive;\n    \n        #include <logdepthbuf_fragment>\n        #include <map_fragment>\n        #include <color_fragment>\n        #include <alphamap_fragment>\n        #include <alphatest_fragment>\n        #include <specularmap_fragment>\n        #include <normal_fragment_begin>\n        #include <normal_fragment_maps>\n        #include <emissivemap_fragment>\n    \n        // accumulation\n        #include <lights_phong_fragment>\n        #include <lights_fragment_begin>\n        #include <lights_fragment_maps>\n        #include <lights_fragment_end>\n    \n        // modulation\n        #include <aomap_fragment>\n    \n        vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;\n    \n        #include <envmap_fragment>\n    \n        gl_FragColor = vec4( outgoingLight, diffuseColor.a );\n    \n        #include <tonemapping_fragment>\n        #include <encodings_fragment>\n        #include <fog_fragment>\n        #include <premultiplied_alpha_fragment>\n        #include <dithering_fragment>\n    \n        #ifdef EGRET  \n            // modified by egret\n            #include <custom_end_fragment>\n        #endif\n    }\n",
                        programs: {}
                    }
                }],
                techniques: [{
                    name: "meshphong",
                    attributes: {},
                    uniforms: {
                        uvTransform: {type: 35675, value: [1, 0, 0, 0, 1, 0, 0, 0, 1]},
                        displacementMap: {type: 35678},
                        displacementScale: {type: 5126, value: 1},
                        displacementBias: {type: 5126},
                        refractionRatio: {type: 5126, value: .98},
                        bindMatrix: {type: 35676},
                        bindMatrixInverse: {type: 35676},
                        diffuse: {type: 35665, value: [1, 1, 1]},
                        emissive: {type: 35665, value: [0, 0, 0]},
                        specular: {type: 35665, value: [1, 1, 1]},
                        shininess: {type: 5126, value: 30},
                        opacity: {type: 5126, value: 1},
                        map: {type: 35678},
                        alphaMap: {type: 35678},
                        aoMap: {type: 35678},
                        aoMapIntensity: {type: 5126, value: 1},
                        emissiveMap: {type: 35678},
                        envMapIntensity: {type: 5126, value: 1},
                        flipEnvMap: {type: 5126, value: 1},
                        maxMipLevel: {type: 5124},
                        envMap: {type: 35678},
                        reflectivity: {type: 5126, value: 1},
                        gradientMap: {type: 35678},
                        "lightProbe[0]": {type: 35665},
                        bumpMap: {type: 35678},
                        bumpScale: {type: 5126, value: 1},
                        normalMap: {type: 35678},
                        normalScale: {type: 35664, value: [1, 1]},
                        specularMap: {type: 35678},
                        "clippingPlanes[0]": {type: 35666}
                    }
                }],
                programs: []
            }
        }
    }, Y = {
        asset: {version: "2.0", generator: "shader plugin for egret"},
        extensionsRequired: ["egret", "KHR_techniques_webgl"],
        extensionsUsed: ["egret", "KHR_techniques_webgl"],
        extensions: {
            KHR_techniques_webgl: {
                shaders: [{
                    name: "meshphysical_vert", type: 35633, uri: "shaders/meshphysical.shader.glsl.js", extras: {
                        data: "    #define STANDARD\n    \n    varying vec3 vViewPosition;\n    \n    #ifndef FLAT_SHADED\n    \n     varying vec3 vNormal;\n    \n        #ifdef USE_TANGENT\n    \n            varying vec3 vTangent;\n            varying vec3 vBitangent;\n    \n        #endif\n    \n    #endif\n    \n    #include <common>\n    #include <uv_pars_vertex>\n    #include <uv2_pars_vertex>\n    #include <displacementmap_pars_vertex>\n    #include <color_pars_vertex>\n    #include <fog_pars_vertex>\n    #include <morphtarget_pars_vertex>\n    #include <skinning_pars_vertex>\n    #include <shadowmap_pars_vertex>\n    #include <logdepthbuf_pars_vertex>\n    #include <clipping_planes_pars_vertex>\n    \n    \n    #ifdef EGRET      \n        #include <custom_vertex> // modified by egret\n    #endif\n    \n    \n    void main() {\n    \n        #ifdef EGRET  \n            // modified by egret\n            #ifdef USE_INSTANCED\n                #include <instances_vertex>\n            #endif\n        #endif\n    \n        #include <custom_begin_vertex>\n    \n        #include <uv_vertex>\n        #include <uv2_vertex>\n        #include <color_vertex>\n    \n        #include <beginnormal_vertex>\n        #include <morphnormal_vertex>\n        #include <skinbase_vertex>\n        #include <skinnormal_vertex>\n        #include <defaultnormal_vertex>\n    \n    #ifndef FLAT_SHADED // Normal computed with derivatives when FLAT_SHADED\n    \n        vNormal = normalize( transformedNormal );\n    \n        #ifdef USE_TANGENT\n    \n            vTangent = normalize( transformedTangent );\n            vBitangent = normalize( cross( vNormal, vTangent ) * tangent.w );\n    \n        #endif\n    \n    #endif\n    \n        #include <begin_vertex>\n        #include <morphtarget_vertex>\n        #include <skinning_vertex>\n        #include <displacementmap_vertex>\n        #include <project_vertex>\n        #include <logdepthbuf_vertex>\n        #include <clipping_planes_vertex>\n    \n        vViewPosition = - mvPosition.xyz;\n    \n        #include <worldpos_vertex>\n        #include <shadowmap_vertex>\n        #include <fog_vertex>\n    \n    \n        \n        #ifdef EGRET  \n             // modified by egret\n            #include <custom_end_vertex>\n        #endif\n    \n    \n    }\n",
                        programs: {}
                    }
                }, {
                    name: "meshphysical_frag", type: 35632, uri: "shaders/meshphysical.shader.glsl.js", extras: {
                        data: "    #define STANDARD\n    \n    #ifdef PHYSICAL\n     #define REFLECTIVITY\n        #define CLEARCOAT\n        #define TRANSPARENCY\n    #endif\n    \n    uniform vec3 diffuse;\n    uniform vec3 emissive;\n    uniform float roughness;\n    uniform float metalness;\n    uniform float opacity;\n    \n    #ifdef TRANSPARENCY\n        uniform float transparency;\n    #endif\n    \n    #ifdef REFLECTIVITY\n        uniform float reflectivity;\n    #endif\n    \n    #ifdef CLEARCOAT\n        uniform float clearcoat;\n        uniform float clearcoatRoughness;\n    #endif\n    \n    #ifdef USE_SHEEN\n        uniform vec3 sheen;\n    #endif\n    \n    varying vec3 vViewPosition;\n    \n    #ifndef FLAT_SHADED\n    \n        varying vec3 vNormal;\n    \n        #ifdef USE_TANGENT\n    \n            varying vec3 vTangent;\n            varying vec3 vBitangent;\n    \n        #endif\n    \n    #endif\n    \n    #include <common>\n    #include <packing>\n    #include <dithering_pars_fragment>\n    #include <color_pars_fragment>\n    #include <uv_pars_fragment>\n    #include <uv2_pars_fragment>\n    #include <map_pars_fragment>\n    #include <alphamap_pars_fragment>\n    #include <aomap_pars_fragment>\n    #include <lightmap_pars_fragment>\n    #include <emissivemap_pars_fragment>\n    #include <bsdfs>\n    #include <cube_uv_reflection_fragment>\n    #include <envmap_common_pars_fragment>\n    #include <envmap_physical_pars_fragment>\n    #include <fog_pars_fragment>\n    #include <lights_pars_begin>\n    #include <lights_physical_pars_fragment>\n    #include <shadowmap_pars_fragment>\n    #include <bumpmap_pars_fragment>\n    #include <normalmap_pars_fragment>\n    #include <clearcoat_normalmap_pars_fragment>\n    #include <roughnessmap_pars_fragment>\n    #include <metalnessmap_pars_fragment>\n    #include <logdepthbuf_pars_fragment>\n    #include <clipping_planes_pars_fragment>\n    \n    #ifdef EGRET  \n        #include <custom_fragment> // modified by egret\n    #endif\n    \n    void main() {\n    \n     \n        #ifdef EGRET  \n            // modified by egret\n            #include <custom_begin_fragment>\n        #endif\n    \n        #include <clipping_planes_fragment>\n    \n        vec4 diffuseColor = vec4( diffuse, opacity );\n        ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n        vec3 totalEmissiveRadiance = emissive;\n    \n        #include <logdepthbuf_fragment>\n        #include <map_fragment>\n        #include <color_fragment>\n        #include <alphamap_fragment>\n        #include <alphatest_fragment>\n        #include <roughnessmap_fragment>\n        #include <metalnessmap_fragment>\n        #include <normal_fragment_begin>\n        #include <normal_fragment_maps>\n        #include <clearcoat_normal_fragment_begin>\n        #include <clearcoat_normal_fragment_maps>\n        #include <emissivemap_fragment>\n    \n        // accumulation\n        #include <lights_physical_fragment>\n        #include <lights_fragment_begin>\n        #include <lights_fragment_maps>\n        #include <lights_fragment_end>\n    \n        // modulation\n        #include <aomap_fragment>\n    \n        vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;\n    \n        // this is a stub for the transparency model\n        #ifdef TRANSPARENCY\n            diffuseColor.a *= saturate( 1. - transparency + linearToRelativeLuminance( reflectedLight.directSpecular + reflectedLight.indirectSpecular ) );\n        #endif\n    \n        gl_FragColor = vec4( outgoingLight, diffuseColor.a );\n    \n        #include <tonemapping_fragment>\n        #include <encodings_fragment>\n        #include <fog_fragment>\n        #include <premultiplied_alpha_fragment>\n        #include <dithering_fragment>\n    \n         \n        #ifdef EGRET  \n            // modified by egret\n            #include <custom_end_fragment>\n        #endif\n    \n    \n    }\n",
                        programs: {}
                    }
                }], techniques: [{
                    name: "meshphysical", attributes: {}, uniforms: {
                        uvTransform: {type: 35675, value: [1, 0, 0, 0, 1, 0, 0, 0, 1]},
                        displacementMap: {type: 35678},
                        displacementScale: {type: 5126, value: 1},
                        displacementBias: {type: 5126},
                        bindMatrix: {type: 35676},
                        bindMatrixInverse: {type: 35676},
                        diffuse: {type: 35665, value: [1, 1, 1]},
                        emissive: {type: 35665, value: [0, 0, 0]},
                        roughness: {type: 5126, value: .5},
                        metalness: {type: 5126, value: .5},
                        opacity: {type: 5126, value: 1},
                        transparency: {type: 5126},
                        reflectivity: {type: 5126, value: 1},
                        clearcoat: {type: 5126},
                        clearcoatRoughness: {type: 5126},
                        sheen: {type: 35665},
                        map: {type: 35678},
                        alphaMap: {type: 35678},
                        aoMap: {type: 35678},
                        aoMapIntensity: {type: 5126, value: 1},
                        emissiveMap: {type: 35678},
                        envMapIntensity: {type: 5126, value: 1},
                        flipEnvMap: {type: 5126, value: 1},
                        maxMipLevel: {type: 5124},
                        envMap: {type: 35678},
                        refractionRatio: {type: 5126, value: .98},
                        "lightProbe[0]": {type: 35665},
                        bumpMap: {type: 35678},
                        bumpScale: {type: 5126, value: 1},
                        normalMap: {type: 35678},
                        normalScale: {type: 35664, value: [1, 1]},
                        clearcoatNormalMap: {type: 35678},
                        clearcoatNormalScale: {type: 35664},
                        roughnessMap: {type: 35678},
                        metalnessMap: {type: 35678},
                        "clippingPlanes[0]": {type: 35666}
                    }
                }], programs: []
            }
        }
    }, q = {
        asset: {version: "2.0", generator: "shader plugin for egret"},
        extensionsRequired: ["egret", "KHR_techniques_webgl"],
        extensionsUsed: ["egret", "KHR_techniques_webgl"],
        extensions: {
            KHR_techniques_webgl: {
                shaders: [{
                    name: "normal_vert", type: 35633, uri: "shaders/normal.shader.glsl.js", extras: {
                        data: "    #define NORMAL\n    \n    #if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )\n    \n     varying vec3 vViewPosition;\n    \n    #endif\n    \n    #ifndef FLAT_SHADED\n    \n        varying vec3 vNormal;\n    \n        #ifdef USE_TANGENT\n    \n            varying vec3 vTangent;\n            varying vec3 vBitangent;\n    \n        #endif\n    \n    #endif\n    \n    #include <uv_pars_vertex>\n    #include <displacementmap_pars_vertex>\n    #include <morphtarget_pars_vertex>\n    #include <skinning_pars_vertex>\n    #include <logdepthbuf_pars_vertex>\n    #include <clipping_planes_pars_vertex>\n    \n    void main() {\n        #ifdef EGRET  \n            // modified by egret\n            #ifdef USE_INSTANCED\n                #include <instances_vertex>\n            #endif\n        #endif\n    \n        #include <uv_vertex>\n    \n        #include <beginnormal_vertex>\n        #include <morphnormal_vertex>\n        #include <skinbase_vertex>\n        #include <skinnormal_vertex>\n        #include <defaultnormal_vertex>\n    \n    #ifndef FLAT_SHADED // Normal computed with derivatives when FLAT_SHADED\n    \n        vNormal = normalize( transformedNormal );\n    \n        #ifdef USE_TANGENT\n    \n            vTangent = normalize( transformedTangent );\n            vBitangent = normalize( cross( vNormal, vTangent ) * tangent.w );\n    \n        #endif\n    \n    #endif\n    \n        #include <begin_vertex>\n        #include <morphtarget_vertex>\n        #include <skinning_vertex>\n        #include <displacementmap_vertex>\n        #include <project_vertex>\n        #include <logdepthbuf_vertex>\n        #include <clipping_planes_vertex>\n    \n    #if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )\n    \n        vViewPosition = - mvPosition.xyz;\n    \n    #endif\n    \n    }\n",
                        programs: {}
                    }
                }, {
                    name: "normal_frag",
                    type: 35632,
                    uri: "shaders/normal.shader.glsl.js",
                    extras: {
                        data: "    #define NORMAL\n    \n    uniform float opacity;\n    \n    #if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )\n    \n     varying vec3 vViewPosition;\n    \n    #endif\n    \n    #ifndef FLAT_SHADED\n    \n        varying vec3 vNormal;\n    \n        #ifdef USE_TANGENT\n    \n            varying vec3 vTangent;\n            varying vec3 vBitangent;\n    \n        #endif\n    \n    #endif\n    \n    #include <packing>\n    #include <uv_pars_fragment>\n    #include <bumpmap_pars_fragment>\n    #include <normalmap_pars_fragment>\n    #include <logdepthbuf_pars_fragment>\n    #include <clipping_planes_pars_fragment>\n    \n    void main() {\n    \n        #include <clipping_planes_fragment>\n        #include <logdepthbuf_fragment>\n        #include <normal_fragment_begin>\n        #include <normal_fragment_maps>\n    \n        gl_FragColor = vec4( packNormalToRGB( normal ), opacity );\n    \n    }\n",
                        programs: {}
                    }
                }],
                techniques: [{
                    name: "normal",
                    attributes: {},
                    uniforms: {
                        uvTransform: {type: 35675, value: [1, 0, 0, 0, 1, 0, 0, 0, 1]},
                        displacementMap: {type: 35678},
                        displacementScale: {type: 5126, value: 1},
                        displacementBias: {type: 5126},
                        bindMatrix: {type: 35676},
                        bindMatrixInverse: {type: 35676},
                        opacity: {type: 5126, value: 1},
                        bumpMap: {type: 35678},
                        bumpScale: {type: 5126, value: 1},
                        normalMap: {type: 35678},
                        normalScale: {type: 35664, value: [1, 1]},
                        "clippingPlanes[0]": {type: 35666}
                    }
                }],
                programs: []
            }
        }
    }, Z = {
        asset: {version: "2.0", generator: "shader plugin for egret"},
        extensionsRequired: ["egret", "KHR_techniques_webgl"],
        extensionsUsed: ["egret", "KHR_techniques_webgl"],
        extensions: {
            KHR_techniques_webgl: {
                shaders: [{
                    name: "particle_vert", type: 35633, uri: "shaders/particle.shader.glsl.js", extras: {
                        data: "    //inspired by layaair:https://github.com/layabox/layaair/blob/master/src/d3/src/laya/d3/shader/files/ParticleShuriKen.vs\n    #include <common>\n    #if defined(SPHERHBILLBOARD)||defined(STRETCHEDBILLBOARD)||defined(HORIZONTALBILLBOARD)||defined(VERTICALBILLBOARD)\n     attribute vec2 corner;\n    #endif\n    attribute vec3 startPosition;\n    attribute vec3 startVelocity;\n    attribute vec4 startColor;\n    attribute vec3 startSize;\n    attribute vec3 startRotation;\n    attribute vec2 time;\n    #if defined(COLOROGRADIENT)||defined(COLORTWOGRADIENTS)||defined(SIZETWOCURVES)||defined(SIZETWOCURVESSEPERATE)||defined(ROTATIONTWOCONSTANTS)||defined(ROTATIONTWOCURVES)\n      attribute vec4 random0;\n    #endif\n    #if defined(TEXTURESHEETANIMATIONTWOCURVE)||defined(VELOCITYTWOCONSTANT)||defined(VELOCITYTWOCURVE)\n      attribute vec4 random1;\n    #endif\n    attribute vec3 startWorldPosition;\n    attribute vec4 startWorldRotation;\n    \n    #include <particle_common>\n    #include <fog_pars_vertex>\n    \n    void main()\n    {\n        float age = u_currentTime - time.y;\n        float t = age/time.x;\n        if(t>1.0){             \n                v_discard=1.0;\n                return;\n          }\n          \n        #include <particle_affector>\n        vec4 mvPosition = viewMatrix * vec4( center, 1.0 );\n        gl_Position = projectionMatrix * mvPosition;\n        v_color = computeColor(startColor, t);\n        v_texcoord = computeUV(uv, t);\n        v_discard=0.0;\n        #include <fog_vertex>\n    }\n",
                        programs: {}
                    }
                }, {
                    name: "particle_frag",
                    type: 35632,
                    uri: "shaders/particle.shader.glsl.js",
                    extras: {
                        data: "    //inspired by layaair:https://github.com/layabox/layaair/blob/master/src/d3/src/laya/d3/shader/files/ParticleShuriKen.ps\n    #include <common>\n    #include <fog_pars_fragment>\n    uniform sampler2D map;\n    uniform vec3 diffuse;\n    uniform float opacity;\n    varying float v_discard;\n    varying vec4 v_color;\n    varying vec2 v_texcoord;\n    \n    #ifdef RENDERMESH\n     varying vec4 v_mesh_color;\n    #endif\n    \n    void main()\n    {    \n        #ifdef RENDERMESH\n            gl_FragColor=v_mesh_color;\n        #else\n            gl_FragColor=vec4(1.0);    \n        #endif\n    \n        if(v_discard!=0.0)\n            discard;\n        gl_FragColor*=texture2D(map,v_texcoord)*vec4(diffuse, opacity)*v_color*2.0;\n    \n        #include <premultiplied_alpha_fragment>\n        #include <tonemapping_fragment>\n        #include <encodings_fragment>\n        #include <fog_fragment>\n    }\n",
                        programs: {}
                    }
                }], techniques: [{
                    name: "particle", attributes: {}, uniforms: {
                        u_currentTime: {type: 5126},
                        u_gravity: {type: 35665},
                        u_worldPosition: {type: 35665, value: [0, 0, 0]},
                        u_worldRotation: {type: 35666, value: [0, 0, 0, 1]},
                        u_startRotation3D: {type: 35670},
                        u_scalingMode: {type: 5124},
                        u_positionScale: {type: 35665},
                        u_sizeScale: {type: 35665},
                        u_lengthScale: {type: 5126},
                        u_speeaScale: {type: 5126},
                        u_simulationSpace: {type: 5124},
                        u_spaceType: {type: 5124},
                        u_velocityConst: {type: 35665},
                        "u_velocityCurveX[0]": {type: 35664},
                        "u_velocityCurveY[0]": {type: 35664},
                        "u_velocityCurveZ[0]": {type: 35664},
                        u_velocityConstMax: {type: 35665},
                        "u_velocityCurveMaxX[0]": {type: 35664},
                        "u_velocityCurveMaxY[0]": {type: 35664},
                        "u_velocityCurveMaxZ[0]": {type: 35664},
                        "u_colorGradient[0]": {type: 35666},
                        "u_alphaGradient[0]": {type: 35664},
                        "u_colorGradientMax[0]": {type: 35666},
                        "u_alphaGradientMax[0]": {type: 35664},
                        "u_sizeCurve[0]": {type: 35664},
                        "u_sizeCurveMax[0]": {type: 35664},
                        "u_sizeCurveX[0]": {type: 35664},
                        "u_sizeCurveY[0]": {type: 35664},
                        "u_sizeCurveZ[0]": {type: 35664},
                        "u_sizeCurveMaxX[0]": {type: 35664},
                        "u_sizeCurveMaxY[0]": {type: 35664},
                        "u_sizeCurveMaxZ[0]": {type: 35664},
                        u_rotationConst: {type: 5126},
                        u_rotationConstMax: {type: 5126},
                        "u_rotationCurve[0]": {type: 35664},
                        "u_rotationCurveMax[0]": {type: 35664},
                        u_rotationConstSeprarate: {type: 35665},
                        u_rotationConstMaxSeprarate: {type: 35665},
                        "u_rotationCurveX[0]": {type: 35664},
                        "u_rotationCurveY[0]": {type: 35664},
                        "u_rotationCurveZ[0]": {type: 35664},
                        "u_rotationCurveW[0]": {type: 35664},
                        "u_rotationCurveMaxX[0]": {type: 35664},
                        "u_rotationCurveMaxY[0]": {type: 35664},
                        "u_rotationCurveMaxZ[0]": {type: 35664},
                        "u_rotationCurveMaxW[0]": {type: 35664},
                        u_cycles: {type: 5126},
                        u_subUV: {type: 35666},
                        "u_uvCurve[0]": {type: 35664},
                        "u_uvCurveMax[0]": {type: 35664},
                        map: {type: 35678},
                        diffuse: {type: 35665, value: [1, 1, 1]},
                        opacity: {type: 5126, value: 1}
                    }
                }], programs: []
            }
        }
    }, K = {
        asset: {version: "2.0", generator: "shader plugin for egret"},
        extensionsRequired: ["egret", "KHR_techniques_webgl"],
        extensionsUsed: ["egret", "KHR_techniques_webgl"],
        extensions: {
            KHR_techniques_webgl: {
                shaders: [{
                    name: "points_vert", type: 35633, uri: "shaders/points.shader.glsl.js", extras: {
                        data: "    uniform float size;\n    uniform float scale;\n    \n    #include <common>\n    #include <color_pars_vertex>\n    #include <fog_pars_vertex>\n    #include <morphtarget_pars_vertex>\n    #include <logdepthbuf_pars_vertex>\n    #include <clipping_planes_pars_vertex>\n    \n    void main() {\n     #ifdef EGRET  \n            // modified by egret\n            #ifdef USE_INSTANCED\n                #include <instances_vertex>\n            #endif\n        #endif\n        \n        #include <color_vertex>\n        #include <begin_vertex>\n        #include <morphtarget_vertex>\n        #include <project_vertex>\n    \n        gl_PointSize = size;\n    \n        #ifdef USE_SIZEATTENUATION\n    \n            bool isPerspective = ( projectionMatrix[ 2 ][ 3 ] == - 1.0 );\n    \n            if ( isPerspective ) gl_PointSize *= ( scale / - mvPosition.z );\n    \n        #endif\n    \n        #include <logdepthbuf_vertex>\n        #include <clipping_planes_vertex>\n        #include <worldpos_vertex>\n        #include <fog_vertex>\n    \n    }\n",
                        programs: {}
                    }
                }, {
                    name: "points_frag",
                    type: 35632,
                    uri: "shaders/points.shader.glsl.js",
                    extras: {
                        data: "    uniform vec3 diffuse;\n    uniform float opacity;\n    \n    #include <common>\n    #include <color_pars_fragment>\n    #include <map_particle_pars_fragment>\n    #include <fog_pars_fragment>\n    #include <logdepthbuf_pars_fragment>\n    #include <clipping_planes_pars_fragment>\n    \n    void main() {\n    \n     #include <clipping_planes_fragment>\n    \n        vec3 outgoingLight = vec3( 0.0 );\n        vec4 diffuseColor = vec4( diffuse, opacity );\n    \n        #include <logdepthbuf_fragment>\n        #include <map_particle_fragment>\n        #include <color_fragment>\n        #include <alphatest_fragment>\n    \n        outgoingLight = diffuseColor.rgb;\n    \n        gl_FragColor = vec4( outgoingLight, diffuseColor.a );\n    \n        #include <premultiplied_alpha_fragment>\n        #include <tonemapping_fragment>\n        #include <encodings_fragment>\n        #include <fog_fragment>\n    \n    }\n",
                        programs: {}
                    }
                }],
                techniques: [{
                    name: "points",
                    attributes: {},
                    uniforms: {
                        size: {type: 5126},
                        scale: {type: 5126, value: 1},
                        diffuse: {type: 35665, value: [1, 1, 1]},
                        opacity: {type: 5126, value: 1},
                        uvTransform: {type: 35675, value: [1, 0, 0, 0, 1, 0, 0, 0, 1]},
                        map: {type: 35678},
                        "clippingPlanes[0]": {type: 35666}
                    }
                }],
                programs: []
            }
        }
    }, Q = {
        asset: {version: "2.0", generator: "shader plugin for egret"},
        extensionsRequired: ["egret", "KHR_techniques_webgl"],
        extensionsUsed: ["egret", "KHR_techniques_webgl"],
        extensions: {
            KHR_techniques_webgl: {
                shaders: [{
                    name: "shadow_vert",
                    type: 35633,
                    uri: "shaders/shadow.shader.glsl.js",
                    extras: {
                        data: "    #include <fog_pars_vertex>\n    #include <shadowmap_pars_vertex>\n    \n    void main() {\n    \n     #include <begin_vertex>\n        #include <project_vertex>\n        #include <worldpos_vertex>\n        #include <shadowmap_vertex>\n        #include <fog_vertex>\n    \n    }\n",
                        programs: {}
                    }
                }, {
                    name: "shadow_frag",
                    type: 35632,
                    uri: "shaders/shadow.shader.glsl.js",
                    extras: {
                        data: "    uniform vec3 color;\n    uniform float opacity;\n    \n    #include <common>\n    #include <packing>\n    #include <fog_pars_fragment>\n    #include <bsdfs>\n    #include <lights_pars_begin>\n    #include <shadowmap_pars_fragment>\n    #include <shadowmask_pars_fragment>\n    \n    void main() {\n    \n     gl_FragColor = vec4( color, opacity * ( 1.0 - getShadowMask() ) );\n    \n        #include <fog_fragment>\n    \n    }\n",
                        programs: {}
                    }
                }],
                techniques: [{
                    name: "shadow",
                    attributes: {},
                    uniforms: {color: {type: 35665}, opacity: {type: 5126, value: 1}, "lightProbe[0]": {type: 35665}}
                }],
                programs: []
            }
        }
    }, J = {
        asset: {version: "2.0", generator: "shader plugin for egret"},
        extensionsRequired: ["egret", "KHR_techniques_webgl"],
        extensionsUsed: ["egret", "KHR_techniques_webgl"],
        extensions: {
            KHR_techniques_webgl: {
                shaders: [{
                    name: "sprite_vert", type: 35633, uri: "shaders/sprite.shader.glsl.js", extras: {
                        data: "    uniform float rotation;\n    uniform vec2 center;\n    \n    #include <common>\n    #include <uv_pars_vertex>\n    #include <fog_pars_vertex>\n    #include <logdepthbuf_pars_vertex>\n    #include <clipping_planes_pars_vertex>\n    \n    void main() {\n    \n     #include <uv_vertex>\n    \n        vec4 mvPosition = modelViewMatrix * vec4( 0.0, 0.0, 0.0, 1.0 );\n    \n        vec2 scale;\n        scale.x = length( vec3( modelMatrix[ 0 ].x, modelMatrix[ 0 ].y, modelMatrix[ 0 ].z ) );\n        scale.y = length( vec3( modelMatrix[ 1 ].x, modelMatrix[ 1 ].y, modelMatrix[ 1 ].z ) );\n    \n        #ifndef USE_SIZEATTENUATION\n    \n            bool isPerspective = ( projectionMatrix[ 2 ][ 3 ] == - 1.0 );\n    \n            if ( isPerspective ) scale *= - mvPosition.z;\n    \n        #endif\n    \n        vec2 alignedPosition = ( position.xy - ( center - vec2( 0.5 ) ) ) * scale;\n    \n        vec2 rotatedPosition;\n        rotatedPosition.x = cos( rotation ) * alignedPosition.x - sin( rotation ) * alignedPosition.y;\n        rotatedPosition.y = sin( rotation ) * alignedPosition.x + cos( rotation ) * alignedPosition.y;\n    \n        mvPosition.xy += rotatedPosition;\n    \n        gl_Position = projectionMatrix * mvPosition;\n    \n        #include <logdepthbuf_vertex>\n        #include <clipping_planes_vertex>\n        #include <fog_vertex>\n    \n    }\n",
                        programs: {}
                    }
                }, {
                    name: "sprite_frag",
                    type: 35632,
                    uri: "shaders/sprite.shader.glsl.js",
                    extras: {
                        data: "    uniform vec3 diffuse;\n    uniform float opacity;\n    \n    #include <common>\n    #include <uv_pars_fragment>\n    #include <map_pars_fragment>\n    #include <fog_pars_fragment>\n    #include <logdepthbuf_pars_fragment>\n    #include <clipping_planes_pars_fragment>\n    \n    void main() {\n    \n     #include <clipping_planes_fragment>\n    \n        vec3 outgoingLight = vec3( 0.0 );\n        vec4 diffuseColor = vec4( diffuse, opacity );\n    \n        #include <logdepthbuf_fragment>\n        #include <map_fragment>\n        #include <alphatest_fragment>\n    \n        outgoingLight = diffuseColor.rgb;\n    \n        gl_FragColor = vec4( outgoingLight, diffuseColor.a );\n    \n        #include <tonemapping_fragment>\n        #include <encodings_fragment>\n        #include <fog_fragment>\n    \n    }\n",
                        programs: {}
                    }
                }],
                techniques: [{
                    name: "sprite",
                    attributes: {},
                    uniforms: {
                        rotation: {type: 5126},
                        center: {type: 35664},
                        uvTransform: {type: 35675, value: [1, 0, 0, 0, 1, 0, 0, 0, 1]},
                        diffuse: {type: 35665, value: [1, 1, 1]},
                        opacity: {type: 5126, value: 1},
                        map: {type: 35678},
                        "clippingPlanes[0]": {type: 35666}
                    }
                }],
                programs: []
            }
        }
    }, $ = function (e) {
        function t() {
            return null !== e && e.apply(this, arguments) || this
        }

        var n;
        return u(t, e), n = t, t.prototype._createShader = function (e, t) {
            var n = m.create(t);
            return n.entity.uri = e, a.ResourceManager.instance.addResource({
                uri: e,
                type: "shader",
                status: "Ok",
                data: n
            }), n
        }, t.prototype.initialize = function (t, r, i) {
            void 0 === i && (i = null), e.prototype.initialize.call(this, t, r, i);
            var o = n;
            o.MESH_BASIC = this._createShader("builtin/meshbasic.shader.json", H), o.MESH_NORMAL = this._createShader("builtin/meshnormal.shader.json", q), o.MESH_LAMBERT = this._createShader("builtin/meshlambert.shader.json", W), o.MESH_PHONG = this._createShader("builtin/meshphong.shader.json", X), o.MESH_PHYSICAL = this._createShader("builtin/meshphysical.shader.json", Y), o.POINTS = this._createShader("builtin/points.shader.json", K), o.LINEDASHED = this._createShader("builtin/linedashed.shader.json", j), o.SPRITE = this._createShader("builtin/sprite.shader.json", J), o.CUBE = this._createShader("builtin/cube.shader.json", F), o.EQUIRECT = this._createShader("builtin/equirect.shader.json", B), o.DEPTH = this._createShader("builtin/depth.shader.json", k), o.DISTANCE_RGBA = this._createShader("builtin/distance_rgba.shader.json", V), o.SHADOW = this._createShader("builtin/shadow.shader.json", Q), o.COPY = this._createShader("builtin/copy.shader.json", U), o.BACKGROUND = this._createShader("builtin/background.shader.json", N), o.FXAA = this._createShader("builtin/fxaa.shader.json", G), o.PARTICLE = this._createShader("builtin/particle.shader.json", Z), o.BASEJOIN = this._createShader("builtin/baseJoint.shader.json", z)
        }, t.MESH_BASIC = null, t.MESH_NORMAL = null, t.MESH_LAMBERT = null, t.MESH_PHONG = null, t.MESH_PHYSICAL = null, t.POINTS = null, t.LINEDASHED = null, t.SPRITE = null, t.CUBE = null, t.EQUIRECT = null, t.DEPTH = null, t.DISTANCE_RGBA = null, t.SHADOW = null, t.COPY = null, t.BACKGROUND = null, t.FXAA = null, t.PARTICLE = null, t.BASEJOIN = null, t = n = c([Object(a.hideFlag)(28), Object(r.component)({
            isRemovable: !1,
            isAbstract: !1
        })], t)
    }(r.Component);
    __reflect($, "@egret/render/DefaultShaders");
    var ee = function (e) {
        function t() {
            return null !== e && e.apply(this, arguments) || this
        }

        var n;
        return u(t, e), n = t, t.prototype._createMaterial = function (e, t) {
            var n = S.create(t);
            return n.entity.uri = e, a.ResourceManager.instance.addResource({
                uri: e,
                type: "material",
                status: "Ok",
                data: n
            }), n
        }, t.prototype.initialize = function (t, r, o) {
            void 0 === o && (o = null), e.prototype.initialize.call(this, t, r, o);
            var a = n;
            a.MESH_BASIC = this._createMaterial("builtin/meshbasic.mat.json", $.MESH_BASIC).setTexture(I.WHITE), a.MESH_NORMAL = this._createMaterial("builtin/meshnormal.mat.json", $.MESH_NORMAL), a.MESH_LAMBERT = this._createMaterial("builtin/meshlambert.mat.json", $.MESH_LAMBERT).setTexture(I.WHITE), a.MESH_PHONG = this._createMaterial("builtin/meshphong.mat.json", $.MESH_PHONG).setTexture(I.WHITE), a.MESH_PHYSICAL = this._createMaterial("builtin/meshphysical.mat.json", $.MESH_PHYSICAL).setTexture(I.WHITE), a.MESH_STANDARD = this._createMaterial("builtin/meshstandard.mat.json", $.MESH_PHYSICAL).setTexture(I.WHITE).addDefine("STANDARD"), a.LINEDASHED = this._createMaterial("builtin/linedashed.mat.json", $.LINEDASHED), a.MISSING = this._createMaterial("builtin/missing.mat.json", $.MESH_BASIC).setColor(i.Color.PURPLE), a.BACKGROUND = this._createMaterial("builtin/background.mat.json", $.BACKGROUND).setDepth(!1, !1).setCullFace(!0), a.PARTICLE = this._createMaterial("builtin/particle.mat.json", $.PARTICLE).setBlend(2, 3e3).setTexture(I.WHITE).addDefine("USE_COLOR"), a.SHADOW_DEPTH_3200 = this._createMaterial("builtin/shadow_depth_3200.mat.json", $.DEPTH).setDepth(!0, !0).setCullFace(!0, 2305, 1029).addDefine("DEPTH_PACKING 3200"), a.SHADOW_DEPTH_3201 = this._createMaterial("builtin/shadow_depth_3201.mat.json", $.DEPTH).setDepth(!0, !0).setCullFace(!0, 2305, 1029).addDefine("DEPTH_PACKING 3201"), a.SHADOW_DISTANCE = this._createMaterial("builtin/shadow_distance.mat.json", $.DISTANCE_RGBA).setDepth(!0, !0).addDefine("FLIP_SIDED").addDefine("USE_SHADOWMAP").setCullFace(!0, 2305, 1029), a.COPY = this._createMaterial("builtin/copy.mat.json", $.COPY).setBlend(2, 3e3).setDepth(!1, !1), a.FXAA = this._createMaterial("builtin/fxaa.mat.json", $.FXAA).setBlend(2, 3e3).setDepth(!1, !1)
        }, t.MESH_BASIC = null, t.MESH_NORMAL = null, t.MESH_LAMBERT = null, t.MESH_PHONG = null, t.MESH_PHYSICAL = null, t.MESH_STANDARD = null, t.LINEDASHED = null, t.MISSING = null, t.BACKGROUND = null, t.PARTICLE = null, t.SHADOW_DEPTH_3201 = null, t.SHADOW_DEPTH_3200 = null, t.SHADOW_DISTANCE = null, t.COPY = null, t.FXAA = null, t = n = c([Object(a.hideFlag)(28), Object(r.component)({
            isRemovable: !1,
            isAbstract: !1
        })], t)
    }(r.Component);
    __reflect(ee, "@egret/render/DefaultMaterials");
    var te = function (e) {
        function t() {
            var t = null !== e && e.apply(this, arguments) || this;
            return t._renderContext = i.Application.instance.renderContext, t
        }

        return u(t, e), t.prototype.renderPostprocessTarget = function (e, t, n) {
            void 0 === t && (t = null), void 0 === n && (n = null), this._renderContext.render(e, t, null !== n ? n : e.postprocessingRenderTarget)
        }, t.prototype.blit = function (e, t, n, r) {
            void 0 === t && (t = null), void 0 === n && (n = null), void 0 === r && (r = null), null === t && (t = ee.COPY).setTexture(e);
            var i = this._renderContext, o = i.drawCallCollector, a = i.cameraCollector, s = this._renderContext,
                l = a.currentCamera, u = a.postprocessingCamera;
            s.renderTarget = n, s.viewport = u.viewport, null !== r && 0 === r || (s.clearColor = l.backgroundColor, s.clearBuffer(r || l.bufferMask)), a.currentCamera = u, s.draw(o.postprocessing, t), a.currentCamera = l
        }, t = c([Object(r.component)({allowMultiple: !0, type: "cameraPostprocessing", isAbstract: !0})], t)
    }(i.GameComponent);
    __reflect(te, "@egret/render/CameraPostprocessing");
    var ne = function (e) {
        function t() {
            var t = null !== e && e.apply(this, arguments) || this;
            return t._stage = null, t._renderTexture = null, t
        }

        return u(t, e), t.prototype._onStageResize = function () {
            var e = this._stage.viewport, t = e.w, n = e.h, r = this._renderTexture;
            r && r.setSize(t, n)
        }, t.prototype.initialize = function (t, n, r) {
            void 0 === r && (r = null), e.prototype.initialize.call(this, t, n, r);
            var o = this._stage = i.Application.instance.stage;
            this._renderTexture = b.create({
                width: o.viewport.w,
                height: o.viewport.h,
                format: 6407
            }).setFilter(1).setRepeat(!1), o.onResize.add(this._onStageResize, this)
        }, t.prototype.uninitialize = function () {
            e.prototype.uninitialize.call(this), this._stage.onResize.remove(this._onStageResize, this), this._stage = null, this._renderTexture = null
        }, t.prototype.onRender = function (e) {
            var t = this._renderContext, n = this._renderTexture;
            t.renderTarget = n, t.clearColor = e.backgroundColor, t.clearBuffer(17664), this.renderPostprocessTarget(e, void 0, n), ee.FXAA.setTexture(n), this.blit(n, ee.FXAA)
        }, t = c([Object(r.component)({isAbstract: !1})], t)
    }(te);
    __reflect(ne, "@egret/render/FXAAPostprocess");
    var re = [[[0, 0]], [[4, 4], [-4, -4]], [[-2, -6], [6, -2], [-6, 2], [2, 6]], [[1, -3], [-1, 3], [5, 1], [-3, -5], [-5, 5], [-7, -1], [3, 7], [7, -7]], [[1, 1], [-1, -3], [-3, 2], [4, -1], [-5, -2], [2, 5], [5, 3], [3, -5], [-2, 6], [0, -7], [-4, -6], [-6, 4], [-8, 0], [7, -4], [6, 7], [-7, -8]], [[-4, -7], [-7, -5], [-3, -5], [-5, -4], [-1, -4], [-2, -2], [-6, -1], [-4, 0], [-7, 1], [-1, 2], [-6, 3], [-3, 3], [-7, 6], [-3, 6], [-5, 7], [-1, 7], [5, -7], [1, -6], [6, -5], [4, -4], [2, -3], [7, -2], [1, -1], [4, -1], [2, 1], [6, 2], [0, 4], [4, 4], [2, 5], [7, 5], [5, 6], [3, 7]]],
        ie = function (e) {
            function t() {
                var t = null !== e && e.apply(this, arguments) || this;
                return t.sampleLevel = 2, t.unbiased = !1, t._stage = null, t._clearColor = i.Color.create(0, 0, 0, 0), t._subViewport = i.Rectangle.create(0, 0, 1, 1), t._copyMaterial = null, t._sampleRenderTarget = null, t._finalSampleRenderTarget = null, t
            }

            return u(t, e), t.prototype._onStageResize = function () {
                var e = this._stage.viewport, t = e.w, n = e.h, r = this._sampleRenderTarget,
                    i = this._finalSampleRenderTarget;
                r && r.setSize(t, n), i && i.setSize(t, n)
            }, t.prototype.initialize = function (t, n, r) {
                void 0 === r && (r = null), e.prototype.initialize.call(this, t, n, r);
                var o = this._stage = i.Application.instance.stage;
                o.onResize.add(this._onStageResize, this), this._copyMaterial = S.create($.COPY).setBlend(5, 3e3).setDepth(!1, !1).addDefine("PREMULTIPLIED_ALPHA"), this._sampleRenderTarget = b.create({
                    width: o.viewport.w,
                    height: o.viewport.h,
                    format: 6408,
                    sampler: {minFilter: 9729, magFilter: 9729}
                }), this._finalSampleRenderTarget = b.create({
                    width: o.viewport.w,
                    height: o.viewport.h,
                    format: 6407,
                    sampler: {minFilter: 9729, magFilter: 9729}
                })
            }, t.prototype.uninitialize = function () {
                e.prototype.uninitialize.call(this), this._stage.onResize.remove(this._onStageResize, this), this._stage = null, this._copyMaterial = null, this._sampleRenderTarget = null, this._finalSampleRenderTarget = null
            }, t.prototype.onRender = function (e) {
                var t = this, n = t._renderContext, r = t._stage, i = t._copyMaterial, o = t._sampleRenderTarget,
                    a = t._finalSampleRenderTarget, s = t._subViewport, l = t._clearColor, u = t.unbiased,
                    c = re[Math.max(0, Math.min(this.sampleLevel, 5))], p = 1 / c.length, d = r.viewport, h = d.w,
                    f = d.h;
                i.setTexture(o);
                for (var m = 0, _ = c.length; m < _; m++) {
                    var g = c[m];
                    e.subViewport = s.set(.0625 * g[0] / h, .0625 * g[1] / f, 1, 1);
                    var v = p;
                    if (u) v += 1 / 32 * ((m + .5) / _ - .5);
                    n.renderTarget = o, n.clearColor = l, n.clearBuffer(17664), n.render(e, null, o), n.renderTarget = a, 0 === m && (n.clearColor = l, n.clearBuffer(17664)), i.opacity = v, this.blit(o, i, a, 0)
                }
                this.blit(a), e.subViewport.set(0, 0, 1, 1)
            }, c([Object(a.property)("uint", {
                minimum: 0,
                maximum: 5,
                step: 1
            })], t.prototype, "sampleLevel", void 0), c([Object(a.property)("boolean")], t.prototype, "unbiased", void 0), t = c([Object(r.component)({isAbstract: !1})], t)
        }(te);
    __reflect(ie, "@egret/render/SSAAPostprocess");
    var oe = function (e) {
        function t() {
            var t = null !== e && e.apply(this, arguments) || this;
            return t.reflections = !0, t._materials = [], t
        }

        return u(t, e), t.prototype.uninitialize = function () {
            e.prototype.uninitialize.call(this), this._materials.length = 0
        }, Object.defineProperty(t.prototype, "materials", {
            get: function () {
                return this._materials
            }, set: function (e) {
                var t = this._materials;
                if (e !== t) {
                    var n = 0;
                    t.length = e.length;
                    for (var r = 0, i = e; r < i.length; r++) {
                        var o = i[r];
                        t[n++] = o
                    }
                } else console.warn("Potentially risky operation.")
            }, enumerable: !0, configurable: !0
        }), Object.defineProperty(t.prototype, "material", {
            get: function () {
                var e = this._materials;
                return e.length > 0 ? e[0] : null
            }, set: function (e) {
                this._materials[0] = e
            }, enumerable: !0, configurable: !0
        }), c([Object(a.property)("boolean"), a.serializedField], t.prototype, "reflections", void 0), c([Object(a.property)("asset", {assetType: "material"}, !0), a.serializedField], t.prototype, "materials", null), t = c([Object(r.component)({isAbstract: !1})], t)
    }(i.GameComponent);
    __reflect(oe, "@egret/render/Skybox");
    var ae = function (e) {
        function t() {
            var t = null !== e && e.apply(this, arguments) || this;
            return t.instanced = 0, t.subMeshIndex = -1, t.zdist = -1, t.modelViewMatrix = i.Matrix4.IDENTITY.clone(), t.mesh = null, t.material = null, t.matrix = null, t.renderer = null, t
        }

        return u(t, e), t.prototype.uninitialize = function () {
            e.prototype.uninitialize.call(this), this.instanced = 0, this.subMeshIndex = -1, this.zdist = -1, this.modelViewMatrix.identity(), this.mesh = null, this.material = null, this.matrix = null, this.renderer = null
        }, t = c([Object(a.hideFlag)(28), Object(r.component)({isAbstract: !1})], t)
    }(r.Component);
    __reflect(ae, "@egret/render/DrawCall");
    var se, le = function (e) {
        function t() {
            return null !== e && e.apply(this, arguments) || this
        }

        return u(t, e), t = c([Object(r.component)({isAbstract: !1})], t)
    }(r.Component);
    __reflect(le, "@egret/render/StaticBatching"), function (e) {
        e[e.GammaInput = 0] = "GammaInput", e[e.GammaOutput = 1] = "GammaOutput", e[e.GammaFactor = 2] = "GammaFactor", e[e.ToneMapping = 3] = "ToneMapping", e[e.LogarithmicDepthBuffer = 4] = "LogarithmicDepthBuffer", e[e.InstancingEnable = 5] = "InstancingEnable", e[e.ShadowQuality = 6] = "ShadowQuality"
    }(se || (se = {}));
    var ue = function (e) {
        function t() {
            return null !== e && e.apply(this, arguments) || this
        }

        return u(t, e), t = c([Object(a.hideFlag)(28)], t)
    }(r.Component);
    __reflect(ue, "@egret/render/_RenderUpdate");
    var ce = function (e) {
        function t() {
            var t = null !== e && e.apply(this, arguments) || this;
            return t.changes = [], t
        }

        return u(t, e), t = c([Object(r.component)({isAbstract: !1})], t)
    }(ue);
    __reflect(ce, "@egret/render/_RenderContextUpdate");
    var pe = function (e) {
        function t() {
            return null !== e && e.apply(this, arguments) || this
        }

        return u(t, e), t = c([Object(r.component)({isAbstract: !1})], t)
    }(ue);
    __reflect(pe, "@egret/render/_MeshUpdate");
    var de = function (e) {
        function t() {
            return null !== e && e.apply(this, arguments) || this
        }

        return u(t, e), t = c([Object(r.component)({isAbstract: !1})], t)
    }(ue);
    __reflect(de, "@egret/render/_MaterialsUpdate");
    var he = function (e) {
        function t() {
            return null !== e && e.apply(this, arguments) || this
        }

        return u(t, e), t = c([Object(r.component)({isAbstract: !1})], t)
    }(ue);
    __reflect(he, "@egret/render/_LightCullingMaskUpdate");
    var fe = function (e) {
        function t() {
            var t = null !== e && e.apply(this, arguments) || this;
            return t.lightType = -1, t.intensity = 1, t.color = i.Color.create(1, 1, 1, 1), t._cullingMask = 1, t
        }

        return u(t, e), Object.defineProperty(t.prototype, "cullingMask", {
            get: function () {
                return this._cullingMask
            }, set: function (e) {
                this._cullingMask !== e && (this._cullingMask = e, this.entity.getOrAddComponent(he))
            }, enumerable: !0, configurable: !0
        }), c([Object(a.property)("float", {minimum: 0}), a.serializedField], t.prototype, "intensity", void 0), c([Object(a.property)("color"), a.serializedField], t.prototype, "color", void 0), c([Object(a.property)("enum", {listItems: Object(a.getItemsFromEnum)(i.NodeLayer)}), a.serializedField], t.prototype, "cullingMask", null), t = c([Object(r.component)({
            type: "light",
            isAbstract: !0
        })], t)
    }(i.GameComponent);
    __reflect(fe, "@egret/render/BaseLight");
    var me = function (e) {
        function t() {
            var t = null !== e && e.apply(this, arguments) || this;
            return t.lightType = 0, t
        }

        return u(t, e), t = c([Object(r.component)({isAbstract: !1})], t)
    }(fe);
    __reflect(me, "@egret/render/DirectionalLight");
    var _e = function (e) {
        function t() {
            var t = null !== e && e.apply(this, arguments) || this;
            return t.lightType = 4, t.groundColor = i.Color.create(0, 0, 0, 1), t
        }

        return u(t, e), c([Object(a.property)("color"), a.serializedField], t.prototype, "groundColor", void 0), t = c([Object(r.component)({isAbstract: !1})], t)
    }(fe);
    __reflect(_e, "@egret/render/HemisphereLight");
    var ge, ve, ye, be, xe, Te, Ee, Ce, Se, Me, Ae, Oe, we, Re, Pe, Le, De, Ie, Ne, ze, Ue, Fe, ke, Ve, Be, Ge, je, He,
        We, Xe, Ye = function (e) {
            function t() {
                var t = null !== e && e.apply(this, arguments) || this;
                return t.lightType = 3, t.decay = 1, t.distance = 0, t
            }

            return u(t, e), c([Object(a.property)("float", {minimum: 0}), a.serializedField], t.prototype, "decay", void 0), c([Object(a.property)("float", {minimum: 0}), a.serializedField], t.prototype, "distance", void 0), t = c([Object(r.component)({isAbstract: !1})], t)
        }(fe);
    __reflect(Ye, "@egret/render/PointLight"), function (e) {
        e.CameraFrustumCulling = "cameraFrustumCulling", e.Octree = "octree"
    }(ge || (ge = {})), function (e) {
        e[e.Background = -2e3] = "Background", e[e.EditorBackground = -1e3] = "EditorBackground", e[e.Default = 0] = "Default", e[e.EditorPerspective = 1e3] = "EditorPerspective", e[e.Foreground = 2e3] = "Foreground", e[e.EditorOrthographic = 3e3] = "EditorOrthographic"
    }(ve || (ve = {})), function (e) {
        e[e.Background = 1e3] = "Background", e[e.Geometry = 2e3] = "Geometry", e[e.AlphaTest = 2450] = "AlphaTest", e[e.GeometryLast = 2999] = "GeometryLast", e[e.Blend = 3e3] = "Blend", e[e.Overlay = 4e3] = "Overlay"
    }(ye || (ye = {})), function (e) {
        e[e.Default = -1] = "Default", e[e.Low = 0] = "Low", e[e.Medium = 1] = "Medium", e[e.Hight = 2] = "Hight", e[e.VeryHight = 3] = "VeryHight"
    }(be || (be = {})), function (e) {
        e[e.None = 0] = "None", e[e.Normal = 2] = "Normal", e[e.Normal_PreMultiply = 3] = "Normal_PreMultiply", e[e.Additive = 4] = "Additive", e[e.Additive_PreMultiply = 5] = "Additive_PreMultiply", e[e.Subtractive = 8] = "Subtractive", e[e.Subtractive_PreMultiply = 9] = "Subtractive_PreMultiply", e[e.Multiply = 16] = "Multiply", e[e.Multiply_PreMultiply = 17] = "Multiply_PreMultiply", e[e.Custom = -1] = "Custom"
    }(xe || (xe = {})), function (e) {
        e[e.LinearEncoding = 1] = "LinearEncoding", e[e.sRGBEncoding = 2] = "sRGBEncoding", e[e.RGBEEncoding = 3] = "RGBEEncoding", e[e.RGBM7Encoding = 4] = "RGBM7Encoding", e[e.RGBM16Encoding = 5] = "RGBM16Encoding", e[e.RGBDEncoding = 6] = "RGBDEncoding", e[e.GammaEncoding = 7] = "GammaEncoding"
    }(Te || (Te = {})), function (e) {
        e[e.UV = 0] = "UV", e[e.Cube = 1] = "Cube", e[e.CubeUV = 2] = "CubeUV", e[e.Equirectangular = 3] = "Equirectangular", e[e.Spherical = 4] = "Spherical"
    }(Ee || (Ee = {})), function (e) {
        e[e.Point = 0] = "Point", e[e.Bilinear = 1] = "Bilinear", e[e.Trilinear = 2] = "Trilinear"
    }(Ce || (Ce = {})), function (e) {
        e[e.None = 0] = "None", e[e.BoundingBox = 1] = "BoundingBox", e[e.DrawMode = 2] = "DrawMode", e[e.VertexArray = 4] = "VertexArray", e[e.VertexBuffer = 8] = "VertexBuffer", e[e.IndexBuffer = 16] = "IndexBuffer", e[e.All = 31] = "All"
    }(Se || (Se = {})), function (e) {
        e[e.Image = 1] = "Image", e[e.Buffer = 2] = "Buffer", e[e.Levels = 4] = "Levels", e[e.All = 7] = "All"
    }(Me || (Me = {})), function (e) {
        e[e.None = 0] = "None", e[e.UVTransform = 1] = "UVTransform", e[e.All = 1] = "All"
    }(Ae || (Ae = {})), function (e) {
        e[e.Mesh = 1] = "Mesh", e[e.BoneMatrices = 2] = "BoneMatrices", e[e.Skinned = 4] = "Skinned", e[e.All = 7] = "All"
    }(Oe || (Oe = {})), function (e) {
        e[e.SelfMatrices = 1] = "SelfMatrices", e[e.BoneMatrices = 2] = "BoneMatrices", e[e.Skinned = 4] = "Skinned", e[e.All = 7] = "All"
    }(we || (we = {})), function (e) {
        e[e.ProjectionMatrix = 1] = "ProjectionMatrix", e[e.TransformMatrix = 2] = "TransformMatrix", e[e.ClipToWorldMatrix = 4] = "ClipToWorldMatrix", e[e.WorldToClipMatrix = 8] = "WorldToClipMatrix", e[e.CullingMatrix = 16] = "CullingMatrix", e[e.PixelViewport = 32] = "PixelViewport", e[e.CullingFrustum = 64] = "CullingFrustum", e[e.All = 127] = "All"
    }(Re || (Re = {})), function (e) {
        e[e.StateEnables = 1] = "StateEnables", e[e.Program = 2] = "Program", e[e.Camera = 4] = "Camera", e[e.Light = 8] = "Light", e[e.Mesh = 16] = "Mesh", e[e.Material = 32] = "Material", e[e.Other = 64] = "Other", e[e.All = 127] = "All"
    }(Pe || (Pe = {})), function (e) {
        e[e.None = 0] = "None", e[e.LinearToneMapping = 1] = "LinearToneMapping", e[e.ReinhardToneMapping = 2] = "ReinhardToneMapping", e[e.Uncharted2ToneMapping = 3] = "Uncharted2ToneMapping", e[e.CineonToneMapping = 4] = "CineonToneMapping"
    }(Le || (Le = {})), function (e) {
        e[e.Fog = 0] = "Fog", e[e.FogEXP2 = 1] = "FogEXP2"
    }(De || (De = {})), function (e) {
        e[e.Directional = 0] = "Directional", e[e.Spot = 1] = "Spot", e[e.RectangleArea = 2] = "RectangleArea", e[e.Point = 3] = "Point", e[e.Hemisphere = 4] = "Hemisphere"
    }(Ie || (Ie = {})), function (e) {
        e[e.Directional = 43] = "Directional", e[e.Spot = 50] = "Spot", e[e.RectangleArea = 44] = "RectangleArea", e[e.Point = 47] = "Point", e[e.Hemisphere = 41] = "Hemisphere"
    }(Ne || (Ne = {})), function (e) {
        e[e.DirectLightBuffer = 11] = "DirectLightBuffer", e[e.SpotLightBuffer = 18] = "SpotLightBuffer", e[e.RectangleAreaLightBuffer = 12] = "RectangleAreaLightBuffer", e[e.PointLightBuffer = 15] = "PointLightBuffer", e[e.HemisphereLightBuffer = 9] = "HemisphereLightBuffer"
    }(ze || (ze = {})), function (e) {
        e[e.Directional = 16] = "Directional", e[e.Spot = 16] = "Spot", e[e.Point = 16] = "Point"
    }(Ue || (Ue = {})), function (e) {
        e.INSTANCE_DISTANCE = "_INSTANCE_DISTANCE", e.INSTANCE_START = "_INSTANCE_START", e.INSTANCE_END = "_INSTANCE_END", e.INSTANCE_COLOR_START = "_INSTANCE_COLOR_START", e.INSTANCE_COLOR_END = "_INSTANCE_COLOR_END", e.INSTANCE_DISTANCE_START = "_INSTANCE_DISTANCE_START", e.INSTANCE_DISTANCE_END = "_INSTANCE_DISTANCE_END", e.CORNER = "_CORNER", e.START_POSITION = "_START_POSITION", e.START_VELOCITY = "_START_VELOCITY", e.START_COLOR = "_START_COLOR", e.START_SIZE = "_START_SIZE", e.START_ROTATION = "_START_ROTATION", e.TIME = "_TIME", e.RANDOM0 = "_RANDOM0", e.RANDOM1 = "_RANDOM1", e.WORLD_POSITION = "_WORLD_POSITION", e.WORLD_ROTATION = "_WORLD_ROTATION", e.INSTANCED_MODEL0 = "_INSTANCED_MODEL0", e.INSTANCED_MODEL1 = "_INSTANCED_MODEL1", e.INSTANCED_MODEL2 = "_INSTANCED_MODEL2", e.INSTANCED_MODEL3 = "_INSTANCED_MODEL3", e.INSTANCED_MODEL_VIEW0 = "_INSTANCED_MODEL_VIEW0", e.INSTANCED_MODEL_VIEW1 = "_INSTANCED_MODEL_VIEW1", e.INSTANCED_MODEL_VIEW2 = "_INSTANCED_MODEL_VIEW2", e.INSTANCED_MODEL_VIEW3 = "_INSTANCED_MODEL_VIEW3"
    }(Fe || (Fe = {})), function (e) {
        e.BONETEXTURE = "_BONETEXTURE", e.BONETEXTURESIZE = "_BONETEXTURESIZE", e.RESOLUTION = "_RESOLUTION", e.CLOCK = "_CLOCK", e.VIEWPROJECTION = "_VIEWPROJECTION", e.CAMERA_POS = "_CAMERA_POS", e.CAMERA_UP = "_CAMERA_UP", e.CAMERA_FORWARD = "_CAMERA_FORWARD", e.AMBIENTLIGHTCOLOR = "_AMBIENTLIGHTCOLOR", e.DIRECTLIGHTS = "_DIRECTLIGHTS", e.SPOTLIGHTS = "_SPOTLIGHTS", e.RECTAREALIGHTS = "_RECTAREALIGHTS", e.POINTLIGHTS = "_POINTLIGHTS", e.HEMILIGHTS = "_HEMILIGHTS", e.DIRECTIONSHADOWMAT = "_DIRECTIONSHADOWMAT", e.SPOTSHADOWMAT = "_SPOTSHADOWMAT", e.POINTSHADOWMAT = "_POINTSHADOWMAT", e.DIRECTIONSHADOWMAP = "_DIRECTIONSHADOWMAP", e.POINTSHADOWMAP = "_POINTSHADOWMAP", e.SPOTSHADOWMAP = "_SPOTSHADOWMAP", e.LIGHTMAPTEX = "_LIGHTMAPTEX", e.LIGHTMAPINTENSITY = "_LIGHTMAPINTENSITY", e.LIGHTMAP_SCALE_OFFSET = "_LIGHTMAP_SCALE_OFFSET", e.REFERENCEPOSITION = "_REFERENCEPOSITION", e.NEARDICTANCE = "_NEARDICTANCE", e.FARDISTANCE = "_FARDISTANCE", e.TONE_MAPPING_EXPOSURE = "_TONE_MAPPING_EXPOSURE", e.TONE_MAPPING_WHITE_POINT = "_TONE_MAPPING_WHITE_POINT", e.LOG_DEPTH_BUFFC = "_LOG_DEPTH_BUFFC", e.FOG_COLOR = "_FOG_COLOR", e.FOG_DENSITY = "_FOG_DENSITY", e.FOG_NEAR = "_FOG_NEAR", e.FOG_FAR = "_FOG_FAR", e.ROTATION = "_ROTATION", e.SCALE2D = "_SCALE2D", e.PREFABMATRIX = "_PREFABMATRIX", e.ANITEXTURE = "_ANITEXTURE", e.WIDTHANDHEIGHT = "_WIDTHANDHEIGHT", e.FRAME = "_FRAME"
    }(ke || (ke = {})), function (e) {
        e.Diffuse = "diffuse", e.Opacity = "opacity", e.Size = "size", e.Map = "map", e.AlphaMap = "alphaMap", e.AOMap = "aoMap", e.BumpMap = "bumpMap", e.NormalMap = "normalMap", e.SpecularMap = "specularMap", e.GradientMap = "gradientMap", e.RoughnessMap = "roughnessMap", e.MetalnessMap = "metalnessMap", e.DisplacementMap = "displacementMap", e.EnvMap = "envMap", e.EmissiveMap = "emissiveMap", e.CubeMap = "tCube", e.EquirectMap = "tEquirect", e.Flip = "tFlip", e.UVTransform = "uvTransform", e.Reflectivity = "reflectivity", e.RefractionRatio = "refractionRatio", e.Specular = "specular", e.Shininess = "shininess", e.BumpScale = "bumpScale", e.NormalScale = "normalScale", e.Roughness = "roughness", e.Metalness = "metalness", e.Emissive = "emissive", e.EmissiveIntensity = "emissiveIntensity", e.FlipEnvMap = "flipEnvMap", e.MaxMipLevel = "maxMipLevel", e.Rotation = "rotation", e.Scale2D = "scale2D", e.Center = "center"
    }(Ve || (Ve = {})), function (e) {
        e[e.None = 0] = "None", e[e.Name = 1] = "Name", e[e.Content = 2] = "Content", e[e.NameAndContent = 3] = "NameAndContent", e[e.Code = 4] = "Code"
    }(Be || (Be = {})), function (e) {
        e[e.Vertex = 1] = "Vertex", e[e.Fragment = 2] = "Fragment", e[e.All = 3] = "All"
    }(Ge || (Ge = {})), function (e) {
        e[e.GammaFactor = 1] = "GammaFactor", e[e.DecodingFun = 2] = "DecodingFun", e[e.EncodingFun = 3] = "EncodingFun"
    }(je || (je = {})), function (e) {
        e.TONE_MAPPING = "TONE_MAPPING", e.GAMMA_FACTOR = "GAMMA_FACTOR", e.USE_LOGDEPTHBUF = "USE_LOGDEPTHBUF", e.USE_LOGDEPTHBUF_EXT = "USE_LOGDEPTHBUF_EXT", e.USE_COLOR = "USE_COLOR", e.USE_MAP = "USE_MAP", e.USE_ALPHAMAP = "USE_ALPHAMAP", e.USE_AOMAP = "USE_AOMAP", e.USE_BUMPMAP = "USE_BUMPMAP", e.USE_NORMALMAP = "USE_NORMALMAP", e.TANGENTSPACE_NORMALMAP = "TANGENTSPACE_NORMALMAP", e.USE_SPECULARMAP = "USE_SPECULARMAP", e.USE_ROUGHNESSMAP = "USE_ROUGHNESSMAP", e.USE_METALNESSMAP = "USE_METALNESSMAP", e.USE_DISPLACEMENTMAP = "USE_DISPLACEMENTMAP", e.USE_EMISSIVEMAP = "USE_EMISSIVEMAP", e.USE_ENVMAP = "USE_ENVMAP", e.USE_LIGHTMAP = "USE_LIGHTMAP", e.USE_SHADOWMAP = "USE_SHADOWMAP", e.USE_SKINNING = "USE_SKINNING", e.USE_SIZEATTENUATION = "USE_SIZEATTENUATION", e.USE_INSTANCED = "USE_INSTANCED", e.USE_MORPHTARGETS = "USE_MORPHTARGETS", e.USE_MORPHNORMALS = "USE_MORPHNORMALS", e.USE_GPU_ANI = "USE_GPU_ANI", e.TOON = "TOON", e.STANDARD = "STANDARD", e.TEXTURE_LOD_EXT = "TEXTURE_LOD_EXT", e.ENVMAP_TYPE_CUBE = "ENVMAP_TYPE_CUBE", e.ENVMAP_TYPE_CUBE_UV = "ENVMAP_TYPE_CUBE_UV", e.ENVMAP_TYPE_EQUIREC = "ENVMAP_TYPE_EQUIREC", e.ENVMAP_TYPE_SPHERE = "ENVMAP_TYPE_SPHERE", e.ENVMAP_MODE_REFRACTION = "ENVMAP_MODE_REFRACTION", e.ENVMAP_BLENDING_MULTIPLY = "ENVMAP_BLENDING_MULTIPLY", e.ENVMAP_BLENDING_MIX = "ENVMAP_BLENDING_MIX", e.ENVMAP_BLENDING_ADD = "ENVMAP_BLENDING_ADD", e.FLAT_SHADED = "FLAT_SHADED", e.MAX_BONES = "MAX_BONES", e.BONE_TEXTURE = "BONE_TEXTURE", e.NUM_DIR_LIGHTS = "NUM_DIR_LIGHTS", e.NUM_POINT_LIGHTS = "NUM_POINT_LIGHTS", e.NUM_RECT_AREA_LIGHTS = "NUM_RECT_AREA_LIGHTS", e.NUM_SPOT_LIGHTS = "NUM_SPOT_LIGHTS", e.NUM_HEMI_LIGHTS = "NUM_HEMI_LIGHTS", e.NUM_CLIPPING_PLANES = "NUM_CLIPPING_PLANES", e.UNION_CLIPPING_PLANES = "UNION_CLIPPING_PLANES", e.NUM_DIR_LIGHT_SHADOWS = "NUM_DIR_LIGHT_SHADOWS", e.NUM_SPOT_LIGHT_SHADOWS = "NUM_SPOT_LIGHT_SHADOWS", e.NUM_POINT_LIGHT_SHADOWS = "NUM_POINT_LIGHT_SHADOWS", e.SHADOWMAP_TYPE_PCF = "SHADOWMAP_TYPE_PCF", e.SHADOWMAP_TYPE_PCF_SOFT = "SHADOWMAP_TYPE_PCF_SOFT", e.DEPTH_PACKING_3200 = "DEPTH_PACKING 3200", e.DEPTH_PACKING_3201 = "DEPTH_PACKING 3201", e.FLIP_SIDED = "FLIP_SIDED", e.DOUBLE_SIDED = "DOUBLE_SIDED", e.PREMULTIPLIED_ALPHA = "PREMULTIPLIED_ALPHA", e.USE_FOG = "USE_FOG", e.FOG_EXP2 = "FOG_EXP2", e.FLIP_V = "FLIP_V", e.LIGHT_CULLING = "LIGHT_CULLING", e.USE_UV = "USE_UV"
    }(He || (He = {})), function (e) {
        e.CullBackFace = "CullBackFace", e.CullFrontFace = "CullFrontFace", e.CullFrontAndBackFaces = "CullFrontAndBackFaces", e.DisableCullFace = "DisableCullFace"
    }(We || (We = {})), function (e) {
        e.CCW = "CCW", e.CW = "CW"
    }(Xe || (Xe = {}));
    var qe = function (e) {
        function t() {
            var t = null !== e && e.apply(this, arguments) || this;
            return t.radius = 1, t.bias = 0, t.near = .5, t.far = 500, t.size = 10, t._quality = -1, t._mapSize = 512, t._matrix = i.Matrix4.create(), t._renderTarget = null, t
        }

        var n;
        return u(t, e), n = t, t.prototype._updateMapSize = function () {
            var e = i.Application.instance.renderContext, t = this._quality, r = -1 === t ? e.shadowQuality : t,
                o = Math.min(n._mapSize[Math.max(r, 0)], e.maxTextureSize);
            null !== this.entity.getComponent(Ye) ? this._renderTarget.setSize(4 * o, 2 * o) : this._renderTarget.setSize(o, o), this._mapSize = o
        }, t.prototype.initialize = function (t, n) {
            e.prototype.initialize.call(this, t, n), this._renderTarget = b.create({
                width: 512,
                height: 512
            }), this._updateMapSize()
        }, t.prototype.uninitialize = function () {
            e.prototype.uninitialize.call(this), this._renderTarget.entity.destroy(), this._renderTarget = null
        }, Object.defineProperty(t.prototype, "quality", {
            get: function () {
                return this._quality
            }, set: function (e) {
                this._quality !== e && (this._quality = e, this._updateMapSize())
            }, enumerable: !0, configurable: !0
        }), Object.defineProperty(t.prototype, "mapSize", {
            get: function () {
                return this._mapSize
            }, enumerable: !0, configurable: !0
        }), t._mapSize = [256, 512, 1024, 2048], c([a.serializedField, Object(a.property)("float", {minimum: 0})], t.prototype, "radius", void 0), c([a.serializedField, Object(a.property)("float", {
            minimum: -.01,
            maximum: .01,
            step: 1e-6
        })], t.prototype, "bias", void 0), c([a.serializedField, Object(a.property)("float", {
            minimum: .01,
            maximum: 9999
        })], t.prototype, "near", void 0), c([a.serializedField, Object(a.property)("float", {
            minimum: .02,
            maximum: 1e4
        })], t.prototype, "far", void 0), c([a.serializedField, Object(a.property)("float", {minimum: .01})], t.prototype, "size", void 0), c([Object(a.property)("enum", {listItems: Object(a.getItemsFromEnum)(be)}), a.serializedField], t.prototype, "quality", null), t = n = c([Object(r.component)({isAbstract: !1})], t)
    }(i.GameComponent);
    __reflect(qe, "@egret/render/LightShadow");
    var Ze = function (e) {
        function t() {
            var t = null !== e && e.apply(this, arguments) || this;
            return t.lightType = 2, t.width = 1, t.height = 1, t
        }

        return u(t, e), c([Object(a.property)("float", {minimum: 0}), a.serializedField], t.prototype, "width", void 0), c([Object(a.property)("float", {minimum: 0}), a.serializedField], t.prototype, "height", void 0), t = c([Object(r.component)({isAbstract: !1})], t)
    }(fe);
    __reflect(Ze, "@egret/render/RectangleAreaLight");
    var Ke = function (e) {
        function t() {
            var t = null !== e && e.apply(this, arguments) || this;
            return t.lightType = 1, t.decay = 1, t.distance = 0, t.angle = .7853981633974483, t.penumbra = 0, t
        }

        return u(t, e), c([a.serializedField, Object(a.property)("float", {minimum: 0})], t.prototype, "decay", void 0), c([a.serializedField, Object(a.property)("float", {minimum: 0})], t.prototype, "distance", void 0), c([a.serializedField, Object(a.property)("float", {
            minimum: .01,
            maximum: 1.5607963267948965
        })], t.prototype, "angle", void 0), c([a.serializedField, Object(a.property)("float", {
            minimum: 0,
            maximum: 1
        })], t.prototype, "penumbra", void 0), t = c([Object(r.component)({isAbstract: !1})], t)
    }(fe);
    __reflect(Ke, "@egret/render/SpotLight");
    var Qe = function (e) {
        function t() {
            var t = null !== e && e.apply(this, arguments) || this;
            return t.useMorph = !1, t.weight = null, t.isStatic = !1, t.frustumCulled = !0, t._boundingSphereDirty = !0, t._nativeLocalBoundingBox = !1, t._receiveShadows = !1, t._castShadows = !1, t._localBoundingBox = i.Box.create(), t._boundingSphere = i.Sphere.create(), t._materials = [], t
        }

        return u(t, e), t.prototype._recalculateSphere = function () {
            var e = this.localBoundingBox, t = this.getBoundingTransform().localToWorldMatrix;
            this._boundingSphere.set(e.center, e.boundingSphereRadius), this._boundingSphere.center.applyMatrix(t), this._boundingSphere.radius *= t.maxScaleOnAxis
        }, t.prototype._onTransformChanged = function () {
            this._boundingSphereDirty = !0
        }, t.prototype.initialize = function (t, n, r) {
            void 0 === r && (r = null), e.prototype.initialize.call(this, t, n, r), this.getBoundingTransform().onChanged.add(this._onTransformChanged, this)
        }, t.prototype.uninitialize = function () {
            this.entity.isDestroyed || this.getBoundingTransform().onChanged.remove(this._onTransformChanged, this), e.prototype.uninitialize.call(this), this._materials.length = 0
        }, t.prototype.getBoundingTransform = function () {
            return this.entity.getComponent(i.Transform)
        }, Object.defineProperty(t.prototype, "receiveShadows", {
            get: function () {
                return this._receiveShadows
            }, set: function (e) {
                e !== this._receiveShadows && (this._receiveShadows = e)
            }, enumerable: !0, configurable: !0
        }), Object.defineProperty(t.prototype, "castShadows", {
            get: function () {
                return this._castShadows
            }, set: function (e) {
                e !== this._castShadows && (this._castShadows = e)
            }, enumerable: !0, configurable: !0
        }), Object.defineProperty(t.prototype, "localBoundingBox", {
            get: function () {
                var e = this._localBoundingBox;
                if (!this._nativeLocalBoundingBox) {
                    var t = this._getlocalBoundingBox();
                    null !== t && e.copy(t)
                }
                return e
            }, set: function (e) {
                this._boundingSphereDirty = !0, this._nativeLocalBoundingBox = !0, this._localBoundingBox.copy(e)
            }, enumerable: !0, configurable: !0
        }), Object.defineProperty(t.prototype, "boundingSphere", {
            get: function () {
                return this._boundingSphereDirty && (this._recalculateSphere(), this._boundingSphereDirty = !1), this._boundingSphere
            }, enumerable: !0, configurable: !0
        }), Object.defineProperty(t.prototype, "materials", {
            get: function () {
                return this._materials
            }, set: function (e) {
                var t = this._materials;
                if (e !== t) {
                    var n = 0;
                    t.length = e.length;
                    for (var r = 0, i = e; r < i.length; r++) {
                        var o = i[r];
                        t[n++] = o
                    }
                    this.entity.getOrAddComponent(de)
                } else console.warn("Potentially risky operation.")
            }, enumerable: !0, configurable: !0
        }), Object.defineProperty(t.prototype, "material", {
            get: function () {
                var e = this._materials;
                return e.length > 0 ? e[0] : null
            }, set: function (e) {
                this._materials[0] = e, this.entity.getOrAddComponent(de)
            }, enumerable: !0, configurable: !0
        }), c([Object(a.property)("boolean"), a.serializedField], t.prototype, "useMorph", void 0), c([Object(a.property)("boolean"), a.serializedField], t.prototype, "isStatic", void 0), c([Object(a.property)("boolean"), a.serializedField], t.prototype, "frustumCulled", void 0), c([a.serializedField], t.prototype, "_nativeLocalBoundingBox", void 0), c([a.serializedField], t.prototype, "_receiveShadows", void 0), c([a.serializedField], t.prototype, "_castShadows", void 0), c([a.serializedField], t.prototype, "_localBoundingBox", void 0), c([Object(a.property)("boolean")], t.prototype, "receiveShadows", null), c([Object(a.property)("boolean")], t.prototype, "castShadows", null), c([Object(a.property)("nested")], t.prototype, "localBoundingBox", null), c([Object(a.property)("asset", {assetType: "material"}, !0), a.serializedField], t.prototype, "materials", null), t = c([Object(r.component)({
            type: "renderer",
            requireComponents: [i.Transform],
            isAbstract: !0
        })], t)
    }(r.Component);
    __reflect(Qe, "@egret/render/BaseRenderer");
    var Je = function (e) {
        function t() {
            var t = null !== e && e.apply(this, arguments) || this;
            return t._mesh = null, t
        }

        return u(t, e), t.prototype.uninitialize = function () {
            e.prototype.uninitialize.call(this), this._mesh = null
        }, Object.defineProperty(t.prototype, "mesh", {
            get: function () {
                return this._mesh
            }, set: function (e) {
                this._mesh !== e && (this._mesh = e, this.entity.getOrAddComponent(pe))
            }, enumerable: !0, configurable: !0
        }), c([Object(a.property)("asset", {assetType: "mesh"}), a.serializedField], t.prototype, "mesh", null), t = c([Object(r.component)({isAbstract: !1})], t)
    }(r.Component);
    __reflect(Je, "@egret/render/MeshFilter");
    var $e = function (e) {
        function t() {
            var t = null !== e && e.apply(this, arguments) || this;
            return t._lightmapIndex = -1, t._lightmapScaleOffset = i.Vector4.create(), t
        }

        return u(t, e), t.prototype._getlocalBoundingBox = function () {
            var e = this.entity.getComponent(Je).mesh;
            return null !== e ? e.boundingBox : null
        }, t.prototype.getTriangle = function (e, t) {
            void 0 === t && (t = null), null === t && (t = i.Triangle.create());
            var n = this.entity.getComponent(Je).mesh;
            if (null !== n) {
                var r = this.entity.getComponent(i.Transform).localToWorldMatrix;
                n.getTriangle(e, t), t.a.applyMatrix(r), t.b.applyMatrix(r), t.c.applyMatrix(r)
            }
            return t
        }, t.prototype.raycast = function (e, t) {
            void 0 === t && (t = null);
            var n = this.entity.getComponent(Je).mesh;
            if (null !== n) {
                var r = this.entity.getComponent(i.Transform), o = r.worldToLocalMatrix,
                    a = i.Ray.create().applyMatrix(o, e).release(), s = i.Matrix3.create().release();
                if ((!this._nativeLocalBoundingBox || this.localBoundingBox.raycast(a)) && n.raycast(a, t)) {
                    if (null !== t) {
                        var l = r.localToWorldMatrix, u = t.normal;
                        t.distance = e.origin.getDistance(t.position.applyMatrix(l)), t.transform = r, null !== u && u.applyMatrix3(s.fromMatrix4(o).transpose()).normalize()
                    }
                    return !0
                }
            }
            return !1
        }, Object.defineProperty(t.prototype, "lightmapIndex", {
            get: function () {
                return this._lightmapIndex
            }, set: function (e) {
                e !== this._lightmapIndex && (this._lightmapIndex = e)
            }, enumerable: !0, configurable: !0
        }), Object.defineProperty(t.prototype, "lightmapScaleOffset", {
            get: function () {
                return this._lightmapScaleOffset
            }, set: function (e) {
                this._lightmapScaleOffset.copy(e)
            }, enumerable: !0, configurable: !0
        }), c([Object(a.property)("int"), a.serializedField], t.prototype, "lightmapIndex", null), c([a.serializedField], t.prototype, "lightmapScaleOffset", null), t = c([Object(r.component)({
            requireComponents: [Je],
            isAbstract: !1
        })], t)
    }(Qe);
    __reflect($e, "@egret/render/MeshRenderer");
    var et = function (e) {
        function t() {
            var t = null !== e && e.apply(this, arguments) || this;
            return t.boneMatrices = null, t.boneTexture = null, t.source = null, t._needUpdated = 7, t._bones = [], t._rootBone = null, t._skinnedVertices = null, t
        }

        return u(t, e), t.prototype._getlocalBoundingBox = function () {
            var e = this.entity.getComponent(Je).mesh;
            if (!e) return null;
            var t = e.glTF, n = this.entity.node.parent, r = null, o = 0;
            if (void 0 !== t.skins) {
                var a = t.skins[0], s = n.getChildren({});
                if (void 0 !== a.skeleton) {
                    for (var l = t.nodes[a.skeleton], u = 0; u < t.nodes.length; u++) this.rootBone.entity.getComponent(i.TreeNode).name === t.nodes[u].name && (o = u);
                    if (l.name in s) {
                        var c = s[l.name];
                        r = Array.isArray(c) ? c[0].entity : c.entity
                    }
                }
            }
            if (null !== e) {
                if (this._nativeLocalBoundingBox = !0, null !== r) {
                    var p = e.inverseBindMatrices, d = i.Matrix4.create().release();
                    return d.fromArray(p, 16 * o), this._localBoundingBox.applyMatrix(d, e.boundingBox)
                }
                return this._localBoundingBox.applyMatrix(this.getBoundingTransform().worldToLocalMatrix, e.boundingBox)
            }
            return null
        }, t.prototype._updateBones = function () {
            this._bones.length = 0, this.rootBone = null, this.boneMatrices = null;
            var e = this.entity.getComponent(Je).mesh, t = this.entity.node.parent, n = this._bones;
            if (null !== e && null !== t) {
                var r = e.glTF;
                if (void 0 !== r.skins) {
                    var o = r.skins[0], a = t.getChildren({});
                    if (void 0 !== o.skeleton) {
                        var s = r.nodes[o.skeleton];
                        if (s.name in a) {
                            var l = a[s.name];
                            this.rootBone = Array.isArray(l) ? l[0].entity.transform : l.entity.transform
                        }
                    }
                    for (var u = 0, c = o.joints; u < c.length; u++) {
                        var p = c[u], d = r.nodes[p];
                        if (d.name in a) {
                            l = a[d.name];
                            n.push(Array.isArray(l) ? l[0].entity.transform : l.entity.transform)
                        } else n.push(null)
                    }
                    var h = i.Application.instance.renderContext;
                    h.textureFloatEnabled ? (this.boneMatrices = new Float32Array(16 * n.length), this.boneTexture = R.create({
                        source: this.boneMatrices,
                        width: 4 * n.length,
                        height: 1,
                        type: 5126
                    })) : (this.boneMatrices = new Float32Array(16 * n.length), n.length > h.maxBoneCount && console.error("The bone count of this mesh has exceeded the maxBoneCount and will use the forced CPU skin."))
                }
            }
        }, t.prototype._updateBoneMatrices = function () {
            var e = this.entity.getComponent(Je).mesh, t = this.boneMatrices;
            if (null !== e && null !== t) {
                for (var n = this._bones, r = e.inverseBindMatrices, o = i.Matrix4.create().release(), a = 0, s = n.length; a < s; ++a) {
                    var l = 16 * a, u = n[a], c = void 0;
                    null !== u ? u.isDestroyed ? (c = i.Matrix4.IDENTITY, n[a] = null) : c = u.localToWorldMatrix : c = i.Matrix4.IDENTITY, o.fromArray(r, l).premultiply(c).toArray(t, l)
                }
                null !== this.boneTexture && this.boneTexture.setSource(t), this._needUpdated |= 4
            }
        }, t.prototype._skinning = function (e, t) {
            var n = this.entity.getComponent(Je).mesh, r = this.boneMatrices, o = i.Vector3.create().release(),
                a = i.Vector3.create().release(), s = i.Vector3.create().release(), l = i.Matrix4.create().release(),
                u = n.getVertices(), c = n.getIndices(), p = n.getAttribute("JOINTS_0"),
                d = n.getAttribute("WEIGHTS_0");
            null === this._skinnedVertices && (this._skinnedVertices = new Float32Array(u.length)), 0 === t ? t = c.length : t += e;
            for (var h = e; h < t; ++h) {
                var f = c[h], m = 3 * f, _ = 4 * f;
                o.fromArray(u, m), a.clear();
                for (var g = 0; g < 4; ++g) {
                    var v = d[_ + g];
                    v < .01 || a.add(s.applyMatrix(l.fromArray(r, 16 * p[_ + g]), o).multiplyScalar(v))
                }
                a.toArray(this._skinnedVertices, m)
            }
        }, t.prototype.uninitialize = function () {
            e.prototype.uninitialize.call(this), null !== this.boneTexture && this.boneTexture.entity.destroy(), this.boneMatrices = null, this.boneTexture = null, this._needUpdated = 7, this._bones.length = 0, this._skinnedVertices = null, this._rootBone = null
        }, t.prototype.needUpdate = function (e) {
            0 != (1 & e) && (e |= 6), this._needUpdated |= e
        }, t.prototype.update = function (e) {
            var t = this._needUpdated & e;
            0 != (1 & t) && this._updateBones(), 0 != (2 & t) && this._updateBoneMatrices(), 0 != (4 & e) && this._skinning(0, 0), this._needUpdated &= ~e
        }, t.prototype.getBoundingTransform = function () {
            var t = this._rootBone;
            return null !== t ? t : e.prototype.getBoundingTransform.call(this)
        }, t.prototype.getTriangle = function (t, n) {
            if (void 0 === n && (n = null), null !== this.boneMatrices) {
                null === n && (n = i.Triangle.create());
                var r = this.entity.getComponent(Je).mesh;
                null !== r && (this._skinning(3 * t, 3), r.getTriangle(t, n, this._skinnedVertices))
            } else n = e.prototype.getTriangle.call(this, t, n);
            return n
        }, t.prototype.raycast = function (e, t) {
            void 0 === t && (t = null);
            var n = this.entity.getComponent(Je).mesh;
            if (null !== n && !n.isDestroyed && null !== this.boneMatrices) {
                var r = i.Ray.create().applyMatrix(this.getBoundingTransform().worldToLocalMatrix, e).release();
                if (this.localBoundingBox.raycast(r) && (this.update(4), n.raycast(e, t, this._skinnedVertices) && null !== t)) return t.transform = this.entity.getComponent(i.Transform), !0
            }
            return !1
        }, Object.defineProperty(t.prototype, "boneCount", {
            get: function () {
                return this._bones.length
            }, enumerable: !0, configurable: !0
        }), Object.defineProperty(t.prototype, "bones", {
            get: function () {
                return this._bones
            }, enumerable: !0, configurable: !0
        }), Object.defineProperty(t.prototype, "rootBone", {
            get: function () {
                return this._rootBone
            }, set: function (e) {
                this._rootBone !== e && (this.getBoundingTransform().onChanged.remove(this._onTransformChanged, this), this._rootBone = e, this.getBoundingTransform().onChanged.add(this._onTransformChanged, this))
            }, enumerable: !0, configurable: !0
        }), c([Object(a.property)("uint", {readonly: !0})], t.prototype, "boneCount", null), c([Object(a.property)("component", {componentClass: i.Transform})], t.prototype, "rootBone", null), t = c([Object(r.component)({isAbstract: !1})], t)
    }($e);
    __reflect(et, "@egret/render/SkinnedMeshRenderer");
    var tt = function (e) {
        function t() {
            var t = null !== e && e.apply(this, arguments) || this;
            return t.boneMatrices = null, t._boneTexture = null, t.targetMatrixData = null, t._currentFrame = 0, t.source = null, t._needUpdated = 7, t._skinnedVertices = null, t._targrtTranform = null, t
        }

        return u(t, e), Object.defineProperty(t.prototype, "boneTexture", {
            get: function () {
                return this._boneTexture
            }, set: function (e) {
                e !== this._boneTexture && (this._boneTexture = e, this.update(2))
            }, enumerable: !0, configurable: !0
        }), Object.defineProperty(t.prototype, "currentFrame", {
            get: function () {
                return this._currentFrame
            }, set: function (e) {
                e !== this._currentFrame && (this._currentFrame = e, this.update(2))
            }, enumerable: !0, configurable: !0
        }), Object.defineProperty(t.prototype, "targetTransform", {
            set: function (e) {
                this._targrtTranform !== e && (this._targrtTranform = e, this.needUpdate(1))
            }, enumerable: !0, configurable: !0
        }), t.prototype.update = function (e) {
            0 != (1 & (this._needUpdated & e)) && this._updateTargetMatrixData(), this._needUpdated &= ~e
        }, t.prototype.needUpdate = function (e) {
            this._needUpdated |= e
        }, t.prototype._updateBoneMatrices = function () {
        }, t.prototype._updateTargetMatrixData = function () {
            null === this._targrtTranform && (this._targrtTranform = this.entity.getComponent(i.Transform)), this.targetMatrixData = this._targrtTranform.localToWorldMatrix.rawData
        }, t.prototype._getlocalBoundingBox = function () {
            var e = this.entity.getComponent(Je).mesh;
            if (!e) return null;
            var t = e.glTF, n = this.entity.node.parent, r = null, o = 0;
            if (void 0 !== t.skins) {
                var a = t.skins[0], s = n.getChildren({});
                if (void 0 !== a.skeleton) {
                    o = a.skeleton;
                    var l = t.nodes[a.skeleton];
                    if (l.name in s) {
                        var u = s[l.name];
                        r = Array.isArray(u) ? u[0].entity : u.entity
                    }
                }
            }
            if (null !== e) {
                if (this._nativeLocalBoundingBox = !0, null !== r) {
                    var c = e.inverseBindMatrices, p = i.Matrix4.create().release();
                    return p.fromArray(c, 16 * o), this._localBoundingBox.applyMatrix(p, e.boundingBox)
                }
                return this._localBoundingBox.applyMatrix(this.getBoundingTransform().worldToLocalMatrix, e.boundingBox)
            }
            return null
        }, t.prototype._skinning = function (e, t) {
            var n = this.entity.getComponent(Je).mesh, r = this.boneMatrices, o = i.Vector3.create().release(),
                a = i.Vector3.create().release(), s = i.Vector3.create().release(), l = i.Matrix4.create().release(),
                u = n.getVertices(), c = n.getIndices(), p = n.getAttribute("JOINTS_0"),
                d = n.getAttribute("WEIGHTS_0");
            null === this._skinnedVertices && (this._skinnedVertices = new Float32Array(u.length)), 0 === t ? t = c.length : t += e;
            for (var h = e; h < t; ++h) {
                var f = c[h], m = 3 * f, _ = 4 * f;
                o.fromArray(u, m), a.clear();
                for (var g = 0; g < 4; ++g) {
                    var v = d[_ + g];
                    v < .01 || a.add(s.applyMatrix(l.fromArray(r, 16 * p[_ + g]), o).multiplyScalar(v))
                }
                a.toArray(this._skinnedVertices, m)
            }
        }, t.prototype.getTriangle = function (t, n) {
            if (void 0 === n && (n = null), null !== this.boneMatrices) {
                null === n && (n = i.Triangle.create());
                var r = this.entity.getComponent(Je).mesh;
                null !== r && (this._skinning(3 * t, 3), r.getTriangle(t, n, this._skinnedVertices))
            } else n = e.prototype.getTriangle.call(this, t, n);
            return n
        }, t.prototype.raycast = function (e, t) {
            void 0 === t && (t = null);
            var n = this.entity.getComponent(Je).mesh;
            if (null !== n && !n.isDestroyed && null !== this.boneMatrices) {
                var r = i.Ray.create().applyMatrix(this.getBoundingTransform().worldToLocalMatrix, e).release();
                if (this.localBoundingBox.raycast(r) && n.raycast(e, t, this._skinnedVertices) && null !== t) return t.transform = this.entity.getComponent(i.Transform), !0
            }
            return !1
        }, t.prototype.uninitialize = function () {
            e.prototype.uninitialize.call(this), this.boneMatrices = null, this.boneTexture = null, this._skinnedVertices = null
        }, t = c([Object(r.component)({isAbstract: !1})], t)
    }($e);
    __reflect(tt, "@egret/render/GpuSkinnedMeshRenderer");
    var nt = function (e) {
        function t() {
            var t = null !== e && e.apply(this, arguments) || this;
            return t.mode = 0, t.density = .01, t.near = .01, t.far = 100, t.color = i.Color.create(.5, .5, .5, 1), t
        }

        return u(t, e), c([Object(a.property)("enum", {listItems: Object(a.getItemsFromEnum)(De)}), a.serializedField], t.prototype, "mode", void 0), c([Object(a.property)("float", {minimum: 0}), a.serializedField], t.prototype, "density", void 0), c([Object(a.property)("float", {
            minimum: .01,
            step: 1
        }), a.serializedField], t.prototype, "near", void 0), c([Object(a.property)("float", {
            minimum: .02,
            step: 1
        }), a.serializedField], t.prototype, "far", void 0), c([Object(a.property)("color"), a.serializedField], t.prototype, "color", void 0), t = c([Object(r.component)({isAbstract: !1})], t)
    }(i.GameComponent);
    __reflect(nt, "@egret/render/Fog");
    var rt = function (e) {
        function t() {
            var t = null !== e && e.apply(this, arguments) || this;
            return t.ambientColor = i.Color.create(.2, .2, .25, 1), t.lightmapIntensity = 1, t._lightmaps = [], t
        }

        return u(t, e), Object.defineProperty(t.prototype, "lightmaps", {
            get: function () {
                return this._lightmaps
            }, set: function (e) {
                var t = this._lightmaps;
                if (e !== t) {
                    t.length = 0;
                    for (var n = 0, r = e; n < r.length; n++) {
                        var i = r[n];
                        t.push(i)
                    }
                }
            }, enumerable: !0, configurable: !0
        }), c([Object(a.property)("color"), a.serializedField], t.prototype, "ambientColor", void 0), c([Object(a.property)("float", {minimum: 0}), a.serializedField], t.prototype, "lightmapIntensity", void 0), c([a.serializedField], t.prototype, "lightmaps", null), t = c([Object(r.component)({isAbstract: !1})], t)
    }(i.GameComponent);
    __reflect(rt, "@egret/render/SceneLight");
    var it = function (e) {
        function t() {
            var t = null !== e && e.apply(this, arguments) || this;
            return t.cameras = [], t.currentCamera = null, t._cameraGroup = i.Application.instance.gameEntityContext.getGroup(r.Matcher.create(i.GameEntity, !1, i.Transform, L)), t._postprocessingCamera = null, t._shadowCamera = null, t._mainCamera = null, t
        }

        return u(t, e), t.prototype._sortCameras = function (e, t) {
            return (null !== e.renderTarget || null !== e._innerRenderTarget ? e.order : 1e3 * (e.order + 1)) - (null !== t.renderTarget || null !== t._innerRenderTarget ? t.order : 1e3 * (t.order + 1))
        }, t.prototype.updateCameras = function (e) {
            var t = this.cameras;
            t.length = 0;
            for (var n = 0, r = e; n < r.length; n++) {
                var i = r[n];
                t.push(i.getComponentByType("camera"))
            }
        }, t.prototype.sortCameras = function () {
            this.cameras.sort(this._sortCameras)
        }, Object.defineProperty(t.prototype, "cameraCount", {
            get: function () {
                return this.cameras.length
            }, enumerable: !0, configurable: !0
        }), Object.defineProperty(t.prototype, "mainCamera", {
            get: function () {
                var e = this._mainCamera;
                if (null !== e) {
                    if (!e.isDestroyed) return e;
                    e = null
                }
                for (var t = 0, n = this._cameraGroup.entities; t < n.length; t++) {
                    var r = n[t];
                    "MainCamera" === r.node.tag && (e = r.getComponent(L))
                }
                return this._mainCamera = e, e
            }, enumerable: !0, configurable: !0
        }), Object.defineProperty(t.prototype, "postprocessingCamera", {
            get: function () {
                if (null === this._postprocessingCamera) {
                    var e = i.EngineFactory.createGameEntity3D("Postprocessing Camera", {parent: i.Application.instance.sceneManager.globalScene.root.entity}),
                        t = e.transform, n = e.addComponent(L);
                    t.enabled = !1, n.enabled = !1, n.opvalue = 0, n.size = 1, n.near = .01, n.far = 1, n.projectionMatrix = i.Matrix4.IDENTITY, this._postprocessingCamera = n
                }
                return this._postprocessingCamera
            }, enumerable: !0, configurable: !0
        }), Object.defineProperty(t.prototype, "shadowCamera", {
            get: function () {
                if (null === this._shadowCamera) {
                    var e = i.EngineFactory.createGameEntity3D("Shadow Camera", {parent: i.Application.instance.sceneManager.globalScene.root.entity}),
                        t = e.transform, n = e.getOrAddComponent(L);
                    t.enabled = !1, n.enabled = !1, this._shadowCamera = n
                }
                return this._shadowCamera
            }, enumerable: !0, configurable: !0
        }), c([Object(a.property)("uint", {readonly: !0})], t.prototype, "cameraCount", null), t = c([Object(a.hideFlag)(28), Object(r.component)({
            isRemovable: !1,
            isAbstract: !1
        })], t)
    }(r.Component);
    __reflect(it, "@egret/render/CameraCollector");
    var ot = function (e) {
        function t() {
            var t = null !== e && e.apply(this, arguments) || this;
            return t.elements = [], t.nodes = [], t._capacity = 64, t._depth = 0, t._maxDepth = 2, t._boundingBox = i.Box.create(), t._boundingSphere = i.Sphere.create(), t._containFunc = null, t
        }

        return u(t, e), t.return = function (e) {
            for (var t = 0, n = e.nodes; t < n.length; t++) {
                var r = n[t];
                this.return(r)
            }
            o.Pool.getPool(this, !0).return(e), e.nodes.length = 0
        }, t.create = function (e, t, n, r, i) {
            var a = o.Pool.getPool(this, !0).borrow();
            return a.initialize(), a.set(e, t, n, r, i)
        }, t.createNodes = function (e, n, r, o, a, s, l) {
            for (var u = s.minimum, c = s.maximum, p = i.Vector3.create().set((c.x - u.x) / 2, (c.y - u.y) / 2, (c.z - u.z) / 2).release(), d = i.Vector3.create().release(), h = i.Vector3.create().release(), f = i.Box.create().release(), m = i.Vector3.create().release(), _ = 0; _ < 2; _++) for (var g = 0; g < 2; g++) for (var v = 0; v < 2; v++) {
                d.copy(u).add(m.set(_, g, v).multiply(p)), h.copy(u).add(m.set(_ + 1, g + 1, v + 1).multiply(p)), f.set(d, h);
                var y = t.create(n, r, o + 1, a, f);
                y.addElements(e), l.push(y)
            }
        }, t.prototype.set = function (e, t, n, r, i) {
            return this._containFunc = e, this._capacity = t, this._depth = n, this._maxDepth = r, this._boundingBox.copy(i), this._boundingSphere.set(i.center, i.boundingSphereRadius), this.elements.length = 0, this.nodes.length = 0, this
        }, t.prototype.addElement = function (e) {
            if (this.nodes.length > 0) for (var n = 0, r = this.nodes; n < r.length; n++) {
                (a = r[n]).addElement(e)
            } else if (this._containFunc(e, this) && this.elements.indexOf(e) < 0 && this.elements.push(e), this.elements.length > this._capacity && this._depth < this._maxDepth) {
                for (var i = 0, o = this.nodes; i < o.length; i++) {
                    var a = o[i];
                    t.return(a)
                }
                this.nodes.length = 0, t.createNodes(this.elements, this._containFunc, this._capacity, this._depth, this._maxDepth, this._boundingBox, this.nodes)
            }
        }, t.prototype.removeElement = function (e) {
            if (this.nodes.length > 0) for (var t = 0, n = this.nodes; t < n.length; t++) {
                n[t].removeElement(e)
            } else {
                var r = this.elements.indexOf(e);
                r >= 0 && this.elements.splice(r, 1)
            }
        }, t.prototype.addElements = function (e) {
            for (var t = 0, n = e; t < n.length; t++) {
                var r = n[t];
                this.addElement(r)
            }
        }, Object.defineProperty(t.prototype, "capacity", {
            get: function () {
                return this._capacity
            }, enumerable: !0, configurable: !0
        }), Object.defineProperty(t.prototype, "depath", {
            get: function () {
                return this._depth
            }, enumerable: !0, configurable: !0
        }), Object.defineProperty(t.prototype, "boundingBox", {
            get: function () {
                return this._boundingBox
            }, enumerable: !0, configurable: !0
        }), Object.defineProperty(t.prototype, "boundingSphere", {
            get: function () {
                return this._boundingSphere
            }, enumerable: !0, configurable: !0
        }), t
    }(o.Releasable);
    __reflect(ot, "@egret/render/OctreeNode");
    var at = function (e) {
        function t() {
            var t = null !== e && e.apply(this, arguments) || this;
            return t.nodes = [], t.dynamicElements = [], t._maxCapacity = 64, t._maxDepath = 2, t._boundingBox = i.Box.create(), t
        }

        return u(t, e), t.prototype.uninitialize = function () {
            e.prototype.uninitialize.call(this);
            for (var t = 0, n = this.nodes; t < n.length; t++) {
                var r = n[t];
                ot.return(r)
            }
            this.nodes.length = 0, this.dynamicElements.length = 0
        }, t.prototype.reset = function (e, t, n, r, o) {
            void 0 === n && (n = 64), void 0 === r && (r = 2), this._boundingBox.copy(t), this._boundingBox.minimum.subtract(i.Vector3.ONE), this._boundingBox.maximum.add(i.Vector3.ONE), this._maxCapacity = n, this._maxDepath = r;
            for (var a = 0, s = this.nodes; a < s.length; a++) {
                var l = s[a];
                ot.return(l)
            }
            this.nodes.length = 0, ot.createNodes(e, o, this.maxCapacity, 0, this.maxDepath, this.boundingBox, this.nodes)
        }, t.prototype.addElement = function (e) {
            for (var t = 0, n = this.nodes; t < n.length; t++) {
                n[t].addElement(e)
            }
        }, t.prototype.removeElement = function (e) {
            for (var t = 0, n = this.nodes; t < n.length; t++) {
                n[t].removeElement(e)
            }
        }, t.prototype.addDynamicElement = function (e) {
            this.dynamicElements.indexOf(e) < 0 && this.dynamicElements.push(e)
        }, t.prototype.removeDynamicElement = function (e) {
            var t = this.dynamicElements.indexOf(e);
            t >= 0 && this.dynamicElements.splice(t, 1)
        }, Object.defineProperty(t.prototype, "maxCapacity", {
            get: function () {
                return this._maxCapacity
            }, enumerable: !0, configurable: !0
        }), Object.defineProperty(t.prototype, "maxDepath", {
            get: function () {
                return this._maxDepath
            }, enumerable: !0, configurable: !0
        }), Object.defineProperty(t.prototype, "boundingBox", {
            get: function () {
                return this._boundingBox
            }, enumerable: !0, configurable: !0
        }), t = c([Object(a.hideFlag)(4), Object(r.component)({type: "octree", isAbstract: !1})], t)
    }(r.Component);
    __reflect(at, "@egret/render/Octree");
    var st = function (e) {
        function t() {
            var t = null !== e && e.apply(this, arguments) || this;
            return t._intersectsInfo = [], t
        }

        var n;
        return u(t, e), n = t, t.prototype._intersects = function (e, t, n) {
            if (e.intersectsSphere(t.boundingSphere)) if (t.nodes.length > 0) for (var r = 0, i = t.nodes; r < i.length; r++) {
                var o = i[r];
                this._intersects(e, o, n)
            } else {
                var a = t.elements, s = n.length;
                n.length += a.length;
                for (var l = 0, u = a.length; l < u; l++) n[s++] = a[l]
            }
        }, t.prototype.reset = function (t, r, i, o) {
            void 0 === i && (i = 64), void 0 === o && (o = 2), e.prototype.reset.call(this, t, r, i, o, n.containsDrawCall)
        }, t.prototype.intersects = function (e) {
            var t = this.nodes, n = this.dynamicElements, r = this._intersectsInfo;
            r.length = 0;
            for (var i = 0, o = t; i < o.length; i++) {
                var a = o[i];
                this._intersects(e, a, r)
            }
            var s = r.length;
            r.length += n.length;
            for (var l = 0, u = n.length; l < u; l++) r[s++] = n[l];
            return this._intersectsInfo
        }, t.containsDrawCall = function (e, t) {
            var n = e.getComponent(ae), r = n.renderer;
            if (null === r) return !1;
            var o = t.boundingBox, a = r.localBoundingBox, s = n.matrix,
                l = i.Box.create(a.minimum, a.maximum).applyMatrix(s).release();
            return o.intersects(l)
        }, t = n = c([Object(r.component)({isAbstract: !1})], t)
    }(at);
    __reflect(st, "@egret/render/CameraFrustumOctree");
    var lt = function (e) {
        function t() {
            return this
        }

        return u(t, DebuggerClass), t.createPlane = function (e, t, n, r) {
            void 0 === e && (e = 1), void 0 === t && (t = 1), void 0 === n && (n = 1), void 0 === r && (r = 1);
            for (var i = e / 2, o = t / 2, a = n + 1, s = r + 1, l = e / n, u = t / r, c = [], p = [], d = [], h = [], f = 0; f < s; f++) for (var m = f * u - o, _ = 0; _ < a; _++) {
                var g = _ * l - i;
                p.push(g, -m, 0), d.push(0, 0, -1), h.push(_ / n, f / r)
            }
            for (f = 0; f < r; f++) for (_ = 0; _ < n; _++) {
                var v = _ + a * f, y = _ + a * (f + 1), b = _ + 1 + a * (f + 1), x = _ + 1 + a * f;
                c.push(v, y, x, x, y, b)
            }
            var T = w.create(p.length / 3, c.length);
            return T.setAttribute("POSITION", p), T.setAttribute("NORMAL", d), T.setAttribute("TEXCOORD_0", h), T.setIndices(c), T
        }, t.createCube = function (e, t, n, r, o, a, s) {
            void 0 === e && (e = 1), void 0 === t && (t = 1), void 0 === n && (n = 1), void 0 === r && (r = 1), void 0 === o && (o = 1), void 0 === a && (a = 1), void 0 === s && (s = !1);
            var l = 0, u = i.Vector3.create().release(), c = [], p = [], d = [], h = [];

            function f(e, t, n, r, i, o, a, s, f, m) {
                for (var _ = 0, g = o / f, v = a / m, y = o / 2, b = a / 2, x = s / 2, T = f + 1, E = m + 1, C = 0; C < E; C++) for (var S = C * v - b, M = 0; M < T; M++) {
                    var A = M * g - y;
                    u[e] = A * r, u[t] = S * i, u[n] = x, p.push(u.x, u.y, u.z), u[e] = 0, u[t] = 0, u[n] = s > 0 ? 1 : -1, d.push(u.x, u.y, u.z), h.push(M / f, C / m), _ += 1
                }
                for (C = 0; C < m; C++) for (M = 0; M < f; M++) {
                    var O = l + M + T * C, w = l + M + T * (C + 1), R = l + (M + 1) + T * (C + 1),
                        P = l + (M + 1) + T * C;
                    c.push(O, w, P, w, R, P)
                }
                l += _
            }

            if (f("z", "y", "x", -1, -1, n, t, -e, a, o), f("z", "y", "x", 1, -1, n, t, e, a, o), f("x", "z", "y", 1, 1, e, n, -t, r, a), f("x", "z", "y", 1, -1, e, n, t, r, a), f("x", "y", "z", 1, -1, e, t, -n, r, o), f("x", "y", "z", -1, -1, e, t, n, r, o), s) {
                var m = c.length / 6, _ = w.create(p.length / 3, 0);
                _.setAttribute("POSITION", p), _.setAttribute("NORMAL", d), _.setAttribute("TEXCOORD_0", h);
                for (var g = 0; g < 6; ++g) _.addSubMesh(m, g), _.setIndices(c, g, m * g);
                return _
            }
            var v = w.create(p.length / 3, c.length);
            return v.setAttribute("POSITION", p), v.setAttribute("NORMAL", d), v.setAttribute("TEXCOORD_0", h), v.setIndices(c), v
        }, t.createFrustumCone = function (e, t, n, r, o, a, s, l, u) {
            void 0 === e && (e = .5), void 0 === t && (t = .5), void 0 === n && (n = 1), void 0 === r && (r = 10), void 0 === o && (o = 1), void 0 === a && (a = !1), void 0 === s && (s = 0), void 0 === l && (l = 6.283185307179586), void 0 === u && (u = !1);
            var c = 0, p = 0, d = n / 2, h = i.Vector3.create().release(), f = [], m = [], _ = [], g = [], v = [],
                y = [];

            function b(n) {
                var i, o, a = 0, u = n ? e : t, f = n ? 1 : -1;
                i = c;
                for (var b = 1; b <= r; b++) g.push(0, d * f, 0), v.push(0, f, 0), y.push(.5, .5), c++;
                o = c;
                for (b = 0; b <= r; b++) {
                    var x = b / r * l + s, T = Math.cos(x), E = Math.sin(x);
                    h.x = u * E, h.y = d * f, h.z = -u * T, g.push(h.x, h.y, h.z), v.push(0, f, 0), y.push(.5 * E * f + .5, .5 * T + .5), c++
                }
                for (b = 0; b < r; b++) {
                    var C = i + b, S = o + b;
                    !0 === n ? _.push(S, S + 1, C) : _.push(S + 1, S, C), a += 3
                }
                m.push(p, a, !0 === n ? 1 : 2), p += a
            }

            if (function () {
                for (var i = 0, a = (t - e) / n, u = 0; u <= o; u++) {
                    for (var b = [], x = u / o, T = x * (t - e) + e, E = 0; E <= r; E++) {
                        var C = E / r, S = C * l + s, M = Math.sin(S), A = Math.cos(S);
                        h.x = T * M, h.y = -x * n + d, h.z = -T * A, g.push(h.x, h.y, h.z), h.set(M, a, A).normalize(), v.push(h.x, h.y, -h.z), y.push(C, x), b.push(c++)
                    }
                    f.push(b)
                }
                for (E = 0; E < r; E++) for (u = 0; u < o; u++) {
                    var O = f[u][E], w = f[u + 1][E], R = f[u + 1][E + 1], P = f[u][E + 1];
                    _.push(O, w, P, w, R, P), i += 6
                }
                m.push(p, i, 0), p += i
            }(), a || (e > 0 && b(!0), t > 0 && b(!1)), u) {
                var x = w.create(g.length / 3, 0);
                x.setAttribute("POSITION", g), x.setAttribute("NORMAL", v), x.setAttribute("TEXCOORD_0", y);
                for (var T = 0; T < m.length; T += 3) x.addSubMesh(m[1], m[2]), x.setIndices(_, T, m[0]);
                return x
            }
            var E = w.create(g.length / 3, _.length);
            return E.setAttribute("POSITION", g), E.setAttribute("NORMAL", v), E.setAttribute("TEXCOORD_0", y), E.setIndices(_), E
        }, t.createTorus = function (e, t, n, r, o, a) {
            void 0 === e && (e = .5), void 0 === t && (t = .1), void 0 === n && (n = 10), void 0 === r && (r = 10), void 0 === o && (o = 1), void 0 === a && (a = 3);
            for (var s = i.Vector3.create().release(), l = i.Vector3.create().release(), u = [], c = [], p = [], d = [], h = 0; h <= n; h++) for (var f = 0; f <= r; f++) {
                var m = f / r * 6.283185307179586 * o, _ = h / n * 6.283185307179586;
                switch (a) {
                    case 1:
                        s.x = t * Math.sin(_), s.y = (e + t * Math.cos(_)) * Math.cos(m), s.z = -(e + t * Math.cos(_)) * Math.sin(m);
                        break;
                    case 2:
                        s.x = (e + t * Math.cos(_)) * Math.cos(m), s.y = -t * Math.sin(_), s.z = -(e + t * Math.cos(_)) * Math.sin(m);
                        break;
                    case 3:
                        s.x = (e + t * Math.cos(_)) * Math.cos(m), s.y = (e + t * Math.cos(_)) * Math.sin(m), s.z = -t * Math.sin(_)
                }
                c.push(s.x, s.y, s.z), l.x = e * Math.cos(m), l.y = e * Math.sin(m), l.z = 0, l.subtract(s, l).normalize(), p.push(l.x, l.y, -l.z), d.push(f / r), d.push(h / n)
            }
            for (h = 1; h <= n; h++) for (f = 1; f <= r; f++) {
                var g = (r + 1) * h + f - 1, v = (r + 1) * (h - 1) + f - 1, y = (r + 1) * (h - 1) + f,
                    b = (r + 1) * h + f;
                u.push(g, v, b, v, y, b)
            }
            var x = w.create(c.length / 3, u.length, ["POSITION", "NORMAL", "TEXCOORD_0"]);
            return x.setAttribute("POSITION", c), x.setAttribute("NORMAL", p), x.setAttribute("TEXCOORD_0", d), x.setIndices(u), x
        }, t.createSphere = function (e, t, n, r, o, a, s) {
            void 0 === e && (e = .5), void 0 === t && (t = 10), void 0 === n && (n = 10), void 0 === r && (r = 0), void 0 === o && (o = 6.283185307179586), void 0 === a && (a = 0), void 0 === s && (s = 3.141592653589793), t = Math.max(3, t), n = Math.max(2, n);
            for (var l = 0, u = a + s, c = i.Vector3.create().release(), p = [], d = [], h = [], f = [], m = [], _ = 0; _ <= n; _++) {
                for (var g = _ / n, v = [], y = 0; y <= t; y++) {
                    var b = y / t, x = e * Math.sin(a + g * s);
                    c.x = -x * Math.cos(r + b * o), c.y = e * Math.cos(a + g * s), c.z = x * Math.sin(r + b * o), h.push(c.x, c.y, -c.z), c.normalize(), f.push(c.x, c.y, -c.z), m.push(b, g), v.push(l++)
                }
                p.push(v)
            }
            for (var T = 0; T < n; T++) for (var E = 0; E < t; E++) {
                var C = p[T][E + 1], S = p[T][E], M = p[T + 1][E], A = p[T + 1][E + 1];
                (0 !== T || a > 0) && d.push(C, S, A), (T !== n - 1 || u < 3.141592653589793) && d.push(S, M, A)
            }
            var O = w.create(h.length / 3, d.length, ["POSITION", "NORMAL", "TEXCOORD_0"]);
            return O.setAttribute("POSITION", h), O.setAttribute("NORMAL", f), O.setAttribute("TEXCOORD_0", m), O.setIndices(d), O
        }, t.createTorusKnot = function (e, t, n, r, o, a) {
            void 0 === e && (e = .5), void 0 === t && (t = .2), void 0 === n && (n = 64), void 0 === r && (r = 8), void 0 === o && (o = 2), void 0 === a && (a = 3);
            var s = i.Vector3.create().release(), l = i.Vector3.create().release(), u = i.Vector3.create().release(),
                c = i.Vector3.create().release(), p = i.Vector3.create().release(), d = i.Vector3.create().release(),
                h = i.Vector3.create().release(), f = [], m = [], _ = [], g = [];

            function v(e, t, n, r, i) {
                var o = Math.cos(e), a = Math.sin(e), s = n / t * e, l = Math.cos(s);
                i.x = r * (2 + l) * .5 * o, i.y = r * (2 + l) * a * .5, i.z = r * Math.sin(s) * .5
            }

            for (var y = 0; y <= n; ++y) {
                var b = y / n * o * 6.283185307179586;
                v(b, o, a, e, u), v(b + .01, o, a, e, c), d.subtract(c, u), h.add(c, u), p.cross(d, h), h.cross(p, d), p.normalize(), h.normalize();
                for (var x = 0; x <= r; ++x) {
                    var T = x / r * 6.283185307179586, E = -t * Math.cos(T), C = t * Math.sin(T);
                    s.x = u.x + (E * h.x + C * p.x), s.y = u.y + (E * h.y + C * p.y), s.z = u.z + (E * h.z + C * p.z), m.push(s.x, s.y, -s.z), l.subtract(s, u).normalize(), _.push(l.x, l.y, -l.z), g.push(y / n, x / r)
                }
            }
            for (x = 1; x <= n; x++) for (y = 1; y <= r; y++) {
                var S = (r + 1) * (x - 1) + (y - 1), M = (r + 1) * x + (y - 1), A = (r + 1) * x + y,
                    O = (r + 1) * (x - 1) + y;
                f.push(S, M, O, M, A, O)
            }
            var R = w.create(m.length / 3, f.length, ["POSITION", "NORMAL", "TEXCOORD_0"]);
            return R.setAttribute("POSITION", m), R.setAttribute("NORMAL", _), R.setAttribute("TEXCOORD_0", g), R.setIndices(f), R
        }, t.createCapsule = function (e, t, n, r, o, a, s, l, u, c, p, d) {
            void 0 === e && (e = .25), void 0 === t && (t = .5), void 0 === n && (n = 0), void 0 === r && (r = 0), void 0 === o && (o = 0), void 0 === a && (a = 10), void 0 === s && (s = 10), void 0 === l && (l = 1), void 0 === u && (u = 0), void 0 === c && (c = 6.283185307179586), void 0 === p && (p = 0), void 0 === d && (d = 3.141592653589793), s % 2 && s++, a = Math.max(3, a);
            for (var h = 0, f = (s = Math.max(2, s)) + (l ? 1 : 0), m = .5 * (s + 1), _ = p + d, g = i.Vector3.create().release(), v = [], y = [], b = [], x = [], T = [], E = 0; E <= f; E++) {
                var C = E / f, S = E < m ? E / s : (E - 1) / s, M = [];
                v.push(M);
                for (var A = 0; A <= a; A++) {
                    var O = A / a, R = e * Math.sin(p + C * d);
                    g.x = -R * Math.cos(u + O * c), g.z = R * Math.sin(u + O * c), g.y = e * Math.cos(p + S * d), E < m ? b.push(g.x + n, g.y + .5 * t + r, -g.z + o) : b.push(g.x + n, g.y - .5 * t + r, -g.z + o), g.normalize(), x.push(g.x, g.y, -g.z), T.push(O, C), M.push(h++)
                }
            }
            for (E = 0; E < f; E++) for (A = 0; A < a; A++) {
                var P = v[E][A + 1], L = v[E][A], D = v[E + 1][A], I = v[E + 1][A + 1];
                (0 !== E || p > 0) && y.push(P, L, I), (E !== f - 1 || _ < 3.141592653589793) && y.push(L, D, I)
            }
            var N = w.create(b.length / 3, y.length, ["POSITION", "NORMAL", "TEXCOORD_0"]);
            return N.setAttribute("POSITION", b), N.setAttribute("NORMAL", x), N.setAttribute("TEXCOORD_0", T), N.setIndices(y), N
        }, t
    }();
    __reflect(lt, "@egret/render/MeshCreater");
    var ut = function (e) {
        function t() {
            return null !== e && e.apply(this, arguments) || this
        }

        var n;
        return u(t, e), n = t, t.prototype._addToResources = function (e, t) {
            return t.entity.uri = e, a.ResourceManager.instance.addResource({
                uri: e,
                type: "mesh",
                status: "Ok",
                data: t
            }), t
        }, t.prototype.initialize = function (t, r) {
            e.prototype.initialize.call(this, t, r);
            var i = n, o = ["POSITION", "COLOR_0"];
            i.QUAD = this._addToResources("builtin/quad.mesh.bin", lt.createPlane()), i.PLANE = this._addToResources("builtin/plane.mesh.bin", lt.createPlane(10, 10)), i.SPRITE = this._addToResources("builtin/sprite.mesh.bin", lt.createPlane()), i.FULLSCREEN = this._addToResources("builtin/fullscreen.mesh.bin", lt.createPlane(2, 2)), i.POSTPROCESSING = this._addToResources("builtin/postprocessing.mesh.bin", lt.createPlane(2, 2));
            for (var a = i.POSTPROCESSING.getUVs(), s = 1, l = a.length; s < l; s += 2) a[s] = 1 - a[s];
            i.CUBE = this._addToResources("builtin/cube.mesh.bin", lt.createCube()), i.PYRAMID = this._addToResources("builtin/pyramid.mesh.bin", lt.createFrustumCone(0, Math.sqrt(.5), 1, 4, 1, !1, .7853981633974483)), i.CONE = this._addToResources("builtin/cone.mesh.bin", lt.createFrustumCone(0, .5, 1, 10, 1)), i.CYLINDER = this._addToResources("builtin/cylinder.mesh.bin", lt.createFrustumCone()), i.SPHERE = this._addToResources("builtin/sphere.mesh.bin", lt.createSphere(.5, 20, 20)), i.TORUS = this._addToResources("builtin/torus.mesh.bin", lt.createTorus());
            var u = w.create(4, 2, o);
            i.LINE_X = this._addToResources("builtin/line_x.mesh.bin", u), u.glTFMesh.primitives[0].mode = 1, u.setAttribute("POSITION", [0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0, 0]), u.setAttribute("COLOR_0", [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]), u.setIndices([0, 1], 0);
            u = w.create(4, 2, o);
            i.LINE_Y = this._addToResources("builtin/line_y.mesh.bin", u), u.glTFMesh.primitives[0].mode = 1, u.setAttribute("POSITION", [0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0]), u.setAttribute("COLOR_0", [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]), u.setIndices([0, 1], 0);
            u = w.create(4, 2, o);
            i.LINE_Z = this._addToResources("builtin/line_z.mesh.bin", u), u.glTFMesh.primitives[0].mode = 1, u.setAttribute("POSITION", [0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1]), u.setAttribute("COLOR_0", [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]), u.setIndices([0, 1], 0);
            u = this._addToResources("builtin/triangle.mesh.bin", w.create(3, 0, o));
            i.TRIANGLE = u, u.setAttribute("POSITION", [0, .5, 0, -.5, -.5, 0, .5, -.5, 0]), u.setAttribute("COLOR_0", [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1])
        }, t.QUAD = null, t.PLANE = null, t.SPRITE = null, t.FULLSCREEN = null, t.POSTPROCESSING = null, t.CUBE = null, t.PYRAMID = null, t.CONE = null, t.CYLINDER = null, t.SPHERE = null, t.TORUS = null, t.LINE_X = null, t.LINE_Y = null, t.LINE_Z = null, t.TRIANGLE = null, t = n = c([Object(a.hideFlag)(28), Object(r.component)({
            isRemovable: !1,
            isAbstract: !1
        })], t)
    }(r.Component);
    __reflect(ut, "@egret/render/DefaultMeshes");
    var ct = function (e) {
        function t() {
            var t = null !== e && e.apply(this, arguments) || this;
            return t.drawCallCount = 0, t._skyBox = null, t._postprocessing = null, t._drawCallss = {}, t
        }

        return u(t, e), Object.defineProperty(t.prototype, "skyBox", {
            get: function () {
                if (null === this._skyBox) {
                    var e = i.Application.instance.entityContext.createEntity().addComponent(ae);
                    e.enabled = !1, e.subMeshIndex = 0, this._skyBox = e
                }
                return this._skyBox
            }, enumerable: !0, configurable: !0
        }), Object.defineProperty(t.prototype, "postprocessing", {
            get: function () {
                if (null === this._postprocessing) {
                    var e = i.Application.instance.entityContext.createEntity().addComponent(ae);
                    e.enabled = !1, e.subMeshIndex = 0, e.mesh = ut.POSTPROCESSING, e.matrix = i.Matrix4.IDENTITY, this._postprocessing = e
                }
                return this._postprocessing
            }, enumerable: !0, configurable: !0
        }), t.prototype.createDrawCall = function (e) {
            var t = this._drawCallss;
            e in t || (t[e] = []);
            var n = t[e], r = i.Application.instance.entityContext.createEntity().addComponent(ae);
            return n[n.length] = r, r
        }, t.prototype.destroyDrawCall = function (e) {
            var t = this._drawCallss;
            if (!(e in t)) return !1;
            for (var n = t[e], r = n.length; r--;) n[r].entity.destroy();
            return n.length = 0, !0
        }, t = c([Object(a.hideFlag)(28), Object(r.component)({isRemovable: !1, isAbstract: !1})], t)
    }(r.Component);
    __reflect(ct, "@egret/render/DrawCallCollector");
    var pt = function (e) {
        function t() {
            var t = null !== e && e.apply(this, arguments) || this;
            return t.currentShadowLight = null, t.hasAnyCastShadow = !1, t.lights = [], t.directionalLights = [], t.spotLights = [], t.rectangleAreaLights = [], t.pointLights = [], t.hemisphereLights = [], t.directLightBuffer = new Float32Array(0), t.spotLightBuffer = new Float32Array(0), t.rectangleAreaLightBuffer = new Float32Array(0), t.pointLightBuffer = new Float32Array(0), t.hemisphereLightBuffer = new Float32Array(0), t.directShadowMatrix = new Float32Array(0), t.spotShadowMatrix = new Float32Array(0), t.pointShadowMatrix = new Float32Array(0), t.directShadowMaps = [], t.spotShadowMaps = [], t.pointShadowMaps = [], t
        }

        return u(t, e), t = c([Object(a.hideFlag)(28), Object(r.component)({isRemovable: !1, isAbstract: !1})], t)
    }(r.Component);
    __reflect(pt, "@egret/render/LightCollector");
    var dt = function (e) {
        function t() {
            var t = null !== e && e.apply(this, arguments) || this;
            return t.version = "", t.standardDerivativesEnabled = !1, t.textureFloatEnabled = !1, t.fragDepthEnabled = !1, t.sRGB = null, t.textureFilterAnisotropic = null, t.shaderTextureLOD = null, t.vertexArrayObject = null, t.instancedArrays = null, t.compressed_texture_astc = null, t.compressed_texture_s3tc = null, t.compressed_texture_etc1 = null, t.compressed_texture_pvrtc = null, t.maxVertexAttributes = 0, t.maxVertexUniformVectors = 0, t.maxFragmentUniformVectors = 0, t.maxVertexTextures = 0, t.maxTextures = 0, t.maxTextureSize = 0, t.maxCubemapSize = 0, t.maxRenderBufferize = 0, t.maxAnisotropy = 0, t.maxBoneCount = 0, t.maxVertexPrecision = "", t.maxFragmentPrecision = "", t.maxDirectionalLightCount = 0, t.maxSpotLightCount = 0, t.maxRectangleAreaLightCount = 0, t.maxPointLightCount = 0, t.maxHemisphereLightCount = 0, t.compressedTextureFormats = [], t.customUniformMap = {}, t.clockBuffer = new Float32Array(4), t.drawCallCollector = null, t.cameraCollector = null, t.lightCollector = null, t.caches = {
                useLightMap: !1,
                receiveShadows: !1,
                cullingMask: 0,
                boneCount: 0,
                subMeshIndex: -1,
                materialVerison: -1,
                lightmapIndex: -1,
                useMorph: !1,
                fogMode: -1,
                program: null,
                currentScene: null,
                defaultSceneLight: null,
                defaultFog: null,
                camera: null,
                light: null,
                mesh: null,
                material: null,
                skyBoxTexture: null,
                attributeCount: 0,
                stateEnables: {}
            }, t.render = null, t._depthMask = !0, t._clearDepth = 1, t._clearStencil = 1, t._viewport = i.Rectangle.create(), t._clearColor = i.Color.create(), t._colorMask = [!0, !0, !0, !0], t._renderTarget = null, t._logarithmicDepthBuffer = !1, t._gammaInput = !0, t._gammaOutput = !0, t._gpuInstancingEnable = !1, t._gammaFactor = 1, t._toneMapping = 0, t._shadowQuality = 0, t.premultipliedAlpha = !1, t.toneMappingExposure = 1, t.toneMappingWhitePoint = 1, t
        }

        return u(t, e), t.prototype._onChanged = function (e) {
            var t = this.entity.getOrAddComponent(ce);
            t.changes.indexOf(e) < 0 && t.changes.push(e)
        }, t.prototype._setViewport = function (e, t, n, r) {
            throw new Error("Method not implemented.")
        }, t.prototype._setColorMask = function (e, t, n, r) {
            throw new Error("Method not implemented.")
        }, t.prototype._setRenderTarget = function (e) {
            throw new Error("Method not implemented.")
        }, t.prototype._clearOnEnd = function () {
        }, t.prototype.initialize = function (t, n) {
            e.prototype.initialize.call(this, t, n), i.Application.instance.renderContext = this;
            this.drawCallCollector = this.entity.getComponent(ct), this.cameraCollector = this.entity.getComponent(it), this.lightCollector = this.entity.getComponent(pt), this._onChanged(0), this._onChanged(1), this._onChanged(2), this._onChanged(3)
        }, t.prototype.clearCache = function (e) {
            var t = this.caches;
            if (0 != (2 & e) && (t.attributeCount = 0, t.lightmapIndex = -1, t.program = null, t.currentScene = null, e |= 61), 0 != (1 & e)) for (var n in t.stateEnables) delete t.stateEnables[n];
            0 != (4 & e) && (t.camera = null), 0 != (8 & e) && (t.light = null), 0 != (16 & e) && (t.subMeshIndex = -1, t.mesh = null), 0 != (32 & e) && (t.materialVerison = -1, t.material = null), 0 != (64 & e) && (t.cullingMask = 0)
        }, t.prototype.clearBuffer = function (e) {
            throw new Error("Method not implemented.")
        }, t.prototype.copyFramebufferToTexture = function (e, t, n) {
            throw new Error("Method not implemented.")
        }, t.prototype.draw = function (e, t) {
            throw new Error("Method not implemented.")
        }, Object.defineProperty(t.prototype, "clearDepth", {
            get: function () {
                return this._clearDepth
            }, set: function (e) {
                this._clearDepth = e
            }, enumerable: !0, configurable: !0
        }), Object.defineProperty(t.prototype, "clearStencil", {
            get: function () {
                return this._clearStencil
            }, set: function (e) {
                this._clearStencil = e
            }, enumerable: !0, configurable: !0
        }), Object.defineProperty(t.prototype, "viewport", {
            get: function () {
                return this._viewport
            }, set: function (e) {
                this._viewport.copy(e);
                var t, n, r = this._renderTarget;
                if (null !== r) t = r.width, n = r.height; else {
                    var o = i.Application.instance.screen, a = o.useDevicePixelRatio, s = o.pixelRatio,
                        l = o.devicePixelRatio, u = i.Application.instance.stage.viewport, c = a ? l : s;
                    t = u.w * c, n = u.h * c
                }
                this._setViewport(t * e.x, n * (1 - e.y - e.h), t * e.w, n * e.h)
            }, enumerable: !0, configurable: !0
        }), Object.defineProperty(t.prototype, "clearColor", {
            get: function () {
                return this._clearColor
            }, set: function (e) {
                this.premultipliedAlpha ? this._clearColor.set(e.r * e.a, e.g * e.a, e.b * e.a, e.a) : this._clearColor.copy(e)
            }, enumerable: !0, configurable: !0
        }), Object.defineProperty(t.prototype, "colorMask", {
            get: function () {
                return this._colorMask
            }, set: function (e) {
                this._colorMask[0] = e[0], this._colorMask[1] = e[1], this._colorMask[2] = e[2], this._colorMask[3] = e[3], this._setColorMask(e[0], e[1], e[2], e[3])
            }, enumerable: !0, configurable: !0
        }), Object.defineProperty(t.prototype, "renderTarget", {
            get: function () {
                return this._renderTarget
            }, set: function (e) {
                this._renderTarget = e, this._setRenderTarget(e)
            }, enumerable: !0, configurable: !0
        }), Object.defineProperty(t.prototype, "gpuInstancingEnable", {
            get: function () {
                return this._gpuInstancingEnable
            }, set: function (e) {
                this._gpuInstancingEnable !== e && (null !== this.instancedArrays ? (this._gpuInstancingEnable = e, this._onChanged(5)) : console.warn("The current platform does not support ANGLE_instanced_arrays extension."))
            }, enumerable: !0, configurable: !0
        }), Object.defineProperty(t.prototype, "logarithmicDepthBuffer", {
            get: function () {
                return this._logarithmicDepthBuffer
            }, set: function (e) {
                this._logarithmicDepthBuffer !== e && (this._logarithmicDepthBuffer = e, this._onChanged(4))
            }, enumerable: !0, configurable: !0
        }), Object.defineProperty(t.prototype, "gammaInput", {
            get: function () {
                return this._gammaInput
            }, set: function (e) {
                this._gammaInput !== e && (this._gammaInput = e, this._onChanged(0))
            }, enumerable: !0, configurable: !0
        }), Object.defineProperty(t.prototype, "gammaOutput", {
            get: function () {
                return this._gammaOutput
            }, set: function (e) {
                this._gammaOutput !== e && (this._gammaOutput = e, this._onChanged(1))
            }, enumerable: !0, configurable: !0
        }), Object.defineProperty(t.prototype, "gammaFactor", {
            get: function () {
                return this._gammaFactor
            }, set: function (e) {
                (e != e || e < 1) && (e = 1), this._gammaFactor !== e && (this._gammaFactor = e, this._onChanged(2))
            }, enumerable: !0, configurable: !0
        }), Object.defineProperty(t.prototype, "toneMapping", {
            get: function () {
                return this._toneMapping
            }, set: function (e) {
                this._toneMapping !== e && (this._toneMapping = e, this._onChanged(3))
            }, enumerable: !0, configurable: !0
        }), Object.defineProperty(t.prototype, "shadowQuality", {
            get: function () {
                return this._shadowQuality
            }, set: function (e) {
                this._shadowQuality !== e && (this._shadowQuality = e, this._onChanged(6))
            }, enumerable: !0, configurable: !0
        }), c([Object(a.property)("boolean"), a.serializedField], t.prototype, "gpuInstancingEnable", null), c([Object(a.property)("boolean"), a.serializedField], t.prototype, "logarithmicDepthBuffer", null), c([Object(a.property)("boolean"), a.serializedField], t.prototype, "gammaInput", null), c([Object(a.property)("boolean"), a.serializedField], t.prototype, "gammaOutput", null), c([Object(a.property)("float", {step: .1}), a.serializedField], t.prototype, "gammaFactor", null), c([Object(a.property)("enum", {listItems: Object(a.getItemsFromEnum)(Le)}), a.serializedField], t.prototype, "toneMapping", null), c([Object(a.property)("enum", {listItems: Object(a.getItemsFromEnum)(be)}), a.serializedField], t.prototype, "shadowQuality", null), c([Object(a.property)("boolean"), a.serializedField], t.prototype, "premultipliedAlpha", void 0), c([Object(a.property)("float", {
            minimum: 0,
            maximum: 10
        }), a.serializedField], t.prototype, "toneMappingExposure", void 0), c([Object(a.property)("float", {
            minimum: 0,
            maximum: 10
        }), a.serializedField], t.prototype, "toneMappingWhitePoint", void 0), t = c([Object(a.hideFlag)(16), Object(r.component)({
            isRemovable: !1,
            requireComponents: [v, rt, g, ct, it, pt],
            isAbstract: !1
        })], t)
    }(r.Component);
    __reflect(dt, "@egret/render/RenderContext");
    var ht = function (e) {
        function t() {
            var t = null !== e && e.apply(this, arguments) || this;
            return t.mesh = null, t.materials = [], t
        }

        return u(t, e), t.prototype.uninitialize = function () {
            e.prototype.uninitialize.call(this), null !== this.mesh && this.mesh.entity.destroy();
            this.mesh = null, this.materials.length = 0
        }, t = c([Object(a.hideFlag)(20), Object(r.component)({isAbstract: !1})], t)
    }(r.Component);
    __reflect(ht, "@egret/render/CombineMeshRenderer");
    var ft = function (e) {
        function t() {
            return null !== e && e.apply(this, arguments) || this
        }

        return u(t, e), t = c([Object(a.hideFlag)(20), Object(r.component)({isAbstract: !1})], t)
    }(r.Component);
    __reflect(ft, "@egret/render/CombineMeshElement");
    var mt = i.Vector3.create(), _t = i.Matrix4.create(), gt = [], vt = 0, yt = function (e) {
        function t() {
            var t = null !== e && e.apply(this, arguments) || this;
            return t.verticesCount = 0, t.indicesCount = 0, t.lightmapIndex = -1, t.primitiveIndices = [], t.meshAttribute = {}, t.root = null, t.materials = [], t.instances = [], t
        }

        return u(t, e), t
    }(DebuggerClass);
    __reflect(yt, "@egret/render/CombineInstance");
    var bt = function (e) {
        function t() {
            return null !== e && e.apply(this, arguments) || this
        }

        return u(t, e), t._copyAccessorBuffer = function (e, t, n, r) {
            for (var i = e.createTypeArrayFromAccessor(e.getAccessor(t)), o = i.length, a = 0; a < o; a++) n[r + a] = i[a]
        }, t._fillBuffer = function (e, t, n, r) {
            for (var i = r.length, o = 0; o < n; o++) for (var a = 0; a < i; a++) e[t++] = r[a]
        }, t._colletCombineInstance = function (e, t, n) {
            if (!(gt.indexOf(e.uuid) >= 0)) {
                gt.push(e.uuid);
                for (var r = 0, i = e.node.children; r < i.length; r++) {
                    var o = i[r];
                    o && this._colletCombineInstance(o.entity, t, n)
                }
                var a = e.getComponent(Je), s = e.getComponent($e);
                if (null === e.getComponent(ht) && null === e.getComponent(ft) && s && s.isStatic && s.materials && !(s.materials.length < 1) && a && a.mesh) {
                    vt++;
                    var l = s.materials, u = a.mesh, c = e.node.layer + "_" + s.lightmapIndex + "_";
                    l.forEach((function (e) {
                        c = c + "_" + e.uuid
                    })), t[c] || (t[c] = [], t[c].push(new yt));
                    var p = t[c], d = p[p.length - 1];
                    if (d.verticesCount + u.vertexCount > 5e4 && (d = new yt, t[c].push(d)), null === d.root) {
                        d.root = n || e, d.lightmapIndex = s.lightmapIndex;
                        for (var h = 0, f = l; h < f.length; h++) {
                            var m = f[h];
                            d.materials.push(m)
                        }
                    }
                    for (var _ = u.glTFMesh.primitives, g = 0; g < _.length; g++) {
                        for (var v in _[g].attributes) {
                            var y = v;
                            d.meshAttribute[y] || (d.meshAttribute[y] = y)
                        }
                        d.primitiveIndices[g] || (d.primitiveIndices[g] = 0);
                        var b = u.getIndices(g).length;
                        d.primitiveIndices[g] += b, d.indicesCount += b
                    }
                    d.verticesCount += u.vertexCount, d.instances.push(e)
                }
            }
        }, t._combineInstance = function (e) {
            var t = this._combineMesh(e), n = e.root;
            n.removeComponent(ft);
            var r = n.getOrAddComponent(ht);
            r.mesh = t, r.materials = e.materials
        }, t._combineMesh = function (e) {
            var t = e.root, n = e.meshAttribute, r = t.getComponent($e).lightmapScaleOffset, i = [];
            for (var o in n) i.push(o);
            var a = e.primitiveIndices, s = w.create(e.verticesCount, a[0], i);
            s.drawMode = 35048;
            for (var l = 1, u = a.length; l < u; l++) {
                var c = a[l];
                s.addSubMesh(c, l)
            }
            var p = s.getVertices(), d = s.getNormals(), h = s.getUVs(), f = s.getAttribute("TEXCOORD_1"),
                m = s.getColors(), _ = s.getAttribute("JOINTS_0"), g = s.getAttribute("WEIGHTS_0");
            _t.copy(t.transform.worldToLocalMatrix);
            for (var v = 0, y = 0, b = 0, x = 0, T = 0, E = 0, C = 0, S = 0, M = 0, A = 0, O = 0, R = 0, P = e.instances; R < P.length; R++) {
                var L = P[R], D = L.getComponent(Je), I = L.getComponent($e), N = L.transform.localToWorldMatrix,
                    z = D.mesh, U = I.lightmapScaleOffset, F = z.glTFMesh.primitives, k = !0;
                for (l = 0; l < F.length; l++) {
                    var V = F[l];
                    if (k) {
                        k = !1;
                        var B = z.vertexCount, G = F[l].attributes,
                            j = z.createTypeArrayFromAccessor(z.getAccessor(G.POSITION)), H = 0;
                        for (u = j.length; H < u; H += 3) mt.fromArray(j, H).applyMatrix(N).applyMatrix(_t), p[v++] = mt.x, p[v++] = mt.y, p[v++] = mt.z;
                        if (n.NORMAL) if (void 0 !== G.NORMAL) {
                            var W = z.createTypeArrayFromAccessor(z.getAccessor(G.NORMAL));
                            for (H = 0, u = W.length; H < u; H += 3) mt.fromArray(W, H).applyDirection(N).applyDirection(_t), d[y++] = mt.x, d[y++] = mt.y, d[y++] = mt.z
                        } else this._fillBuffer(d, y, B, [0, 0, 0]), y += 3 * B;
                        if (n.TEXCOORD_0 && (void 0 !== G.TEXCOORD_0 ? this._copyAccessorBuffer(z, G.TEXCOORD_0, h, T) : this._fillBuffer(h, T, B, [0, 0]), T += 2 * B), n.TEXCOORD_1) if (e.lightmapIndex >= 0) {
                            var X = void 0 !== G.TEXCOORD_1 ? z.getAccessor(G.TEXCOORD_1) : z.getAccessor(G.TEXCOORD_0),
                                Y = z.createTypeArrayFromAccessor(X);
                            for (H = 0, u = Y.length; H < u; H += 2) {
                                var q = Y[H + 0], Z = Y[H + 1];
                                q = (q * U.x + U.z - r.z) / r.x, Z = (Z * U.y - U.y - U.w + r.w + r.x) / r.x, f[E++] = q, f[E++] = Z
                            }
                        } else void 0 !== G.TEXCOORD_1 ? this._copyAccessorBuffer(z, G.TEXCOORD_1, f, E) : this._fillBuffer(f, E, B, [0, 0]), E += 2 * B;
                        n.COLOR_0 && (void 0 !== G.COLOR_0 ? this._copyAccessorBuffer(z, G.COLOR_0, m, b) : this._fillBuffer(m, b, B, [1, 1, 1, 1]), b += 4 * B), n.COLOR_1 && (void 0 !== G.COLOR_1 ? this._copyAccessorBuffer(z, G.COLOR_1, m, x) : this._fillBuffer(m, x, B, [1, 1, 1, 1]), x += 4 * B), n.JOINTS_0 && (void 0 !== G.JOINTS_0 ? this._copyAccessorBuffer(z, G.JOINTS_0, _, C) : this._fillBuffer(_, C, B, [0, 0, 0, 0]), C += 4 * B), n.WEIGHTS_0 && (void 0 !== G.WEIGHTS_0 ? this._copyAccessorBuffer(z, G.WEIGHTS_0, g, S) : this._fillBuffer(g, S, B, [1, 0, 0, 0]), S += 4 * B)
                    }
                    var K = s.getIndices(l), Q = z.createTypeArrayFromAccessor(z.getAccessor(V.indices));
                    for (H = 0, u = Q.length; H < u; H++) {
                        var J = Q[H] + A;
                        K[M++] = J, O = J > O ? J : O
                    }
                }
                A = O + 1, L !== e.root && L.addComponent(ft)
            }
            return s
        }, t.combineScene = function (e) {
            this.combine([e.root.entity])
        }, t.combine = function (e) {
            gt.length = 0, vt = 0;
            for (var t = {}, n = 0, r = e; n < r.length; n++) {
                var i = r[n];
                this._colletCombineInstance(i, t)
            }
            var o = 0;
            for (var a in t) for (var s = 0, l = t[a]; s < l.length; s++) {
                var u = l[s];
                this._combineInstance(u), o++
            }
            console.log("combine", vt, "to", o, "save", vt - o), gt.length = 0
        }, t
    }(DebuggerClass);
    __reflect(bt, "@egret/render/StaticBatchingUtil");
    var xt = function (e) {
        function t() {
            return null !== e && e.apply(this, arguments) || this
        }

        return u(t, e), t.prototype._loadAssets = function (e, t) {
            return Promise.all(e.map((function (e) {
                return t.loadUri(e)
            })))
        }, t.prototype.load = function (e, t, n) {
            return p(this, void 0, void 0, (function () {
                var r, i, o, s, l, u, c, p, h, f;
                return d(this, (function (d) {
                    switch (d.label) {
                        case 0:
                            return d.trys.push([0, 2, , 3]), [4, t.loadResouceData(e, "json", n)];
                        case 1:
                            return r = d.sent(), [3, 3];
                        case 2:
                            return d.sent(), console.error("Load resource error.", e), [2, ee.MISSING];
                        case 3:
                            if (i = r.materials[0], o = r.extensions.egret.assets.concat(), s = i.extensions.KHR_techniques_webgl.values, l = [], void 0 !== s) for (h in s) "string" == typeof (u = s[h]) && (l.push(h), o.push(u));
                            return [4, this._loadAssets(o, t)];
                        case 4:
                            for (d.sent(), c = 0, p = l; c < p.length; c++) h = p[c], s[h] = a.ResourceManager.instance.getResource(s[h]);
                            return (f = S.fromGLTF(r)).entity.subResources = o, [2, f]
                    }
                }))
            }))
        }, t
    }(DebuggerClass);
    __reflect(xt, "@egret/render/MaterialLoader");
    var Tt, Et = function (e) {
        function t() {
            return null !== e && e.apply(this, arguments) || this
        }

        return u(t, e), t.prototype.load = function (e, t, n) {
            return p(this, void 0, void 0, (function () {
                var r, i;
                return d(this, (function (o) {
                    switch (o.label) {
                        case 0:
                            return [4, t.loadResouceData(e, "binary", n)];
                        case 1:
                            return null === (r = o.sent()) ? (console.error("Load resource error.", e), [2, ut.CUBE]) : null === (i = w.fromGLB(r instanceof ArrayBuffer ? new Uint32Array(r) : r)) ? [2, ut.CUBE] : [2, i]
                    }
                }))
            }))
        }, t
    }(DebuggerClass);
    __reflect(Et, "@egret/render/MeshLoader"), function (e) {
        e.VERTEX = "#VERTEX", e.FRAGMENT = "#FRAGMENT"
    }(Tt || (Tt = {}));
    var Ct = function (e) {
        function t() {
            return null !== e && e.apply(this, arguments) || this
        }

        return u(t, e), t.prototype._loadAssets = function (e, t) {
            return p(this, void 0, void 0, (function () {
                return d(this, (function (n) {
                    return [2, Promise.all(e.map((function (e) {
                        return t.loadUri(e)
                    })))]
                }))
            }))
        }, t.prototype.load = function (e, t, n) {
            return p(this, void 0, void 0, (function () {
                var r, i, o, a, s, l, u, c, p, h, f, _, g;
                return d(this, (function (d) {
                    switch (d.label) {
                        case 0:
                            return [4, t.loadResouceData(e, "json", n)];
                        case 1:
                            if (null === (r = d.sent())) return console.error("Load resource error.", e), [2, $.MESH_NORMAL];
                            for (i = r.extensions.KHR_techniques_webgl.shaders, o = [], a = 0, s = i; a < s.length; a++) l = s[a], o.indexOf(l.uri) < 0 && o.push(l.uri);
                            return [4, this._loadAssets(o, t)];
                        case 2:
                            if (u = d.sent(), (c = (v = u[0].data, v.replace(/\r/g, "\n").replace(/\t/g, "    ").replace(/[ \t]*\/\/.*\n/g, "\n").replace(/[ \t]*\/\*[\s\S]*?\*\//g, "\n").replace(/\n{2,}/g, "\n")).split("#VERTEX")[1].split("#FRAGMENT")).length !== i.length) return console.error("Invalid shader.", e), [2, $.MESH_NORMAL];
                            for (p = 0, h = i.length; p < h; ++p) {
                                for (f = (f = c[p].trim().split("\n")).slice(1, f.length - 1), _ = 0, g = f.length; _ < g; ++_) f[_] = f[_].replace("    ", "");
                                i[p].extras = {data: f.join("\n"), programs: {}}
                            }
                            return [2, m.fromGLTF(r)]
                    }
                    var v
                }))
            }))
        }, t
    }(DebuggerClass);
    __reflect(Ct, "@egret/render/ShaderLoader");
    var St = function (e) {
        function t() {
            return null !== e && e.apply(this, arguments) || this
        }

        return u(t, e), t.prototype._loadAssets = function (e, t) {
            return Promise.all(e.map((function (e) {
                return t.loadUri(e)
            })))
        }, t.prototype._getSource = function (e) {
            var t = i.Application.instance.renderContext.compressedTextureFormats, n = e.textures[0],
                r = n.extensions.egret;
            if (void 0 !== r.compression) for (var o = 0, a = r.compression; o < a.length; o++) {
                var s = a[o], l = s.internalFormat, u = s.source;
                if (t.indexOf(l) > -1) return u
            }
            return n.source
        }, t.prototype.load = function (e, t, n) {
            return p(this, void 0, void 0, (function () {
                var r, i, o, a, s, l, u, c, p, h, f, m, _, g, v, y, b;
                return d(this, (function (d) {
                    switch (d.label) {
                        case 0:
                            return d.trys.push([0, 2, , 3]), [4, t.loadResouceData(e, "json", n)];
                        case 1:
                            return r = d.sent(), [3, 3];
                        case 2:
                            return d.sent(), console.error("Load resource error.", e), [2, I.MISSING];
                        case 3:
                            return i = this._getSource(r), void 0 === (o = r.images[i]).uri ? (console.error("GLTF data error.", e), [2, I.MISSING]) : (a = Array.isArray(o.uri) ? o.uri : [o.uri], [4, this._loadAssets(a, t)]);
                        case 4:
                            if (s = d.sent(), a.length > 1) for (f = 0, m = a.length; f < m; f++) if (c = s[f].data, Array.isArray(c.source)) for (p = c.source, void 0 === r.buffers && (r.buffers = []), void 0 === r.bufferViews && (r.bufferViews = []), h = o.bufferView, void 0 === o.bufferView && (h = o.bufferView = []), l = 0, u = p.length; l < u; l++) _ = p[l], r.buffers[l] = {
                                byteLength: _.byteLength,
                                extras: {data: _}
                            }, r.bufferViews[l] = {
                                buffer: l,
                                byteLength: _.byteLength
                            }, h.push(l); else void 0 === o.extras && (o.extras = {data: []}), o.extras.data[f] = c.source; else if (c = s[0].data, Array.isArray(c.source)) for (p = c.source, void 0 === r.buffers && (r.buffers = []), void 0 === r.bufferViews && (r.bufferViews = []), h = o.bufferView, void 0 === o.bufferView && (h = o.bufferView = []), f = 0, m = p.length; f < m; f++) _ = p[f], r.buffers[f] = {
                                byteLength: _.byteLength,
                                extras: {data: _}
                            }, r.bufferViews[f] = {
                                buffer: f,
                                byteLength: _.byteLength
                            }, h.push(f); else o.extras = {data: c.source};
                            return g = s[0].data, v = r.textures[0], y = v.extensions.egret, v.extras = {
                                currentSource: i,
                                isCompressed: g.isCompressed || !1,
                                internalFormat: g.internalFormat
                            }, void 0 !== g && (void 0 === y.width && (y.width = g.width), void 0 === y.height && (y.height = g.height), void 0 === y.depth && (y.depth = g.depth), void 0 === y.format && (y.format = g.format)), (b = R.fromGLTF(r)).entity.subResources = a, [2, b]
                    }
                }))
            }))
        }, t
    }(DebuggerClass);
    __reflect(St, "@egret/render/TextureLoader");
    var Mt = function (e) {
        function t() {
            return null !== e && e.apply(this, arguments) || this
        }

        return u(t, e), t.prototype._onStageResize = function () {
            for (var e = i.Application.instance.stage.viewport, t = e.w, n = e.h, r = 0, o = this.groups[0].entities; r < o.length; r++) {
                var a = o[r].getComponent(L), s = a._readRenderTarget, l = a._writeRenderTarget;
                null !== s && s.setSize(t, n), null !== l && l.setSize(t, n), a.needUpdate(32)
            }
        }, t.prototype._onTransformChanged = function (e) {
            e.entity.getComponent(L).worldToCameraMatrix = e.worldToLocalMatrix
        }, t.prototype.getMatchers = function () {
            var e;
            return [r.Matcher.create(i.GameEntity, !1, i.Transform, L), (e = r.Matcher.create(i.GameEntity, !0)).anyOf.apply(e, Object(r.getComponentsByType)("camera"))]
        }, t.prototype.onAwake = function () {
            this.collectors[0].reactiveType = 6
        }, t.prototype.onEnable = function () {
            i.Application.instance.stage.onResize.add(this._onStageResize, this)
        }, t.prototype.onEntityRemoved = function (e, t) {
            var n = this.groups;
            t === n[0] ? e.getComponent(i.Transform).onChanged.remove(this._onTransformChanged, this) : t === n[1] && i.Application.instance.globalEntity.getComponent(dt).cameraCollector.updateCameras(t.entities)
        }, t.prototype.onEntityAdded = function (e, t) {
            var n = this.groups;
            t === n[0] ? e.getComponent(i.Transform).onChanged.add(this._onTransformChanged, this) : t === n[1] && i.Application.instance.globalEntity.getComponent(dt).cameraCollector.updateCameras(t.entities)
        }, t.prototype.onDisable = function () {
            i.Application.instance.stage.onResize.remove(this._onStageResize, this)
        }, t = c([Object(r.system)({noneOfExecuteMode: 32})], t)
    }(r.System);
    __reflect(Mt, "@egret/render/CameraSystem");
    var At = function (e) {
        function t() {
            return null !== e && e.apply(this, arguments) || this
        }

        return u(t, e), t.prototype._sortLights = function (e, t) {
            return (null !== t.entity.getComponent(qe) ? 1 : 0) - (null !== e.entity.getComponent(qe) ? 1 : 0)
        }, t.prototype._updateLightBuffer = function (e) {
            var t = i.Application.instance.globalEntity.getComponent(dt).lightCollector, n = t.directionalLights,
                r = t.spotLights, o = t.rectangleAreaLights, a = t.pointLights, s = t.hemisphereLights,
                l = t.directLightBuffer, u = t.spotLightBuffer, c = t.pointLightBuffer, p = t.rectangleAreaLightBuffer,
                d = t.hemisphereLightBuffer, h = e.getComponentByType("light"), f = 0, m = null;
            switch (h.lightType) {
                case 0:
                    f = 43 * n.indexOf(h) + 11, m = l;
                    break;
                case 1:
                    f = 50 * r.indexOf(h) + 18, m = u;
                    break;
                case 2:
                    f = 44 * o.indexOf(h) + 12, m = p;
                    break;
                case 3:
                    f = 47 * a.indexOf(h) + 15, m = c;
                    break;
                case 4:
                    f = 41 * s.indexOf(h) + 9, m = d;
                    break;
                default:
                    console.warn(":" + h.lightType)
            }
            if (null !== m) for (var _ = h.cullingMask, g = 0; g < 32; ++g) {
                var v = 1 << g;
                m[f + g] = 0 == (_ & v) ? 0 : 1
            }
        }, t.prototype._updateLightCollector = function (e) {
            for (var t = i.Application.instance.globalEntity.getComponent(dt), n = t.lightCollector, r = n.lights, o = n.directionalLights, a = n.spotLights, s = n.rectangleAreaLights, l = n.pointLights, u = n.hemisphereLights, c = 0, p = 0, d = 0, h = 0, f = 0, m = 0, _ = 0, g = e; _ < g.length; _++) {
                var y = (A = g[_]).getComponentByType("light");
                switch (r[c++] = y, y.lightType) {
                    case 0:
                        o[p++] = y;
                        break;
                    case 1:
                        a[d++] = y;
                        break;
                    case 2:
                        s[h++] = y;
                        break;
                    case 3:
                        l[f++] = y;
                        break;
                    case 4:
                        u[m++] = y
                }
            }
            var b = t.maxDirectionalLightCount, x = t.maxSpotLightCount, T = t.maxRectangleAreaLightCount,
                E = t.maxPointLightCount, C = t.maxHemisphereLightCount;
            p > b && console.warn(":" + b), d > x && console.warn(":" + x), h > T && console.warn(":" + T), f > E && console.warn(":" + E), m > C && console.warn(":" + C), r.length = c, o.length = p, a.length = d, s.length = h, l.length = f, u.length = m, o.sort(this._sortLights), a.sort(this._sortLights), l.sort(this._sortLights), n.directLightBuffer = new Float32Array(43 * p), n.spotLightBuffer = new Float32Array(50 * d), n.pointLightBuffer = new Float32Array(47 * f), n.rectangleAreaLightBuffer = new Float32Array(44 * h), n.hemisphereLightBuffer = new Float32Array(41 * m), n.directShadowMatrix = new Float32Array(16 * p), n.spotShadowMatrix = new Float32Array(16 * d), n.pointShadowMatrix = new Float32Array(16 * f), n.directShadowMaps.length = p, n.spotShadowMaps.length = d, n.pointShadowMaps.length = f;
            for (var S = 0, M = e; S < M.length; S++) {
                var A = M[S];
                this._updateLightBuffer(A)
            }
            var O = t.entity.getComponent(v);
            p > 0 ? O.addDefine("NUM_DIR_LIGHTS", p) : O.removeDefine("NUM_DIR_LIGHTS"), d > 0 ? O.addDefine("NUM_SPOT_LIGHTS", d) : O.removeDefine("NUM_SPOT_LIGHTS"), h > 0 ? O.addDefine("NUM_RECT_AREA_LIGHTS", h) : O.removeDefine("NUM_RECT_AREA_LIGHTS"), f > 0 ? O.addDefine("NUM_POINT_LIGHTS", f) : O.removeDefine("NUM_POINT_LIGHTS"), m > 0 ? O.addDefine("NUM_HEMI_LIGHTS", m) : O.removeDefine("NUM_HEMI_LIGHTS")
        }, t.prototype.getMatchers = function () {
            var e, t, n = Object(r.getComponentsByType)("light");
            return [(e = r.Matcher.create(i.GameEntity, !0, i.Transform)).anyOf.apply(e, n), (t = r.Matcher.create(i.GameEntity, !0, i.Transform, he)).anyOf.apply(t, n)]
        }, t.prototype.onEntityRemoved = function (e, t) {
            t === this.groups[0] && this._updateLightCollector(t.entities)
        }, t.prototype.onEntityAdded = function (e, t) {
            var n = this.groups;
            if (t === n[0]) this._updateLightCollector(t.entities); else if (t === n[1]) {
                this._updateLightBuffer(e);
                var r = e.getComponent(he);
                null !== r && e.removeComponent(r)
            }
        }, t = c([Object(r.system)({noneOfExecuteMode: 32})], t)
    }(r.System);
    __reflect(At, "@egret/render/LightSystem");
    var Ot = function (e) {
        function t() {
            var t = null !== e && e.apply(this, arguments) || this;
            return t._drawCallCollector = i.Application.instance.globalEntity.getComponent(ct), t._materialFilter = [], t
        }

        return u(t, e), t.prototype._updateDrawCalls = function (e) {
            var t = this._drawCallCollector, n = this._materialFilter, r = e.getComponent(ht),
                o = (null !== r ? r : e.getComponent(Je)).mesh, a = e.getComponent($e),
                s = (null !== r ? r : a).materials, l = s.length;
            if (t.destroyDrawCall(e.uuid), null !== o && 0 !== l && null === e.getComponent(ft)) {
                var u = o.glTFMesh.primitives, c = u.length;
                if (0 === c) throw new Error;
                var p = o.glTFMesh.weights;
                if (void 0 !== p) {
                    null === a.weight && (a.weight = new Float32Array(8));
                    for (var d = 0, h = p.length; d < h; ++d) a.weight[d] = p[d]
                }
                var f = e.getComponent(i.Transform).localToWorldMatrix;
                n.length < l && (n.length = l), null !== r && (a.localBoundingBox = o.boundingBox);
                for (d = 0; d < c; ++d) {
                    var m = u[d].material || 0, _ = null;
                    if (m < l && (_ = s[m], n[m] = !0), null !== _) (v = t.createDrawCall(e.uuid)).subMeshIndex = d, v.mesh = o, v.material = _, v.matrix = f, v.renderer = a
                }
                for (d = 0, h = n.length; d < h; ++d) if (n[d]) n[d] = !1; else {
                    if (d >= l) break;
                    _ = s[d];
                    for (var g = 0; g < c; ++g) {
                        var v;
                        (v = t.createDrawCall(e.uuid)).subMeshIndex = g, v.mesh = o, v.material = _, v.matrix = f, v.renderer = a
                    }
                }
            }
        }, t.prototype.getMatchers = function () {
            return [r.Matcher.create(i.GameEntity, !0, i.Transform, Je, $e).noneOf(ft), r.Matcher.create(i.GameEntity, !0, i.Transform, ht), r.Matcher.create(i.GameEntity, !0, i.Transform, Je, $e).anyOf(pe, de)]
        }, t.prototype.onEntityRemoved = function (e, t) {
            var n = this.groups;
            (t === n[0] || t === n[1]) && this._drawCallCollector.destroyDrawCall(e.uuid)
        }, t.prototype.onEntityAdded = function (e, t) {
            var n = this.groups;
            if (t === n[0]) this._updateDrawCalls(e); else if (t === n[1]) this._updateDrawCalls(e); else if (t === n[2]) {
                null === e.getComponent(ft) && this._updateDrawCalls(e);
                var r = e.getComponent(pe), i = e.getComponent(de);
                null !== r && e.removeComponent(r), null !== i && e.removeComponent(i)
            }
        }, t.prototype.onFrame = function () {
            for (var e = 0, t = this.groups[0].entities; e < t.length; e++) {
                t[e].transform.localToWorldMatrix
            }
        }, t = c([Object(r.system)({noneOfExecuteMode: 32})], t)
    }(r.System);
    __reflect(Ot, "@egret/render/MeshRendererSystem");
    var wt = function (e) {
        function t() {
            var t = null !== e && e.apply(this, arguments) || this;
            return t._combineModelMats = [], t._combineModelViewMats = [], t._postprocessings = [], t._renderTargets = {}, t._renderContext = null, t
        }

        var n;
        return u(t, e), n = t, t.prototype._onRenderContextChanged = function (e) {
            var t = this._renderContext, n = t.entity.getComponent(v), r = e.getComponent(ce);
            if (null !== r) {
                for (var i = 0, o = r.changes; i < o.length; i++) {
                    switch (o[i]) {
                        case 0:
                            E.updateTextureDefines(n, "envMap", t.caches.skyBoxTexture, t.gammaInput);
                            for (var a = 0, s = this.groups[1].entities; a < s.length; a++) {
                                s[a].getComponent(S)._addOrRemoveTexturesDefine()
                            }
                            break;
                        case 1:
                            E.updateTexelEncoding(n, t.gammaOutput);
                            break;
                        case 2:
                            n.addDefine("GAMMA_FACTOR", t.gammaFactor, "", 1, 3, 2);
                            break;
                        case 3:
                            E.updateToneMapping(n, t.toneMapping);
                            break;
                        case 4:
                            t.logarithmicDepthBuffer ? (n.addDefine("USE_LOGDEPTHBUF"), t.fragDepthEnabled ? n.addDefine("USE_LOGDEPTHBUF_EXT") : n.removeDefine("USE_LOGDEPTHBUF_EXT")) : (n.removeDefine("USE_LOGDEPTHBUF"), n.removeDefine("USE_LOGDEPTHBUF_EXT"));
                            break;
                        case 5:
                            for (var l = 0, u = this.groups[1].entities; l < u.length; l++) {
                                u[l].getComponent(S)._addOrRemoveInstancingDefine()
                            }
                            break;
                        case 6:
                            for (var c = 0, p = t.lightCollector.lights; c < p.length; c++) {
                                var d = p[c].entity.getComponent(qe);
                                null !== d && -1 === d.quality && d._updateMapSize()
                            }
                    }
                }
                e.removeComponent(r)
            }
        }, t.prototype._sortDrawCallForOpaque = function (e, t) {
            var n = e.material, r = t.material;
            return n.renderQueue !== r.renderQueue ? n.renderQueue - r.renderQueue : n.technique.program !== r.technique.program ? n.technique.program - r.technique.program : n.index !== r.index ? n.index - r.index : e.mesh.index !== t.mesh.index ? e.mesh.index - t.mesh.index : e.zdist - t.zdist
        }, t.prototype._sortDrawCallForBlend = function (e, t) {
            var n = e.material, r = t.material;
            return n.renderQueue === r.renderQueue ? t.zdist - e.zdist : n.renderQueue - r.renderQueue
        }, t.prototype._sortDrawcallForShadow = function (e, t) {
            return e.mesh.index !== t.mesh.index ? e.mesh.index - t.mesh.index : e.zdist - t.zdist
        }, t.prototype._frustumCulling = function (e) {
            for (var t = i.Application.instance.sceneManager.editorScene, n = e.context, r = e.frustum, o = e.entity.node.scene, a = n.opaqueDrawCalls, s = n.blendDrawCalls, l = i.Vector3.create().release(), u = i.Vector3.create().fromMatrixPosition(e.cameraToWorldMatrix).release(), c = 0, p = 0, d = 0, h = this.groups[2].entities; d < h.length; d++) {
                var f = h[d].getComponent(ae), m = f.renderer, _ = m.entity.node;
                _.scene === t && o !== t || 0 == (e.cullingMask & _.layer) || e.frustumCulled && m.frustumCulled && !r.intersectsSphere(m.boundingSphere) || (f.material.renderQueue >= 3e3 ? s[p++] = f : a[c++] = f, f.zdist = l.fromMatrixPosition(f.matrix).getSquaredDistance(u), f.modelViewMatrix.multiply(e.worldToCameraMatrix, f.matrix), f.instanced = 0)
            }
            a.length !== c && (a.length = c), s.length !== p && (s.length = p), a.sort(this._sortDrawCallForOpaque), s.sort(this._sortDrawCallForBlend)
        }, t.prototype._shadowFrustumCulling = function (e) {
            for (var t = i.Application.instance.sceneManager.editorScene, n = e.frustum, r = e.context, o = e.entity.node.scene, a = r.shadowDrawCalls, s = 0, l = 0, u = this.groups[2].entities; l < u.length; l++) {
                var c = u[l].getComponent(ae), p = c.renderer, d = p.entity.node;
                !p.castShadows || d.scene === t && o !== t || 0 == (e.cullingMask & d.layer) || e.frustumCulled && !p.frustumCulled && !n.intersectsSphere(p.boundingSphere) || (c.modelViewMatrix.multiply(e.worldToCameraMatrix, c.matrix), c.instanced = 0, a[s++] = c)
            }
            a.length !== s && (a.length = s), a.sort(this._sortDrawcallForShadow)
        }, t.prototype._updateLights = function (e) {
            var t = this._renderContext.lightCollector, n = t.directionalLights, r = t.spotLights,
                o = t.rectangleAreaLights, a = t.pointLights, s = t.hemisphereLights, l = t.directLightBuffer,
                u = t.spotLightBuffer, c = t.rectangleAreaLightBuffer, p = t.pointLightBuffer,
                d = t.hemisphereLightBuffer, h = t.directShadowMatrix, f = t.spotShadowMatrix, m = t.pointShadowMatrix,
                _ = t.directShadowMaps, g = t.spotShadowMaps, v = t.pointShadowMaps, y = 0, b = 0, x = 0,
                T = i.Vector3.create().release(), E = e.worldToCameraMatrix;
            t.hasAnyCastShadow = !1;
            for (var C = 0, S = n; C < S.length; C++) {
                var M = (F = S[C]).intensity, A = F.color;
                x = 43 * y++, F.entity.transform.getForward(T).applyDirection(E), l[x++] = -T.x, l[x++] = -T.y, l[x++] = -T.z, l[x++] = A.r * M, l[x++] = A.g * M, l[x++] = A.b * M, null !== (D = F.entity.getComponent(qe)) && D.isActiveAndEnabled ? (l[x++] = 1, l[x++] = D.bias, l[x++] = D.radius, l[x++] = D.mapSize, l[x++] = D.mapSize, h.set(D._matrix.rawData, 16 * b), _[b++] = D._renderTarget, t.hasAnyCastShadow = !0) : (l[x++] = 0, _[b++] = null)
            }
            y = b = 0;
            for (var O = 0, w = r; O < w.length; O++) {
                M = (F = w[O]).intensity;
                var R = F.distance;
                A = F.color;
                x = 50 * y++, T.applyMatrix(E, F.entity.transform.position), u[x++] = T.x, u[x++] = T.y, u[x++] = T.z, F.entity.transform.getForward(T).applyDirection(E), u[x++] = -T.x, u[x++] = -T.y, u[x++] = -T.z, u[x++] = A.r * M, u[x++] = A.g * M, u[x++] = A.b * M, u[x++] = R, u[x++] = 0 === R ? 0 : F.decay, u[x++] = Math.cos(F.angle), u[x++] = Math.cos(F.angle * (1 - F.penumbra)), null !== (D = F.entity.getComponent(qe)) && D.isActiveAndEnabled ? (u[x++] = 1, u[x++] = D.bias, u[x++] = D.radius, u[x++] = D.mapSize, u[x++] = D.mapSize, f.set(D._matrix.rawData, 16 * b), g[b++] = D._renderTarget, t.hasAnyCastShadow = !0) : (u[x++] = 0, g[b++] = null)
            }
            y = b = 0;
            for (var P = 0, L = a; P < L.length; P++) {
                var D;
                M = (F = L[P]).intensity, R = F.distance, A = F.color;
                x = 47 * y++, T.applyMatrix(E, F.entity.transform.position), p[x++] = T.x, p[x++] = T.y, p[x++] = T.z, p[x++] = A.r * M, p[x++] = A.g * M, p[x++] = A.b * M, p[x++] = R, p[x++] = 0 === R ? 0 : F.decay, null !== (D = F.entity.getComponent(qe)) && D.isActiveAndEnabled ? (p[x++] = 1, p[x++] = D.bias, p[x++] = D.radius, p[x++] = D.mapSize, p[x++] = D.mapSize, p[x++] = D.near, p[x++] = D.far, m.set(D._matrix.rawData, 16 * b), v[b++] = D._renderTarget, t.hasAnyCastShadow = !0) : (p[x++] = 0, v[b++] = null)
            }
            y = b = 0;
            for (var I = 0, N = o; I < N.length; I++) {
                M = (F = N[I]).intensity, A = F.color;
                x = 44 * y++, T.applyMatrix(E, F.entity.transform.position), c[x++] = T.x, c[x++] = T.y, c[x++] = T.z, c[x++] = A.r * M, c[x++] = A.g * M, c[x++] = A.b * M
            }
            y = b = 0;
            for (var z = 0, U = s; z < U.length; z++) {
                M = (F = U[z]).intensity, A = F.color;
                var F, k = F.groundColor;
                x = 41 * y++, F.entity.transform.getForward(T).applyDirection(E), d[x++] = -T.x, d[x++] = -T.y, d[x++] = -T.z, d[x++] = A.r * M, d[x++] = A.g * M, d[x++] = A.b * M, d[x++] = k.r * M, d[x++] = k.g * M, d[x++] = k.b * M
            }
        }, t.prototype._updateShadowCamera = function (e, t, r, o) {
            switch (e.lightType) {
                case 0:
                    var a = e.entity.transform, s = a.position, l = a.rotation, u = t.near, c = t.far, p = t.size,
                        d = t._matrix;
                    (m = r.entity.transform).setLocalPosition(s).setLocalRotation(l), r.cullingMask = e.cullingMask, r.viewport.set(0, 0, 1, 1), r.projectionMatrix = i.Matrix4.create().fromProjection(u, c, 0, p, 0, 1, 0).release(), r.worldToCameraMatrix = m.worldToLocalMatrix, d.set(.5, 0, 0, .5, 0, .5, 0, .5, 0, 0, .5, .5, 0, 0, 0, 1).multiply(r.projectionMatrix).multiply(r.worldToCameraMatrix);
                    break;
                case 1:
                    var h = e.entity.transform, f = (s = h.position, l = h.rotation, h.worldToLocalMatrix);
                    u = t.near, c = t.far, d = t._matrix;
                    (m = r.entity.transform).setLocalPosition(s).setLocalRotation(l), r.cullingMask = e.cullingMask, r.viewport.set(0, 0, 1, 1), r.projectionMatrix = i.Matrix4.create().fromProjection(u, c, 2 * e.angle, 0, 1, 1, 0).release(), r.worldToCameraMatrix = f, d.set(.5, 0, 0, .5, 0, .5, 0, .5, 0, 0, .5, .5, 0, 0, 0, 1).multiply(r.projectionMatrix).multiply(f);
                    break;
                case 3:
                    var m;
                    u = t.near, c = t.far, d = t._matrix, s = t.entity.transform.position;
                    (m = r.entity.transform).setLocalPosition(s).lookAt(s.clone().add(n._targets[o]).release(), n._ups[o]), r.cullingMask = e.cullingMask, r.viewport.copy(n._viewPortsScale[o]), r.projectionMatrix = i.Matrix4.create().fromProjection(u, c, 1.5707963267948966, 0, 1, 1, 0).release(), r.worldToCameraMatrix = m.worldToLocalMatrix, d.fromTranslate(s.clone().multiplyScalar(-1).release())
            }
        }, t.prototype._combineDraw = function (e, t) {
            void 0 === t && (t = null);
            for (var r, i, o, a, s, l, u, c, p = this._combineModelMats, d = this._combineModelViewMats, h = this._renderContext, f = !0, m = 0, _ = 0, g = e.length; _ < g; _++) {
                var v = _ === g - 1, y = e[_], b = v ? e[_] : e[_ + 1], x = null !== t ? t : y.material, T = y.mesh,
                    E = null !== t ? t : b.material, C = b.mesh;
                if (!x.gpuInstancingEnable || (p[m] = y.matrix, d[m] = y.modelViewMatrix, m++, v || x !== E || T !== C)) {
                    var S = T.getAttribute("_INSTANCED_MODEL_VIEW0");
                    if (null !== S ? (f = S.length / 4 === m) || (T.removeAttribute("_INSTANCED_MODEL0"), T.removeAttribute("_INSTANCED_MODEL1"), T.removeAttribute("_INSTANCED_MODEL2"), T.removeAttribute("_INSTANCED_MODEL3"), T.removeAttribute("_INSTANCED_MODEL_VIEW0"), T.removeAttribute("_INSTANCED_MODEL_VIEW1"), T.removeAttribute("_INSTANCED_MODEL_VIEW2"), T.removeAttribute("_INSTANCED_MODEL_VIEW3")) : f = !1, m > 0) {
                        f ? (r = T.getAttribute("_INSTANCED_MODEL0"), i = T.getAttribute("_INSTANCED_MODEL1"), o = T.getAttribute("_INSTANCED_MODEL2"), a = T.getAttribute("_INSTANCED_MODEL3"), s = T.getAttribute("_INSTANCED_MODEL_VIEW0"), l = T.getAttribute("_INSTANCED_MODEL_VIEW1"), u = T.getAttribute("_INSTANCED_MODEL_VIEW2"), c = T.getAttribute("_INSTANCED_MODEL_VIEW3")) : (r = T.addAttribute("_INSTANCED_MODEL0", "VEC4", m, 1), i = T.addAttribute("_INSTANCED_MODEL1", "VEC4", m, 1), o = T.addAttribute("_INSTANCED_MODEL2", "VEC4", m, 1), a = T.addAttribute("_INSTANCED_MODEL3", "VEC4", m, 1), s = T.addAttribute("_INSTANCED_MODEL_VIEW0", "VEC4", m, 1), l = T.addAttribute("_INSTANCED_MODEL_VIEW1", "VEC4", m, 1), u = T.addAttribute("_INSTANCED_MODEL_VIEW2", "VEC4", m, 1), c = T.addAttribute("_INSTANCED_MODEL_VIEW3", "VEC4", m, 1));
                        for (var M = 0; M < m; M++) {
                            var A = p[M].rawData, O = d[M].rawData, w = 4 * M + 0, R = 4 * M + 1, P = 4 * M + 2,
                                L = 4 * M + 3;
                            r[w] = A[0], r[R] = A[1], r[P] = A[2], r[L] = A[3], i[w] = A[4], i[R] = A[5], i[P] = A[6], i[L] = A[7], o[w] = A[8], o[R] = A[9], o[P] = A[10], o[L] = A[11], a[w] = A[12], a[R] = A[13], a[P] = A[14], a[L] = A[15], s[w] = O[0], s[R] = O[1], s[P] = O[2], s[L] = O[3], l[w] = O[4], l[R] = O[5], l[P] = O[6], l[L] = O[7], u[w] = O[8], u[R] = O[9], u[P] = O[10], u[L] = O[11], c[w] = O[12], c[R] = O[13], c[P] = O[14], c[L] = O[15]
                        }
                        y.instanced = m, m = 0, f && T.uploadVertexBuffer(n._instancingAttributes)
                    }
                    h.draw(y, x)
                }
            }
        }, t.prototype._renderShadow = function (e, t) {
            var n = this._renderContext, r = n, o = r.cameraCollector, a = r.lightCollector,
                s = o.currentCamera = o.shadowCamera, l = s.viewport, u = s.entity.getComponent(P).shadowDrawCalls,
                c = 3 === e.lightType, p = c ? ee.SHADOW_DISTANCE : ee.SHADOW_DEPTH_3201, d = t.mapSize;
            n.renderTarget = t._renderTarget, n.clearColor = i.Color.WHITE, n.clearBuffer(16640), a.currentShadowLight = e;
            for (var h = 0, f = c ? 6 : 1; h < f; h++) {
                this._updateShadowCamera(e, t, s, h);
                var m = s.entity.getComponentByType("cameraFrustumCulling");
                if (null !== m && m.enabled ? m.shadowFrustumCulling(s) : this._shadowFrustumCulling(s), n._setViewport(l.x * d, l.y * d, l.w * d, l.h * d), n.gpuInstancingEnable) this._combineDraw(u, p); else for (var _ = 0, g = u; _ < g.length; _++) {
                    var v = g[_];
                    n.draw(v, p)
                }
                n.clearCache(4)
            }
            o.currentCamera = null, a.currentShadowLight = null
        }, t.prototype._contextRender = function (e, t, n) {
            var r = this._renderContext;
            r.renderTarget = n, r.viewport = e.viewport, r.clearColor = e.backgroundColor, r.clearBuffer(e.bufferMask);
            var i = r.caches, o = e.entity.getComponent(oe);
            if (null !== o && o.isActiveAndEnabled && null !== o.material) {
                var a = r.drawCallCollector, s = r.entity.getComponent(v), l = a.skyBox, u = o.material;
                if (u.shader !== $.BACKGROUND) {
                    var c = u.shader === $.CUBE ? u.getTexture("tCube") : u.shader === $.EQUIRECT ? u.getTexture("tEquirect") : u.getTexture();
                    o.reflections ? i.skyBoxTexture !== c && (E.updateTextureDefines(s, "envMap", c, r.gammaInput), i.skyBoxTexture = c) : null !== i.skyBoxTexture && (E.updateTextureDefines(s, "envMap", null, r.gammaInput), i.skyBoxTexture = null), l.mesh = ut.CUBE
                } else null !== i.skyBoxTexture && (E.updateTextureDefines(s, "envMap", null, r.gammaInput), i.skyBoxTexture = null), l.mesh = ut.FULLSCREEN;
                l.matrix = e.cameraToWorldMatrix, r.draw(l, u)
            } else if (null !== i.skyBoxTexture) {
                s = r.entity.getComponent(v);
                E.updateTextureDefines(s, "envMap", null, r.gammaInput), i.skyBoxTexture = null
            }
            var p = e.entity.getComponent(P), d = p.opaqueDrawCalls, h = p.blendDrawCalls;
            if (r.gpuInstancingEnable) this._combineDraw(d, t), this._combineDraw(h, t); else {
                for (var f = 0, m = d; f < m.length; f++) {
                    var _ = m[f];
                    r.draw(_, t)
                }
                for (var g = 0, y = h; g < y.length; g++) {
                    _ = y[g];
                    r.draw(_, t)
                }
            }
        }, t.prototype._cameraRender = function (e, t, n) {
            if (void 0 === t && (t = null), void 0 === n && (n = null), i.Application.instance.renderContext.cameraCollector.currentCamera = e, null !== e.entity.getComponent(L)) {
                var r = e.entity.getComponentByType("cameraFrustumCulling");
                null !== r ? r.frustumCulling(e) : this._frustumCulling(e), this._updateLights(e);
                var o = !1, a = this._postprocessings;
                if (a.length > 0 && (a.length = 0), e.entity.getComponentsByType("cameraPostprocessing", a), a.length > 0) for (var s = 0, l = a; s < l.length; s++) {
                    if ((p = l[s]).isActiveAndEnabled) {
                        o = !0;
                        break
                    }
                }
                if (o) {
                    for (var u = 0, c = a; u < c.length; u++) {
                        var p;
                        (p = c[u]).isActiveAndEnabled && p.onRender(e)
                    }
                    var d = e._writeRenderTarget;
                    e._readRenderTarget = e._writeRenderTarget, e._writeRenderTarget = d
                } else null === n && (n = e._innerRenderTarget), this._contextRender(e, t, n)
            } else n || (n = e._innerRenderTarget), e._render(e, null, n)
        }, t.prototype._getSceneComponent = function (e) {
            var t = i.Application.instance.globalEntity, n = i.Application.instance.sceneManager, r = n.globalScene,
                o = n.activeScene.entity.getComponent(e);
            return null !== o && o.isActiveAndEnabled || null !== (o = r.entity.getComponent(e)) && o.isActiveAndEnabled || null !== (o = t.getComponent(e)) && o.isActiveAndEnabled ? o : null
        }, t.prototype.getMatchers = function () {
            return [r.Matcher.create(i.GlobalEntity, !1, dt).anyOf(ce), r.Matcher.create(a.AssetEntity, !1, S), r.Matcher.create(r.Entity, !0, ae), r.Matcher.create(i.GameEntity, !0, i.Transform, L)]
        }, t.prototype.onAwake = function () {
            this._renderContext = i.Application.instance.globalEntity.getComponent(dt), this._renderContext.render = this._contextRender.bind(this)
        }, t.prototype.onEntityAdded = function (e, t) {
            var n = this.groups;
            t === n[0] ? this._onRenderContextChanged(e) : t === n[3] && (e.getComponent(L)._render = this._cameraRender.bind(this))
        }, t.prototype.onFrame = function () {
            var e = i.Application.instance, t = e.executeMode, n = e.clock, r = e.sceneManager, o = this._renderTargets,
                a = this._renderContext, s = a, l = s.caches, u = s.cameraCollector, c = s.lightCollector,
                p = u.cameras, d = c.lights;
            if (a.drawCallCollector.drawCallCount = 0, p.length > 0) {
                var h = 0 != (4 & t), f = r.editorScene;
                if (a.clearCache(2), a.clockBuffer[0] = n.frameTime, l.defaultSceneLight = this._getSceneComponent(rt), l.defaultFog = this._getSceneComponent(nt), u.sortCameras(), d.length > 0) for (var m = 0, _ = d; m < _.length; m++) {
                    var g = _[m], v = g.entity.getComponent(qe);
                    null !== v && v.isActiveAndEnabled && this._renderShadow(g, v)
                }
                for (var y = 0, b = p; y < b.length; y++) {
                    var x = b[y], T = x.entity.node.scene, E = x._innerRenderTarget, C = (null !== E ? E : a).uuid;
                    null === E && h !== (T === f) && x.constructor === L || (C in o || (0 == (16384 & x.bufferMask) && (a.renderTarget = E, a.clearColor = x.backgroundColor, a.clearBuffer(16384)), o[C] = !0), this._cameraRender(x))
                }
            } else i.Application.instance.driveByEgret2d || (a.clearColor = i.Color.BLACK, a.clearBuffer(16640));
            a._clearOnEnd()
        }, t.prototype.onFrameCleanup = function () {
            Object(o.clearRecord)(this._renderTargets)
        }, t.prototype.onDestory = function () {
            this._postprocessings.length = 0, Object(o.clearRecord)(this._renderTargets), this._renderContext = null
        }, t._instancingAttributes = ["_INSTANCED_MODEL0", "_INSTANCED_MODEL1", "_INSTANCED_MODEL2", "_INSTANCED_MODEL3", "_INSTANCED_MODEL_VIEW0", "_INSTANCED_MODEL_VIEW1", "_INSTANCED_MODEL_VIEW2", "_INSTANCED_MODEL_VIEW3"], t._targets = [i.Vector3.RIGHT, i.Vector3.LEFT, i.Vector3.FORWARD, i.Vector3.BACK, i.Vector3.UP, i.Vector3.DOWN], t._ups = [i.Vector3.UP, i.Vector3.UP, i.Vector3.UP, i.Vector3.UP, i.Vector3.FORWARD, i.Vector3.BACK], t._viewPortsScale = [i.Rectangle.create(2, 1, 1, 1), i.Rectangle.create(0, 1, 1, 1), i.Rectangle.create(3, 1, 1, 1), i.Rectangle.create(1, 1, 1, 1), i.Rectangle.create(3, 0, 1, 1), i.Rectangle.create(1, 0, 1, 1)], t = n = c([Object(r.system)({noneOfExecuteMode: 32})], t)
    }(r.System);
    __reflect(wt, "@egret/render/RenderSystem");
    var Rt = function (e) {
        function t() {
            var t = null !== e && e.apply(this, arguments) || this;
            return t._drawCallCollector = i.Application.instance.globalEntity.getComponent(ct), t._materialFilter = [], t
        }

        return u(t, e), t.prototype._updateDrawCalls = function (e) {
            var t = this._drawCallCollector, n = this._materialFilter, r = e.getComponent(Je).mesh,
                o = e.getComponent(et), a = o.materials, s = a.length;
            if (t.destroyDrawCall(e.uuid), null !== r && 0 !== s) {
                var l = r.glTFMesh.primitives, u = l.length, c = i.Matrix4.IDENTITY;
                if (0 === u) throw new Error;
                n.length < s && (n.length = s);
                for (var p = 0; p < u; ++p) {
                    var d = l[p].material || 0, h = null;
                    if (d < s && (h = a[d], n[d] = !0), null !== h) (_ = t.createDrawCall(e.uuid)).subMeshIndex = p, _.mesh = r, _.material = h, _.matrix = c, _.renderer = o
                }
                p = 0;
                for (var f = n.length; p < f; ++p) if (n[p]) n[p] = !1; else {
                    if (p >= s) break;
                    h = a[p];
                    for (var m = 0; m < u; ++m) {
                        var _;
                        (_ = t.createDrawCall(e.uuid)).subMeshIndex = m, _.mesh = r, _.material = h, _.matrix = c, _.renderer = o
                    }
                }
            }
        }, t.prototype.getMatchers = function () {
            return [r.Matcher.create(i.GameEntity, !0, i.Transform, Je, et), r.Matcher.create(i.GameEntity, !0, Je, et).anyOf(pe, de)]
        }, t.prototype.onEntityAdded = function (e, t) {
            var n = this.groups;
            if (t === n[0]) this._updateDrawCalls(e); else if (t === n[1]) {
                if (this._updateDrawCalls(e), null !== e.getComponent(pe)) {
                    var r = e.getComponent(et);
                    null !== r && r.needUpdate(1), e.removeComponent(pe)
                }
                var i = e.getComponent(de);
                null !== i && e.removeComponent(i)
            }
        }, t.prototype.onEntityRemoved = function (e, t) {
            t === this.groups[0] && this._drawCallCollector.destroyDrawCall(e.uuid)
        }, t.prototype.onFrame = function () {
            for (var e = 0, t = this.groups[0].entities; e < t.length; e++) {
                var n = t[e].getComponent(et);
                n.needUpdate(6), n.update(3)
            }
        }, t = c([Object(r.system)({noneOfExecuteMode: 32})], t)
    }(r.System);
    __reflect(Rt, "@egret/render/SkinnedMeshRendererSystem");
    var Pt = function (e) {
        function t() {
            var t = null !== e && e.apply(this, arguments) || this;
            return t._drawCallCollector = i.Application.instance.globalEntity.getComponent(ct), t._materialFilter = [], t
        }

        return u(t, e), t.prototype.getMatchers = function () {
            return [r.Matcher.create(i.GameEntity, !0, i.Transform, Je, tt)]
        }, t.prototype.onEntityAdded = function (e, t) {
            t === this.groups[0] && this._updateDrawCalls(e)
        }, t.prototype.onEntityRemoved = function (e, t) {
            t === this.groups[0] && this._drawCallCollector.destroyDrawCall(e.uuid)
        }, t.prototype.onFrame = function () {
            for (var e = 0, t = this.groups[0].entities; e < t.length; e++) {
                var n = t[e].getComponent(tt);
                n.needUpdate(1), n.update(1)
            }
        }, t.prototype._updateDrawCalls = function (e) {
            var t = this._drawCallCollector, n = this._materialFilter, r = e.getComponent(Je).mesh,
                o = e.getComponent(tt), a = o.materials, s = a.length;
            if (t.destroyDrawCall(e.uuid), null !== r && 0 !== s) {
                var l = r.glTFMesh.primitives, u = l.length, c = i.Matrix4.IDENTITY;
                if (0 === u) throw new Error;
                n.length < s && (n.length = s);
                for (var p = 0; p < u; ++p) {
                    var d = l[p].material || 0, h = null;
                    if (d < s && (h = a[d], n[d] = !0), null !== h) (_ = t.createDrawCall(e.uuid)).subMeshIndex = p, _.mesh = r, _.material = h, _.matrix = c, _.renderer = o
                }
                p = 0;
                for (var f = n.length; p < f; ++p) if (n[p]) n[p] = !1; else {
                    if (p >= s) break;
                    h = a[p];
                    for (var m = 0; m < u; ++m) {
                        var _;
                        (_ = t.createDrawCall(e.uuid)).subMeshIndex = m, _.mesh = r, _.material = h, _.matrix = c, _.renderer = o
                    }
                }
            }
        }, t = c([Object(r.system)({noneOfExecuteMode: 32})], t)
    }(r.System);
    __reflect(Pt, "@egret/render/GpuSkinnedMeshRendererSystem");
    var Lt = function (e) {
        function t() {
            return null !== e && e.apply(this, arguments) || this
        }

        return u(t, e), t.prototype.getMatchers = function () {
            return [r.Matcher.create(i.GameEntity, !0, i.Scene, i.TreeNode, le)]
        }, t.prototype.onEntityAdded = function (e) {
            var t = e.getComponent(i.Scene);
            null !== t && bt.combine([t.root.entity])
        }, t = c([Object(r.system)({noneOfExecuteMode: 32})], t)
    }(r.System);
    __reflect(Lt, "@egret/render/StaticBatchingSystem");
    var Dt = function (e) {
        function t() {
            return null !== e && e.apply(this, arguments) || this
        }

        return u(t, e), t.prototype.load = function (e, n, r) {
            return p(this, void 0, void 0, (function () {
                return d(this, (function (r) {
                    return [2, n.loader.loadBinary(e, n.baseUrl).then((function (e) {
                        var n = new Uint8Array(e, 0, 12);
                        if (171 !== n[0] || 75 !== n[1] || 84 !== n[2] || 88 !== n[3] || 32 !== n[4] || 49 !== n[5] || 49 !== n[6] || 187 !== n[7] || 13 !== n[8] || 10 !== n[9] || 26 !== n[10] || 10 !== n[11]) return console.error("texture missing KTX identifier"), Promise.resolve(null);
                        var r = Uint32Array.BYTES_PER_ELEMENT, i = new DataView(e, 12, 13 * r),
                            o = 67305985 === i.getUint32(0, !0), a = i.getUint32(1 * r, o),
                            s = (i.getUint32(2 * r, o), i.getUint32(3 * r, o)), l = i.getUint32(4 * r, o),
                            u = (i.getUint32(5 * r, o), i.getUint32(6 * r, o), i.getUint32(7 * r, o)),
                            c = i.getUint32(8 * r, o), p = i.getUint32(9 * r, o), d = i.getUint32(10 * r, o),
                            h = Math.max(1, i.getUint32(11 * r, o)), f = i.getUint32(12 * r, o);
                        if (0 !== a) return console.error("only compressed formats currently supported"), Promise.resolve(null);
                        if (0 === u || 0 !== c) return console.error("only 2D textures currently supported"), Promise.resolve(null);
                        if (0 !== p) return console.error("texture arrays not currently supported"), Promise.resolve(null);
                        for (var m = [], _ = t.HEADER_LEN + f, g = 0; g < h; g++) {
                            var v = new Int32Array(e, _, 1)[0];
                            _ += 4;
                            for (var y = 0; y < d; y++) {
                                var b = new Uint8Array(e, _, v);
                                m.push(b), _ += v, _ += 3 - (v + 3) % 4
                            }
                        }
                        var x = {
                            source: m,
                            width: u,
                            height: u,
                            format: s,
                            depth: c,
                            isCompressed: !0,
                            internalFormat: l
                        };
                        return Promise.resolve(x)
                    }))]
                }))
            }))
        }, t.HEADER_LEN = 64, t.COMPRESSED_2D = 0, t.COMPRESSED_3D = 1, t.TEX_2D = 2, t.TEX_3D = 3, t
    }(DebuggerClass);
    __reflect(Dt, "@egret/render/KTXLoader");
    var It = function (e) {
        function t() {
            return null !== e && e.apply(this, arguments) || this
        }

        return u(t, e), t.prototype.onAwake = function () {
            var e = i.Application.instance, t = e.globalEntity, n = e.systemManager;
            t.getOrAddComponent(dt), t.getOrAddComponent(ut), t.getOrAddComponent(I), t.getOrAddComponent($), t.getOrAddComponent(ee), n.registerSystem(Ot, 7e3), n.registerSystem(Rt, 7e3), n.registerSystem(Pt, 7e3), n.registerSystem(Lt, 7e3), n.registerSystem(Mt, 7e3), n.registerSystem(At, 7e3), n.registerSystem(wt, 8e3), a.ResourceManager.instance.setProcessor("ktx", new Dt), a.ResourceManager.instance.setProcessor("mesh", new Et), a.ResourceManager.instance.setProcessor("texture", new St), a.ResourceManager.instance.setProcessor("shader", new Ct), a.ResourceManager.instance.setProcessor("material", new xt), n.unregisterSystem(this)
        }, t = c([Object(r.system)()], t)
    }(r.System);

    function Nt() {
        return p(this, void 0, void 0, (function () {
            return d(this, (function (e) {
                return i.SystemManager.preRegisterSystem(It, 0), console.debug("Egret rendering registered."), [2]
            }))
        }))
    }

    __reflect(It, "@egret/render/StartupSystem")
}, function (e, t, n) {
    "use strict";
    n.r(t), n.d(t, "Animation", (function () {
        return k
    })), n.d(t, "AnimationAsset", (function () {
        return y
    })), n.d(t, "AnimationBaseState", (function () {
        return w
    })), n.d(t, "AnimationBinder", (function () {
        return C
    })), n.d(t, "AnimationBlendType", (function () {
        return i
    })), n.d(t, "AnimationChannel", (function () {
        return M
    })), n.d(t, "AnimationController", (function () {
        return x
    })), n.d(t, "AnimationEvent", (function () {
        return V
    })), n.d(t, "AnimationEventType", (function () {
        return a
    })), n.d(t, "AnimationFadeState", (function () {
        return O
    })), n.d(t, "AnimationMask", (function () {
        return T
    })), n.d(t, "AnimationState", (function () {
        return P
    })), n.d(t, "AnimationSystem", (function () {
        return B
    })), n.d(t, "AnimationTreeState", (function () {
        return R
    })), n.d(t, "ApplyRootMotion", (function () {
        return o
    })), n.d(t, "BakedAnimationAsset", (function () {
        return b
    })), n.d(t, "DefaultNames", (function () {
        return r
    })), n.d(t, "MeshRendererHelper", (function () {
        return E
    })), n.d(t, "startup", (function () {
        return W
    }));
    var r, i, o, a, s = n(2), l = n(4), u = n(0), c = n(1), p = n(3), d = n(9), h = n(5), f = function (e, t) {
        return (f = Object.setPrototypeOf || {__proto__: []} instanceof Array && function (e, t) {
            e.__proto__ = t
        } || function (e, t) {
            for (var n in t) t.hasOwnProperty(n) && (e[n] = t[n])
        })(e, t)
    };

    function m(e, t) {
        function n() {
            this.constructor = e
        }

        f(e, t), e.prototype = null === t ? Object.create(t) : (n.prototype = t.prototype, new n)
    }

    function _(e, t, n, r) {
        var i, o = arguments.length, a = o < 3 ? t : null === r ? r = Object.getOwnPropertyDescriptor(t, n) : r;
        if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) a = Reflect.decorate(e, t, n, r); else for (var s = e.length - 1; s >= 0; s--) (i = e[s]) && (a = (o < 3 ? i(a) : o > 3 ? i(t, n, a) : i(t, n)) || a);
        return o > 3 && a && Object.defineProperty(t, n, a), a
    }

    function g(e, t, n, r) {
        return new (n || (n = Promise))((function (i, o) {
            function a(e) {
                try {
                    l(r.next(e))
                } catch (e) {
                    o(e)
                }
            }

            function s(e) {
                try {
                    l(r.throw(e))
                } catch (e) {
                    o(e)
                }
            }

            function l(e) {
                e.done ? i(e.value) : new n((function (t) {
                    t(e.value)
                })).then(a, s)
            }

            l((r = r.apply(e, t || [])).next())
        }))
    }

    function v(e, t) {
        var n, r, i, o, a = {
            label: 0, sent: function () {
                if (1 & i[0]) throw i[1];
                return i[1]
            }, trys: [], ops: []
        };
        return o = {
            next: s(0),
            throw: s(1),
            return: s(2)
        }, "function" == typeof Symbol && (o[Symbol.iterator] = function () {
            return this
        }), o;

        function s(o) {
            return function (s) {
                return function (o) {
                    if (n) throw new TypeError("Generator is already executing.");
                    for (; a;) try {
                        if (n = 1, r && (i = 2 & o[0] ? r.return : o[0] ? r.throw || ((i = r.return) && i.call(r), 0) : r.next) && !(i = i.call(r, o[1])).done) return i;
                        switch (r = 0, i && (o = [2 & o[0], i.value]), o[0]) {
                            case 0:
                            case 1:
                                i = o;
                                break;
                            case 4:
                                return a.label++, {value: o[1], done: !1};
                            case 5:
                                a.label++, r = o[1], o = [0];
                                continue;
                            case 7:
                                o = a.ops.pop(), a.trys.pop();
                                continue;
                            default:
                                if (!(i = a.trys, (i = i.length > 0 && i[i.length - 1]) || 6 !== o[0] && 2 !== o[0])) {
                                    a = 0;
                                    continue
                                }
                                if (3 === o[0] && (!i || o[1] > i[0] && o[1] < i[3])) {
                                    a.label = o[1];
                                    break
                                }
                                if (6 === o[0] && a.label < i[1]) {
                                    a.label = i[1], i = o;
                                    break
                                }
                                if (i && a.label < i[2]) {
                                    a.label = i[2], a.ops.push(o);
                                    break
                                }
                                i[2] && a.ops.pop(), a.trys.pop();
                                continue
                        }
                        o = t.call(e, a)
                    } catch (e) {
                        o = [6, e], r = 0
                    } finally {
                        n = i = 0
                    }
                    if (5 & o[0]) throw o[1];
                    return {value: o[0] ? o[1] : void 0, done: !0}
                }([o, s])
            }
        }
    }

    !function (e) {
        e.NoName = "NoName", e.Default = "Default"
    }(r || (r = {})), function (e) {
        e[e.E1D = 0] = "E1D"
    }(i || (i = {})), function (e) {
        e[e.X = 1] = "X", e[e.Y = 2] = "Y", e[e.Z = 4] = "Z", e[e.RY = 16] = "RY", e[e.XZ = 5] = "XZ"
    }(o || (o = {})), function (e) {
        e[e.Start = 0] = "Start", e[e.LoopComplete = 1] = "LoopComplete", e[e.Complete = 2] = "Complete", e[e.KeyFrame = 3] = "KeyFrame", e[e.Sound = 4] = "Sound"
    }(a || (a = {}));
    var y = function (e) {
        function t() {
            return null !== e && e.apply(this, arguments) || this
        }

        return m(t, e), t.createGLTF = function () {
            var e = l.GLTFAsset.createGLTF();
            return e.buffers = [], e.bufferViews = [], e.accessors = [], e.animations = [{
                channels: [],
                samplers: [],
                extensions: {egret: {frameRate: 30, clips: []}}
            }], e
        }, t.prototype._setGLTF = function (t) {
            e.prototype._setGLTF.call(this, t);
            var n = t.animations;
            if (void 0 !== n) for (var r = 0, i = n; r < i.length; r++) {
                i[r].extras = {channels: {}}
            }
        }, t.prototype.getAnimationClip = function (e) {
            var t = this._glTF.animations;
            if (!t || 0 === t.length) return null;
            var n = t[0];
            if (0 === n.extensions.egret.clips.length) return null;
            if (0 === e.length) return n.extensions.egret.clips[0];
            for (var r = 0, i = t; r < i.length; r++) for (var o = 0, a = i[r].extensions.egret.clips; o < a.length; o++) {
                var s = a[o];
                if (s.name === e) return s
            }
            return null
        }, t = _([Object(s.component)({isAbstract: !1})], t)
    }(l.GLTFAsset);
    __reflect(y, "@egret/animation/AnimationAsset");
    var b = function (e) {
        function t() {
            var t = null !== e && e.apply(this, arguments) || this;
            return t.texture = null, t.skeletonName = "", t.name = "", t.frameRate = 60, t
        }

        var n;
        return m(t, e), n = t, t.fromFloat32Array = function (e, t, r, i, o) {
            var a = l.Texture.create({source: i, width: e, height: t, type: 5126, format: 6408}), s = "",
                u = o.split("\\").join("/").split("/").filter((function (e) {
                    if ("" !== e) return e
                })).pop().split("-"), c = (s = u[u.length - 1]).indexOf(".");
            -1 !== c && (s = s.slice(0, c));
            var p = u[0], d = new n;
            return d.texture = a, d.name = s, d.skeletonName = p, d.frameRate = r, d
        }, t.getBakedAnimationAssetsByConfig = function (e) {
            var t = u.ResourceManager.instance.getResource(e), r = [];
            if (!t) return r;
            for (var i = 0, o = t.skinnedMeshAssets; i < o.length; i++) {
                var a = o[i], s = u.ResourceManager.instance.getResource(a);
                if (s) {
                    var l = this.getAnimationNameFromAsset(a);
                    n._assets[l] || (n._assets[l] = []);
                    var c = n._assets[l];
                    -1 === c.indexOf(s) && c.push(s), r.indexOf(l) < 0 && r.push(l)
                } else console.warn("get resource error,", a)
            }
            for (var p = 0, d = t.meshAssets; p < d.length; p++) {
                a = d[p];
                var h = u.ResourceManager.instance.getResource(a), f = this.getSkeletonNameFromMeshAsset(a);
                if (h) {
                    l = this.getAnimationNameFromAsset(a);
                    n._bonesData[l] || (n._bonesData[l] = {});
                    var m = n._bonesData[l];
                    m[f] !== h && (m[f] = h)
                } else console.warn("get resource error,", a)
            }
            return r
        }, t.getSkeletonNameFromMeshAsset = function (e) {
            var t = e.split("-");
            return t[t.length - 2].split("/").pop()
        }, t.getAnimationNameFromAsset = function (e) {
            var t = e.split("-");
            return t[t.length - 1].split(".").shift()
        }, t.setBakedDataByAnimationName = function (e, t) {
            var r = null;
            n._bonesData[e] && (r = n._bonesData[e]), t.bonesData = r;
            var i = [];
            n._assets[e] && (i = n._assets[e]), t.assets = i
        }, t._assets = {}, t._bonesData = {}, t = n = _([Object(s.component)({isAbstract: !1})], t)
    }(s.Component);
    __reflect(b, "@egret/animation/BakedAnimationAsset");
    var x = function (e) {
        function t() {
            var t = null !== e && e.apply(this, arguments) || this;
            return t._glTFAnimationController = null, t
        }

        return m(t, e), t.createGLTF = function () {
            var e = l.GLTFAsset.createGLTF();
            return e.extensions = {egret: {animationControllers: [{layers: [], parameters: []}]}}, e
        }, t.create = function (e) {
            return void 0 === e && (e = null), this.fromGLTF(null !== e ? e : this.createGLTF())
        }, t.prototype._setGLTF = function (t) {
            e.prototype._setGLTF.call(this, t), this._glTFAnimationController = t.extensions.egret.animationControllers[0]
        }, t.prototype.uninitialize = function () {
            e.prototype.uninitialize.call(this), this._glTFAnimationController = null
        }, t.prototype.addLayer = function (e) {
            var t = {additive: !1, weight: 1, name: e, machine: {name: "Default", nodes: []}};
            return this._glTFAnimationController.layers.push(t), t
        }, t.prototype.createAnimationTree = function (e, t) {
            var n = {blendType: 0, timeScale: 1, name: t, parameters: [], nodes: []}, r = e.nodes;
            return r.indexOf(n) < 0 && r.push(n), n
        }, t.prototype.createAnimationNode = function (e, t, n) {
            var r = {asset: t, name: n, timeScale: 1}, i = e.nodes;
            return i.indexOf(r) < 0 && i.push(r), r
        }, t.prototype.getOrAddLayer = function (e) {
            var t = this._glTFAnimationController.layers;
            return e >= t.length && (e = t.length, this.addLayer("NoName")), t[e]
        }, Object.defineProperty(t.prototype, "layers", {
            get: function () {
                return this._glTFAnimationController.layers
            }, enumerable: !0, configurable: !0
        }), t = _([Object(s.component)({isAbstract: !1})], t)
    }(l.GLTFAsset);
    __reflect(x, "@egret/animation/AnimationController");
    var T = function (e) {
        function t() {
            var t = null !== e && e.apply(this, arguments) || this;
            return t._dirty = !1, t._jointNamesDirty = !1, t._jointNames = [], t._glTFAnimationMask = null, t
        }

        return m(t, e), t.createGLTF = function () {
            var e = l.GLTFAsset.createGLTF();
            return e.nodes = [], e.extensions = {egret: {animationMasks: [{retargeting: [], joints: []}]}}, e
        }, t.create = function (e) {
            return void 0 === e && (e = null), this.fromGLTF(null !== e ? e : this.createGLTF())
        }, t.prototype._setGLTF = function (t) {
            e.prototype._setGLTF.call(this, t), this._glTFAnimationMask = t.extensions.egret.animationMasks[0]
        }, t.prototype._addJoint = function (e, t, n, r) {
            if (t.indexOf(n) < 0 && (t.push(n), this._dirty = !0, this._jointNamesDirty = !0), r) {
                var i = e[n].children;
                if (!i) return;
                for (var o = 0, a = i; o < a.length; o++) {
                    var s = a[o];
                    this._addJoint(e, t, s, r)
                }
            }
        }, t.prototype.uninitialize = function () {
            e.prototype.uninitialize.call(this), this._dirty = !1, this._jointNamesDirty = !1, this._jointNames.length = 0, this._glTFAnimationMask = null
        }, t.prototype.createJoints = function (e) {
            var t = this._glTF.nodes;
            t.length = 0;
            for (var n = 0, r = e.glTF.nodes; n < r.length; n++) {
                var i = r[n], o = {name: i.name};
                i.children && (o.children = i.children.concat()), t.push(o)
            }
            return this
        }, t.prototype.addJoint = function (e, t) {
            void 0 === t && (t = !0);
            for (var n = this._glTF.nodes, r = this._glTFAnimationMask.joints, i = 0, o = 0, a = n; o < a.length; o++) {
                if (a[o].name === e) return this._addJoint(n, r, i, t), this;
                i++
            }
            return console.warn("Invalid joint mask name.", e), this
        }, t.prototype.removeJoint = function (e, t) {
            for (var n = this._glTF.nodes, r = this._glTFAnimationMask.joints, i = 0, o = 0, a = n; o < a.length; o++) {
                if (a[o].name === e) {
                    r.indexOf(i) >= 0 && r.splice(i, 1);
                    break
                }
                i++
            }
            return this
        }, t.prototype.removeJoints = function () {
            return this._glTFAnimationMask.joints.length = 0, this._dirty = !0, this._jointNamesDirty = !0, this
        }, Object.defineProperty(t.prototype, "jointNames", {
            get: function () {
                var e = this._jointNames;
                if (this._jointNamesDirty) {
                    var t = this._glTF.nodes, n = this._glTFAnimationMask.joints;
                    e.length = 0;
                    for (var r = 0, i = n; r < i.length; r++) {
                        var o = i[r];
                        e.push(t[o].name)
                    }
                    this._jointNamesDirty = !1
                }
                return e
            }, enumerable: !0, configurable: !0
        }), t = _([Object(s.component)({isAbstract: !1})], t)
    }(l.GLTFAsset);
    __reflect(T, "@egret/animation/AnimationMask");
    var E = function (e) {
        function t() {
            var t = null !== e && e.apply(this, arguments) || this;
            return t.bonesData = [], t._currentInex = 0, t.skeleton = "", t.targetTransfrom = null, t
        }

        return m(t, e), Object.defineProperty(t.prototype, "currentIndex", {
            set: function (e) {
                e !== this._currentInex && (this._currentInex = e >= 0 ? e : 0)
            }, enumerable: !0, configurable: !0
        }), t.prototype.initialize = function () {
        }, t.prototype.uninitialize = function () {
            this.targetTransfrom = null
        }, t.prototype.updateTransform = function () {
            if (this._currentInex < this.bonesData.length) {
                var e = this.bonesData, t = this._currentInex, n = e[t].position, r = e[t].rotation, i = e[t].scale;
                this.targetTransfrom.setLocalPosition(n[0], n[1], n[2]), this.targetTransfrom.setLocalRotation(r[0], r[1], r[2], r[3]), this.targetTransfrom.setLocalScale(i[0], i[1], i[2])
            }
        }, t = _([Object(s.component)({isAbstract: !1})], t)
    }(c.GameComponent);
    __reflect(E, "@egret/animation/MeshRendererHelper");
    var C = function (e) {
        function t() {
            var t = null !== e && e.apply(this, arguments) || this;
            return t.dirty = 0, t.weight = 0, t.totalWeight = 0, t.target = null, t.bindPose = null, t.layer = null, t.quaternions = null, t.quaternionWeights = null, t.morphWeight = [], t.updateTarget = null, t
        }

        return m(t, e), t.create = function () {
            var e = p.Pool.getPool(this, !0).borrow();
            return e.initialize(), e
        }, t.prototype.uninitialize = function () {
            if (e.prototype.uninitialize.call(this), this.clear(), this.quaternions) for (var t = 0, n = this.quaternions; t < n.length; t++) {
                n[t].release()
            }
            this.bindPose && this.bindPose.release && this.bindPose.release(), this.target = null, this.bindPose = null, this.updateTarget = null, this.quaternions = null, this.quaternionWeights = null
        }, t.prototype.clear = function () {
            this.dirty = 0, this.weight = 1, this.totalWeight = 0, this.layer = null;
            var e = this.quaternionWeights;
            if (e) for (var t = 0, n = e.length; t < n; ++t) e[t] = 0
        }, t.prototype.updateBlend = function (e, t) {
            var n = t._globalWeight;
            return this.dirty > 0 ? e.additive ? (this.dirty++, this.weight = n, !0) : this.layer === t.animationLayer ? (this.dirty++, this.weight = n, this.totalWeight += this.weight, !0) : this.totalWeight < .9999999999999998 && (this.dirty++, this.weight = n * (1 - this.totalWeight), this.totalWeight += this.weight, this.layer = t.animationLayer, !0) : (this.dirty++, this.weight = n, this.layer = t.animationLayer, e.additive || (this.totalWeight += n), !0)
        }, t.prototype.onUpdateTranslation = function () {
            var e = this.target.localPosition;
            if (this.totalWeight < .9999999999999998) {
                var t = 1 - this.totalWeight, n = this.bindPose;
                this.dirty > 0 ? (e.x += n.x * t, e.y += n.y * t, e.z += n.z * t) : (e.x = n.x * t, e.y = n.y * t, e.z = n.z * t)
            }
            e.updater.update()
        }, t.prototype.onUpdateRotation = function () {
            var e = this.target.localRotation, t = this.bindPose, n = this.quaternions;
            if (n) for (var r = !1, i = n.length; i--;) {
                var o = n[i];
                0 !== (a = this.quaternionWeights[i]) && (a < 0 ? (o.lerp(c.Quaternion.IDENTITY, o, -a), r || (e.rawData[0] = t.rawData[0], e.rawData[1] = t.rawData[1], e.rawData[2] = t.rawData[2], e.rawData[3] = t.rawData[3]), e.multiply(o, e)) : (1 !== a && (o.dot(e) < 0 && (a = -a), o.rawData[0] *= a, o.rawData[1] *= a, o.rawData[2] *= a, o.rawData[3] *= a), r ? (e.rawData[0] += o.rawData[0], e.rawData[1] += o.rawData[1], e.rawData[2] += o.rawData[2], e.rawData[3] += o.rawData[3]) : (e.rawData[0] = o.rawData[0], e.rawData[1] = o.rawData[1], e.rawData[2] = o.rawData[2], e.rawData[3] = o.rawData[3])), r = !0)
            }
            if (this.totalWeight < .9999999999999998) {
                var a = 1 - this.totalWeight;
                t.dot(e) < 0 && (a = -a), this.dirty > 0 ? (e.rawData[0] += t.rawData[0] * a, e.rawData[1] += t.rawData[1] * a, e.rawData[2] += t.rawData[2] * a, e.rawData[3] += t.rawData[3] * a) : (e.rawData[0] = t.rawData[0] * a, e.rawData[1] = t.rawData[1] * a, e.rawData[2] = t.rawData[2] * a, e.rawData[3] = t.rawData[3] * a)
            }
            e.normalize(), e.updater.update()
        }, t.prototype.onUpdateScale = function () {
            var e = this.target.localScale;
            if (this.totalWeight < .9999999999999998) {
                var t = 1 - this.totalWeight, n = this.bindPose;
                this.dirty > 0 ? (e.x += n.x * t, e.y += n.y * t, e.z += n.z * t) : (e.x = n.x * t, e.y = n.y * t, e.z = n.z * t)
            }
            e.updater.update()
        }, t.prototype.onUpdateMorph = function () {
            var e;
            if (null !== this.target.entity.getComponent(l.MeshRenderer)) e = this.target.entity.getComponent(l.MeshRenderer); else {
                if (null === this.target.entity.getComponent(l.SkinnedMeshRenderer)) return;
                e = this.target.entity.getComponent(l.SkinnedMeshRenderer)
            }
            null === e.weight && (e.weight = new Float32Array(8));
            for (var t = 0; t < this.morphWeight.length; t++) e.weight[t] = this.morphWeight[t]
        }, t = _([Object(p.pool)()], t)
    }(p.Releasable);
    __reflect(C, "@egret/animation/AnimationBinder");
    var S = c.Quaternion.create(), M = function (e) {
        function t() {
            var t = null !== e && e.apply(this, arguments) || this;
            return t.enabled = !0, t.glTFChannel = null, t.glTFSampler = null, t.inputBuffer = null, t.outputBuffer = null, t.updateTarget = null, t.needUpdate = null, t
        }

        return m(t, e), t.create = function () {
            var e = p.Pool.getPool(this, !0).borrow();
            return e.initialize(), e
        }, t.prototype.uninitialize = function () {
            e.prototype.uninitialize.call(this), this.enabled = !0, this.updateTarget = null, this.needUpdate = null
        }, t.prototype.onUpdateTranslation = function (e, t, n) {
            var r, i, o, a = e.additive, s = t._currentTime, l = this.glTFSampler.interpolation, u = this.outputBuffer,
                c = this.getFrameIndex(s);
            if (c >= 0) {
                var p = 3 * c;
                if (r = u[p++], i = u[p++], o = u[p++], !l || "STEP" !== l) {
                    var d = this.inputBuffer, h = d[c], f = (s - h) / (d[c + 1] - h);
                    r += (u[p++] - r) * f, i += (u[p++] - i) * f, o += (u[p++] - o) * f
                }
            } else r = u[0], i = u[1], o = u[2];
            a && (r -= u[0], i -= u[1], o -= u[2]);
            var m = n.weight, _ = n.target.localPosition, g = t.animationClip;
            if (this.glTFChannel.target.node === g.root) {
                var v = g.applyRootMotion || 5;
                1 !== m && (0 == (1 & v) && (r *= m), 0 == (2 & v) && (i *= m), 0 == (4 & v) && (o *= m)), n.dirty > 1 ? (0 == (1 & v) && (_.x += r, r = 0), 0 == (2 & v) && (_.y += i, i = 0), 0 == (4 & v) && (_.z += o, o = 0)) : (0 != (1 & v) ? _.x = u[0] : (_.x = r, r = 0), 0 != (2 & v) ? _.y = u[1] : (_.y = i, i = 0), 0 != (4 & v) ? _.z = u[2] : (_.z = o, o = 0)), t._applyRootMotion(r, i, o, m, s, this)
            } else 1 !== m && (r *= m, i *= m, o *= m), n.dirty > 1 ? (_.x += r, _.y += i, _.z += o) : (_.x = r, _.y = i, _.z = o)
        }, t.prototype.onUpdateRotation = function (e, t, n) {
            var r, i, o, a, s = e.additive, l = this.glTFSampler.interpolation, u = this.outputBuffer,
                p = t._currentTime, d = this.getFrameIndex(p);
            if (d >= 0) {
                var h = 4 * d;
                if (r = u[h++], i = u[h++], o = u[h++], a = u[h++], void 0 === l || "STEP" !== l) {
                    var f = this.inputBuffer, m = f[d], _ = (p - m) / (f[d + 1] - m);
                    r += (u[h++] - r) * _, i += (u[h++] - i) * _, o += (u[h++] - o) * _, a += (u[h++] - a) * _
                }
            } else r = u[0], i = u[1], o = u[2], a = u[3];
            var g = n.weight, v = n.target.localRotation, y = n.quaternions;
            if (null !== y) {
                var b = void 0, x = n.dirty - 1;
                y.length <= x && y.push(c.Quaternion.create()), b = y[x], s ? (b.rawData[0] = -u[0], b.rawData[1] = -u[1], b.rawData[2] = -u[2], b.rawData[3] = u[3], b.multiply(S.set(r, i, o, a), b), n.quaternionWeights[x] = -g) : (b.rawData[0] = r, b.rawData[1] = i, b.rawData[2] = o, b.rawData[3] = a, n.quaternionWeights[x] = g)
            } else 1 !== g && (S.set(r, i, o, a).dot(v) < 0 && (g = -g), r *= g, i *= g, o *= g, a *= g), n.dirty > 1 ? (v.rawData[0] += r, v.rawData[1] += i, v.rawData[2] += o, v.rawData[3] += a) : (v.rawData[0] = r, v.rawData[1] = i, v.rawData[2] = o, v.rawData[3] = a)
        }, t.prototype.onUpdateScale = function (e, t, n) {
            var r, i, o, a = e.additive, s = this.glTFSampler.interpolation, l = this.outputBuffer, u = t._currentTime,
                c = this.getFrameIndex(u);
            if (c >= 0) {
                var p = 3 * c;
                if (r = l[p++], i = l[p++], o = l[p++], void 0 === s || "STEP" !== s) {
                    var d = this.inputBuffer, h = d[c], f = (u - h) / (d[c + 1] - h);
                    r += (l[p++] - r) * f, i += (l[p++] - i) * f, o += (l[p++] - o) * f
                }
            } else r = l[0], i = l[1], o = l[2];
            a && (r -= l[0], i -= l[1], o -= l[2]);
            var m = n.weight, _ = n.target.localScale;
            1 !== m && (r *= m, i *= m, o *= m), n.dirty > 1 ? (_.x += r, _.y += i, _.z += o) : (_.x = r, _.y = i, _.z = o)
        }, t.prototype.onUpdateMorph = function (e, t, n) {
            var r = e.additive, i = this.glTFSampler.interpolation, o = this.outputBuffer, a = t._currentTime,
                s = this.getFrameIndex(a), l = this.outputBuffer.length / this.inputBuffer.length, u = [];
            if (s >= 0) {
                for (var c = s * l, p = 0; p < l; p++) u.push(o[c++]);
                if (void 0 === i || "STEP" !== i) {
                    var d = this.inputBuffer, h = d[s], f = (a - h) / (d[s + 1] - h);
                    for (p = 0; p < l; p++) u[p] += (o[c++] - u[p]) * f
                }
            } else for (p = 0; p < l; p++) u.push(o[p]);
            if (r) for (p = 0; p < l; p++) u[p] -= o[p];
            var m = n.weight;
            if (1 !== m) for (p = 0; p < l; p++) u[p] *= m;
            if (n.dirty > 1) for (p = 0; p < l; p++) n.morphWeight[p] += u[p]; else for (p = 0; p < l; p++) n.morphWeight[p] = u[p]
        }, t.prototype.onUpdateActive = function (e, t, n) {
            var r = t._currentTime, i = this.outputBuffer, o = this.getFrameIndex(r);
            n.target.entity.enabled = 0 !== (o >= 0 ? i[o] : i[0])
        }, t.prototype.onUpdateFloat = function (e, t, n) {
            var r, i = e.additive, o = this.glTFSampler.interpolation, a = this.outputBuffer, s = t._currentTime,
                l = this.getFrameIndex(s), u = this.glTFChannel.extensions.egret;
            if (l >= 0) {
                var c = l;
                if (r = a[c++], void 0 === o || "STEP" !== o) {
                    var p = this.inputBuffer, d = p[l], h = (s - d) / (p[l + 1] - d);
                    r += (a[c++] - r) * h
                }
            } else r = a[0];
            i && (r -= a[0]), n.target[u.property] = r, null !== this.needUpdate && this.needUpdate(u.needUpdate)
        }, t.prototype.getFrameIndex = function (e) {
            var t = this.inputBuffer, n = t.length;
            if (0 === n) throw new Error;
            if (1 === n) return -1;
            if (e <= t[0]) return 0;
            if (e >= t[n - 1]) return n - 2;
            for (var r = 0, i = n - 1; i - r > 1;) {
                var o = r + .5 * (i - r) >> 0;
                e >= t[o] ? r = o : i = o
            }
            return r
        }, t = _([Object(p.pool)()], t)
    }(p.Releasable);
    __reflect(M, "@egret/animation/AnimationChannel");
    var A = c.Vector3.create(), O = function (e) {
        function t() {
            var t = null !== e && e.apply(this, arguments) || this;
            return t.fadeState = -1, t.subFadeState = -1, t.progress = 0, t.time = 0, t.totalTime = 0, t.states = [], t
        }

        return m(t, e), t.create = function () {
            var e = p.Pool.getPool(this, !0).borrow();
            return e.initialize(), e
        }, t.prototype.uninitialize = function () {
            e.prototype.uninitialize.call(this);
            for (var t = 0, n = this.states; t < n.length; t++) {
                n[t].release()
            }
            this.fadeState = -1, this.subFadeState = -1, this.progress = 0, this.time = 0, this.totalTime = 0, this.states.length = 0
        }, t.prototype.fadeOut = function (e) {
            if (this.fadeState > 0) {
                if (e > this.totalTime - this.time) return this
            } else this.fadeState = 1, this.subFadeState = -1, (e <= 0 || this.progress <= 0) && (this.progress = 2220446049250313e-31);
            return this.totalTime = this.progress > 2220446049250313e-31 ? e / this.progress : 0, this.time = this.totalTime * (1 - this.progress), this
        }, t = _([Object(p.pool)()], t)
    }(p.Releasable);
    __reflect(O, "@egret/animation/AnimationFadeState");
    var w = function (e) {
        function t() {
            var t = null !== e && e.apply(this, arguments) || this;
            return t.weight = 1, t.animationLayer = null, t.animationNode = null, t._globalWeight = 0, t._globalTimeScale = 1, t._parent = null, t
        }

        return m(t, e), t.prototype.uninitialize = function () {
            e.prototype.uninitialize.call(this), this.weight = 1, this.animationLayer = null, this.animationNode = null, this._globalWeight = 0, this._globalTimeScale = 1, this._parent = null
        }, t
    }(p.Releasable);
    __reflect(w, "@egret/animation/AnimationBaseState");
    var R = function (e) {
        function t() {
            return null !== e && e.apply(this, arguments) || this
        }

        return m(t, e), t.create = function () {
            var e = p.Pool.getPool(this, !0).borrow();
            return e.initialize(), e
        }, Object.defineProperty(t.prototype, "name", {
            get: function () {
                return this.animationNode.name
            }, enumerable: !0, configurable: !0
        }), t = _([Object(p.pool)()], t)
    }(w);
    __reflect(R, "@egret/animation/AnimationTreeState");
    var P = function (e) {
        function t() {
            var t = null !== e && e.apply(this, arguments) || this;
            return t.playTimes = 0, t.currentPlayTimes = 0, t.animationAsset = null, t.animation = null, t.animationClip = null, t._playheadEnabled = !0, t._playState = -1, t._timeScale = 1, t._time = 0, t._currentTime = -1, t._lastRootMotionRotation = 0, t._channelBinders = {}, t._lastRootMotionPosition = null, t._animation = null, t
        }

        return m(t, e), t.create = function () {
            var e = p.Pool.getPool(this, !0).borrow();
            return e.initialize(), e
        }, t.prototype._applyRootMotion = function (e, t, n, r, i, o) {
            if (this._animation.applyRootMotion) {
                this._lastRootMotionPosition || (this._lastRootMotionPosition = c.Vector4.create());
                var a = this._animation.entity.transform, s = this._lastRootMotionPosition;
                if (this._animation.timeScale * this.timeScale > 0) s.w > i && (this._lastRootMotionRotation = 0, s.set(0, 0, 0, 0)); else if (s.w < i) {
                    var l = this.animationClip.applyRootMotion || 5, u = o.outputBuffer, p = u.length - 3;
                    this._lastRootMotionRotation = 0, s.set(1 & l ? u[p] : 0, 2 & l ? u[p + 1] : 0, 4 & l ? u[p + 2] : 0, this.animationClip.duration)
                }
                var d = A.set(e, t, n).subtract(s).applyMatrix3(a.localMatrix).multiplyScalar(r);
                a.translate(d), s.set(e, t, n, i)
            }
        }, t.prototype._initialize = function (e, t, n, r, i) {
            var o = r.glTF;
            if (this.animationAsset = r, this.animation = o.animations[0], this.animationClip = i, this.animationLayer = t, this.animationNode = n, this._animation = e, this.animation.channels) {
                var a = t.mask, s = a ? a.jointNames : null, l = e.entity, u = l.node.getChildren({});
                u.__root__ = l.node;
                for (var p = 0, d = 0, h = this.animation.channels; d < h.length; d++) {
                    var f = h[d], m = f.target.node, _ = f.target.path, g = f.extensions ? f.extensions.egret : null;
                    if (void 0 === m) console.warn("Unknown animation channel.", _); else {
                        var v = this.animationAsset.getNode(m).name;
                        if (!(v in u) || s && s.indexOf(v) < 0) continue;
                        var y = u[v];
                        Array.isArray(y) && (y = y[0]);
                        var b = this.animation.extras, x = null;
                        void 0 !== b && (p in b.channels ? x = b.channels[p] : ((x = M.create()).glTFChannel = f, x.glTFSampler = this.animation.samplers[f.sampler], x.inputBuffer = this.animationAsset.createTypeArrayFromAccessor(this.animationAsset.getAccessor(x.glTFSampler.input)), x.outputBuffer = this.animationAsset.createTypeArrayFromAccessor(this.animationAsset.getAccessor(x.glTFSampler.output)), b.channels[p] = x));
                        var T = y.entity.transform, E = null;
                        switch (g || ((E = this._channelBinders[p] = e._getBinder(v, _)).target = T), _) {
                            case"translation":
                                x.updateTarget = x.onUpdateTranslation, null === E.bindPose && (E.bindPose = c.Vector3.create().copy(T.localPosition), E.updateTarget = E.onUpdateTranslation);
                                break;
                            case"rotation":
                                x.updateTarget = x.onUpdateRotation, null === E.bindPose && (E.bindPose = c.Quaternion.create().copy(T.localRotation), E.updateTarget = E.onUpdateRotation), t.additive && !E.quaternions && (E.quaternions = [], E.quaternionWeights = []);
                                break;
                            case"scale":
                                x.updateTarget = x.onUpdateScale, null === E.bindPose && (E.bindPose = c.Vector3.create().copy(T.localScale), E.updateTarget = E.onUpdateScale);
                                break;
                            case"weights":
                                x.updateTarget = x.onUpdateMorph, E.updateTarget = E.onUpdateMorph;
                                break;
                            case"custom":
                                break;
                            default:
                                console.warn("Unknown animation channel.", _)
                        }
                    }
                    p++
                }
            }
        }, t.prototype.uninitialize = function () {
            e.prototype.uninitialize.call(this), this._lastRootMotionPosition && this._lastRootMotionPosition.release(), this.playTimes = 0, this.currentPlayTimes = 0, this.animationAsset = null, this.animation = null, this.animationClip = null, this._playheadEnabled = !0, this._playState = -1, this._timeScale = 1, this._time = 0, this._currentTime = -1, this._lastRootMotionRotation = 0, this._lastRootMotionPosition = null, this._animation = null
        }, t.prototype.play = function () {
            return this._playheadEnabled = !0, this
        }, t.prototype.stop = function () {
            return this._playheadEnabled = !1, this
        }, Object.defineProperty(t.prototype, "isPlaying", {
            get: function () {
                return this._playheadEnabled && 1 !== this._playState
            }, enumerable: !0, configurable: !0
        }), Object.defineProperty(t.prototype, "isCompleted", {
            get: function () {
                return 1 === this._playState
            }, enumerable: !0, configurable: !0
        }), Object.defineProperty(t.prototype, "timeScale", {
            get: function () {
                return this._timeScale
            }, set: function (e) {
                e != e && (e = 0), this._timeScale = e
            }, enumerable: !0, configurable: !0
        }), Object.defineProperty(t.prototype, "totalTime", {
            get: function () {
                return this.animationClip.duration
            }, enumerable: !0, configurable: !0
        }), Object.defineProperty(t.prototype, "currentTime", {
            get: function () {
                return this._currentTime
            }, enumerable: !0, configurable: !0
        }), Object.defineProperty(t.prototype, "name", {
            get: function () {
                return null !== this.animationClip ? this.animationClip.name : ""
            }, enumerable: !0, configurable: !0
        }), t = _([Object(p.pool)()], t)
    }(w);
    __reflect(P, "@egret/animation/AnimationState");
    var L = function (e) {
        function t(e) {
            return this.$autoPlay = !1, this.$timeScale = 1, this.entity = e, this
        }

        return m(t, DebuggerClass), t.prototype.getAutoPlay = function () {
            return this.$autoPlay
        }, t.prototype.setAutoPlay = function (e) {
            this.$autoPlay !== e && (this.$autoPlay = e)
        }, t.prototype.getTimeScale = function () {
            return this.$timeScale
        }, Object.defineProperty(t.prototype, "animations", {
            get: function () {
                var e = this.entity.getComponent(k);
                return e ? e._animations : []
            }, enumerable: !0, configurable: !0
        }), t.prototype.release = function () {
            this.entity = null, this.$autoPlay = !1, this.$timeScale = 1
        }, t
    }();
    __reflect(L, "@egret/animation/Animator");
    var D = function (e) {
        function t() {
            var t = null !== e && e.apply(this, arguments) || this;
            return t._animationController = null, t._lastAnimationLayer = null, t._binders = {}, t._fadeStates = [], t
        }

        return m(t, e), t.prototype.getAnimationController = function () {
            return null === this._animationController && (this._animationController = x.create()), this._animationController
        }, t.prototype.getFadeStates = function () {
            return this._fadeStates
        }, t.prototype.getLastAnimationState = function () {
            var e = this._animationController, t = this._lastAnimationLayer;
            if (null !== e && null !== t) {
                var n = e.layers.indexOf(t), r = this._fadeStates;
                if (r.length > n) {
                    var i = r[n];
                    if (i.length > 0) {
                        var o = i[i.length - 1].states, a = o[o.length - 1];
                        if (a.constructor === P) return a
                    }
                }
            }
            return null
        }, t.prototype.setTimeScale = function (e) {
            this.$timeScale = e
        }, t.prototype.play = function (e, t) {
            void 0 === e && (e = ""), void 0 === t && (t = -1), null === this._animationController && (this._animationController = x.create());
            var n = this._animationController.getOrAddLayer(0);
            n._clipNames || (n._clipNames = []);
            var r = n._clipNames;
            if (r.length = 0, Array.isArray(e)) if (e.length > 0) {
                for (var i = 0, o = e; i < o.length; i++) {
                    var a = o[i];
                    r.push(a)
                }
                e = r.shift()
            } else e = "";
            var s = null;
            if ("" !== e) s = this.fadeIn(e, 0, t); else {
                var l = this.getLastAnimationState();
                if (null !== l) l.isPlaying || l.isCompleted ? s = this.fadeIn(l.animationClip.name, 0, t) : (s = l, l.play()); else {
                    var u = this.animations;
                    if (u.length > 0) {
                        var c = u[0];
                        null !== c && (e = c.glTF.animations[0].extensions.egret.clips[0].name, s = this.fadeIn(e, 0, t))
                    }
                }
            }
            return s
        }, t.prototype.stop = function (e, t) {
            if (void 0 === e && (e = ""), void 0 === t && (t = 0), e) null !== (l = this.getState(e, t)) && l.constructor === P && l.stop(); else for (var n = 0, r = this._fadeStates; n < r.length; n++) for (var i = 0, o = r[n]; i < o.length; i++) for (var a = 0, s = o[i].states; a < s.length; a++) {
                var l;
                (l = s[a]).constructor === P && l.stop()
            }
        }, t.prototype.fadeIn = function (e, t, n, r, i) {
            void 0 === n && (n = -1), void 0 === r && (r = 0), void 0 === i && (i = !1), this._animationController || (this._animationController = x.create());
            var o = this._animationController;
            if (r > o.layers.length) return console.warn("The animation layers must be continuous."), null;
            var a = o.getOrAddLayer(r);
            a.additive = i;
            for (var s = null, l = null, c = null, p = 0, d = this.animations; p < d.length && (!(s = d[p]) || null === (l = s.getAnimationClip(e))); p++) ;
            if (!s || !l) {
                for (var h = 0, f = a.machine.nodes; h < f.length; h++) {
                    var m = f[h];
                    m.name === e && (c = m)
                }
                if (!c) return console.warn('There is no animation clip named "' + e + '" in the "' + this.entity.node.path + '" GameEntity.'), null
            }
            var _ = this._fadeStates;
            r >= _.length && (_[r] = []);
            for (var g = 0, v = _[r]; g < v.length; g++) {
                v[g].fadeOut(t)
            }
            var y = O.create();
            if (y.totalTime = t, _[r].push(y), c) {
                var b = R.create();
                b.animationLayer = a, b.animationNode = c, y.states.push(b);
                for (var T = 0, E = c.nodes; T < E.length; T++) {
                    var C = E[T];
                    if ((s = u.ResourceManager.instance.getResource(C.asset)) && (l = s.getAnimationClip(C.name))) {
                        var S = P.create();
                        S._parent = b, S._initialize(this.entity.getComponent(k), a, null, s, l), S.playTimes = n < 0 ? l.playTimes || 0 : n, y.states.push(S)
                    }
                }
                return this._lastAnimationLayer = a, null
            }
            var M = P.create();
            return M._initialize(this.entity.getComponent(k), a, null, s, l), M.playTimes = n < 0 ? l.playTimes || 0 : n, y.states.push(M), this._lastAnimationLayer = a, M
        }, t.prototype.getState = function (e, t) {
            void 0 === t && (t = 0);
            var n = this._fadeStates;
            if (n.length > t) for (var r = n[t], i = r.length; i--;) for (var o = 0, a = r[i].states; o < a.length; o++) {
                var s = a[o];
                if (s.name === e) return s
            }
            return null
        }, t.prototype.getBinders = function () {
            return this._binders
        }, t.prototype.hasAnimation = function (e) {
            for (var t = 0, n = this.animations; t < n.length; t++) {
                var r = n[t];
                if (null !== r) if (null !== r.getAnimationClip(e)) return !0
            }
            return !1
        }, t.prototype.uninitialize = function () {
            for (var e = 0, t = this._fadeStates; e < t.length; e++) for (var n = 0, r = t[e]; n < r.length; n++) {
                r[n].release()
            }
            var i = this._binders;
            for (var o in i) i[o].release(), delete i[o];
            this.animations.length = 0, this._fadeStates.length = 0, this._animationController = null, this._lastAnimationLayer = null
        }, t
    }(L);
    __reflect(D, "@egret/animation/AnimationAnimator");
    var I = function (e) {
        function t() {
            var t = null !== e && e.apply(this, arguments) || this;
            return t.playTimes = 0, t.currentPlayTimes = 0, t.animationAsset = null, t._frameRate = 60, t._playheadEnabled = !1, t._playState = -1, t._timeScale = 1, t._currentTime = 0, t._currentFrame = 0, t._totalFrame = 0, t
        }

        return m(t, e), t.create = function () {
            var e = p.Pool.getPool(this, !0).borrow();
            return e.initialize(), e
        }, t.prototype._initialize = function (e, t) {
            this.animationAsset = t, this._totalFrame = t.texture.width, this.timeScale = e.timeScale, this._frameRate = t.frameRate
        }, t.prototype.uninitialize = function () {
            this.playTimes = 0, this.currentPlayTimes = 0, this._totalFrame = 0, this._currentTime = 0, this._currentFrame = 0, this._timeScale = 1, this._playState = -1, this._playheadEnabled = !1, this._frameRate = 60
        }, t.prototype.play = function () {
            return this._playheadEnabled = !0, this
        }, t.prototype.stop = function () {
            return this._playheadEnabled = !1, this
        }, Object.defineProperty(t.prototype, "isPlaying", {
            get: function () {
                return this._playheadEnabled && 1 !== this._playState
            }, enumerable: !0, configurable: !0
        }), Object.defineProperty(t.prototype, "isCompleted", {
            get: function () {
                return 1 === this._playState
            }, enumerable: !0, configurable: !0
        }), Object.defineProperty(t.prototype, "isLoop", {
            get: function () {
                return 0 === this.playTimes
            }, enumerable: !0, configurable: !0
        }), Object.defineProperty(t.prototype, "timeScale", {
            get: function () {
                return this._timeScale
            }, set: function (e) {
                e != e && (e = 0), this._timeScale = e
            }, enumerable: !0, configurable: !0
        }), Object.defineProperty(t.prototype, "totalTime", {
            get: function () {
                return this._totalFrame / this._frameRate
            }, enumerable: !0, configurable: !0
        }), Object.defineProperty(t.prototype, "currentTime", {
            get: function () {
                return this._currentTime
            }, set: function (e) {
                e !== this._currentTime && (this._currentTime = e > 0 ? e : 0, this.currentFrame = Math.floor(this._currentTime * this._frameRate))
            }, enumerable: !0, configurable: !0
        }), Object.defineProperty(t.prototype, "totalFrame", {
            get: function () {
                return this._totalFrame
            }, enumerable: !0, configurable: !0
        }), Object.defineProperty(t.prototype, "currentFrame", {
            get: function () {
                return this._currentFrame
            }, set: function (e) {
                e !== this._currentFrame && (this._currentFrame = e > 0 ? e : 0)
            }, enumerable: !0, configurable: !0
        }), Object.defineProperty(t.prototype, "frameRate", {
            get: function () {
                return this._frameRate
            }, enumerable: !0, configurable: !0
        }), Object.defineProperty(t.prototype, "name", {
            get: function () {
                return null !== this.animationAsset ? this.animationAsset.name : ""
            }, enumerable: !0, configurable: !0
        }), t = _([Object(p.pool)()], t)
    }(w);
    __reflect(I, "@egret/animation/BakedAnimationState");
    var N = function (e) {
        function t() {
            var t = null !== e && e.apply(this, arguments) || this;
            return t.renders = [], t.helpers = [], t.skeletonNames = [], t.hasLoadedAnimatins = [], t._assets = [], t.bonesData = {}, t._totalFrame = 0, t.totalFrame = 0, t._lastAnimationState = null, t
        }

        return m(t, e), t.prototype.getAnimationController = function () {
            return console.warn("Invalid function in BakedAnimator"), null
        }, t.prototype.getLastAnimationState = function () {
            return this.lastAnimationState
        }, t.prototype.getFadeStates = function () {
            return console.warn("Invalid function in BakedAnimator"), []
        }, t.prototype.setTimeScale = function (e) {
            this.$timeScale = e, this._lastAnimationState && (this._lastAnimationState.timeScale = this.$timeScale)
        }, t.prototype.getBinders = function () {
            return console.warn("Invalid function in BakedAnimator"), null
        }, t.prototype.play = function (e, t) {
            if (void 0 === e && (e = ""), void 0 === t && (t = 0), Array.isArray(e)) {
                if (0 === e.length) return null;
                e = e[0]
            }
            if (this._lastAnimationState) {
                if ("" === e && !this._lastAnimationState.isCompleted) return this._lastAnimationState.play(), null;
                this._lastAnimationState.uninitialize()
            }
            if (0 === this.animations.length || "" !== e && !1 === this.hasAnimation(e)) return console.warn('There is no animation clip named "' + e + '" in the "' + this.entity.node.path + '" GameEntity.'), null;
            "" === e && (this.hasAnimation(e), e = this.hasLoadedAnimatins[0]), b.setBakedDataByAnimationName(e, this);
            var n = this.assets[0];
            if (!n) return null;
            var r = this._lastAnimationState = I.create();
            return r._initialize(this.entity.getComponent(k), n), 0 !== this.renders.length || 0 !== this.helpers.length ? (r.playTimes = t < 0 ? 0 : t, r.play(), r) : null
        }, t.prototype.stop = function (e) {
            if (void 0 === e && (e = ""), e) {
                var t = this.lastAnimationState;
                null !== t && t.constructor === I && t.stop()
            } else this.lastAnimationState && this.lastAnimationState.stop()
        }, t.prototype.getState = function (e, t) {
            return console.warn("Invalid function in BakedAnimator"), null
        }, t.prototype.fadeIn = function (e, t, n, r, i) {
            return console.warn("Invalid function in BakedAnimator"), null
        }, t.prototype.hasAnimation = function (e) {
            for (var t = 0, n = this.hasLoadedAnimatins; t < n.length; t++) {
                if (n[t] === e) return !0
            }
            this.hasLoadedAnimatins = b.getBakedAnimationAssetsByConfig(this.entity.getComponent(k).bakedAnimationConfig.assetPath);
            for (var r = 0, i = this.hasLoadedAnimatins; r < i.length; r++) {
                if (i[r] === e) return !0
            }
            return !1
        }, t.prototype.getAssetBySkeleton = function (e) {
            for (var t = 0, n = this._assets; t < n.length; t++) {
                var r = n[t];
                if (r.skeletonName === e) return r
            }
            return null
        }, t.prototype.getBonesDataBySkeleton = function (e) {
            return this.bonesData ? this.bonesData[e] : null
        }, t.prototype.updateRenders = function () {
            for (var e = 0, t = this.renders; e < t.length; e++) {
                t[e].currentFrame = this.currentFrame
            }
        }, t.prototype.updateHelpers = function () {
            for (var e = 0, t = this.helpers; e < t.length; e++) {
                var n = t[e];
                n.currentIndex = this.currentFrame, n.updateTransform()
            }
        }, Object.defineProperty(t.prototype, "assets", {
            get: function () {
                return this._assets
            }, set: function (e) {
                if (e !== this._assets) {
                    this._assets.length = 0;
                    for (var t = 0, n = e; t < n.length; t++) {
                        var r = n[t];
                        this._assets.push(r), this.hasLoadedAnimatins.indexOf(r.name) < 0 && this.hasLoadedAnimatins.push(r.name)
                    }
                    if (this._assets.length > 0) {
                        for (var i = 0, o = this.renders; i < o.length; i++) {
                            var a = o[i];
                            (r = this.getAssetBySkeleton(a.entity.node.name)) && (a.boneTexture = r.texture)
                        }
                        for (var s = 0, l = this.helpers; s < l.length; s++) {
                            var u = l[s], c = this.getBonesDataBySkeleton(u.skeleton);
                            c && (u.bonesData = c)
                        }
                        this._totalFrame = this._assets[0].texture ? this._assets[0].texture.width : 0
                    } else this._totalFrame = 0
                }
            }, enumerable: !0, configurable: !0
        }), Object.defineProperty(t.prototype, "currentFrame", {
            get: function () {
                return this._lastAnimationState ? this._lastAnimationState.currentFrame : 0
            }, enumerable: !0, configurable: !0
        }), Object.defineProperty(t.prototype, "lastAnimationState", {
            get: function () {
                return this._lastAnimationState
            }, enumerable: !0, configurable: !0
        }), t.prototype.uninitialize = function () {
            this.animations.length = 0
        }, t
    }(L);
    __reflect(N, "@egret/animation/BakedAnimator");
    var z = function (e) {
        function t() {
            return null !== e && e.apply(this, arguments) || this
        }

        return m(t, e), t.initialize = function (e, t) {
            return e && this.$getSupportExtension() ? new N(t) : new D(t)
        }, t.$getSupportExtension = function () {
            if (void 0 === t.SUPORT_FLOAT_TEXTURE) {
                var e = Object(d.getSupportedExtensions)(), n = !1;
                if (null === e) return t.SUPORT_FLOAT_TEXTURE = n = !1, n;
                for (var r = 0, i = e; r < i.length; r++) {
                    if (i[r].indexOf("OES_texture_float") >= 0) {
                        n = !0;
                        break
                    }
                }
                t.SUPORT_FLOAT_TEXTURE = n
            }
            return t.SUPORT_FLOAT_TEXTURE
        }, t
    }(DebuggerClass);
    __reflect(z, "@egret/animation/AnimatorFactory");
    var U = function (e) {
        function t() {
            var t = null !== e && e.apply(this, arguments) || this;
            return t.bonesMap = null, t._animation = null, t._updateEntityAnimatonState = function (e, n) {
                var r = t._animation = e.getComponent(h.Animation), i = r.animationController;
                if (i) {
                    var o = i.layers, a = r.fadeStates, s = r.binders;
                    for (var l in s) {
                        (S = s[l]).clear()
                    }
                    for (var u = a.length - 1; u >= 0; u--) for (var c = a[u], p = 0, d = 0, f = c.length; p < f; ++p) {
                        var m = !1, _ = c[p], g = _.fadeState, v = _.subFadeState;
                        if (1 === g && 1 === v) d++, _.release(); else {
                            d > 0 && (c[p - d] = _), 0 === g && 0 === v || (m = !0, t._updateAnimationFadeState(_, n));
                            for (var y = 0, b = _.states; y < b.length; y++) {
                                var x = b[y];
                                x.constructor === h.AnimationTreeState ? t._updateAnimationTreeState(_, x) : t._updateAnimationState(_, x, n, m)
                            }
                        }
                        p === f - 1 && d > 0 && (c.length -= d)
                    }
                    for (var T = 0, E = o; T < E.length; T++) {
                        var C = E[T].mask;
                        C && C._dirty && (C._dirty = !1)
                    }
                    for (var l in s) {
                        var S;
                        null !== (S = s[l]) && null !== S.updateTarget && S.updateTarget()
                    }
                }
            }, t
        }

        return m(t, e), Object.defineProperty(t, "instance", {
            get: function () {
                return this._instance || (this._instance = new t), this._instance
            }, enumerable: !0, configurable: !0
        }), t.prototype.generate = function (e, t, n) {
            void 0 === t && (t = 60);
            for (var r = e.getComponentsInChildren(l.SkinnedMeshRenderer), i = e.getComponentsInChildren(l.MeshRenderer), o = [], a = [], s = null, u = 0, c = n; u < c.length; u++) {
                var p = c[u], d = p.glTF.animations[0].extensions.egret.clips[0].name;
                s = this.getBakedAnimationAssetsPath(p.entity.uri);
                for (var h = 0, f = r; h < f.length; h++) {
                    var m = (x = f[h]).entity.getComponent(l.MeshFilter),
                        _ = this.generateAnimationTexture(e, m.mesh, n, d, t), g = new Uint8Array(_.buffer),
                        v = s + (m.entity.node.name + "-") + d + ".gan.bin";
                    o.push(v), this.createBakedAnimationAssets(g, v)
                }
                for (var y = 0, b = i; y < b.length; y++) {
                    var x = b[y];
                    _ = this.getMeshRenderBonesDataFromAnimation(e, x, n, d, t), v = s + (x.entity.node.name + "-") + d + ".json";
                    a.push(v), this.createBakedAnimationAssets(JSON.stringify(_), v)
                }
            }
            var T = {skinnedMeshAssets: o, meshAssets: a};
            if (o.length > 0 || a.length > 0) {
                var E = s + "bakedConfig.json";
                return o && this.createBakedAnimationAssets(JSON.stringify(T, null, "\t"), E), E
            }
            return null
        }, t.prototype.getBakedAnimationAssetsPath = function (e) {
            return e.slice(0, e.lastIndexOf("/")) + "/baked/"
        }, t.prototype.createBakedAnimationAssets = function (e, t) {
            c.Application.instance.signals.getSignal("GenerateGpuAnimationAsset").dispatch(e, t)
        }, t.prototype._updateAnimationFadeState = function (e, t) {
            t < 0 && (t = -t);
            var n = 1 === e.fadeState, r = e.totalTime, i = e.time += t;
            -1 === e.subFadeState && (e.subFadeState = 0), i >= r ? (e.subFadeState = 1, e.progress = n ? 0 : 1) : e.progress = i > 0 ? n ? 1 - i / r : i / r : n ? 1 : 0, 1 === e.subFadeState && (n || (e.fadeState = 0, e.subFadeState = 0))
        }, t.prototype._updateAnimationTreeState = function (e, t) {
            var n = t.animationLayer.weight * t.weight;
            null !== t._parent ? n *= t._parent._globalWeight : n *= e.progress, t._globalWeight = n
        }, t.prototype._updateAnimationState = function (e, t, n, r) {
            var i = this._animation, o = i.entity, a = t.animationLayer, s = a.weight * t.weight;
            null !== t._parent ? s *= t._parent._globalWeight : s *= e.progress, t._globalWeight = s, t._playheadEnabled && (n *= i.timeScale * t.timeScale, t._time += n);
            var l = t._time, u = t._playState, c = t.currentPlayTimes, p = t._currentTime, d = t.playTimes,
                f = t.animationClip.duration, m = d * f, _ = 0;
            if (d > 0 && (l >= m || l <= -m) ? (t._playState <= 0 && t._playheadEnabled && (t._playState = 1), t.currentPlayTimes = d, _ = l >= m ? f : 0) : (0 !== t._playState && t._playheadEnabled && (t._playState = 0), l < 0 ? (l = -l, t.currentPlayTimes = l / f >> 0, _ = f - l % f) : (t.currentPlayTimes = l / f >> 0, _ = l % f)), _ += t.animationClip.position, t._currentTime = _, r || 0 !== s) {
                var g = a.mask, v = t.animation.extras.channels;
                if (g && g._dirty) {
                    var y = g.jointNames, b = t.animationAsset.glTF.nodes;
                    for (var x in v) {
                        var T = v[x];
                        if (y.length > 0) {
                            var E = T.glTFChannel.target.node;
                            T.enabled = void 0 === E || y.indexOf(b[E].name) >= 0
                        } else T.enabled = !0
                    }
                }
                var C = 0;
                for (var x in v) {
                    if (null !== (T = v[x]).updateTarget && T.enabled) {
                        var S = t._channelBinders[C];
                        S.constructor === h.AnimationBinder ? S.updateBlend(a, t) && T.updateTarget(a, t, S) : T.updateTarget(a, t, S), C++
                    }
                }
            }
            -1 === u && -1 !== t._playState && o.sendMessage("onAnimationEvent", h.AnimationEvent.create(0, t), !1);
            var M = !1, A = t.animation.extensions.egret.events;
            if (0 !== n && A) if (n > 0) if (p < _) for (var O = 0, w = A; O < w.length; O++) {
                var R = w[O];
                p < R.position && R.position <= _ && o.sendMessage("onAnimationEvent", h.AnimationEvent.create(3, t, R), !1)
            } else {
                for (var P = 0, L = A; P < L.length; P++) {
                    var D = L[P];
                    p < D.position && o.sendMessage("onAnimationEvent", h.AnimationEvent.create(3, t, D), !1)
                }
                o.sendMessage("onAnimationEvent", h.AnimationEvent.create(1, t), !1);
                for (var I = 0, N = A; I < N.length; I++) {
                    var z = N[I];
                    z.position <= _ && o.sendMessage("onAnimationEvent", h.AnimationEvent.create(3, t, z), !1)
                }
                M = !0
            } else if (p > _) for (var U = 0, F = A; U < F.length; U++) {
                var k = F[U];
                _ <= k.position && k.position < p && o.sendMessage("onAnimationEvent", h.AnimationEvent.create(3, t, k), !1)
            } else {
                for (var V = 0, B = A; V < B.length; V++) {
                    var G = B[V];
                    G.position < p && o.sendMessage("onAnimationEvent", h.AnimationEvent.create(3, t, G), !1)
                }
                o.sendMessage("onAnimationEvent", h.AnimationEvent.create(1, t), !1);
                for (var j = 0, H = A; j < H.length; j++) {
                    var W = H[j];
                    _ <= W.position && o.sendMessage("onAnimationEvent", h.AnimationEvent.create(3, t, W), !1)
                }
                M = !0
            }
            if (t.currentPlayTimes !== c && (M || o.sendMessage("onAnimationEvent", h.AnimationEvent.create(1, t), !1), 1 === t._playState)) {
                var X = a._clipNames;
                X && X.length > 0 ? i.play(X.shift()) : o.sendMessage("onAnimationEvent", h.AnimationEvent.create(2, t), !1)
            }
        }, t.prototype.generateAnimationTexture = function (e, t, n, r, i) {
            for (var o = this.getBonesDataFromAnimation(e, n, r, i), a = t.glTF.nodes, s = t.glTF.skins[0].joints, l = t.inverseBindMatrices, u = [], p = 3 * s.length; p > 0; p--) u.push([]);
            for (var d = 0, h = o; d < h.length; d++) {
                var f = h[d];
                for (p = 0; p < s.length; p++) {
                    var m = a[s[p]].name, _ = c.Matrix4.create().fromArray(l, 16 * p), g = f[m],
                        v = c.Matrix4.create().multiply(g);
                    v.multiply(_);
                    var y = 3 * p;
                    u[y].push(v.rawData[0]), u[y].push(v.rawData[4]), u[y].push(v.rawData[8]), u[y++].push(v.rawData[12]), u[y].push(v.rawData[1]), u[y].push(v.rawData[5]), u[y].push(v.rawData[9]), u[y++].push(v.rawData[13]), u[y].push(v.rawData[2]), u[y].push(v.rawData[6]), u[y].push(v.rawData[10]), u[y++].push(v.rawData[14])
                }
            }
            for (var b = [], x = 0, T = u; x < T.length; x++) {
                var E = T[x];
                b.push.apply(b, E)
            }
            return b.unshift(i), b.unshift(u.length), b.unshift(o.length), new Float32Array(b)
        }, t.prototype.getPrefabBonesMap = function (e) {
            var t = {};
            return this.getEntityMap(e, t, e), t
        }, t.prototype.getEntityMap = function (e, t, n) {
            var r = e.node, i = {transform: e.transform};
            t[r.name] = i;
            for (var o = 0, a = r.children; o < a.length; o++) {
                var s = a[o];
                this.getEntityMap(s.entity, t, n)
            }
        }, t.prototype.getBonesDataFromAnimation = function (e, t, n, r) {
            var i = e.enabled;
            e.enabled = !0;
            var o = e.getOrAddComponent(h.Animation);
            o.animations = t, o.preferBaked = !1, o.play(n, 1);
            var a = o.lastAnimationState, s = 1 / r, l = [];
            this.bonesMap = this.getPrefabBonesMap(e);
            for (var u = this.bonesMap; !a.isCompleted;) {
                this._updateEntityAnimatonState(e, s);
                var c = {};
                for (var p in u) c[p] = u[p].transform.localToWorldMatrix.clone();
                l.push(c)
            }
            return e.enabled = i, l
        }, t.prototype.getMeshRenderBonesDataFromAnimation = function (e, t, n, r, i) {
            var o = e.enabled;
            e.enabled = !0;
            var a = e.getOrAddComponent(h.Animation);
            a.animations = n, a.preferBaked = !1, a.play(r, 1);
            for (var s = a.lastAnimationState, l = 1 / i, u = [], c = t.entity; !s.isCompleted;) {
                this._updateEntityAnimatonState(e, l);
                var p = c.transform.position, d = c.transform.rotation, f = c.transform.scale, m = {
                    position: [F(p.x), F(p.y), F(p.z)],
                    rotation: [F(d.rawData[0]), F(d.rawData[1]), F(d.rawData[2]), F(d.rawData[3])],
                    scale: [F(f.x), F(f.y), F(f.z)]
                };
                u.push(m)
            }
            return e.enabled = o, u
        }, t
    }(DebuggerClass);

    function F(e, t) {
        return void 0 === t && (t = 3), parseFloat(e.toFixed(t))
    }

    __reflect(U, "@egret/animation/BakedAnimationGenerator");
    var k = function (e) {
        function t() {
            var t = null !== e && e.apply(this, arguments) || this;
            return t._preferBaked = !1, t._animator = null, t.applyRootMotion = !1, t._animations = [], t._bakedAnimationConfig = {
                options: [{
                    name: "frameRate",
                    type: "int",
                    value: 60
                }], preferBaked: !1, assetPath: ""
            }, t
        }

        return m(t, e), Object.defineProperty(t.prototype, "autoPlay", {
            get: function () {
                return this._animator.getAutoPlay()
            }, set: function (e) {
                this._animator.setAutoPlay(e)
            }, enumerable: !0, configurable: !0
        }), Object.defineProperty(t.prototype, "preferBaked", {
            get: function () {
                return this._preferBaked
            }, set: function (e) {
                if (this._preferBaked !== e) {
                    this._preferBaked = e;
                    var t = z.initialize(this.preferBaked, this.entity);
                    this._animator && (t.setTimeScale(this._animator.getTimeScale()), t.setAutoPlay(this._animator.getAutoPlay()), this._animator.release()), this._animator = t
                }
            }, enumerable: !0, configurable: !0
        }), Object.defineProperty(t.prototype, "timeScale", {
            get: function () {
                return this._animator.getTimeScale()
            }, set: function (e) {
                this._animator.setTimeScale(e)
            }, enumerable: !0, configurable: !0
        }), Object.defineProperty(t.prototype, "animator", {
            get: function () {
                return this._animator
            }, enumerable: !0, configurable: !0
        }), t.prototype.initialize = function (t, n, r) {
            void 0 === r && (r = null), e.prototype.initialize.call(this, t, n, r), this._animator = z.initialize(this.preferBaked, this.entity)
        }, t.prototype.uninitialize = function () {
            this._animator.uninitialize(), e.prototype.uninitialize.call(this)
        }, t.prototype.play = function (e, t) {
            return void 0 === e && (e = ""), void 0 === t && (t = -1), this._animator.play(e, t)
        }, t.prototype.stop = function (e, t) {
            return void 0 === e && (e = ""), void 0 === t && (t = 0), this._animator.stop(e, t)
        }, t.prototype.getState = function (e, t) {
            return void 0 === t && (t = 0), this._animator.getState(e, t)
        }, t.prototype.hasAnimation = function (e) {
            return this._animator.hasAnimation(e)
        }, Object.defineProperty(t.prototype, "binders", {
            get: function () {
                return this._animator.getBinders()
            }, enumerable: !0, configurable: !0
        }), t.prototype._getBinder = function (e, t) {
            var n = this.binders;
            return (e += "/" + t) in n || (n[e] = C.create()), n[e]
        }, t.prototype.fadeIn = function (e, t, n, r, i) {
            return void 0 === n && (n = -1), void 0 === r && (r = 0), void 0 === i && (i = !1), this.animator.fadeIn(e, t, n, r, i)
        }, Object.defineProperty(t.prototype, "lastAnimationnName", {
            get: function () {
                var e = this.lastAnimationState;
                return null !== e ? e.name : ""
            }, enumerable: !0, configurable: !0
        }), Object.defineProperty(t.prototype, "animations", {
            get: function () {
                return this._animations
            }, set: function (e) {
                if (e !== this._animations) {
                    this._animations = [];
                    for (var t = 0, n = e; t < n.length; t++) {
                        var r = n[t];
                        this._animations.push(r)
                    }
                } else console.warn("Potentially risky operation.")
            }, enumerable: !0, configurable: !0
        }), Object.defineProperty(t.prototype, "animationController", {
            get: function () {
                return this.animator.getAnimationController()
            }, enumerable: !0, configurable: !0
        }), Object.defineProperty(t.prototype, "lastAnimationState", {
            get: function () {
                return this.animator.getLastAnimationState()
            }, enumerable: !0, configurable: !0
        }), Object.defineProperty(t.prototype, "fadeStates", {
            get: function () {
                return this.animator.getFadeStates()
            }, enumerable: !0, configurable: !0
        }), Object.defineProperty(t.prototype, "bakedAnimationConfig", {
            get: function () {
                return this._bakedAnimationConfig
            }, set: function (e) {
                if (this._bakedAnimationConfig.options = e.options, this._bakedAnimationConfig.preferBaked = e.preferBaked, this._bakedAnimationConfig.preferBaked) if (this._bakedAnimationConfig.assetPath || e.assetPath) this._bakedAnimationConfig.assetPath = e.assetPath; else {
                    var t = this.generate();
                    this._bakedAnimationConfig.assetPath = t
                } else this._bakedAnimationConfig.assetPath = null;
                this.preferBaked = this._bakedAnimationConfig.preferBaked
            }, enumerable: !0, configurable: !0
        }), t.prototype.generate = function () {
            var e = this.bakedAnimationConfig.options[0].value;
            return U.instance.generate(this.entity, e, this.animations)
        }, _([Object(u.property)("boolean"), u.serializedField], t.prototype, "autoPlay", null), _([Object(u.property)("float"), u.serializedField], t.prototype, "timeScale", null), _([Object(u.property)("boolean"), u.serializedField], t.prototype, "applyRootMotion", void 0), _([Object(u.serializedField)("_animations"), Object(u.property)("asset", {assetType: "animation"}, !0)], t.prototype, "animations", null), _([Object(u.property)("button"), u.serializedField], t.prototype, "bakedAnimationConfig", null), t = _([Object(s.component)({isAbstract: !1})], t)
    }(c.GameComponent);
    __reflect(k, "@egret/animation/Animation");
    var V = function (e) {
        function t() {
            var t = null !== e && e.apply(this, arguments) || this;
            return t.type = 0, t.animationState = null, t.frameEvent = null, t
        }

        return m(t, e), t.create = function (e, t, n) {
            void 0 === n && (n = null);
            var r = p.Pool.getPool(this, !0).borrow();
            return r.initialize(), r.type = e, r.animationState = t, r.frameEvent = n, r
        }, t = _([Object(p.pool)()], t)
    }(p.Releasable);
    __reflect(V, "@egret/animation/AnimationEvent");
    var B = function (e) {
        function t() {
            var t = null !== e && e.apply(this, arguments) || this;
            return t._animation = null, t._updates = {}, t._updateEntityAnimatonState = function (e, n) {
                var r = t._animation = e.getComponent(k), i = r.animationController;
                if (i) {
                    var o = i.layers, a = r.fadeStates, s = r.binders;
                    for (var l in s) {
                        (C = s[l]).clear()
                    }
                    for (var u = a.length - 1; u >= 0; u--) for (var c = a[u], p = 0, d = 0, h = c.length; p < h; ++p) {
                        var f = !1, m = c[p], _ = m.fadeState, g = m.subFadeState;
                        if (1 === _ && 1 === g) d++, m.release(); else {
                            d > 0 && (c[p - d] = m), 0 === _ && 0 === g || (f = !0, t._updateAnimationFadeState(m, n));
                            for (var v = 0, y = m.states; v < y.length; v++) {
                                var b = y[v];
                                b.constructor === R ? t._updateAnimationTreeState(m, b) : t._updateAnimationState(m, b, n, f)
                            }
                        }
                        p === h - 1 && d > 0 && (c.length -= d)
                    }
                    for (var x = 0, T = o; x < T.length; x++) {
                        var E = T[x].mask;
                        E && E._dirty && (E._dirty = !1)
                    }
                    for (var l in s) {
                        var C;
                        null !== (C = s[l]) && null !== C.updateTarget && C.updateTarget()
                    }
                }
            }, t._updateEntityBakedAnimState = function (e, t) {
                var n = e.getComponent(k).animator, r = n.lastAnimationState;
                r && (r.isPlaying && (r.currentTime += t * r.timeScale, r.currentFrame >= r._totalFrame && (r._playState = 1)), r.isCompleted && r._playheadEnabled && (r.isLoop || r.currentPlayTimes++, (r.isLoop || r.currentPlayTimes < r.playTimes) && (r.currentTime = (r.currentFrame - r._totalFrame) / r.frameRate, r._playState = 0))), n.updateRenders(), n.updateHelpers()
            }, t
        }

        return m(t, e), t.prototype._updateAnimationFadeState = function (e, t) {
            t < 0 && (t = -t);
            var n = 1 === e.fadeState, r = e.totalTime, i = e.time += t;
            -1 === e.subFadeState && (e.subFadeState = 0), i >= r ? (e.subFadeState = 1, e.progress = n ? 0 : 1) : e.progress = i > 0 ? n ? 1 - i / r : i / r : n ? 1 : 0, 1 === e.subFadeState && (n || (e.fadeState = 0, e.subFadeState = 0))
        }, t.prototype._updateAnimationTreeState = function (e, t) {
            var n = t.animationLayer.weight * t.weight;
            null !== t._parent ? n *= t._parent._globalWeight : n *= e.progress, t._globalWeight = n
        }, t.prototype._updateAnimationState = function (e, t, n, r) {
            var i = this._animation, o = i.entity, a = t.animationLayer, s = a.weight * t.weight;
            null !== t._parent ? s *= t._parent._globalWeight : s *= e.progress, t._globalWeight = s, t._playheadEnabled && (n *= i.timeScale * t.timeScale, t._time += n);
            var l = t._time, u = t._playState, c = t.currentPlayTimes, p = t._currentTime, d = t.playTimes,
                h = t.animationClip.duration, f = d * h, m = 0;
            if (d > 0 && (l >= f || l <= -f) ? (t._playState <= 0 && t._playheadEnabled && (t._playState = 1), t.currentPlayTimes = d, m = l >= f ? h : 0) : (0 !== t._playState && t._playheadEnabled && (t._playState = 0), l < 0 ? (l = -l, t.currentPlayTimes = l / h >> 0, m = h - l % h) : (t.currentPlayTimes = l / h >> 0, m = l % h)), m += t.animationClip.position, t._currentTime = m, r || 0 !== s) {
                var _ = a.mask, g = t.animation.extras.channels;
                if (_ && _._dirty) {
                    var v = _.jointNames, y = t.animationAsset.glTF.nodes;
                    for (var b in g) {
                        var x = g[b];
                        if (v.length > 0) {
                            var T = x.glTFChannel.target.node;
                            x.enabled = void 0 === T || v.indexOf(y[T].name) >= 0
                        } else x.enabled = !0
                    }
                }
                var E = 0;
                for (var b in g) {
                    if (null !== (x = g[b]).updateTarget && x.enabled) {
                        var S = t._channelBinders[E];
                        S.constructor === C ? S.updateBlend(a, t) && x.updateTarget(a, t, S) : x.updateTarget(a, t, S), E++
                    }
                }
            }
            -1 === u && -1 !== t._playState && o.sendMessage("onAnimationEvent", V.create(0, t), !1);
            var M = !1, A = t.animation.extensions.egret.events;
            if (0 !== n && A) if (n > 0) if (p < m) for (var O = 0, w = A; O < w.length; O++) {
                var R = w[O];
                p < R.position && R.position <= m && o.sendMessage("onAnimationEvent", V.create(3, t, R), !1)
            } else {
                for (var P = 0, L = A; P < L.length; P++) {
                    var D = L[P];
                    p < D.position && o.sendMessage("onAnimationEvent", V.create(3, t, D), !1)
                }
                o.sendMessage("onAnimationEvent", V.create(1, t), !1);
                for (var I = 0, N = A; I < N.length; I++) {
                    var z = N[I];
                    z.position <= m && o.sendMessage("onAnimationEvent", V.create(3, t, z), !1)
                }
                M = !0
            } else if (p > m) for (var U = 0, F = A; U < F.length; U++) {
                var k = F[U];
                m <= k.position && k.position < p && o.sendMessage("onAnimationEvent", V.create(3, t, k), !1)
            } else {
                for (var B = 0, G = A; B < G.length; B++) {
                    var j = G[B];
                    j.position < p && o.sendMessage("onAnimationEvent", V.create(3, t, j), !1)
                }
                o.sendMessage("onAnimationEvent", V.create(1, t), !1);
                for (var H = 0, W = A; H < W.length; H++) {
                    var X = W[H];
                    m <= X.position && o.sendMessage("onAnimationEvent", V.create(3, t, X), !1)
                }
                M = !0
            }
            if (t.currentPlayTimes !== c && (M || o.sendMessage("onAnimationEvent", V.create(1, t), !1), 1 === t._playState)) {
                var Y = a._clipNames;
                Y && Y.length > 0 ? i.play(Y.shift()) : o.sendMessage("onAnimationEvent", V.create(2, t), !1)
            }
        }, t.prototype.getMatchers = function () {
            return [s.Matcher.create(c.GameEntity, !0, c.Transform, k)]
        }, t.prototype.onEntityAdded = function (e, t) {
            if (t === this.groups[0]) {
                var n = e.getComponent(k);
                n.preferBaked && z.$getSupportExtension() ? (this._updates[e.uuid] = this._updateEntityBakedAnimState, this._convertSkinnedMeshRenderToBakedSkinnedMeshRender(e), this._addHelperToMeshRender(e), this._removeOtherSkeletons(e)) : this._updates[e.uuid] = this._updateEntityAnimatonState, 0 == (4 & c.Application.instance.executeMode) && n.autoPlay && (n.lastAnimationState ? n.lastAnimationState && !n.lastAnimationState.isPlaying && n.play(n.lastAnimationState.name) : n.play())
            }
        }, t.prototype.onFrame = function (e) {
            for (var t = 0, n = this.groups[0].entities; t < n.length; t++) {
                var r = n[t];
                this._updates[r.uuid] && this._updates[r.uuid](r, e)
            }
        }, t.prototype.onEntityRemoved = function (e, t) {
            t === this.groups[0] && delete this._updates[e.uuid]
        }, t.prototype._convertSkinnedMeshRenderToBakedSkinnedMeshRender = function (e) {
            for (var t = e.getComponentsInChildren(l.SkinnedMeshRenderer), n = e.getComponent(k).animator, r = 0, i = t; r < i.length; r++) {
                var o = i[r], a = o.entity;
                a.getComponent(c.Transform).setParent(e.getComponent(c.Transform));
                var s = o.materials.map((function (e) {
                    return e
                }));
                o.materials = [], a.removeComponent(l.SkinnedMeshRenderer);
                var u = a.getOrAddComponent(l.GpuSkinnedMeshRenderer);
                u.materials = s, u.targetTransform = e.getComponent(c.Transform), n.renders.push(u)
            }
        }, t.prototype._addHelperToMeshRender = function (e) {
            for (var t = e.getComponentsInChildren(l.MeshRenderer), n = e.getComponent(k).animator, r = 0, i = t; r < i.length; r++) {
                var o = i[r].entity;
                o.getComponent(c.Transform).setParent(e.getComponent(c.Transform));
                var a = o.getOrAddComponent(E);
                a.skeleton = o.node.name, a.targetTransfrom = o.getComponent(c.Transform), n.helpers.push(a)
            }
        }, t.prototype._removeOtherSkeletons = function (e) {
            for (var t = e.getComponentsInChildren(l.MeshRenderer), n = e.getComponentsInChildren(l.GpuSkinnedMeshRenderer), r = 0, i = t; r < i.length; r++) {
                i[r].entity.node.removeChildren()
            }
            for (var o = 0, a = n; o < a.length; o++) {
                a[o].entity.node.removeChildren()
            }
        }, t = _([Object(s.system)({allOfExecuteMode: 1})], t)
    }(s.System);
    __reflect(B, "@egret/animation/AnimationSystem");
    var G = function (e) {
        function t() {
            return null !== e && e.apply(this, arguments) || this
        }

        return m(t, e), t.prototype.load = function (e, t, n) {
            return g(this, void 0, void 0, (function () {
                var r, i;
                return v(this, (function (o) {
                    switch (o.label) {
                        case 0:
                            return [4, t.loadResouceData(e, "binary", n)];
                        case 1:
                            return null === (r = o.sent()) ? (console.error("Load resource error.", e), [2, null]) : null === (i = y.fromGLB(r instanceof ArrayBuffer ? new Uint32Array(r) : r)) ? [2, null] : [2, i]
                    }
                }))
            }))
        }, t
    }(DebuggerClass);
    __reflect(G, "@egret/animation/AnimationLoader");
    var j = function (e) {
        function t() {
            return null !== e && e.apply(this, arguments) || this
        }

        return m(t, e), t.prototype.load = function (e, t, n) {
            return g(this, void 0, void 0, (function () {
                var r, i, o, a;
                return v(this, (function (s) {
                    switch (s.label) {
                        case 0:
                            return [4, t.loadResouceData(e, "binary", n)];
                        case 1:
                            return null === (r = s.sent()) ? (console.error("Load resource error.", e), [2, null]) : (i = new Float32Array(r, 0, 3), o = new Float32Array(r, 3 * Float32Array.BYTES_PER_ELEMENT), null === (a = b.fromFloat32Array(i[0], i[1], i[2], o, e)) ? [2, null] : [2, a])
                    }
                }))
            }))
        }, t
    }(DebuggerClass);
    __reflect(j, "@egret/animation/BakedAnimationLoader");
    var H = function (e) {
        function t() {
            return null !== e && e.apply(this, arguments) || this
        }

        return m(t, e), t.prototype.onAwake = function () {
            var e = c.Application.instance.systemManager;
            u.ResourceManager.instance.setProcessor("animation", new G), u.ResourceManager.instance.setProcessor("bakedAnimation", new j, "bin", "gan"), e.unregisterSystem(this)
        }, t = _([Object(s.system)()], t)
    }(s.System);

    function W() {
        return g(this, void 0, void 0, (function () {
            return v(this, (function (e) {
                return c.SystemManager.preRegisterSystem(H, 2e3), c.SystemManager.preRegisterSystem(B, 5e3), console.debug("Egret animation registered."), [2]
            }))
        }))
    }

    __reflect(H, "@egret/animation/StartupSystem")
}, function (e, t) {
    var n;
    n = function () {
        return this
    }();
    try {
        n = n || new Function("return this")()
    } catch (e) {
        "object" == typeof window && (n = window)
    }
    e.exports = n
}, function (e, t, n) {
    "use strict";
    n.r(t), n.d(t, "AxisIndex", (function () {
        return s
    })), n.d(t, "Button", (function () {
        return x
    })), n.d(t, "ButtonType", (function () {
        return l
    })), n.d(t, "Input", (function () {
        return y
    })), n.d(t, "InputCode", (function () {
        return r
    })), n.d(t, "InputManager", (function () {
        return E
    })), n.d(t, "InputState", (function () {
        return i
    })), n.d(t, "InputSystem", (function () {
        return C
    })), n.d(t, "InputUtil", (function () {
        return T
    })), n.d(t, "Pointer", (function () {
        return b
    })), n.d(t, "PointerCode", (function () {
        return o
    })), n.d(t, "PointerType", (function () {
        return a
    })), n.d(t, "_inputCodeToCode", (function () {
        return v
    })), n.d(t, "_keyToCode", (function () {
        return g
    })), n.d(t, "startup", (function () {
        return M
    }));
    var r, i, o, a, s, l, u = n(2), c = n(0), p = n(1), d = n(3), h = function (e, t) {
        return (h = Object.setPrototypeOf || {__proto__: []} instanceof Array && function (e, t) {
            e.__proto__ = t
        } || function (e, t) {
            for (var n in t) t.hasOwnProperty(n) && (e[n] = t[n])
        })(e, t)
    };

    function f(e, t) {
        function n() {
            this.constructor = e
        }

        h(e, t), e.prototype = null === t ? Object.create(t) : (n.prototype = t.prototype, new n)
    }

    function m(e, t, n, r) {
        var i, o = arguments.length, a = o < 3 ? t : null === r ? r = Object.getOwnPropertyDescriptor(t, n) : r;
        if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) a = Reflect.decorate(e, t, n, r); else for (var s = e.length - 1; s >= 0; s--) (i = e[s]) && (a = (o < 3 ? i(a) : o > 3 ? i(t, n, a) : i(t, n)) || a);
        return o > 3 && a && Object.defineProperty(t, n, a), a
    }

    function _(e, t) {
        var n, r, i, o, a = {
            label: 0, sent: function () {
                if (1 & i[0]) throw i[1];
                return i[1]
            }, trys: [], ops: []
        };
        return o = {
            next: s(0),
            throw: s(1),
            return: s(2)
        }, "function" == typeof Symbol && (o[Symbol.iterator] = function () {
            return this
        }), o;

        function s(o) {
            return function (s) {
                return function (o) {
                    if (n) throw new TypeError("Generator is already executing.");
                    for (; a;) try {
                        if (n = 1, r && (i = 2 & o[0] ? r.return : o[0] ? r.throw || ((i = r.return) && i.call(r), 0) : r.next) && !(i = i.call(r, o[1])).done) return i;
                        switch (r = 0, i && (o = [2 & o[0], i.value]), o[0]) {
                            case 0:
                            case 1:
                                i = o;
                                break;
                            case 4:
                                return a.label++, {value: o[1], done: !1};
                            case 5:
                                a.label++, r = o[1], o = [0];
                                continue;
                            case 7:
                                o = a.ops.pop(), a.trys.pop();
                                continue;
                            default:
                                if (!(i = a.trys, (i = i.length > 0 && i[i.length - 1]) || 6 !== o[0] && 2 !== o[0])) {
                                    a = 0;
                                    continue
                                }
                                if (3 === o[0] && (!i || o[1] > i[0] && o[1] < i[3])) {
                                    a.label = o[1];
                                    break
                                }
                                if (6 === o[0] && a.label < i[1]) {
                                    a.label = i[1], i = o;
                                    break
                                }
                                if (i && a.label < i[2]) {
                                    a.label = i[2], a.ops.push(o);
                                    break
                                }
                                i[2] && a.ops.pop(), a.trys.pop();
                                continue
                        }
                        o = t.call(e, a)
                    } catch (e) {
                        o = [6, e], r = 0
                    } finally {
                        n = i = 0
                    }
                    if (5 & o[0]) throw o[1];
                    return {value: o[0] ? o[1] : void 0, done: !0}
                }([o, s])
            }
        }
    }

    !function (e) {
        e.Unknown = "Unknown", e.F1 = "F1", e.F2 = "F2", e.F3 = "F3", e.F4 = "F4", e.F5 = "F5", e.F6 = "F6", e.F7 = "F7", e.F8 = "F8", e.F9 = "F9", e.F10 = "F10", e.F11 = "F11", e.F12 = "F12", e.Digit0 = "Digit0", e.Digit1 = "Digit1", e.Digit2 = "Digit2", e.Digit3 = "Digit3", e.Digit4 = "Digit4", e.Digit5 = "Digit5", e.Digit6 = "Digit6", e.Digit7 = "Digit7", e.Digit8 = "Digit8", e.Digit9 = "Digit9", e.KeyA = "KeyA", e.KeyB = "KeyB", e.KeyC = "KeyC", e.KeyD = "KeyD", e.KeyE = "KeyE", e.KeyF = "KeyF", e.KeyG = "KeyG", e.KeyH = "KeyH", e.KeyI = "KeyI", e.KeyJ = "KeyJ", e.KeyK = "KeyK", e.KeyL = "KeyL", e.KeyM = "KeyM", e.KeyN = "KeyN", e.KeyO = "KeyO", e.KeyP = "KeyP", e.KeyQ = "KeyQ", e.KeyR = "KeyR", e.KeyS = "KeyS", e.KeyT = "KeyT", e.KeyU = "KeyU", e.KeyV = "KeyV", e.KeyW = "KeyW", e.KeyX = "KeyX", e.KeyY = "KeyY", e.KeyZ = "KeyZ", e.Backquote = "Backquote", e.Minus = "Minus", e.Equal = "Equal", e.BracketLeft = "BracketLeft", e.BracketRight = "BracketRight", e.Backslash = "Backslash", e.Semicolon = "Semicolon", e.Quote = "Quote", e.Comma = "Comma", e.Period = "Period", e.Slash = "Slash", e.Escape = "Escape", e.ScrollLock = "ScrollLock", e.Pause = "Pause", e.Backspace = "Backspace", e.Tab = "Tab", e.CapsLock = "CapsLock", e.Space = "Space", e.ContextMenu = "ContextMenu", e.ShiftLeft = "ShiftLeft", e.ControlLeft = "ControlLeft", e.AltLeft = "AltLeft", e.MetaLeft = "MetaLeft", e.ShiftRight = "ShiftRight", e.ControlRight = "ControlRight", e.AltRight = "AltRight", e.MetaRight = "MetaRight", e.Insert = "Insert", e.Delete = "Delete", e.Home = "Home", e.End = "End", e.PageUp = "PageUp", e.PageDown = "PageDown", e.ArrowUp = "ArrowUp", e.ArrowDown = "ArrowDown", e.ArrowLeft = "ArrowLeft", e.ArrowRight = "ArrowRight", e.NumpadLock = "NumLock", e.NumpadDivide = "NumpadDivide", e.NumpadMultiply = "NumpadMultiply", e.NumpadSubtract = "NumpadSubtract", e.NumpadAdd = "NumpadAdd", e.NumpadEnter = "NumpadEnter", e.NumpadDecimal = "NumpadDecimal", e.Numpad0 = "Numpad0", e.Numpad1 = "Numpad1", e.Numpad2 = "Numpad2", e.Numpad3 = "Numpad3", e.Numpad4 = "Numpad4", e.Numpad5 = "Numpad5", e.Numpad6 = "Numpad6", e.Numpad7 = "Numpad7",e.Numpad8 = "Numpad8",e.Numpad9 = "Numpad9",e.LeftMouse = "LeftMouse",e.RightMouse = "RightMouse",e.MiddleMouse = "MiddleMouse",e.Back = "Back",e.Forward = "Forward",e.PenEraser = "PenEraser",e.Pencontac = "LeftMouse",e.PenBarrel = "RightMouse",e.X1 = "Back",e.X2 = "Forward",e.TouchContact = "LeftMouse",e.GamepadButton0 = "GamepadButton0",e.GamepadButton1 = "GamepadButton1",e.GamepadButton2 = "GamepadButton2",e.GamepadButton3 = "GamepadButton3",e.GamepadButton4 = "GamepadButton4",e.GamepadButton5 = "GamepadButton5",e.GamepadButton6 = "GamepadButton6",e.GamepadButton7 = "GamepadButton7",e.GamepadButton8 = "GamepadButton8",e.GamepadButton9 = "GamepadButton9",e.GamepadButton10 = "GamepadButton10",e.GamepadButton11 = "GamepadButton11",e.GamepadButton12 = "GamepadButton12",e.GamepadButton13 = "GamepadButton13",e.GamepadButton14 = "GamepadButton14",e.GamepadButton15 = "GamepadButton15"
    }(r || (r = {})), function (e) {
        e[e.Ready = 0] = "Ready", e[e.Down = 1] = "Down", e[e.Hold = 2] = "Hold", e[e.Up = 4] = "Up"
    }(i || (i = {})), function (e) {
        e[e.LeftMouse = 0] = "LeftMouse", e[e.MiddleMouse = 1] = "MiddleMouse", e[e.RightMouse = 2] = "RightMouse", e[e.Back = 3] = "Back", e[e.Forward = 4] = "Forward", e[e.PenEraser = 5] = "PenEraser", e[e.Pencontac = 0] = "Pencontac", e[e.PenBarrel = 2] = "PenBarrel", e[e.X1 = 3] = "X1", e[e.X2 = 4] = "X2", e[e.TouchContact = 0] = "TouchContact"
    }(o || (o = {})), function (e) {
        e.MOUSE_TYPE = "mouse", e.TOUCH_TYPE = "touch"
    }(a || (a = {})), function (e) {
        e[e.AxisX = -2] = "AxisX", e[e.AxisY = -1] = "AxisY", e[e.WheelX = 0] = "WheelX", e[e.WheelY = 1] = "WheelY", e[e.WheelZ = 2] = "WheelZ", e[e.VirtualCount = 3] = "VirtualCount", e[e.JoysticksAxis0 = 3] = "JoysticksAxis0", e[e.JoysticksAxis1 = 4] = "JoysticksAxis1", e[e.JoysticksAxis2 = 5] = "JoysticksAxis2", e[e.JoysticksAxis3 = 6] = "JoysticksAxis3", e[e.JoysticksAxisCount = 4] = "JoysticksAxisCount"
    }(s || (s = {})), function (e) {
        e[e.Input = 0] = "Input", e[e.Pointer = 1] = "Pointer", e[e.Axis = 2] = "Axis"
    }(l || (l = {}));
    var g = ["`", "Backquote", "1", "Digit1", "2", "Digit2", "3", "Digit3", "4", "Digit4", "5", "Digit5", "6", "Digit6", "7", "Digit7", "8", "Digit8", "9", "Digit9", "0", "Digit0", "-", "Minus", "=", "Equal", "[", "BracketLeft", "]", "BracketRight", "\\", "Backslash", ";", "Semicolon", "'", "Quote", ",", "Comma", ".", "Period", "/", "Slash", "~", "Backquote", "!", "Digit1", "@", "Digit2", "#", "Digit3", "$", "Digit4", "%", "Digit5", "^", "Digit6", "&", "Digit7", "*", "Digit8", "(", "Digit9", ")", "Digit0", "_", "Minus", "+", "Equal", "{", "BracketLeft", "}", "BracketRight", "|", "Backslash", ":", "Semicolon", '"', "Quote", "<", "Comma", ">", "Period", "?", "Slash", "a", "KeyA", "b", "KeyB", "c", "KeyC", "d", "KeyD", "e", "KeyE", "f", "KeyF", "g", "KeyG", "h", "KeyH", "i", "KeyI", "j", "KeyJ", "k", "KeyK", "l", "KeyL", "m", "KeyM", "n", "KeyN", "o", "KeyO", "p", "KeyP", "q", "KeyQ", "r", "KeyR", "s", "KeyS", "t", "KeyT", "u", "KeyU", "v", "KeyV", "w", "KeyW", "x", "KeyX", "y", "KeyY", "z", "KeyZ"],
        v = [0, "LeftMouse", 1, "MiddleMouse", 2, "RightMouse", 3, "Back", 4, "Forward", 5, "PenEraser", 48, "Digit0", 49, "Digit1", 50, "Digit2", 51, "Digit3", 52, "Digit4", 53, "Digit5", 54, "Digit6", 55, "Digit7", 56, "Digit8", 57, "Digit9", 65, "KeyA", 66, "KeyB", 67, "KeyC", 68, "KeyD", 69, "KeyE", 70, "KeyF", 71, "KeyG", 72, "KeyH", 73, "KeyI", 74, "KeyJ", 75, "KeyK", 76, "KeyL", 77, "KeyM", 78, "KeyN", 79, "KeyO", 80, "KeyP", 81, "KeyQ", 82, "KeyR", 83, "KeyS", 84, "KeyT", 85, "KeyU", 86, "KeyV", 87, "KeyW", 88, "KeyX", 89, "KeyY", 90, "KeyZ", 96, "Digit0", 97, "Digit1", 98, "Digit2", 99, "Digit3", 100, "Digit4", 101, "Digit5", 102, "Digit6", 103, "Digit7", 104, "Digit8", 105, "Digit9"],
        y = function (e) {
            function t() {
                var t = null !== e && e.apply(this, arguments) || this;
                return t.name = "Unknown", t.isEditor = !1, t.pressure = 0, t.lastPressure = 0, t.timestamp = 0, t.event = null, t
            }

            return f(t, e), Object.defineProperty(t.prototype, "isDown", {
                get: function () {
                    return 0 === this.lastPressure && this.pressure > 0
                }, enumerable: !0, configurable: !0
            }), Object.defineProperty(t.prototype, "isHold", {
                get: function () {
                    return this.lastPressure > 0 && this.pressure > 0
                }, enumerable: !0, configurable: !0
            }), Object.defineProperty(t.prototype, "isUp", {
                get: function () {
                    return this.lastPressure > 0 && 0 === this.pressure
                }, enumerable: !0, configurable: !0
            }), Object.defineProperty(t.prototype, "state", {
                get: function () {
                    return 0 === this.lastPressure ? this.pressure > 0 ? 1 : 0 : this.pressure > 0 ? 2 : 4
                }, enumerable: !0, configurable: !0
            }), m([Object(c.property)("string", {readonly: !0})], t.prototype, "name", void 0), m([Object(c.property)("float")], t.prototype, "pressure", void 0), m([Object(c.property)("float")], t.prototype, "lastPressure", void 0), t = m([Object(u.component)({
                isRemovable: !1,
                isAbstract: !1
            })], t)
        }(u.Component);
    __reflect(y, "@egret/input/Input");
    var b = function (e) {
        function t() {
            var t = null !== e && e.apply(this, arguments) || this;
            return t.index = 0, t.downPosition = p.Vector3.create(), t.position = p.Vector3.create(), t.lastPosition = p.Vector3.create(), t
        }

        return f(t, e), Object.defineProperty(t.prototype, "input", {
            get: function () {
                return this.entity.getComponent(y)
            }, enumerable: !0, configurable: !0
        }), m([Object(c.property)("vector2")], t.prototype, "downPosition", void 0), m([Object(c.property)("vector2")], t.prototype, "position", void 0), m([Object(c.property)("vector2")], t.prototype, "lastPosition", void 0), t = m([Object(u.component)({
            isRemovable: !1,
            isAbstract: !1
        })], t)
    }(u.Component);
    __reflect(b, "@egret/input/Pointer");
    var x = function (e) {
        function t() {
            var t = null !== e && e.apply(this, arguments) || this;
            return t.name = "", t.type = 0, t.snap = !1, t.invert = !1, t.gamepadIndex = 0, t.negativeInput = "Unknown", t.positiveInput = "Unknown", t.pointerIndex = 0, t.axisIndex = 1, t.sensitivity = 0, t.gravity = 0, t.dead = 0, t.value = 0, t.lastValue = 0, t
        }

        return f(t, e), t.prototype.formatValue = function () {
            var e = this.type, t = this.dead, n = this.value;
            0 === e ? n < 0 || n < t ? this.value = 0 : n > 1 && (this.value = 1) : n < -1 ? this.value = -1 : (n < 0 ? -n : n) < this.dead ? this.value = 0 : n > 1 && (this.value = 1)
        }, m([Object(c.property)("string")], t.prototype, "name", void 0), m([Object(c.property)("enum", {listItems: Object(c.getItemsFromEnum)(l)})], t.prototype, "type", void 0), m([Object(c.property)("boolean")], t.prototype, "snap", void 0), m([Object(c.property)("boolean")], t.prototype, "invert", void 0), m([Object(c.property)("uint")], t.prototype, "gamepadIndex", void 0), m([Object(c.property)("enum", {listItems: Object(c.getItemsFromEnum)(r)})], t.prototype, "negativeInput", void 0), m([Object(c.property)("enum", {listItems: Object(c.getItemsFromEnum)(r)})], t.prototype, "positiveInput", void 0), m([Object(c.property)("uint")], t.prototype, "pointerIndex", void 0), m([Object(c.property)("enum", {listItems: Object(c.getItemsFromEnum)(s)})], t.prototype, "axisIndex", void 0), m([Object(c.property)("float", {
            minimum: -1,
            maximum: 1
        })], t.prototype, "sensitivity", void 0), m([Object(c.property)("float", {
            minimum: -1,
            maximum: 1
        })], t.prototype, "gravity", void 0), m([Object(c.property)("float", {
            minimum: 0,
            maximum: 1
        })], t.prototype, "dead", void 0), m([Object(c.property)("float", {minimum: 0})], t.prototype, "value", void 0), m([Object(c.property)("float", {minimum: 0})], t.prototype, "lastValue", void 0), t = m([Object(u.component)({
            isRemovable: !1,
            isAbstract: !1
        })], t)
    }(u.Component);
    __reflect(x, "@egret/input/Button");
    var T = function (e) {
        function t() {
            return this
        }

        return f(t, DebuggerClass), t.getPointerInputCode = function (e, t) {
            var n = v.indexOf(e);
            return n >= 0 && "mouse" === t ? v[n + 1] : "Pointer" + n
        }, t.getGamepadAxisIndex = function (e, t) {
            return void 0 === t && (t = 0), e >= 3 || 0 === t ? e : e + 4 * t
        }, t.getGamepadButtonInputCode = function (e, t) {
            return void 0 === t && (t = 0), "number" == typeof e ? 0 === t ? "GamepadButton" + e : "GamepadButton" + e + "_" + t : 0 === t ? e : e + "_" + t
        }, t
    }();
    __reflect(T, "@egret/input/InputUtil");
    var E = function (e) {
        function t() {
            var t = null !== e && e.apply(this, arguments) || this;
            return t.onFocus = d.Signal.create(), t.onBlur = d.Signal.create(), t.onKeyDown = d.Signal.create(), t.onKeyPress = d.Signal.create(), t.onKeyUp = d.Signal.create(), t.onPointerDown = d.Signal.create(), t.onPointerMove = d.Signal.create(), t.onPointerUp = d.Signal.create(), t.onWheel = d.Signal.create(), t.onCopy = d.Signal.create(), t.onCut = d.Signal.create(), t.onPaste = d.Signal.create(), t._axes = new Float32Array(32), t._editorAxes = new Float32Array(32), t._downs = [], t._holds = [], t._ups = [], t._editorDowns = [], t._editorHolds = [], t._editorUps = [], t._matchInputs = [], t._matchPointer = [], t._inputs = {}, t._editorInputs = {}, t._buttons = {}, t._inputNode = null, t._editorInputNode = null, t._buttonNode = null, t
        }

        return f(t, e), t.prototype.getInput = function (e, t) {
            if (void 0 === t && (t = !1), "number" == typeof e) (n = v.indexOf(e)) >= 0 ? e = v[n + 1] : (console.error('Non-supported input code "' + e + '", use InputCode enumeration instead.'), e = "Unknown"); else if (1 === e.length) {
                var n;
                (n = g.indexOf(e)) >= 0 ? e = g[n + 1] : (console.error('Non-supported input "' + e + '", use InputCode enumeration instead.'), e = "Unknown")
            } else "" === e && (console.error("Invalid code."), e = "Unknown");
            "Pointer0" === e && (e = "LeftMouse");
            var r = e.toLowerCase(), i = t ? this._editorInputs : this._inputs;
            if (r in i) return i[r];
            if (null === this._inputNode) {
                var o = p.Application.instance.sceneManager;
                this._inputNode = p.EngineFactory.createGameEntity("Inputs", {parent: o.globalScene.root.entity}), this._editorInputNode = p.EngineFactory.createGameEntity("Inputs", {parent: o.editorScene.root.entity}), this._buttonNode = p.EngineFactory.createGameEntity("Buttons", {parent: o.globalScene.root.entity})
            }
            var a = p.EngineFactory.createGameEntity(e, {parent: t ? this._editorInputNode : this._inputNode});
            a.enabled = !1;
            var s = a.addComponent(y, !1);
            return s.name = e, s.isEditor = t, i[r] = s
        }, t.prototype.getPointer = function (e, t, n) {
            void 0 === t && (t = !1);
            var r = this.getInput(T.getPointerInputCode(e, n), t).entity, i = r.getComponent(b);
            return null === i && ((i = r.addComponent(b, !1)).index = e), i
        }, t.prototype.getAxis = function (e, t) {
            void 0 === t && (t = !1);
            var n = t ? this._editorAxes : this._axes;
            return e >= 0 && e < n.length ? n[e] : 0
        }, t.prototype.getButton = function (e) {
            var t = this._buttons;
            if (e in t) return t[e];
            var n = p.EngineFactory.createGameEntity(e, {parent: this._buttonNode}).addComponent(x, !0);
            return n.name = e, t[e] = n
        }, t.prototype.isAllOfInputs = function (e, t, n) {
            if (void 0 === n && (n = !1), 0 === e.length) return !1;
            for (var r = 0, i = e; r < i.length; r++) {
                var o = i[r];
                if (this.getInput(o, n).state !== t) return !1
            }
            return !0
        }, t.prototype.isAnyOfInputs = function (e, t, n) {
            if (void 0 === n && (n = !1), 0 === e.length) return !1;
            for (var r = 0, i = e; r < i.length; r++) {
                var o = i[r];
                if (this.getInput(o, n).state === t) return !0
            }
            return !1
        }, t.prototype.isCombinationDown = function (e, t) {
            void 0 === t && (t = !1);
            var n = e.length;
            if (0 === n) return !1;
            var r = t ? this._editorDowns : this._downs, i = t ? this._editorHolds : this._holds;
            if (r.length + i.length !== n) return !1;
            for (var o = 0, a = 0, s = i; a < s.length; a++) {
                if (s[a].name !== e[o]) return !1;
                o++
            }
            for (var l = 0, u = r; l < u.length; l++) {
                if (u[l].name !== e[o]) return !1;
                o++
            }
            return !0
        }, t.prototype.getInputs = function (e, t) {
            void 0 === t && (t = !1);
            var n = this._matchInputs;
            n.length > 0 && (n.length = 0);
            var r = t ? this._editorInputs : this._inputs;
            for (var i in r) {
                var o = r[i];
                o.state === e && (n[n.length] = o)
            }
            return n
        }, t.prototype.getPointers = function (e, t) {
            void 0 === t && (t = !1);
            var n = this._matchPointer;
            n.length > 0 && (n.length = 0);
            var r = t ? this._editorInputs : this._inputs;
            for (var i in r) {
                var o = r[i], a = o.entity.getComponent(b);
                null !== a && o.state === e && (n[n.length] = a)
            }
            return n
        }, t = m([Object(c.hideFlag)(16), Object(u.component)({isRemovable: !1, isAbstract: !1})], t)
    }(u.Component);
    __reflect(E, "@egret/input/InputManager");
    var C = function (e) {
        function t() {
            var t = null !== e && e.apply(this, arguments) || this;
            return t._application = p.Application.instance, t._inputManager = t._application.globalEntity.getComponent(E), t._stage = t._application.globalEntity.getComponent(p.Stage), t
        }

        return f(t, e), t.prototype._onKeyDown = function (e) {
            var t = 0 != (4 & this._application.executeMode), n = this._inputManager.getInput(e.code, t);
            n.event = e, this._inputDown(n)
        }, t.prototype._onKeyUp = function (e) {
            var t = 0 != (4 & this._application.executeMode), n = this._inputManager.getInput(e.code, t);
            n.event = e, this._inputUp(n)
        }, t.prototype._onPointerDown = function (e) {
            var t, n = 0 != (4 & this._application.executeMode), r = "mouse" === e.pointerType ? e.button : e.pointerId,
                i = this._inputManager.getPointer(r, n, e.pointerType);
            i.enabled = !0, this._transformPointerPosition(i.downPosition, e), i.lastPosition.copy(i.downPosition), i.position.copy(i.downPosition), (t = i.input).event = e, this._inputDown(t), t.pressure = e.pressure
        }, t.prototype._onPointerMove = function (e) {
            var t = this, n = 0 != (4 & this._application.executeMode), r = function (r) {
                var i = t._inputManager.getPointer(r, n, e.pointerType);
                i.enabled = !0, i.entity.enabled = !0, t._transformPointerPosition(i.position, e), i.input.event = e
            };
            if ("mouse" === e.pointerType) for (var i = 0; i <= 2; i++) r(i); else r(e.pointerId)
        }, t.prototype._onPointerUp = function (e) {
            var t, n = 0 != (4 & this._application.executeMode), r = "mouse" === e.pointerType ? e.button : e.pointerId,
                i = this._inputManager.getPointer(r, n, e.pointerType);
            this._transformPointerPosition(i.position, e), (t = i.input).event = e, this._inputUp(t)
        }, t.prototype._onPointerWheel = function (e) {
            var t = 0 != (4 & this._application.executeMode) ? this._inputManager._editorAxes : this._inputManager._axes;
            t[0] = 0 === e.deltaX ? 0 : e.deltaX > 0 ? 1 : -1, t[1] = 0 === e.deltaY ? 0 : e.deltaY > 0 ? 1 : -1, t[2] = 0 === e.deltaZ ? 0 : e.deltaZ > 0 ? 1 : -1
        }, t.prototype._inputDown = function (e) {
            e.enabled = !0, e.lastPressure = 0, e.pressure = 1, e.entity.enabled = !0, e.isEditor ? this._inputManager._editorDowns.push(e) : this._inputManager._downs.push(e)
        }, t.prototype._inputUp = function (e) {
            if (e.isEditor) {
                var t = this._inputManager, n = t._editorDowns, r = t._editorHolds, i = t._editorUps;
                e.lastPressure > 0 ? r.splice(r.indexOf(e), 1) : n.splice(n.indexOf(e), 1), i.push(e)
            } else {
                var o = this._inputManager, a = o._downs, s = o._holds, l = o._ups;
                e.lastPressure > 0 ? s.splice(s.indexOf(e), 1) : a.splice(a.indexOf(e), 1), l.push(e)
            }
            e.lastPressure = e.pressure, e.pressure = 0
        }, t.prototype._transformPointerPosition = function (e, t) {
            e.set(t.clientX, t.clientY, 0), this._stage.screenToStage(e, e)
        }, t.prototype.getMatchers = function () {
            return [u.Matcher.create(p.GameEntity, !0, y), u.Matcher.create(p.GameEntity, !0, b), u.Matcher.create(p.GameEntity, !0, x)]
        }, t.prototype.onEnable = function () {
            this._inputManager.onKeyDown.add(this._onKeyDown, this), this._inputManager.onKeyUp.add(this._onKeyUp, this), this._inputManager.onPointerDown.add(this._onPointerDown, this), this._inputManager.onPointerMove.add(this._onPointerMove, this), this._inputManager.onPointerUp.add(this._onPointerUp, this), this._inputManager.onWheel.add(this._onPointerWheel, this)
        }, t.prototype.onFrame = function () {
            for (var e = this.groups, t = this._inputManager, n = 0, r = e[2].entities; n < r.length; n++) {
                var i = r[n].getComponent(x);
                switch (i.type) {
                    case 0:
                        var o = t.getInput(0 === i.gamepadIndex ? i.negativeInput : T.getGamepadButtonInputCode(i.negativeInput, i.gamepadIndex)),
                            a = t.getInput(0 === i.gamepadIndex ? i.positiveInput : T.getGamepadButtonInputCode(i.positiveInput, i.gamepadIndex));
                        i.snap && o.pressure > 0 && a.pressure > 0 ? i.value = 0 : i.invert ? (i.value += o.pressure * i.sensitivity, i.value -= a.pressure * i.sensitivity) : (i.value -= o.pressure * i.sensitivity, i.value += a.pressure * i.sensitivity);
                        break;
                    case 1:
                        var s = t.getPointer(i.pointerIndex), l = s.downPosition, u = s.position,
                            c = -2 === i.axisIndex ? u.x - l.x : u.y - l.y;
                        s.input.pressure > 0 ? (i.value = c / i.sensitivity, i.invert && (i.value = -i.value)) : i.value = 0;
                        break;
                    case 2:
                        i.value = t.getAxis(0 === i.gamepadIndex ? i.axisIndex : T.getGamepadAxisIndex(i.axisIndex, i.gamepadIndex)), i.invert && (i.value = -i.value)
                }
                i.formatValue()
            }
        }, t.prototype.onFrameCleanup = function () {
            for (var e = this.groups, t = this._inputManager, n = t._downs, r = t._holds, i = t._ups, o = t._editorDowns, a = t._editorHolds, s = t._editorUps, l = t._axes, u = t._editorAxes, c = 0, p = e[0].entities; c < p.length; c++) {
                if ((g = (A = p[c]).getComponent(y)).pressure > 0) g.lastPressure = g.pressure, g.isEditor ? 0 === g.lastPressure ? a.push(g) : o.splice(o.indexOf(g), 1) : 0 === g.lastPressure ? r.push(g) : n.splice(n.indexOf(g), 1); else if (g.lastPressure > 0) {
                    if (A.enabled = !1, g.enabled = !1, g.lastPressure = 0, g.isEditor ? s.splice(s.indexOf(g), 1) : i.splice(i.indexOf(g), 1), null !== (E = A.getComponent(b))) {
                        var d = E.downPosition, h = E.position, f = E.lastPosition;
                        E.enabled = !1, d.clear(), f.copy(h)
                    }
                }
            }
            for (var m = 0, _ = e[0].entities; m < _.length; m++) {
                var g;
                (g = (A = _[m]).getComponent(y)).pressure > 0 && (g.lastPressure = g.pressure)
            }
            for (var v = 0, T = e[1].entities; v < T.length; v++) {
                var E;
                h = (E = (A = T[v]).getComponent(b)).position;
                (f = E.lastPosition).copy(h)
            }
            for (var C = 0; C < 3; ++C) l[C] = 0, u[C] = 0;
            for (var S = 0, M = e[2].entities; S < M.length; S++) {
                var A, O = (A = M[S]).getComponent(x);
                O.lastValue = O.value, O.value += O.gravity, O.formatValue()
            }
        }, t.prototype.onDisable = function () {
            this._inputManager.onKeyDown.remove(this._onKeyDown, this), this._inputManager.onKeyUp.remove(this._onKeyUp, this), this._inputManager.onPointerDown.remove(this._onPointerDown, this), this._inputManager.onPointerMove.remove(this._onPointerMove, this), this._inputManager.onPointerUp.remove(this._onPointerUp, this), this._inputManager.onWheel.remove(this._onPointerWheel, this)
        }, t = m([Object(u.system)()], t)
    }(u.System);
    __reflect(C, "@egret/input/InputSystem");
    var S = function (e) {
        function t() {
            return null !== e && e.apply(this, arguments) || this
        }

        return f(t, e), t.prototype.onAwake = function () {
            var e = p.Application.instance, t = e.globalEntity, n = e.systemManager;
            t.getOrAddComponent(E), n.registerSystem(C, 1e4), n.unregisterSystem(this)
        }, t = m([Object(u.system)()], t)
    }(u.System);

    function M() {
        return e = this, t = void 0, r = function () {
            return _(this, (function (e) {
                return p.SystemManager.preRegisterSystem(S, 0), console.debug("Egret register input."), [2]
            }))
        }, new ((n = void 0) || (n = Promise))((function (i, o) {
            function a(e) {
                try {
                    l(r.next(e))
                } catch (e) {
                    o(e)
                }
            }

            function s(e) {
                try {
                    l(r.throw(e))
                } catch (e) {
                    o(e)
                }
            }

            function l(e) {
                e.done ? i(e.value) : new n((function (t) {
                    t(e.value)
                })).then(a, s)
            }

            l((r = r.apply(e, t || [])).next())
        }));
        var e, t, n, r
    }

    __reflect(S, "@egret/input/StartupSystem")
}, function (e, t, n) {
    "use strict";
    var r, i, o, a, s, l, u, c, p, d, h, f, m, _, g, v, y, b, x, T, E;
    n.r(t), n.d(t, "AccessorType", (function () {
        return r
    })), n.d(t, "AttributeSemantics", (function () {
        return i
    })), n.d(t, "BlendEquation", (function () {
        return y
    })), n.d(t, "BlendFactor", (function () {
        return v
    })), n.d(t, "BufferMask", (function () {
        return g
    })), n.d(t, "BufferViewTarget", (function () {
        return f
    })), n.d(t, "ComponentType", (function () {
        return a
    })), n.d(t, "CullFace", (function () {
        return b
    })), n.d(t, "DepthFunc", (function () {
        return E
    })), n.d(t, "EnableState", (function () {
        return T
    })), n.d(t, "FrontFace", (function () {
        return x
    })), n.d(t, "MeshDrawMode", (function () {
        return h
    })), n.d(t, "MeshPrimitiveMode", (function () {
        return d
    })), n.d(t, "ShaderStage", (function () {
        return m
    })), n.d(t, "TextureAlignment", (function () {
        return p
    })), n.d(t, "TextureFilter", (function () {
        return u
    })), n.d(t, "TextureFormat", (function () {
        return l
    })), n.d(t, "TextureType", (function () {
        return s
    })), n.d(t, "TextureWrappingMode", (function () {
        return c
    })), n.d(t, "UniformSemantics", (function () {
        return o
    })), n.d(t, "WebGL", (function () {
        return _
    })), function (e) {
        e.Scalar = "SCALAR", e.Vector2 = "VEC2", e.Vector3 = "VEC3", e.Vector4 = "VEC4", e.Matrix2 = "MAT2", e.Matrix3 = "MAT3", e.Matrix4 = "MAT4"
    }(r || (r = {})), function (e) {
        e.POSITION = "POSITION", e.NORMAL = "NORMAL", e.TANGENT = "TANGENT", e.TEXCOORD_0 = "TEXCOORD_0", e.TEXCOORD_1 = "TEXCOORD_1", e.COLOR_0 = "COLOR_0", e.COLOR_1 = "COLOR_1", e.JOINTS_0 = "JOINTS_0", e.WEIGHTS_0 = "WEIGHTS_0", e.MORPHTARGET_0 = "MORPHTARGET_0", e.MORPHTARGET_1 = "MORPHTARGET_1", e.MORPHTARGET_2 = "MORPHTARGET_2", e.MORPHTARGET_3 = "MORPHTARGET_3", e.MORPHTARGET_4 = "MORPHTARGET_4", e.MORPHTARGET_5 = "MORPHTARGET_5", e.MORPHTARGET_6 = "MORPHTARGET_6", e.MORPHTARGET_7 = "MORPHTARGET_7", e.MORPHNORMAL_0 = "MORPHNORMAL_0", e.MORPHNORMAL_1 = "MORPHNORMAL_1", e.MORPHNORMAL_2 = "MORPHNORMAL_2", e.MORPHNORMAL_3 = "MORPHNORMAL_3"
    }(i || (i = {})), function (e) {
        e.LOCAL = "LOCAL", e.MODEL = "MODEL", e.VIEW = "VIEW", e.PROJECTION = "PROJECTION", e.MODELVIEW = "MODELVIEW", e.MODELVIEWPROJECTION = "MODELVIEWPROJECTION", e.MODELINVERSE = "MODELINVERSE", e.VIEWINVERSE = "VIEWINVERSE", e.PROJECTIONINVERSE = "PROJECTIONINVERSE", e.MODELVIEWINVERSE = "MODELVIEWINVERSE", e.MODELVIEWPROJECTIONINVERSE = "MODELVIEWPROJECTIONINVERSE", e.MODELINVERSETRANSPOSE = "MODELINVERSETRANSPOSE", e.MODELVIEWINVERSETRANSPOSE = "MODELVIEWINVERSETRANSPOSE", e.VIEWPORT = "VIEWPORT", e.JOINTMATRIX = "JOINTMATRIX", e.MORPHTARGETINFLUENCES = "MORPHTARGETINFLUENCES"
    }(o || (o = {})), function (e) {
        e[e.Byte = 5120] = "Byte", e[e.UnsignedByte = 5121] = "UnsignedByte", e[e.Short = 5122] = "Short", e[e.UnsignedShort = 5123] = "UnsignedShort", e[e.Int = 5124] = "Int", e[e.UnsignedInt = 5125] = "UnsignedInt", e[e.Float = 5126] = "Float", e[e.UnsignedShort4444 = 32819] = "UnsignedShort4444", e[e.UnsignedShort5551 = 32820] = "UnsignedShort5551", e[e.UnsignedShort565 = 33635] = "UnsignedShort565", e[e.FloatVector2 = 35664] = "FloatVector2", e[e.FloatVector3 = 35665] = "FloatVector3", e[e.FloatVector4 = 35666] = "FloatVector4", e[e.IntVector2 = 35667] = "IntVector2", e[e.IntVector3 = 35668] = "IntVector3", e[e.IntVector4 = 35669] = "IntVector4", e[e.Boolean = 35670] = "Boolean", e[e.BooleanVector2 = 35671] = "BooleanVector2", e[e.BooleanVector3 = 35672] = "BooleanVector3", e[e.BooleanVector4 = 35673] = "BooleanVector4", e[e.FloatMatrix2 = 35674] = "FloatMatrix2", e[e.FloatMatrix3 = 35675] = "FloatMatrix3", e[e.FloatMatrix4 = 35676] = "FloatMatrix4", e[e.Sampler2D = 35678] = "Sampler2D", e[e.SamplerCube = 35680] = "SamplerCube"
    }(a || (a = {})), function (e) {
        e[e.Texture2DStart = 33984] = "Texture2DStart", e[e.TextureCubeStart = 34069] = "TextureCubeStart", e[e.Texture1D = -1] = "Texture1D", e[e.Texture2D = 3553] = "Texture2D", e[e.Texture3D = 32879] = "Texture3D", e[e.TextureCube = 34067] = "TextureCube"
    }(s || (s = {})), function (e) {
        e[e.Alpha = 6406] = "Alpha", e[e.RGB = 6407] = "RGB", e[e.RGBA = 6408] = "RGBA", e[e.Luminance = 6409] = "Luminance", e[e.LuminanceAlpha = 6410] = "LuminanceAlpha", e[e.RGBA4 = 32854] = "RGBA4", e[e.RGB_S3TC_DXT1 = 33776] = "RGB_S3TC_DXT1", e[e.RGBA_S3TC_DXT1 = 33777] = "RGBA_S3TC_DXT1", e[e.RGBA_S3TC_DXT3 = 33778] = "RGBA_S3TC_DXT3", e[e.RGBA_S3TC_DXT5 = 33779] = "RGBA_S3TC_DXT5", e[e.RGB_PVRTC_4BPPV1 = 35840] = "RGB_PVRTC_4BPPV1", e[e.RGB_PVRTC_2BPPV1 = 35841] = "RGB_PVRTC_2BPPV1", e[e.RGBA_PVRTC_4BPPV1 = 35842] = "RGBA_PVRTC_4BPPV1", e[e.RGBA_PVRTC_2BPPV1 = 35843] = "RGBA_PVRTC_2BPPV1", e[e.RGB_ETC1 = 36196] = "RGB_ETC1", e[e.RGB8_ETC2 = 37492] = "RGB8_ETC2", e[e.RGBA_ASTC_4x4 = 37808] = "RGBA_ASTC_4x4", e[e.RGBA_ASTC_5x4 = 37809] = "RGBA_ASTC_5x4", e[e.RGBA_ASTC_5x5 = 37810] = "RGBA_ASTC_5x5", e[e.RGBA_ASTC_6x5 = 37811] = "RGBA_ASTC_6x5", e[e.RGBA_ASTC_6x6 = 37812] = "RGBA_ASTC_6x6", e[e.RGBA_ASTC_8x5 = 37813] = "RGBA_ASTC_8x5", e[e.RGBA_ASTC_8x6 = 37814] = "RGBA_ASTC_8x6", e[e.RGBA_ASTC_8x8 = 37815] = "RGBA_ASTC_8x8", e[e.RGBA_ASTC_10x5 = 37816] = "RGBA_ASTC_10x5", e[e.RGBA_ASTC_10x6 = 37817] = "RGBA_ASTC_10x6", e[e.RGBA_ASTC_10x8 = 37818] = "RGBA_ASTC_10x8", e[e.RGBA_ASTC_10x10 = 37819] = "RGBA_ASTC_10x10", e[e.RGBA_ASTC_12x10 = 37820] = "RGBA_ASTC_12x10", e[e.RGBA_ASTC_12x12 = 37821] = "RGBA_ASTC_12x12"
    }(l || (l = {})), function (e) {
        e[e.Nearest = 9728] = "Nearest", e[e.Linear = 9729] = "Linear", e[e.NearestMipmapNearest = 9984] = "NearestMipmapNearest", e[e.LinearMipmapNearest = 9985] = "LinearMipmapNearest", e[e.NearestMipMapLinear = 9986] = "NearestMipMapLinear", e[e.LinearMipMapLinear = 9987] = "LinearMipMapLinear"
    }(u || (u = {})), function (e) {
        e[e.Repeat = 10497] = "Repeat", e[e.ClampToEdge = 33071] = "ClampToEdge", e[e.MirroredRepeat = 33648] = "MirroredRepeat"
    }(c || (c = {})), function (e) {
        e[e.One = 1] = "One", e[e.Two = 2] = "Two", e[e.Four = 4] = "Four", e[e.Eight = 8] = "Eight"
    }(p || (p = {})), function (e) {
        e[e.Points = 0] = "Points", e[e.Lines = 1] = "Lines", e[e.LineLoop = 2] = "LineLoop", e[e.LineStrip = 3] = "LineStrip", e[e.Triangles = 4] = "Triangles", e[e.TrianglesStrip = 5] = "TrianglesStrip", e[e.TrianglesFan = 6] = "TrianglesFan"
    }(d || (d = {})), function (e) {
        e[e.Stream = 35040] = "Stream", e[e.Static = 35044] = "Static", e[e.Dynamic = 35048] = "Dynamic"
    }(h || (h = {})), function (e) {
        e[e.ArrayBuffer = 34962] = "ArrayBuffer", e[e.ElementArrayBuffer = 34963] = "ElementArrayBuffer"
    }(f || (f = {})), function (e) {
        e[e.Fragment = 35632] = "Fragment", e[e.Vertex = 35633] = "Vertex"
    }(m || (m = {})), function (e) {
        e[e.UnpackAlignment = 3317] = "UnpackAlignment", e[e.UnpackFlipYWebGL = 37440] = "UnpackFlipYWebGL", e[e.UnpackPremultiplyAlphaWebGL = 37441] = "UnpackPremultiplyAlphaWebGL", e[e.DepthStencilAttachment = 33306] = "DepthStencilAttachment", e[e.DepthStencil = 34041] = "DepthStencil", e[e.DepthAttachment = 36096] = "DepthAttachment", e[e.DepthComponent = 6402] = "DepthComponent", e[e.DepthComponent16 = 33189] = "DepthComponent16", e[e.ColorAttachment0 = 36064] = "ColorAttachment0", e[e.TextureMagFilter = 10240] = "TextureMagFilter", e[e.TextureMinFilter = 10241] = "TextureMinFilter", e[e.TextureWrapS = 10242] = "TextureWrapS", e[e.TextureWrapT = 10243] = "TextureWrapT", e[e.FrameBuffer = 36160] = "FrameBuffer", e[e.RenderBuffer = 36161] = "RenderBuffer", e[e.CompileStatus = 35713] = "CompileStatus", e[e.LinkStatus = 35714] = "LinkStatus"
    }(_ || (_ = {})), function (e) {
        e[e.None = 0] = "None", e[e.Depth = 256] = "Depth", e[e.Stencil = 1024] = "Stencil", e[e.Color = 16384] = "Color", e[e.DepthAndStencil = 1280] = "DepthAndStencil", e[e.DepthAndColor = 16640] = "DepthAndColor", e[e.StencilAndColor = 17408] = "StencilAndColor", e[e.All = 17664] = "All"
    }(g || (g = {})), function (e) {
        e[e.ZERO = 0] = "ZERO", e[e.ONE = 1] = "ONE", e[e.SRC_COLOR = 768] = "SRC_COLOR", e[e.ONE_MINUS_SRC_COLOR = 769] = "ONE_MINUS_SRC_COLOR", e[e.DST_COLOR = 774] = "DST_COLOR", e[e.ONE_MINUS_DST_COLOR = 775] = "ONE_MINUS_DST_COLOR", e[e.SRC_ALPHA = 770] = "SRC_ALPHA", e[e.ONE_MINUS_SRC_ALPHA = 771] = "ONE_MINUS_SRC_ALPHA", e[e.DST_ALPHA = 772] = "DST_ALPHA", e[e.ONE_MINUS_DST_ALPHA = 773] = "ONE_MINUS_DST_ALPHA", e[e.CONSTANT_COLOR = 32769] = "CONSTANT_COLOR", e[e.ONE_MINUS_CONSTANT_COLOR = 32770] = "ONE_MINUS_CONSTANT_COLOR", e[e.CONSTANT_ALPHA = 32771] = "CONSTANT_ALPHA", e[e.ONE_MINUS_CONSTANT_ALPHA = 32772] = "ONE_MINUS_CONSTANT_ALPHA", e[e.SRC_ALPHA_SATURATE = 776] = "SRC_ALPHA_SATURATE"
    }(v || (v = {})), function (e) {
        e[e.Add = 32774] = "Add", e[e.Subtract = 32778] = "Subtract", e[e.ReverseSubtract = 32779] = "ReverseSubtract"
    }(y || (y = {})), function (e) {
        e[e.Front = 1028] = "Front", e[e.Back = 1029] = "Back", e[e.FrontAndBack = 1032] = "FrontAndBack"
    }(b || (b = {})), function (e) {
        e[e.CW = 2304] = "CW", e[e.CCW = 2305] = "CCW"
    }(x || (x = {})), function (e) {
        e[e.Blend = 3042] = "Blend", e[e.CullFace = 2884] = "CullFace", e[e.DepthTest = 2929] = "DepthTest", e[e.StencilTest = 2960] = "StencilTest", e[e.ScissorTest = 3089] = "ScissorTest", e[e.PolygonOffsetFill = 32823] = "PolygonOffsetFill", e[e.SampleAlphaToCoverage = 32926] = "SampleAlphaToCoverage"
    }(T || (T = {})), function (e) {
        e[e.Never = 512] = "Never", e[e.Less = 513] = "Less", e[e.Lequal = 515] = "Lequal", e[e.Equal = 514] = "Equal", e[e.Greater = 516] = "Greater", e[e.NotEqual = 517] = "NotEqual", e[e.GEqual = 518] = "GEqual", e[e.Always = 519] = "Always"
    }(E || (E = {}))
}, function (e, t, n) {
    "use strict";
    n.r(t), n.d(t, "getSupportedExtensions", (function () {
        return S
    })), n.d(t, "startup", (function () {
        return C
    }));
    var r = n(2), i = n(1), o = n(0), a = n(4), s = function (e, t) {
        return (s = Object.setPrototypeOf || {__proto__: []} instanceof Array && function (e, t) {
            e.__proto__ = t
        } || function (e, t) {
            for (var n in t) t.hasOwnProperty(n) && (e[n] = t[n])
        })(e, t)
    };

    function l(e, t) {
        function n() {
            this.constructor = e
        }

        s(e, t), e.prototype = null === t ? Object.create(t) : (n.prototype = t.prototype, new n)
    }

    function u(e, t, n, r) {
        var i, o = arguments.length, a = o < 3 ? t : null === r ? r = Object.getOwnPropertyDescriptor(t, n) : r;
        if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) a = Reflect.decorate(e, t, n, r); else for (var s = e.length - 1; s >= 0; s--) (i = e[s]) && (a = (o < 3 ? i(a) : o > 3 ? i(t, n, a) : i(t, n)) || a);
        return o > 3 && a && Object.defineProperty(t, n, a), a
    }

    function c(e, t) {
        var n, r, i, o, a = {
            label: 0, sent: function () {
                if (1 & i[0]) throw i[1];
                return i[1]
            }, trys: [], ops: []
        };
        return o = {
            next: s(0),
            throw: s(1),
            return: s(2)
        }, "function" == typeof Symbol && (o[Symbol.iterator] = function () {
            return this
        }), o;

        function s(o) {
            return function (s) {
                return function (o) {
                    if (n) throw new TypeError("Generator is already executing.");
                    for (; a;) try {
                        if (n = 1, r && (i = 2 & o[0] ? r.return : o[0] ? r.throw || ((i = r.return) && i.call(r), 0) : r.next) && !(i = i.call(r, o[1])).done) return i;
                        switch (r = 0, i && (o = [2 & o[0], i.value]), o[0]) {
                            case 0:
                            case 1:
                                i = o;
                                break;
                            case 4:
                                return a.label++, {value: o[1], done: !1};
                            case 5:
                                a.label++, r = o[1], o = [0];
                                continue;
                            case 7:
                                o = a.ops.pop(), a.trys.pop();
                                continue;
                            default:
                                if (!(i = a.trys, (i = i.length > 0 && i[i.length - 1]) || 6 !== o[0] && 2 !== o[0])) {
                                    a = 0;
                                    continue
                                }
                                if (3 === o[0] && (!i || o[1] > i[0] && o[1] < i[3])) {
                                    a.label = o[1];
                                    break
                                }
                                if (6 === o[0] && a.label < i[1]) {
                                    a.label = i[1], i = o;
                                    break
                                }
                                if (i && a.label < i[2]) {
                                    a.label = i[2], a.ops.push(o);
                                    break
                                }
                                i[2] && a.ops.pop(), a.trys.pop();
                                continue
                        }
                        o = t.call(e, a)
                    } catch (e) {
                        o = [6, e], r = 0
                    } finally {
                        n = i = 0
                    }
                    if (5 & o[0]) throw o[1];
                    return {value: o[0] ? o[1] : void 0, done: !0}
                }([o, s])
            }
        }
    }

    var p = {
        position: "POSITION",
        normal: "NORMAL",
        uv: "TEXCOORD_0",
        uv2: "TEXCOORD_1",
        color: "COLOR_0",
        morphTarget0: "MORPHTARGET_0",
        morphTarget1: "MORPHTARGET_1",
        morphTarget2: "MORPHTARGET_2",
        morphTarget3: "MORPHTARGET_3",
        morphTarget4: "MORPHTARGET_4",
        morphTarget5: "MORPHTARGET_5",
        morphTarget6: "MORPHTARGET_6",
        morphTarget7: "MORPHTARGET_7",
        morphNormal0: "MORPHNORMAL_0",
        morphNormal1: "MORPHNORMAL_1",
        morphNormal2: "MORPHNORMAL_2",
        morphNormal3: "MORPHNORMAL_3",
        skinIndex: "JOINTS_0",
        skinWeight: "WEIGHTS_0",
        corner: "_CORNER",
        startPosition: "_START_POSITION",
        startVelocity: "_START_VELOCITY",
        startColor: "_START_COLOR",
        startSize: "_START_SIZE",
        startRotation: "_START_ROTATION",
        time: "_TIME",
        random0: "_RANDOM0",
        random1: "_RANDOM1",
        startWorldPosition: "_WORLD_POSITION",
        startWorldRotation: "_WORLD_ROTATION",
        lineDistance: "_INSTANCE_DISTANCE",
        instanceStart: "_INSTANCE_START",
        instanceEnd: "_INSTANCE_END",
        instanceColorStart: "_INSTANCE_COLOR_START",
        instanceColorEnd: "_INSTANCE_COLOR_END",
        instanceDistanceStart: "_INSTANCE_DISTANCE_START",
        instanceDistanceEnd: "_INSTANCE_DISTANCE_END",
        modelMatrix0: "_INSTANCED_MODEL0",
        modelMatrix1: "_INSTANCED_MODEL1",
        modelMatrix2: "_INSTANCED_MODEL2",
        modelMatrix3: "_INSTANCED_MODEL3",
        modelViewMatrix0: "_INSTANCED_MODEL_VIEW0",
        modelViewMatrix1: "_INSTANCED_MODEL_VIEW1",
        modelViewMatrix2: "_INSTANCED_MODEL_VIEW2",
        modelViewMatrix3: "_INSTANCED_MODEL_VIEW3"
    }, d = {
        toneMappingExposure: "_TONE_MAPPING_EXPOSURE",
        toneMappingWhitePoint: "_TONE_MAPPING_WHITE_POINT",
        resolution: "_RESOLUTION"
    }, h = {
        lightMapIntensity: "_LIGHTMAPINTENSITY",
        ambientLightColor: "_AMBIENTLIGHTCOLOR",
        fogColor: "_FOG_COLOR",
        fogDensity: "_FOG_DENSITY",
        fogNear: "_FOG_NEAR",
        fogFar: "_FOG_FAR"
    }, f = {
        viewMatrix: "VIEW",
        projectionMatrix: "PROJECTION",
        viewProjectionMatrix: "_VIEWPROJECTION",
        cameraForward: "_CAMERA_FORWARD",
        cameraUp: "_CAMERA_UP",
        cameraPosition: "_CAMERA_POS",
        "directionalLights[0]": "_DIRECTLIGHTS",
        "spotLights[0]": "_SPOTLIGHTS",
        "rectAreaLights[0]": "_RECTAREALIGHTS",
        "pointLights[0]": "_POINTLIGHTS",
        "hemisphereLights[0]": "_HEMILIGHTS",
        logDepthBufFC: "_LOG_DEPTH_BUFFC"
    }, m = {referencePosition: "_REFERENCEPOSITION", nearDistance: "_NEARDICTANCE", farDistance: "_FARDISTANCE"}, _ = {
        modelMatrix: "MODEL",
        modelViewMatrix: "MODELVIEW",
        modelViewProjectionMatrix: "MODELVIEWPROJECTION",
        normalMatrix: "MODELVIEWINVERSE",
        "boneMatrices[0]": "JOINTMATRIX",
        boneTexture: "_BONETEXTURE",
        boneTextureSize: "_BONETEXTURESIZE",
        clock: "_CLOCK",
        lightMap: "_LIGHTMAPTEX",
        lightMapScaleOffset: "_LIGHTMAP_SCALE_OFFSET",
        "directionalShadowMatrix[0]": "_DIRECTIONSHADOWMAT",
        "spotShadowMatrix[0]": "_SPOTSHADOWMAT",
        "pointShadowMatrix[0]": "_POINTSHADOWMAT",
        "directionalShadowMap[0]": "_DIRECTIONSHADOWMAP",
        "pointShadowMap[0]": "_POINTSHADOWMAP",
        "spotShadowMap[0]": "_SPOTSHADOWMAP",
        rotation: "_ROTATION",
        scale2D: "_SCALE2D",
        "morphTargetInfluences[0]": "MORPHTARGETINFLUENCES",
        prefabMatrix: "_PREFABMATRIX",
        aniTexture: "_ANITEXTURE",
        widthAndHeight: "_WIDTHANDHEIGHT",
        frame: "_FRAME"
    }, g = function (e) {
        function t(e) {
            return this.index = t.count++, this.attributesMask = 0, this.attributes = [], this.uniforms = [], this.globalUniforms = [], this.sceneUniforms = [], this.cameraUniforms = [], this.shadowUniforms = [], this.modelUniforms = [], this.program = e, this
        }

        return l(t, DebuggerClass), t.prototype.extract = function (e, n) {
            for (var r = n.webgl, i = this, o = i.attributes, a = i.globalUniforms, s = i.sceneUniforms, l = i.cameraUniforms, u = i.shadowUniforms, c = i.modelUniforms, g = i.uniforms, v = i.program, y = r.getProgramParameter(v, r.ACTIVE_ATTRIBUTES), b = 0; b < y; ++b) {
                var x = r.getActiveAttrib(v, b), T = x.name, E = x.type, C = r.getAttribLocation(v, T), S = "";
                T in e.attributes ? S = e.attributes[T].semantic : T in p ? S = p[T] : console.warn("Invalid attribute.", T), t.allAttributes.indexOf(S) < 0 && t.allAttributes.push(S), this.attributesMask |= 1 << t.allAttributes.indexOf(S), o.push({
                    name: T,
                    type: E,
                    location: C,
                    semantic: S
                })
            }
            var M = r.getProgramParameter(v, r.ACTIVE_UNIFORMS);
            for (b = 0; b < M; ++b) {
                var A = r.getActiveUniform(v, b), O = A.name, w = (E = A.type, A.size), R = r.getUniformLocation(v, O),
                    P = (S = "", null);
                if (O in e.uniforms) P = g, "" !== (S = e.uniforms[O].semantic || "") && console.debug("Custom uniform.", O, S); else O in d ? (S = d[O], P = a) : O in h ? (S = h[O], P = s) : O in f ? (S = f[O], P = l) : O in m ? (S = m[O], P = u) : O in _ ? (S = _[O], P = c) : console.warn("Invalid uniform.", O);
                null !== P && P.push({name: O, type: E, size: w, semantic: S, location: R, textureUnits: null})
            }
            for (var L = a.concat(s, l, u, c, g), D = [], I = [], N = 0, z = L; N < z.length; N++) {
                var U = (G = z[N]).name;
                35678 !== (E = G.type) && 35680 !== E || (U.indexOf("[") >= 0 ? D.push(U) : I.push(U))
            }
            for (var F = I.concat(D), k = 0, V = 0, B = L; V < B.length; V++) {
                var G = B[V];
                if (!(F.indexOf(G.name) < 0)) {
                    w = G.size;
                    var j = G.textureUnits;
                    null === j && (j = G.textureUnits = []), j.length = w;
                    for (b = 0; b < w; b++) j[b] = k++
                }
            }
            return this
        }, t.count = 0, t.allAttributes = [], t
    }();
    __reflect(g, "@egret/webgl/WebGLProgramBinder");
    var v = ["", "MOZ_", "OP_", "WEBKIT_"], y = /^[ \t]*#include +<([\w\d./]+)>/gm,
        b = /#pragma unroll_loop[\s]+?for \( int i \= (\d+)\; i < (\d+)\; i \+\+ \)([\s\S]+?)\/\/ #end unroll_loop/g,
        x = function (e) {
            function t() {
                var t = null !== e && e.apply(this, arguments) || this;
                return t.commonExtensions = "", t.vertexExtensions = "", t.fragmentExtensions = "", t.commonDefines = "", t.vertexDefines = "", t.fragmentDefines = "", t.defaultCustomShaderChunks = {
                    custom_vertex: "",
                    custom_begin_vertex: "",
                    custom_end_vertex: "",
                    custom_fragment: "",
                    custom_begin_fragment: "",
                    custom_end_fragment: ""
                }, t.webgl = null, t.customShaderChunks = null, t._inverseModelViewMatrix = i.Matrix3.create(), t._modelViewPojectionMatrix = i.Matrix4.create(), t._stateEnables = [3042, 2884, 2929, 2960, 3089], t._renderContext = null, t._currentScene = null, t._sceneLight = null, t._fog = null, t._replace = function (e, n) {
                    var r = !0, i = "";
                    return n in a.chunks ? i = a.chunks[n] : n in t.defaultCustomShaderChunks && (r = !1, i = null !== t.customShaderChunks && n in t.customShaderChunks ? t.customShaderChunks[n] : ""), i.length > 0 ? i.replace(y, t._replace) : (r && console.error("Can not resolve #include <" + n + ">"), "")
                }, t
            }

            return l(t, e), t.prototype._bindWebGL = function () {
                var e = this.webgl, t = this._renderContext;
                null !== t.vertexArrayObject && (e.createVertexArray = t.vertexArrayObject.createVertexArrayOES.bind(t.vertexArrayObject), e.bindVertexArray = t.vertexArrayObject.bindVertexArrayOES.bind(t.vertexArrayObject), e.deleteVertexArray = t.vertexArrayObject.deleteVertexArrayOES.bind(t.vertexArrayObject)), null !== t.instancedArrays && (e.drawArraysInstanced = t.instancedArrays.drawArraysInstancedANGLE.bind(t.instancedArrays), e.drawElementsInstanced = t.instancedArrays.drawElementsInstancedANGLE.bind(t.instancedArrays), e.vertexAttribDivisor = t.instancedArrays.vertexAttribDivisorANGLE.bind(t.instancedArrays))
            }, t.prototype._getExtension = function (e, t) {
                for (var n = 0, r = v; n < r.length; n++) {
                    var i = r[n], o = e.getExtension(i + t);
                    if (null !== o) return o
                }
                return null
            }, t.prototype._getMaxShaderPrecision = function (e, t, n) {
                if ("highp" === n) {
                    if ((r = e.getShaderPrecisionFormat(t, e.HIGH_FLOAT)) && r.precision > 0) return "highp";
                    n = "mediump"
                }
                var r;
                if ("mediump" === n && ((r = e.getShaderPrecisionFormat(t, e.MEDIUM_FLOAT)) && r.precision > 0)) return "mediump";
                return "lowp"
            }, t.prototype._getCommonExtensions = function () {
                var e = this._renderContext, t = "";
                e.standardDerivativesEnabled && (t += "#extension GL_OES_standard_derivatives : enable \n"), e.fragDepthEnabled && (t += "#extension GL_EXT_frag_depth : enable \n"), null !== e.shaderTextureLOD && (t += "#extension GL_EXT_shader_texture_lod : enable \n"), this.fragmentExtensions = t
            }, t.prototype._getCommonDefines = function () {
                var e = this._renderContext, t = "";
                t += "#define EGRET \n", t += "#define USE_UV \n", this.commonDefines = t, t = "", t += "precision " + e.maxVertexPrecision + " float; \n", t += "precision " + e.maxVertexPrecision + " int; \n", this.vertexDefines = t, t = "", t += "precision " + e.maxFragmentPrecision + " float; \n", t += "precision " + e.maxFragmentPrecision + " int; \n", t += a.chunks.encodings_pars_fragment + " \n", this.fragmentDefines = t
            }, t.prototype._getPrefixVertex = function (e) {
                return [this.commonExtensions, this.vertexExtensions, this.commonDefines, this.vertexDefines, e, a.chunks.common_vert_def, "\n"].filter(this._filterEmptyLine).join("\n")
            }, t.prototype._getPrefixFragment = function (e) {
                return [this.commonExtensions, this.fragmentExtensions, this.commonDefines, this.fragmentDefines, e, a.chunks.common_frag_def, "\n"].filter(this._filterEmptyLine).join("\n")
            }, t.prototype._loopReplace = function (e, t, n, r) {
                for (var i = "", o = parseInt(t); o < parseInt(n); o++) i += r.replace(/ i /g, " " + o + " ").replace(/UNROLLED_LOOP_INDEX/g, o.toString());
                return i
            }, t.prototype._parseIncludes = function (e) {
                return e.replace(y, this._replace)
            }, t.prototype._unrollLoops = function (e) {
                return e.replace(b, this._loopReplace)
            }, t.prototype._filterEmptyLine = function (e) {
                return e.length > 0
            }, t.prototype._replaceShaderNums = function (e) {
                var t = this._renderContext.lightCollector, n = t.directionalLights, r = t.spotLights,
                    i = t.rectangleAreaLights, o = t.pointLights, a = t.hemisphereLights;
                return e.replace(new RegExp("NUM_DIR_LIGHTS", "g"), n.length.toString()).replace(new RegExp("NUM_SPOT_LIGHTS", "g"), r.length.toString()).replace(new RegExp("NUM_RECT_AREA_LIGHTS", "g"), i.length.toString()).replace(new RegExp("NUM_POINT_LIGHTS", "g"), o.length.toString()).replace(new RegExp("NUM_HEMI_LIGHTS", "g"), a.length.toString()).replace(new RegExp("NUM_CLIPPING_PLANES", "g"), "0").replace(new RegExp("UNION_CLIPPING_PLANES", "g"), "0").replace(new RegExp("NUM_DIR_LIGHT_SHADOWS", "g"), n.length.toString()).replace(new RegExp("NUM_SPOT_LIGHT_SHADOWS", "g"), r.length.toString()).replace(new RegExp("NUM_POINT_LIGHT_SHADOWS", "g"), o.length.toString())
            }, t.prototype._compileShader = function (e, t) {
                var n = this.webgl, r = n.createShader(e.type), i = this._parseIncludes(e.extras.data);
                return i = this._replaceShaderNums(i), i = this._unrollLoops(t + i), n.shaderSource(r, i), n.compileShader(r), n.getShaderParameter(r, 35713) ? r : (console.error("Compile webgl shader error.", e.name, "\n", n.getShaderInfoLog(r)), n.deleteShader(r), null)
            }, t.prototype._updateRendererDefines = function (e, t) {
                var n = this._renderContext, r = n.caches, i = n.maxBoneCount, o = n.textureFloatEnabled,
                    s = this._renderContext.entity.getComponent(a.Defines), l = !1, u = !1, c = 0, p = !1, d = !1;
                if (null !== e && (null !== e.entity.getComponent(a.MeshFilter) && (d = void 0 !== e.entity.getComponent(a.MeshFilter).mesh.glTFMesh.extras.useMorphNormal && e.entity.getComponent(a.MeshFilter).mesh.glTFMesh.extras.useMorphNormal), p = e.useMorph, l = e.constructor === a.MeshRenderer && e.lightmapIndex >= 0, u = t && e.receiveShadows, c = e.constructor === a.SkinnedMeshRenderer ? Math.min(i, e.boneCount) : 0, c = e.constructor === a.GpuSkinnedMeshRenderer ? i : c), r.useMorph !== p && (p ? (s.addDefine("USE_MORPHTARGETS"), d && s.addDefine("USE_MORPHNORMALS")) : (s.removeDefine("USE_MORPHTARGETS"), d && s.removeDefine("USE_MORPHNORMALS")), r.useMorph = p), r.boneCount !== c && (c > 0 ? (s.addDefine("USE_SKINNING"), o ? (s.addDefine("BONE_TEXTURE"), e.constructor === a.GpuSkinnedMeshRenderer ? s.addDefine("USE_GPU_ANI") : s.removeDefine("USE_GPU_ANI")) : s.addDefine("MAX_BONES", c)) : (s.removeDefine("USE_SKINNING"), o ? (s.removeDefine("BONE_TEXTURE"), s.removeDefine("USE_GPU_ANI")) : s.removeDefine("MAX_BONES")), r.boneCount = c), null !== e && r.cullingMask !== e.entity.node.layer) {
                    var h = e.entity.node.layer, f = Math.log2(h);
                    s.addDefine("LIGHT_CULLING", f), r.cullingMask = h
                }
                r.useLightMap !== l && (l ? s.addDefine("USE_LIGHTMAP") : s.removeDefine("USE_LIGHTMAP"), r.useLightMap = l), r.receiveShadows !== u && (u ? (s.addDefine("USE_SHADOWMAP"), s.addDefine("SHADOWMAP_TYPE_PCF")) : (s.removeDefine("USE_SHADOWMAP"), s.removeDefine("SHADOWMAP_TYPE_PCF")), r.receiveShadows = u);
                var m = null !== this._fog ? this._fog.mode : -1;
                if (r.fogMode !== m) {
                    switch (m) {
                        case 0:
                            s.addDefine("USE_FOG"), s.removeDefine("FOG_EXP2");
                            break;
                        case 1:
                            s.addDefine("USE_FOG"), s.addDefine("FOG_EXP2");
                            break;
                        default:
                            s.removeDefine("USE_FOG"), s.removeDefine("FOG_EXP2")
                    }
                    r.fogMode = m
                }
            }, t.prototype._updateProgram = function (e) {
                var t = this.webgl, n = this._renderContext, r = n.caches, i = e.shader,
                    o = i.glTFShader.extras.programs, s = n.entity.getComponent(a.Defines), l = !1, u = null,
                    c = s.definesMask + e.defines.definesMask;
                if (c in o) u = o[c]; else {
                    var p = i.glTF.extensions.KHR_techniques_webgl, d = [s.defines, e.defines.defines];
                    this.customShaderChunks = i.customs;
                    var h = this._compileShader(p.shaders[0], this._getPrefixVertex(a.Defines.linkDefine(d, 1))),
                        f = this._compileShader(p.shaders[1], this._getPrefixFragment(a.Defines.linkDefine(d, 2)));
                    if (null !== h && null !== f) {
                        var m = t.createProgram();
                        t.attachShader(m, h), t.attachShader(m, f), t.linkProgram(m);
                        var _ = t.getProgramInfoLog(m).trim(), v = t.getShaderInfoLog(h).trim(),
                            y = t.getShaderInfoLog(f).trim();
                        t.getProgramParameter(m, 35714) ? u = new g(m).extract(e.technique, this) : (console.error("Create webgl program error.", _, v, y), t.deleteProgram(m)), t.deleteShader(h), t.deleteShader(f)
                    }
                    o[c] = u
                }
                return u !== r.program && (null !== u && t.useProgram(u.program), n.clearCache(2), r.program = u, l = !0), l
            }, t.prototype._updateAttributes = function (e, t) {
                var n = this.webgl, r = this._renderContext, i = e.glTFMesh, o = i.primitives, a = i.extras,
                    s = o[t].extras;
                if (e.update(28, t), null !== r.vertexArrayObject) n.bindVertexArray(s.vaos[s.program.attributesMask]); else {
                    var l = a.vbo, u = s.ibo;
                    n.bindBuffer(34962, l), n.bindBuffer(34963, u), this.updateVertexAttributes(e, t)
                }
            }, t.prototype._updateGlobalUniforms = function (e, t, n, r, o) {
                var s = this, l = s.webgl, u = s._renderContext, c = s._currentScene, p = s._sceneLight, d = s._fog,
                    h = u, f = h.caches, m = h.lightCollector, _ = e.globalUniforms, g = e.modelUniforms, v = n.matrix,
                    y = n.modelViewMatrix, b = 0;
                if (this._modelViewPojectionMatrix.multiply(t.worldToClipMatrix, v), o) for (b = _.length; b--;) {
                    var x = _[b], T = x.semantic, E = x.location;
                    switch (T) {
                        case"_TONE_MAPPING_EXPOSURE":
                            l.uniform1f(E, u.toneMappingExposure);
                            break;
                        case"_TONE_MAPPING_WHITE_POINT":
                            l.uniform1f(E, u.toneMappingWhitePoint);
                            break;
                        case"_RESOLUTION":
                            var C = i.Application.instance.stage.viewport, S = C.w, M = C.h;
                            l.uniform2f(E, 1 / S, 1 / M)
                    }
                }
                if (c !== f.currentScene) {
                    var A = e.sceneUniforms;
                    if (null !== p) for (b = A.length; b--;) {
                        var O = A[b], w = (T = O.semantic, O.location);
                        switch (T) {
                            case"_AMBIENTLIGHTCOLOR":
                                var R = p.ambientColor;
                                l.uniform3f(w, R.r, R.g, R.b);
                                break;
                            case"_LIGHTMAPINTENSITY":
                                l.uniform1f(w, p.lightmapIntensity)
                        }
                    }
                    if (null !== d) for (b = A.length; b--;) {
                        var P = A[b], L = (T = P.semantic, P.location);
                        switch (T) {
                            case"_FOG_NEAR":
                                l.uniform1f(L, d.near);
                                break;
                            case"_FOG_FAR":
                                l.uniform1f(L, d.far);
                                break;
                            case"_FOG_DENSITY":
                                l.uniform1f(L, d.density);
                                break;
                            case"_FOG_COLOR":
                                var D = d.color;
                                l.uniform3f(L, D.r, D.g, D.b)
                        }
                    }
                    f.currentScene = c
                }
                if (t !== f.camera) {
                    var I = e.cameraUniforms, N = t.cameraToWorldMatrix.rawData;
                    for (b = I.length; b--;) {
                        var z = I[b], U = (T = z.semantic, z.location);
                        switch (T) {
                            case"VIEW":
                                l.uniformMatrix4fv(U, !1, t.worldToCameraMatrix.rawData);
                                break;
                            case"PROJECTION":
                                l.uniformMatrix4fv(U, !1, t.projectionMatrix.rawData);
                                break;
                            case"_VIEWPROJECTION":
                                l.uniformMatrix4fv(U, !1, t.worldToClipMatrix.rawData);
                                break;
                            case"_CAMERA_FORWARD":
                                l.uniform3f(U, -N[8], -N[9], -N[10]);
                                break;
                            case"_CAMERA_UP":
                                l.uniform3f(U, N[4], N[5], N[6]);
                                break;
                            case"_CAMERA_POS":
                                l.uniform3f(U, N[12], N[13], N[14]);
                                break;
                            case"_DIRECTLIGHTS":
                                m.directLightBuffer.byteLength > 0 && l.uniform1fv(U, m.directLightBuffer);
                                break;
                            case"_SPOTLIGHTS":
                                m.spotLightBuffer.byteLength > 0 && l.uniform1fv(U, m.spotLightBuffer);
                                break;
                            case"_RECTAREALIGHTS":
                                m.pointLightBuffer.length > 0 && l.uniform1fv(U, m.rectangleAreaLightBuffer);
                                break;
                            case"_POINTLIGHTS":
                                m.pointLightBuffer.length > 0 && l.uniform1fv(U, m.pointLightBuffer);
                                break;
                            case"_HEMILIGHTS":
                                m.hemisphereLightBuffer.byteLength > 0 && l.uniform1fv(U, m.hemisphereLightBuffer);
                                break;
                            case"_LOG_DEPTH_BUFFC":
                                l.uniform1f(U, t.context.logDepthBufFC)
                        }
                    }
                    f.camera = t
                }
                if (f.light !== m.currentShadowLight) {
                    var F = f.light = m.currentShadowLight;
                    if (null !== F) {
                        var k = e.shadowUniforms, V = F.entity.getComponent(a.LightShadow);
                        for (b = k.length; b--;) {
                            var B = k[b], G = (T = B.semantic, B.location);
                            switch (T) {
                                case"_REFERENCEPOSITION":
                                    N = F.entity.transform.localToWorldMatrix.rawData;
                                    l.uniform3f(G, N[12], N[13], N[14]);
                                    break;
                                case"_NEARDICTANCE":
                                    l.uniform1f(G, V.near);
                                    break;
                                case"_FARDISTANCE":
                                    l.uniform1f(G, V.far)
                            }
                        }
                    }
                }
                b = g.length;
                for (var j = u.customUniformMap; b--;) {
                    var H = g[b], W = (T = H.semantic, H.location);
                    if (T in j) j[T](l, H, n); else switch (T) {
                        case"MODEL":
                            l.uniformMatrix4fv(W, !1, v.rawData);
                            break;
                        case"MODELVIEW":
                            l.uniformMatrix4fv(W, !1, y.rawData);
                            break;
                        case"MODELVIEWPROJECTION":
                            l.uniformMatrix4fv(W, !1, this._modelViewPojectionMatrix.rawData);
                            break;
                        case"MODELVIEWINVERSE":
                            l.uniformMatrix3fv(W, !1, this._inverseModelViewMatrix.getNormalMatrix(y).rawData);
                            break;
                        case"JOINTMATRIX":
                            var X = r.source || r;
                            X.boneMatrices && l.uniformMatrix4fv(W, !1, X.boneMatrices);
                            break;
                        case"MORPHTARGETINFLUENCES":
                            var Y = r.weight;
                            Y && l.uniform1fv(W, Y);
                            break;
                        case"_BONETEXTURE":
                            if (H.textureUnits && 1 === H.textureUnits.length) {
                                if (oe = (r.source || r).boneTexture) {
                                    var q = H.textureUnits[0];
                                    l.uniform1i(W, q), oe.bindTexture(q)
                                }
                            } else console.error("Error texture unit.");
                            break;
                        case"_BONETEXTURESIZE":
                            var Z = r.source || r;
                            Z.boneTexture && l.uniform1i(W, Z.boneTexture.width);
                            break;
                        case"_PREFABMATRIX":
                            (K = r.source || r).targetMatrixData && l.uniformMatrix4fv(W, !1, K.targetMatrixData);
                            break;
                        case"_ANITEXTURE":
                            if (H.textureUnits && 1 === H.textureUnits.length) if ((oe = (K = r.source || r).boneTexture) && oe.glTFTexture) {
                                q = H.textureUnits[0];
                                l.uniform1i(W, q), oe.bindTexture(q)
                            }
                            break;
                        case"_WIDTHANDHEIGHT":
                            (oe = (K = r.source || r).boneTexture) && oe.glTFTexture && l.uniform2f(W, oe.width - 1, oe.height - 1);
                            break;
                        case"_FRAME":
                            var K = r.source || r;
                            l.uniform1f(W, K.currentFrame);
                            break;
                        case"_CLOCK":
                            l.uniform4fv(W, u.clockBuffer);
                            break;
                        case"_ROTATION":
                        case"_SCALE2D":
                            break;
                        case"_DIRECTIONSHADOWMAT":
                            l.uniformMatrix4fv(W, !1, m.directShadowMatrix);
                            break;
                        case"_SPOTSHADOWMAT":
                            l.uniformMatrix4fv(W, !1, m.spotShadowMatrix);
                            break;
                        case"_POINTSHADOWMAT":
                            l.uniformMatrix4fv(W, !1, m.pointShadowMatrix);
                            break;
                        case"_DIRECTIONSHADOWMAP":
                            if (m.directShadowMaps.length > 0 && H.textureUnits) {
                                var Q = H.textureUnits;
                                l.uniform1iv(W, Q);
                                for (var J = 0, $ = Q.length; J < $; J++) {
                                    (m.directShadowMaps[J] || a.DefaultTextures.WHITE).bindTexture(Q[J])
                                }
                            }
                            break;
                        case"_POINTSHADOWMAP":
                            if (m.pointShadowMaps.length > 0 && H.textureUnits) {
                                Q = H.textureUnits;
                                l.uniform1iv(W, Q);
                                var ee = 0;
                                for ($ = Q.length; ee < $; ee++) {
                                    (m.pointShadowMaps[ee] || a.DefaultTextures.WHITE).bindTexture(Q[ee])
                                }
                            }
                            break;
                        case"_SPOTSHADOWMAP":
                            if (m.spotShadowMaps.length > 0 && H.textureUnits) {
                                Q = H.textureUnits;
                                l.uniform1iv(W, Q);
                                var te = 0;
                                for ($ = Q.length; te < $; te++) {
                                    (m.spotShadowMaps[te] || a.DefaultTextures.WHITE).bindTexture(Q[te])
                                }
                            }
                            break;
                        case"_LIGHTMAP_SCALE_OFFSET":
                            var ne = r.lightmapScaleOffset;
                            l.uniform4f(W, ne.x, ne.y, ne.z, ne.w);
                            break;
                        case"_LIGHTMAPTEX":
                            var re = r.lightmapIndex;
                            if (re >= 0 && re !== f.lightmapIndex) {
                                var ie = null !== c ? c.entity.getComponent(a.SceneLight) : null;
                                if (H.textureUnits && 1 === H.textureUnits.length && null !== ie) {
                                    var oe = ie.lightmaps[re] || a.DefaultTextures.WHITE;
                                    q = H.textureUnits[0];
                                    l.uniform1i(W, q), oe.bindTexture(q)
                                } else console.error("Error texture unit.");
                                f.lightmapIndex = re
                            }
                    }
                }
            }, t.prototype._updateUniforms = function (e, t) {
                var n = this.webgl, r = this._renderContext.caches, i = t.technique, o = i.states || null;
                this._updateState(o), i.program !== e.index && (i.program = e.index);
                for (var s = i.uniforms, l = 0, u = e.uniforms; l < u.length; l++) {
                    var c = u[l], p = c.location, d = s[c.name], h = d.value;
                    switch (d.type) {
                        case 35670:
                        case 5124:
                            c.size > 1 ? n.uniform1iv(p, h) : n.uniform1i(p, h);
                            break;
                        case 35671:
                        case 35667:
                            n.uniform2iv(p, h);
                            break;
                        case 35672:
                        case 35668:
                            n.uniform3iv(p, h);
                            break;
                        case 35673:
                        case 35669:
                            n.uniform4iv(p, h);
                            break;
                        case 5126:
                            c.size > 1 ? n.uniform1fv(p, h) : n.uniform1f(p, h);
                            break;
                        case 35664:
                            n.uniform2fv(p, h);
                            break;
                        case 35665:
                            n.uniform3fv(p, h);
                            break;
                        case 35666:
                            n.uniform4fv(p, h);
                            break;
                        case 35674:
                            n.uniformMatrix2fv(p, !1, h);
                            break;
                        case 35675:
                            n.uniformMatrix3fv(p, !1, h);
                            break;
                        case 35676:
                            n.uniformMatrix4fv(p, !1, h);
                            break;
                        case 35678:
                        case 35680:
                            if (c.textureUnits && 1 === c.textureUnits.length) {
                                var f = c.textureUnits[0], m = h;
                                if ("envMap" === c.name) (!m || m.isDestroyed) && (m = r.skyBoxTexture || a.DefaultTextures.WHITE), t.setFloat("flipEnvMap", 34067 === m.glTFTexture.extras.type ? 1 : -1), t.setFloat("maxMipLevel", m.levels);
                                n.uniform1i(p, f), m.bindTexture(f)
                            } else console.error("Error texture unit")
                    }
                }
            }, t.prototype._updateState = function (e) {
                for (var t = this.webgl, n = this._renderContext.caches.stateEnables, r = 0, i = this._stateEnables; r < i.length; r++) {
                    var o = i[r], a = null !== e && void 0 !== e.enable && e.enable.indexOf(o) >= 0;
                    o in n && a === n[o] || (n[o] = a, a ? t.enable(o) : t.disable(o))
                }
                if (null !== e) {
                    var s = e.functions;
                    if (void 0 !== s) for (var l in s) t[l].apply(t, s[l])
                }
            }, t.prototype._setViewport = function (e, t, n, r) {
                this.webgl.viewport(e, t, n, r)
            }, t.prototype._setRenderTarget = function (e) {
                null !== e ? e.activateTexture() : this.webgl.bindFramebuffer(36160, null)
            }, t.prototype._setColorMask = function (e, t, n, r) {
                this.webgl.colorMask(e, t, n, r)
            }, t.prototype._clearBuffer = function (e) {
                if (0 !== e) {
                    var t = this.webgl, n = this._renderContext;
                    if (256 & e && (t.depthMask(!0), t.clearDepth(n.clearDepth)), 1024 & e && t.clearStencil(n.clearStencil), 16384 & e) {
                        var r = n.clearColor;
                        t.clearColor(r.r, r.g, r.b, r.a)
                    }
                    t.clear(e)
                }
            }, t.prototype._copyFramebufferToTexture = function (e, t, n) {
                void 0 === n && (n = 0);
                var r = this.webgl;
                t.bindTexture(0), r.copyTexImage2D(t.glTFTexture.extras.type, n, t.format, e.x, e.y, t.width, t.height, 0)
            }, t.prototype._clearOnEnd = function () {
                null !== this._renderContext.vertexArrayObject && this.webgl.bindVertexArray(null)
            }, t.prototype._getSceneComponent = function (e, t, n) {
                var r = i.Application.instance.sceneManager.editorScene;
                if (e !== r) {
                    if (null !== e && null !== e.entity) {
                        var o = e.entity.getComponent(t);
                        if (null !== o && o.isActiveAndEnabled) return o
                    }
                    return n
                }
                return null !== (n = r.entity.getComponent(t)) && n.isActiveAndEnabled ? n : null
            }, t.prototype._draw = function (e, t) {
                void 0 === t && (t = null);
                var n = this.webgl, r = this._renderContext, i = r, o = i.caches, s = i.cameraCollector,
                    l = i.lightCollector, u = s.currentCamera, c = e.renderer, p = e.mesh,
                    d = this._currentScene = null !== c ? c.entity.node.scene : null;
                null === t && (t = e.material), this._sceneLight = this._getSceneComponent(d, a.SceneLight, o.defaultSceneLight), this._fog = this._getSceneComponent(d, a.Fog, o.defaultFog), this._updateRendererDefines(c, l.hasAnyCastShadow);
                var h = this._updateProgram(t), f = o.program;
                if (null !== f) {
                    var m = e.subMeshIndex, _ = p.glTFMesh.primitives[m], g = void 0 === _.mode ? 4 : _.mode;
                    if (this._updateGlobalUniforms(f, u, e, c, h), o.material === t && o.materialVerison === t.version || (this._updateUniforms(f, t), o.materialVerison = t.version, o.material = t, r.clearCache(16)), o.mesh !== p || o.subMeshIndex !== m) {
                        var v = _.extras.program;
                        null !== v && f.attributesMask === v.attributesMask || (p.needUpdate(4, m), _.extras.program = f), this._updateAttributes(p, m), o.subMeshIndex = m, o.mesh = p
                    }
                    var y = null !== r.instancedArrays ? e.instanced : 0;
                    if (null !== _.extras.draw) {
                        var b = _.extras.draw, x = b.offset, T = b.count;
                        if (void 0 !== _.indices) {
                            var E = p.getAccessor(_.indices);
                            y > 0 ? n.drawElementsInstanced(g, T, E.componentType, x, y) : n.drawElements(g, T, E.componentType, x)
                        } else y > 0 ? n.drawArraysInstanced(g, x, T, y) : n.drawArrays(g, x, T)
                    } else if (void 0 !== _.indices) {
                        E = p.getAccessor(_.indices);
                        y > 0 ? n.drawElementsInstanced(g, E.count, E.componentType, 0, y) : n.drawElements(g, E.count, E.componentType, 0)
                    } else y > 0 ? n.drawArraysInstanced(g, 0, p.vertexCount, y) : n.drawArrays(g, 0, p.vertexCount);
                    r.drawCallCollector.drawCallCount++
                }
            }, t.prototype.initialize = function (t, n, r) {
                e.prototype.initialize.call(this, t, n, r);
                var o = i.Application.instance, s = this.webgl = o.options.webgl || null,
                    l = this._renderContext = o.globalEntity.getComponent(a.RenderContext);
                if (null !== s) {
                    var u = /^WebGL\ ([0-9])/.exec(s.getParameter(s.VERSION));
                    l.version = u ? parseFloat(u[1]).toString() : "1", l.standardDerivativesEnabled = !!this._getExtension(s, "OES_standard_derivatives"), l.textureFloatEnabled = !!this._getExtension(s, "OES_texture_float"), l.fragDepthEnabled = !!this._getExtension(s, "EXT_frag_depth"), l.sRGB = this._getExtension(s, "EXT_sRGB"), l.textureFilterAnisotropic = this._getExtension(s, "EXT_texture_filter_anisotropic"), l.shaderTextureLOD = this._getExtension(s, "EXT_shader_texture_lod"), l.vertexArrayObject = this._getExtension(s, "OES_vertex_array_object"), l.instancedArrays = this._getExtension(s, "ANGLE_instanced_arrays"), l.compressed_texture_astc = this._getExtension(s, "WEBGL_compressed_texture_astc"), l.compressed_texture_etc1 = this._getExtension(s, "WEBGL_compressed_texture_etc1"), l.compressed_texture_pvrtc = this._getExtension(s, "WEBGL_compressed_texture_pvrtc"), l.compressed_texture_s3tc = this._getExtension(s, "WEBGL_compressed_texture_s3tc"), l.maxVertexPrecision = this._getMaxShaderPrecision(s, s.VERTEX_SHADER, "highp"), l.maxFragmentPrecision = this._getMaxShaderPrecision(s, s.FRAGMENT_SHADER, "highp"), l.maxVertexAttributes = s.getParameter(s.MAX_VERTEX_ATTRIBS), l.maxVertexUniformVectors = s.getParameter(s.MAX_VERTEX_UNIFORM_VECTORS), l.maxVertexTextures = s.getParameter(s.MAX_VERTEX_TEXTURE_IMAGE_UNITS), l.maxTextures = s.getParameter(s.MAX_TEXTURE_IMAGE_UNITS), l.maxTextureSize = s.getParameter(s.MAX_TEXTURE_SIZE), l.maxCubemapSize = s.getParameter(s.MAX_CUBE_MAP_TEXTURE_SIZE), l.maxRenderBufferize = s.getParameter(s.MAX_RENDERBUFFER_SIZE), l.maxBoneCount = l.textureFloatEnabled ? 1024 : Math.floor((l.maxVertexUniformVectors - 20) / 4), l.maxAnisotropy = null !== l.textureFilterAnisotropic ? s.getParameter(l.textureFilterAnisotropic.MAX_TEXTURE_MAX_ANISOTROPY_EXT) : 0, l.maxVertexUniformVectors = s.getParameter(s.MAX_VERTEX_UNIFORM_VECTORS), l.maxFragmentUniformVectors = s.getParameter(s.MAX_FRAGMENT_UNIFORM_VECTORS);
                    var c = l.maxFragmentUniformVectors, p = l.maxTextures;
                    l.maxDirectionalLightCount = Math.min(p, Math.floor(c / 43)), l.maxSpotLightCount = Math.min(p, Math.floor(c / 50)), l.maxRectangleAreaLightCount = Math.min(p, Math.floor(c / 44)), l.maxPointLightCount = Math.min(p, Math.floor(c / 47)), l.maxHemisphereLightCount = Math.min(p, Math.floor(c / 41));
                    var d = s.getParameter(s.COMPRESSED_TEXTURE_FORMATS), h = l.compressedTextureFormats;
                    if (void 0 !== d) {
                        h.length = d.length;
                        for (var f = 0, m = d.length; f < m; f++) h[f] = d[f]
                    }
                    this._bindWebGL(), this._getCommonExtensions(), this._getCommonDefines(), l.clearBuffer = this._clearBuffer.bind(this), l.copyFramebufferToTexture = this._copyFramebufferToTexture.bind(this), l.draw = this._draw.bind(this), l._setColorMask = this._setColorMask.bind(this), l._setViewport = this._setViewport.bind(this), l._setRenderTarget = this._setRenderTarget.bind(this), l._clearOnEnd = this._clearOnEnd.bind(this), console.info("WebGL version:", l.version), console.info("Standard derivatives enabled:", l.standardDerivativesEnabled), console.info("Texture float enabled:", l.textureFloatEnabled), console.info("Frag depth enabled:", l.fragDepthEnabled), console.info("SRGB", l.sRGB), console.info("Texture filter anisotropic:", l.textureFilterAnisotropic), console.info("Shader texture LOD:", l.shaderTextureLOD), console.info("Vertex Array Object:", l.vertexArrayObject), console.info("Instanced arrays:", l.instancedArrays), console.info("WEBGL_compressed_texture_astc", l.compressed_texture_astc), console.info("WEBGL_compressed_texture_etc1", l.compressed_texture_etc1), console.info("WEBGL_compressed_texture_pvrtc", l.compressed_texture_pvrtc), console.info("WEBGL_compressed_texture_s3tc", l.compressed_texture_s3tc), console.info("Maximum vertex shader precision:", l.maxVertexPrecision), console.info("Maximum fragment shader precision:", l.maxFragmentPrecision), console.info("Maximum vertex attribute count:", l.maxVertexAttributes), console.info("Maximum vertex uniform vectors:", l.maxVertexUniformVectors), console.info("Maximum vertex texture count:", l.maxVertexTextures), console.info("Maximum texture count:", l.maxTextures), console.info("Maximum texture size:", l.maxTextureSize), console.info("Maximum cube map texture size:", l.maxCubemapSize), console.info("Maximum render buffer size:", l.maxRenderBufferize), console.info("Maximum GPU skinned bone count:", l.maxBoneCount), console.info("Maximum anisotropy:", l.maxAnisotropy)
                }
            }, t.prototype.updateVertexAttributes = function (e, t) {
                for (var n = this.webgl, r = this._renderContext, i = r.caches, o = e.glTFMesh, a = e.attributes, s = o.extras.attributeOffsets, l = null !== r.instancedArrays, u = 0, c = 0, p = o.primitives[t].extras.program.attributes; c < p.length; c++) {
                    var d = p[c], h = d.location, f = d.semantic;
                    if (f in a) {
                        var m = e.getAccessor(a[f]), _ = m.extras, g = _.typeCount, v = _.divisor, y = s[f];
                        n.enableVertexAttribArray(h), n.vertexAttribPointer(h, g, m.componentType, void 0 !== m.normalized && m.normalized, 0, y), l && n.vertexAttribDivisor(h, v)
                    } else n.disableVertexAttribArray(h);
                    u++
                }
                if (u !== i.attributeCount) {
                    for (var b = u, x = i.attributeCount; b < x; ++b) n.disableVertexAttribArray(b);
                    i.attributeCount = u
                }
            }, t = u([Object(o.hideFlag)(28), Object(r.component)({isRemovable: !1, isAbstract: !1})], t)
        }(r.Component);
    __reflect(x, "@egret/webgl/WebGLRenderContext");
    var T = function (e) {
        function t() {
            return this
        }

        return l(t, DebuggerClass), t._setTexturexParameters = function (e, t, n) {
            var r = i.Application.instance.globalEntity, o = r.getComponent(a.RenderContext),
                s = r.getComponent(x).webgl;
            s.texParameteri(e, 10240, t.magFilter || 9728), s.texParameteri(e, 10241, t.minFilter || 9728), s.texParameteri(e, 10242, t.wrapS || 10497), s.texParameteri(e, 10243, t.wrapT || 10497), null !== o.textureFilterAnisotropic && n > 1 && s.texParameterf(e, o.textureFilterAnisotropic.TEXTURE_MAX_ANISOTROPY_EXT, Math.min(n, o.maxAnisotropy))
        }, t.initialize = function () {
            a.Mesh.prototype._uninitialize = function () {
                var e = i.Application.instance.globalEntity.getComponent(x).webgl, t = this.glTFMesh, n = t.primitives,
                    r = t.extras;
                null !== r.vbo && (e.deleteBuffer(r.vbo), r.vbo = null);
                for (var o = 0, a = n; o < a.length; o++) {
                    var s = a[o].extras;
                    s.program = null;
                    var l = s.vaos;
                    if (null !== l) for (var u in l) e.deleteVertexArray(l[u]), delete l[u];
                    null !== s.ibo && (e.deleteBuffer(s.ibo), s.ibo = null)
                }
            }, a.Mesh.prototype._update = function (e, t) {
                if (t >= 0) {
                    var n = i.Application.instance.globalEntity, r = n.getComponent(a.RenderContext),
                        o = n.getComponent(x), s = o.webgl, l = this.glTFMesh, u = this.attributes, c = l.extras,
                        p = l.primitives[t], d = p.extras, h = this._needUpdated & e;
                    if (0 != (8 & h)) {
                        if (null !== r.vertexArrayObject && s.bindVertexArray(null), null === c.vbo) {
                            var f = s.createBuffer();
                            null !== f ? c.vbo = f : console.error("Create webgl array buffer error.")
                        }
                        if (null !== c.vbo) {
                            var m = 0, _ = [];
                            for (var g in u) m += this.getAccessorByteLength(this.getAccessor(u[g])), _.push(g);
                            s.bindBuffer(34962, c.vbo), s.bufferData(34962, m, c.drawMode), this.uploadVertexBuffer(_)
                        }
                    }
                    if (0 != (16 & (h = d.needUpdate & e)) && void 0 !== p.indices) {
                        if (null !== r.vertexArrayObject && s.bindVertexArray(null), null === d.ibo) {
                            var v = s.createBuffer();
                            null !== v ? d.ibo = v : console.error("Create webgl array element buffer error.")
                        }
                        null !== d.ibo && (s.bindBuffer(34963, d.ibo), s.bufferData(34963, this.getAccessorByteLength(this.getAccessor(p.indices)), c.drawMode), this.uploadSubIndexBuffer(t))
                    }
                    if (0 != (4 & h) && null !== r.vertexArrayObject && null !== d.program) {
                        null === d.vaos && (d.vaos = {});
                        var y = d.program, b = d.vaos, T = y.attributesMask, E = b[T] || null;
                        null === E && (null !== (E = s.createVertexArray()) ? b[T] = E : console.error("Create webgl vertex array error.")), null !== E && (s.bindVertexArray(E), s.bindBuffer(34962, c.vbo), o.updateVertexAttributes(this, t), s.bindBuffer(34963, d.ibo), s.bindVertexArray(null))
                    }
                }
            }, a.Mesh.prototype.uploadVertexBuffer = function (e, t, n) {
                void 0 === e && (e = null), void 0 === t && (t = 0), void 0 === n && (n = 0);
                var r = i.Application.instance.globalEntity.getComponent(x).webgl, o = this.attributes,
                    s = this.glTFMesh.extras, l = s.attributeOffsets, u = s.vbo;
                if (null !== u) for (var c in null === e || Array.isArray(e) || (e = [e]), r.bindBuffer(34962, u), o) {
                    var p = this.getAccessor(o[c]);
                    if (null === e || e.indexOf(c) >= 0) {
                        var d = this.createTypeArrayFromAccessor(p, t, n), h = l[c];
                        t > 0 && (h += t * p.extras.typeCount * a.GLTFAsset.getComponentTypeCount(p.componentType)), r.bufferSubData(34962, h, d)
                    }
                }
            }, a.Mesh.prototype.uploadSubIndexBuffer = function (e, t, n) {
                void 0 === e && (e = 0), void 0 === t && (t = 0), void 0 === n && (n = 0);
                var r = this.glTFMesh.primitives;
                if (0 <= e && e < r.length) {
                    var o = r[e], a = o.extras.ibo;
                    if (null !== o.extras.ibo) {
                        var s = i.Application.instance.globalEntity.getComponent(x).webgl,
                            l = this.getAccessor(o.indices), u = this.createTypeArrayFromAccessor(l, t, n);
                        s.bindBuffer(34963, a), s.bufferSubData(34963, t, u)
                    } else console.warn("Error arguments.")
                } else console.warn("Error arguments.")
            }, a.Shader.prototype._uninitialize = function () {
                var e = i.Application.instance.globalEntity.getComponent(x).webgl, t = this.glTFShader.extras.programs;
                for (var n in t) {
                    var r = t[n];
                    null !== r && e.deleteProgram(r.program), delete t[n]
                }
            }, a.Texture.prototype._uninitialize = function () {
                var e = this.glTFTexture.extras;
                null !== e.texture && i.Application.instance.globalEntity.getComponent(x).webgl.deleteTexture(e.texture);
                e.texture = null
            }, a.Texture.prototype._update = function (e) {
                var n = this._needUpdate & e;
                if (0 !== n) {
                    var r = i.Application.instance.globalEntity.getComponent(a.RenderContext).compressedTextureFormats,
                        o = i.Application.instance.globalEntity.getComponent(x).webgl, s = this.glTFTexture,
                        l = s.extensions.egret, u = s.extras;
                    if (0 != (1 & n)) {
                        var c = this._image, p = this._sampler, d = void 0 !== l.format ? l.format : 6408,
                            h = void 0 !== u.internalFormat ? u.internalFormat : d,
                            f = void 0 !== l.type ? l.type : 5121, m = void 0 !== l.faces ? l.faces : 1,
                            _ = u.isCompressed || !1, g = void 0, v = void 0;
                        if (void 0 !== l.depth && l.depth > 1 ? v = g = 32879 : void 0 !== l.faces && l.faces > 1 ? (g = 34067, v = 34069) : v = g = l.height > 0 ? 3553 : -1, u.type = g, null === u.texture && (u.texture = o.createTexture()), o.bindTexture(g, u.texture), o.pixelStorei(3317, l.unpackAlignment || 4), o.pixelStorei(37440, l.flipY || 0), o.pixelStorei(37441, l.premultiplyAlpha || 0), t._setTexturexParameters(g, p, l.anisotropy || 1), _) {
                            var y = l.width, b = l.height, T = this._glTF, E = T.buffers, C = T.bufferViews;
                            if (Array.isArray(c.bufferView)) for (var S = 0; S < m; S++) for (var M = 0; M < c.bufferView.length; M++) {
                                var A = c.bufferView[M * (S + 1)], O = Math.max(1, y >> M), w = Math.max(1, b >> M),
                                    R = E[C[A].buffer];
                                6408 !== h && 6407 !== h ? r.indexOf(h) > -1 ? o.compressedTexImage2D(v + S, M, h, O, w, 0, R.extras.data) : console.warn("unsupported compressed texture format:" + h) : o.texImage2D(v + S, 0, h, O, w, 0, d, f, R.extras.data)
                            }
                        } else if (void 0 !== c.extras) if (Array.isArray(c.extras.data)) for (var P = 0, L = 0, D = c.extras.data; L < D.length; L++) {
                            var I = D[L];
                            o.texImage2D(v + P++, 0, h, d, f, I)
                        } else o.texImage2D(v, 0, h, d, f, c.extras.data); else if (void 0 !== c.bufferView) {
                            y = l.width, b = l.height;
                            var N = this._glTF;
                            E = N.buffers, C = N.bufferViews;
                            if (Array.isArray(c.bufferView)) {
                                P = 0;
                                for (var z = 0, U = c.bufferView; z < U.length; z++) {
                                    R = E[C[A = U[z]].buffer];
                                    o.texImage2D(v + P++, 0, h, y, b, 0, d, f, R.extras.data)
                                }
                            } else {
                                R = E[C[c.bufferView].buffer];
                                o.texImage2D(v, 0, h, y, b, 0, d, f, R.extras.data)
                            }
                        }
                    }
                    0 != (4 & n) && 0 === l.levels && o.generateMipmap(u.type), this.autoReleaseImages && null !== u.texture && this._disposeImageSource()
                }
            }, a.Texture.prototype.bindTexture = function (e) {
                var t = i.Application.instance.globalEntity.getComponent(x).webgl;
                t.activeTexture(33984 + e), this.update(5);
                var n = this.glTFTexture.extras, r = n.type, o = n.texture;
                t.bindTexture(r, o)
            }, a.RenderTexture.prototype._uninitialize = function () {
                var e = i.Application.instance.globalEntity.getComponent(x).webgl, t = this.glTFTexture.extras;
                null !== t.texture && e.deleteTexture(t.texture), null !== t.frameBuffer && e.deleteFramebuffer(t.frameBuffer), null !== t.renderBuffer && e.deleteRenderbuffer(t.renderBuffer), t.texture = null, t.frameBuffer = null, t.renderBuffer = null
            }, a.RenderTexture.prototype._update = function (e) {
                var n = this._needUpdate & e;
                if (0 !== n) {
                    var r = i.Application.instance.globalEntity.getComponent(x).webgl, o = this.glTFTexture,
                        a = o.extensions.egret, s = o.extras, l = a.width, u = a.height;
                    if (0 != (1 & n)) {
                        var c = void 0, p = void 0, d = this._sampler, h = void 0 !== a.format ? a.format : 6408,
                            f = void 0 !== a.type ? a.type : 5121;
                        void 0 !== a.depth && a.depth > 1 ? p = c = 32879 : void 0 !== a.faces && a.faces > 1 ? (c = 34067, p = 34069) : p = c = a.height > 0 ? 3553 : -1, s.type = c, null === s.texture && (s.texture = r.createTexture()), r.bindTexture(c, s.texture), r.pixelStorei(3317, a.unpackAlignment || 4), r.pixelStorei(37440, a.flipY || 0), r.pixelStorei(37441, a.premultiplyAlpha || 0), t._setTexturexParameters(c, d, a.anisotropy || 1), r.texImage2D(p, 0, h, l, u, 0, h, f, null)
                    }
                    if (0 != (4 & n) && 0 === a.levels && r.generateMipmap(s.type), 0 != (2 & n)) {
                        var m = a.depthBuffer || !1, _ = a.stencilBuffer || !1;
                        null === s.frameBuffer && (s.frameBuffer = r.createFramebuffer()), r.bindTexture(s.type, s.texture), r.bindFramebuffer(36160, s.frameBuffer), r.framebufferTexture2D(36160, 36064, s.type, s.texture, 0), (m || _) && (s.renderBuffer || (s.renderBuffer = r.createRenderbuffer()), r.bindRenderbuffer(36161, s.renderBuffer), m && _ ? (r.renderbufferStorage(36161, 34041, l, u), r.framebufferRenderbuffer(36160, 33306, 36161, s.renderBuffer)) : m ? (r.renderbufferStorage(36161, 33189, l, u), r.framebufferRenderbuffer(36160, 36096, 36161, s.renderBuffer)) : r.renderbufferStorage(36161, 32854, l, u))
                    }
                }
            }, a.RenderTexture.prototype.bindTexture = function (e) {
                var t = i.Application.instance.globalEntity.getComponent(x).webgl;
                t.activeTexture(33984 + e), this.update(5);
                var n = this.glTFTexture.extras, r = n.type, o = n.texture;
                t.bindTexture(r, o)
            }, a.RenderTexture.prototype.activateTexture = function () {
                var e = i.Application.instance.globalEntity.getComponent(x).webgl;
                this.update(7);
                var t = this.glTFTexture.extras, n = t.frameBuffer, r = t.renderBuffer;
                e.bindFramebuffer(36160, n), null !== r && e.bindRenderbuffer(36161, r)
            }
        }, t
    }();
    __reflect(T, "@egret/webgl/WebGLImplement");
    var E = function (e) {
        function t() {
            return null !== e && e.apply(this, arguments) || this
        }

        return l(t, e), t.prototype.onAwake = function () {
            var e = i.Application.instance, t = e.globalEntity, n = e.systemManager;
            t.getOrAddComponent(x), n.unregisterSystem(this)
        }, t = u([Object(r.system)({noneOfExecuteMode: 32})], t)
    }(r.System);

    function C() {
        return e = this, t = void 0, r = function () {
            return c(this, (function (e) {
                return i.SystemManager.preRegisterSystem(E, 1), T.initialize(), console.debug("Egret WebGL 1.0 registered."), [2]
            }))
        }, new ((n = void 0) || (n = Promise))((function (i, o) {
            function a(e) {
                try {
                    l(r.next(e))
                } catch (e) {
                    o(e)
                }
            }

            function s(e) {
                try {
                    l(r.throw(e))
                } catch (e) {
                    o(e)
                }
            }

            function l(e) {
                e.done ? i(e.value) : new n((function (t) {
                    t(e.value)
                })).then(a, s)
            }

            l((r = r.apply(e, t || [])).next())
        }));
        var e, t, n, r
    }

    function S() {
        return i.Application.instance.globalEntity.getComponent(x).webgl.getSupportedExtensions()
    }

    __reflect(E, "@egret/webgl/StartupSystem")
}, function (e, t) {
}, function (e, t, n) {
    (function (e) {
        var t = this && this.__awaiter || function (e, t, n, r) {
            return new (n || (n = Promise))((function (i, o) {
                function a(e) {
                    try {
                        l(r.next(e))
                    } catch (e) {
                        o(e)
                    }
                }

                function s(e) {
                    try {
                        l(r.throw(e))
                    } catch (e) {
                        o(e)
                    }
                }

                function l(e) {
                    var t;
                    e.done ? i(e.value) : (t = e.value, t instanceof n ? t : new n((function (e) {
                        e(t)
                    }))).then(a, s)
                }

                l((r = r.apply(e, t || [])).next())
            }))
        }, r = this && this.__generator || function (e, t) {
            var n, r, i, o, a = {
                label: 0, sent: function () {
                    if (1 & i[0]) throw i[1];
                    return i[1]
                }, trys: [], ops: []
            };
            return o = {
                next: s(0),
                throw: s(1),
                return: s(2)
            }, "function" == typeof Symbol && (o[Symbol.iterator] = function () {
                return this
            }), o;

            function s(o) {
                return function (s) {
                    return function (o) {
                        if (n) throw new TypeError("Generator is already executing.");
                        for (; a;) try {
                            if (n = 1, r && (i = 2 & o[0] ? r.return : o[0] ? r.throw || ((i = r.return) && i.call(r), 0) : r.next) && !(i = i.call(r, o[1])).done) return i;
                            switch (r = 0, i && (o = [2 & o[0], i.value]), o[0]) {
                                case 0:
                                case 1:
                                    i = o;
                                    break;
                                case 4:
                                    return a.label++, {value: o[1], done: !1};
                                case 5:
                                    a.label++, r = o[1], o = [0];
                                    continue;
                                case 7:
                                    o = a.ops.pop(), a.trys.pop();
                                    continue;
                                default:
                                    if (!(i = a.trys, (i = i.length > 0 && i[i.length - 1]) || 6 !== o[0] && 2 !== o[0])) {
                                        a = 0;
                                        continue
                                    }
                                    if (3 === o[0] && (!i || o[1] > i[0] && o[1] < i[3])) {
                                        a.label = o[1];
                                        break
                                    }
                                    if (6 === o[0] && a.label < i[1]) {
                                        a.label = i[1], i = o;
                                        break
                                    }
                                    if (i && a.label < i[2]) {
                                        a.label = i[2], a.ops.push(o);
                                        break
                                    }
                                    i[2] && a.ops.pop(), a.trys.pop();
                                    continue
                            }
                            o = t.call(e, a)
                        } catch (e) {
                            o = [6, e], r = 0
                        } finally {
                            n = i = 0
                        }
                        if (5 & o[0]) throw o[1];
                        return {value: o[0] ? o[1] : void 0, done: !0}
                    }([o, s])
                }
            }
        };
        ("undefined" != typeof window ? window : e).__ConfigData = {"project_settings.prefab.json": '{\r\n    "version": "5",\r\n    "minVersion": "5",\r\n    "assets": [],\r\n    "entities": [\r\n        {\r\n            "uuid": "36",\r\n            "__class": "@egret/engine/GlobalEntity",\r\n            "components": [\r\n                {\r\n                    "uuid": "37"\r\n                },\r\n                {\r\n                    "uuid": "38"\r\n                },\r\n                {\r\n                    "uuid": "40"\r\n                },\r\n                {\r\n                    "uuid": "42"\r\n                },\r\n                {\r\n                    "uuid": "44"\r\n                },\r\n                {\r\n                    "uuid": "52"\r\n                },\r\n                {\r\n                    "uuid": "65"\r\n                },\r\n                {\r\n                    "uuid": "70"\r\n                }\r\n            ]\r\n        }\r\n    ],\r\n    "components": [\r\n        {\r\n            "uuid": "37",\r\n            "__class": "@egret/engine/Clock"\r\n        },\r\n        {\r\n            "uuid": "38",\r\n            "__class": "@egret/engine/Stage"\r\n        },\r\n        {\r\n            "uuid": "40",\r\n            "__class": "@egret/render/SceneLight"\r\n        },\r\n        {\r\n            "uuid": "42",\r\n            "__class": "@egret/render/RenderContext",\r\n            "shadowQuality": 2\r\n        },\r\n        {\r\n            "uuid": "44",\r\n            "__class": "@egret/box2d/PhysicsWorld"\r\n        },\r\n        {\r\n            "uuid": "52",\r\n            "__class": "@egret/input/InputManager"\r\n        },\r\n        {\r\n            "uuid": "65",\r\n            "__class": "@egret/collision/CollisionManager"\r\n        },\r\n        {\r\n            "uuid": "70",\r\n            "__class": "@egret/core/MissingComponent",\r\n            "missingObject": {\r\n                "uuid": "1493",\r\n                "__class": "EditorManager"\r\n            }\r\n        }\r\n    ]\r\n}'}, window.startup = function () {
            return t(this, void 0, void 0, (function () {
                var e, t, i, o, a, s, l, u, c, p, d, h, f, m, _;
                return r(this, (function (r) {
                    switch (r.label) {
                        case 0:
                            return e = n(3), console.log("basis"), e.startup ? [4, e.startup()] : [3, 2];
                        case 1:
                            r.sent(), r.label = 2;
                        case 2:
                            return t = n(2), console.log("ecs"), t.startup ? [4, t.startup()] : [3, 4];
                        case 3:
                            r.sent(), r.label = 4;
                        case 4:
                            return i = n(0), console.log("core"), i.startup ? [4, i.startup()] : [3, 6];
                        case 5:
                            r.sent(), r.label = 6;
                        case 6:
                            return i.ResourceManager.instance.baseUrl = "./resource/", o = n(1), console.log("engine"), o.startup ? [4, o.startup()] : [3, 8];
                        case 7:
                            r.sent(), r.label = 8;
                        case 8:
                            return a = n(8), console.log("gltf"), a.startup ? [4, a.startup()] : [3, 10];
                        case 9:
                            r.sent(), r.label = 10;
                        case 10:
                            return s = n(4), console.log("render"), s.startup ? [4, s.startup()] : [3, 12];
                        case 11:
                            r.sent(), r.label = 12;
                        case 12:
                            return l = n(9), console.log("webgl"), l.startup ? [4, l.startup()] : [3, 14];
                        case 13:
                            r.sent(), r.label = 14;
                        case 14:
                            return u = n(7), console.log("input"), u.startup ? [4, u.startup()] : [3, 16];
                        case 15:
                            r.sent(), r.label = 16;
                        case 16:
                            return c = n(12), console.log("collision"), c.startup ? [4, c.startup()] : [3, 18];
                        case 17:
                            r.sent(), r.label = 18;
                        case 18:
                            return p = n(5), console.log("animation"), p.startup ? [4, p.startup()] : [3, 20];
                        case 19:
                            r.sent(), r.label = 20;
                        case 20:
                            return d = n(13), console.log("particle"), d.startup ? [4, d.startup()] : [3, 22];
                        case 21:
                            r.sent(), r.label = 22;
                        case 22:
                            return h = n(14), console.log("behaviour_tree"), h.startup ? [4, h.startup()] : [3, 24];
                        case 23:
                            r.sent(), r.label = 24;
                        case 24:
                            return f = n(15), console.log("tween"), f.startup ? [4, f.startup()] : [3, 26];
                        case 25:
                            r.sent(), r.label = 26;
                        case 26:
                            return m = n(17), console.log("audio"), m.startup ? [4, m.startup()] : [3, 28];
                        case 27:
                            r.sent(), r.label = 28;
                        case 28:
                            return _ = n(18), console.log("platform_browser"), _.startup ? [4, _.startup()] : [3, 30];
                        case 29:
                            r.sent(), r.label = 30;
                        case 30:
                            return n(19), n(1).Application.instance.executeMode |= 0, [2]
                    }
                }))
            }))
        }, console.log("");
        var i = n(20);
        i.keys().forEach(i)
    }).call(this, n(6))
}, function (e, t, n) {
    "use strict";
    n.r(t), n.d(t, "BoxCollider", (function () {
        return p
    })), n.d(t, "CapsuleCollider", (function () {
        return f
    })), n.d(t, "CollisionManager", (function () {
        return _
    })), n.d(t, "FrustumConeCollider", (function () {
        return h
    })), n.d(t, "MeshCollider", (function () {
        return m
    })), n.d(t, "SphereCollider", (function () {
        return d
    })), n.d(t, "startup", (function () {
        return v
    }));
    var r = n(2), i = n(0), o = n(1), a = function (e, t) {
        return (a = Object.setPrototypeOf || {__proto__: []} instanceof Array && function (e, t) {
            e.__proto__ = t
        } || function (e, t) {
            for (var n in t) t.hasOwnProperty(n) && (e[n] = t[n])
        })(e, t)
    };

    function s(e, t) {
        function n() {
            this.constructor = e
        }

        a(e, t), e.prototype = null === t ? Object.create(t) : (n.prototype = t.prototype, new n)
    }

    function l(e, t, n, r) {
        var i, o = arguments.length, a = o < 3 ? t : null === r ? r = Object.getOwnPropertyDescriptor(t, n) : r;
        if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) a = Reflect.decorate(e, t, n, r); else for (var s = e.length - 1; s >= 0; s--) (i = e[s]) && (a = (o < 3 ? i(a) : o > 3 ? i(t, n, a) : i(t, n)) || a);
        return o > 3 && a && Object.defineProperty(t, n, a), a
    }

    function u(e, t) {
        var n, r, i, o, a = {
            label: 0, sent: function () {
                if (1 & i[0]) throw i[1];
                return i[1]
            }, trys: [], ops: []
        };
        return o = {
            next: s(0),
            throw: s(1),
            return: s(2)
        }, "function" == typeof Symbol && (o[Symbol.iterator] = function () {
            return this
        }), o;

        function s(o) {
            return function (s) {
                return function (o) {
                    if (n) throw new TypeError("Generator is already executing.");
                    for (; a;) try {
                        if (n = 1, r && (i = 2 & o[0] ? r.return : o[0] ? r.throw || ((i = r.return) && i.call(r), 0) : r.next) && !(i = i.call(r, o[1])).done) return i;
                        switch (r = 0, i && (o = [2 & o[0], i.value]), o[0]) {
                            case 0:
                            case 1:
                                i = o;
                                break;
                            case 4:
                                return a.label++, {value: o[1], done: !1};
                            case 5:
                                a.label++, r = o[1], o = [0];
                                continue;
                            case 7:
                                o = a.ops.pop(), a.trys.pop();
                                continue;
                            default:
                                if (!(i = a.trys, (i = i.length > 0 && i[i.length - 1]) || 6 !== o[0] && 2 !== o[0])) {
                                    a = 0;
                                    continue
                                }
                                if (3 === o[0] && (!i || o[1] > i[0] && o[1] < i[3])) {
                                    a.label = o[1];
                                    break
                                }
                                if (6 === o[0] && a.label < i[1]) {
                                    a.label = i[1], i = o;
                                    break
                                }
                                if (i && a.label < i[2]) {
                                    a.label = i[2], a.ops.push(o);
                                    break
                                }
                                i[2] && a.ops.pop(), a.trys.pop();
                                continue
                        }
                        o = t.call(e, a)
                    } catch (e) {
                        o = [6, e], r = 0
                    } finally {
                        n = i = 0
                    }
                    if (5 & o[0]) throw o[1];
                    return {value: o[0] ? o[1] : void 0, done: !0}
                }([o, s])
            }
        }
    }

    var c = function (e) {
        function t() {
            return this
        }

        return s(t, DebuggerClass), t.raycastCollider = function (e, t, n, r) {
            var i = e.entity.transform, o = i.worldToLocalMatrix, a = this._helpRay.applyMatrix(o, n);
            if (t.raycast(a, r)) {
                if (null !== r) {
                    var s = i.localToWorldMatrix;
                    r.distance = n.origin.getDistance(r.position.applyMatrix(s)), r.transform = i, r.collider = e;
                    var l = r.normal;
                    null !== l && (r.modifyNormal ? l.applyMatrix3(this._helpMatrix3.fromMatrix4(o).transpose()).normalize() : l.applyDirection(s))
                }
                return !0
            }
            return !1
        }, t._helpMatrix3 = o.Matrix3.create(), t._helpRay = o.Ray.create(), t
    }();
    __reflect(c, "@egret/collision/_Util");
    var p = function (e) {
        function t() {
            var t = null !== e && e.apply(this, arguments) || this;
            return t.colliderType = o.ColliderType.Box, t.box = o.Box.create(o.Vector3.MINUS_ONE, o.Vector3.ONE).expand(-.5), t
        }

        return s(t, e), t.prototype.raycast = function (e, t) {
            return void 0 === t && (t = null), c.raycastCollider(this, this.box, e, t)
        }, l([Object(i.property)("nested"), i.serializedField], t.prototype, "box", void 0), t = l([Object(r.component)({
            allowMultiple: !0,
            type: "collider",
            isAbstract: !1
        })], t)
    }(o.GameComponent);
    __reflect(p, "@egret/collision/BoxCollider");
    var d = function (e) {
        function t() {
            var t = null !== e && e.apply(this, arguments) || this;
            return t.colliderType = o.ColliderType.Sphere, t.sphere = o.Sphere.create(o.Vector3.ZERO, .5), t
        }

        return s(t, e), t.prototype.raycast = function (e, t) {
            return void 0 === t && (t = null), c.raycastCollider(this, this.sphere, e, t)
        }, l([Object(i.property)("nested"), i.serializedField], t.prototype, "sphere", void 0), t = l([Object(r.component)({
            allowMultiple: !0,
            type: "collider",
            isAbstract: !1
        })], t)
    }(o.GameComponent);
    __reflect(d, "@egret/collision/SphereCollider");
    var h = function (e) {
        function t() {
            var t = null !== e && e.apply(this, arguments) || this;
            return t.colliderType = o.ColliderType.FrustumCone, t.frustumCone = o.FrustumCone.create(o.Vector3.ZERO, .5, .5, 1), t
        }

        return s(t, e), t.prototype.raycast = function (e, t) {
            return void 0 === t && (t = null), c.raycastCollider(this, this.frustumCone, e, t)
        }, l([Object(i.property)("nested"), i.serializedField], t.prototype, "frustumCone", void 0), t = l([Object(r.component)({
            allowMultiple: !0,
            type: "collider",
            isAbstract: !1
        })], t)
    }(o.GameComponent);
    __reflect(h, "@egret/collision/FrustumConeCollider");
    var f = function (e) {
        function t() {
            var t = null !== e && e.apply(this, arguments) || this;
            return t.colliderType = o.ColliderType.Capsule, t.capsule = o.Capsule.create(o.Vector3.ZERO, .25, .5), t
        }

        return s(t, e), t.prototype.raycast = function (e, t) {
            return void 0 === t && (t = null), c.raycastCollider(this, this.capsule, e, t)
        }, l([Object(i.property)("nested"), i.serializedField], t.prototype, "capsule", void 0), t = l([Object(r.component)({
            allowMultiple: !0,
            type: "collider",
            isAbstract: !1
        })], t)
    }(o.GameComponent);
    __reflect(f, "@egret/collision/CapsuleCollider");
    var m = function (e) {
        function t() {
            var t = null !== e && e.apply(this, arguments) || this;
            return t.colliderType = o.ColliderType.Mesh, t._mesh = null, t
        }

        return s(t, e), t.prototype.uninitialize = function () {
            e.prototype.uninitialize.call(this), this._mesh = null
        }, t.prototype.raycast = function (e, t) {
            void 0 === t && (t = null);
            var n = this._mesh;
            return null !== n && c.raycastCollider(this, n, e, t)
        }, Object.defineProperty(t.prototype, "mesh", {
            get: function () {
                return this._mesh
            }, set: function (e) {
                this._mesh !== e && (this._mesh = e)
            }, enumerable: !0, configurable: !0
        }), l([Object(i.property)("asset", {assetType: "mesh"}), i.serializedField], t.prototype, "mesh", null), t = l([Object(r.component)({
            allowMultiple: !0,
            type: "collider",
            isAbstract: !1
        })], t)
    }(o.GameComponent);
    __reflect(m, "@egret/collision/MeshCollider");
    var _ = function (e) {
        function t() {
            var t = null !== e && e.apply(this, arguments) || this;
            return t._helpVector3 = o.Vector3.create(), t._helpRaycastInfo = o.RaycastInfo.create(), t._colliderGroup = o.Application.instance.gameEntityContext.getGroup(r.Matcher.create(o.GameEntity, !0, o.Transform).anyOf(p, d, h, f, m)), t._colliders = [], t
        }

        return s(t, e), t.prototype._raycastCollider = function (e, t, n) {
            var r = this._helpRaycastInfo;
            return r.backfaceCulling = n.backfaceCulling, r.modifyNormal = n.modifyNormal, r.normal = null !== n.normal ? this._helpVector3 : null, !!t.raycast(e, r) && ((null === n.transform || n.distance > r.distance) && n.copy(r), !0)
        }, t.prototype._raycast = function (e, t, n, r, i) {
            if (void 0 === n && (n = 1), void 0 === r && (r = 0), !t.isActiveAndEnabled || 0 == (t.node.layer & n)) return !1;
            if (r > 0 && t.transform.position.getSquaredDistance(e.origin) >= r * r) return !1;
            var o = !1, a = this._colliders;
            if (a.length = 0, t.getComponentsByType("collider", a), a.length > 0) {
                for (var s = 0, l = a; s < l.length; s++) {
                    var u = l[s];
                    if (u.enabled) if (null !== i) o = this._raycastCollider(e, u, i) || o; else if (u.raycast(e)) return !0
                }
                a.length = 0
            }
            return o
        }, t.prototype.raycastSingle = function (e, t, n, r, i) {
            return void 0 === n && (n = 1), void 0 === r && (r = 0), void 0 === i && (i = null), this._raycast(e, t, n, r, i)
        }, t.prototype.raycast = function (e, t, n, r) {
            void 0 === t && (t = 1), void 0 === n && (n = 0), void 0 === r && (r = null);
            var i = this._colliderGroup.entities;
            if (null !== r) {
                for (var o = !1, a = 0, s = i; a < s.length; a++) {
                    var l = s[a];
                    o = this._raycast(e, l, t, n, r) || o
                }
                return o
            }
            for (var u = 0, c = i; u < c.length; u++) {
                l = c[u];
                if (this._raycast(e, l, t, n, null)) return !0
            }
            return !1
        }, t.prototype.raycastAll = function (e, t, n) {
            void 0 === t && (t = 1), void 0 === n && (n = 0);
            for (var r = [], i = 0, a = this._colliderGroup.entities; i < a.length; i++) {
                var s = a[i], l = o.RaycastInfo.create().release();
                this._raycast(e, s, t, n, l) && r.push(l)
            }
            return r
        }, t = l([Object(i.hideFlag)(16), Object(r.component)({isRemovable: !1, isAbstract: !1})], t)
    }(r.Component);
    __reflect(_, "@egret/collision/CollisionManager");
    var g = function (e) {
        function t() {
            return null !== e && e.apply(this, arguments) || this
        }

        return s(t, e), t.prototype.onAwake = function () {
            var e = o.Application.instance, t = e.globalEntity, n = e.systemManager;
            t.getOrAddComponent(_), n.unregisterSystem(this)
        }, t = l([Object(r.system)()], t)
    }(r.System);

    function v() {
        return e = this, t = void 0, r = function () {
            return u(this, (function (e) {
                return o.SystemManager.preRegisterSystem(g, 0), [2]
            }))
        }, new ((n = void 0) || (n = Promise))((function (i, o) {
            function a(e) {
                try {
                    l(r.next(e))
                } catch (e) {
                    o(e)
                }
            }

            function s(e) {
                try {
                    l(r.throw(e))
                } catch (e) {
                    o(e)
                }
            }

            function l(e) {
                e.done ? i(e.value) : new n((function (t) {
                    t(e.value)
                })).then(a, s)
            }

            l((r = r.apply(e, t || [])).next())
        }));
        var e, t, n, r
    }

    __reflect(g, "@egret/collision/StartupSystem")
}, function (e, t, n) {
    "use strict";
    n.r(t), n.d(t, "AnimationCurve", (function () {
        return V
    })), n.d(t, "AnimationType", (function () {
        return d
    })), n.d(t, "Burst", (function () {
        return B
    })), n.d(t, "ColorGradientMode", (function () {
        return s
    })), n.d(t, "ColorOverLifetimeModule", (function () {
        return J
    })), n.d(t, "CurveMode", (function () {
        return a
    })), n.d(t, "EmissionModule", (function () {
        return Z
    })), n.d(t, "Gradient", (function () {
        return H
    })), n.d(t, "GradientAlphaKey", (function () {
        return j
    })), n.d(t, "GradientColorKey", (function () {
        return G
    })), n.d(t, "GradientMode", (function () {
        return f
    })), n.d(t, "Keyframe", (function () {
        return k
    })), n.d(t, "MainModule", (function () {
        return q
    })), n.d(t, "MinMaxCurve", (function () {
        return W
    })), n.d(t, "MinMaxGradient", (function () {
        return X
    })), n.d(t, "ParticleAttributeSemantics", (function () {
        return r
    })), n.d(t, "ParticleComponent", (function () {
        return ne
    })), n.d(t, "ParticleMaterialDefine", (function () {
        return o
    })), n.d(t, "ParticleMaterialUniform", (function () {
        return i
    })), n.d(t, "ParticleModule", (function () {
        return Y
    })), n.d(t, "ParticleRenderMode", (function () {
        return m
    })), n.d(t, "ParticleRenderer", (function () {
        return w
    })), n.d(t, "ParticleSystem", (function () {
        return re
    })), n.d(t, "RotationOverLifetimeModule", (function () {
        return ee
    })), n.d(t, "ScalingMode", (function () {
        return u
    })), n.d(t, "ShapeModule", (function () {
        return K
    })), n.d(t, "ShapeMultiModeValue", (function () {
        return p
    })), n.d(t, "ShapeType", (function () {
        return c
    })), n.d(t, "SimulationSpace", (function () {
        return l
    })), n.d(t, "SizeOverLifetimeModule", (function () {
        return $
    })), n.d(t, "TextureSheetAnimationModule", (function () {
        return te
    })), n.d(t, "UVChannelFlags", (function () {
        return h
    })), n.d(t, "VelocityOverLifetimeModule", (function () {
        return Q
    })), n.d(t, "_UpdateType", (function () {
        return _
    })), n.d(t, "startup", (function () {
        return ie
    }));
    var r, i, o, a, s, l, u, c, p, d, h, f, m, _, g = n(2), v = n(0), y = n(1), b = n(4), x = function (e, t) {
        return (x = Object.setPrototypeOf || {__proto__: []} instanceof Array && function (e, t) {
            e.__proto__ = t
        } || function (e, t) {
            for (var n in t) t.hasOwnProperty(n) && (e[n] = t[n])
        })(e, t)
    };

    function T(e, t) {
        function n() {
            this.constructor = e
        }

        x(e, t), e.prototype = null === t ? Object.create(t) : (n.prototype = t.prototype, new n)
    }

    function E(e, t, n, r) {
        var i, o = arguments.length, a = o < 3 ? t : null === r ? r = Object.getOwnPropertyDescriptor(t, n) : r;
        if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) a = Reflect.decorate(e, t, n, r); else for (var s = e.length - 1; s >= 0; s--) (i = e[s]) && (a = (o < 3 ? i(a) : o > 3 ? i(t, n, a) : i(t, n)) || a);
        return o > 3 && a && Object.defineProperty(t, n, a), a
    }

    function C(e, t) {
        var n, r, i, o, a = {
            label: 0, sent: function () {
                if (1 & i[0]) throw i[1];
                return i[1]
            }, trys: [], ops: []
        };
        return o = {
            next: s(0),
            throw: s(1),
            return: s(2)
        }, "function" == typeof Symbol && (o[Symbol.iterator] = function () {
            return this
        }), o;

        function s(o) {
            return function (s) {
                return function (o) {
                    if (n) throw new TypeError("Generator is already executing.");
                    for (; a;) try {
                        if (n = 1, r && (i = 2 & o[0] ? r.return : o[0] ? r.throw || ((i = r.return) && i.call(r), 0) : r.next) && !(i = i.call(r, o[1])).done) return i;
                        switch (r = 0, i && (o = [2 & o[0], i.value]), o[0]) {
                            case 0:
                            case 1:
                                i = o;
                                break;
                            case 4:
                                return a.label++, {value: o[1], done: !1};
                            case 5:
                                a.label++, r = o[1], o = [0];
                                continue;
                            case 7:
                                o = a.ops.pop(), a.trys.pop();
                                continue;
                            default:
                                if (!(i = a.trys, (i = i.length > 0 && i[i.length - 1]) || 6 !== o[0] && 2 !== o[0])) {
                                    a = 0;
                                    continue
                                }
                                if (3 === o[0] && (!i || o[1] > i[0] && o[1] < i[3])) {
                                    a.label = o[1];
                                    break
                                }
                                if (6 === o[0] && a.label < i[1]) {
                                    a.label = i[1], i = o;
                                    break
                                }
                                if (i && a.label < i[2]) {
                                    a.label = i[2], a.ops.push(o);
                                    break
                                }
                                i[2] && a.ops.pop(), a.trys.pop();
                                continue
                        }
                        o = t.call(e, a)
                    } catch (e) {
                        o = [6, e], r = 0
                    } finally {
                        n = i = 0
                    }
                    if (5 & o[0]) throw o[1];
                    return {value: o[0] ? o[1] : void 0, done: !0}
                }([o, s])
            }
        }
    }

    !function (e) {
        e.CORNER = "_CORNER", e.START_POSITION = "_START_POSITION", e.START_VELOCITY = "_START_VELOCITY", e.START_COLOR = "_START_COLOR", e.START_SIZE = "_START_SIZE", e.START_ROTATION = "_START_ROTATION", e.TIME = "_TIME", e.RANDOM0 = "_RANDOM0", e.RANDOM1 = "_RANDOM1", e.WORLD_POSITION = "_WORLD_POSITION", e.WORLD_ROTATION = "_WORLD_ROTATION"
    }(r || (r = {})), function (e) {
        e.WORLD_POSITION = "u_worldPosition", e.WORLD_ROTATION = "u_worldRotation", e.POSITION_SCALE = "u_positionScale", e.SIZE_SCALE = "u_sizeScale", e.SCALING_MODE = "u_scalingMode", e.GRAVIT = "u_gravity", e.START_SIZE3D = "START_SIZE3D", e.START_ROTATION3D = "u_startRotation3D", e.SIMULATION_SPACE = "u_simulationSpace", e.CURRENTTIME = "u_currentTime", e.ALPHAS_GRADIENT = "u_alphaGradient[0]", e.COLOR_GRADIENT = "u_colorGradient[0]", e.ALPHA_GRADIENT_MAX = "u_alphaGradientMax[0]", e.COLOR_GRADIENT_MAX = "u_colorGradientMax[0]", e.VELOCITY_CONST = "u_velocityConst", e.VELOCITY_CURVE_X = "u_velocityCurveX[0]", e.VELOCITY_CURVE_Y = "u_velocityCurveY[0]", e.VELOCITY_CURVE_Z = "u_velocityCurveZ[0]", e.VELOCITY_CONST_MAX = "u_velocityConstMax", e.VELOCITY_CURVE_MAX_X = "u_velocityCurveMaxX[0]", e.VELOCITY_CURVE_MAX_Y = "u_velocityCurveMaxY[0]", e.VELOCITY_CURVE_MAX_Z = "u_velocityCurveMaxZ[0]", e.SPACE_TYPE = "u_spaceType", e.SIZE_CURVE = "u_sizeCurve[0]", e.SIZE_CURVE_X = "u_sizeCurveX[0]", e.SIZE_CURVE_Y = "u_sizeCurveY[0]", e.SIZE_CURVE_Z = "u_sizeCurveZ[0]", e.SIZE_CURVE_MAX = "u_sizeCurveMax[0]", e.SIZE_CURVE_MAX_X = "u_sizeCurveMaxX[0]", e.SIZE_CURVE_MAX_Y = "u_sizeCurveMaxY[0]", e.SIZE_CURVE_MAX_Z = "u_sizeCurveMaxZ[0]", e.ROTATION_CONST = "u_rotationConst", e.ROTATION_CONST_SEPRARATE = "u_rotationConstSeprarate", e.ROTATION_CURVE = "u_rotationCurve[0]", e.ROTATE_CURVE_X = "u_rotationCurveX[0]", e.ROTATE_CURVE_y = "u_rotationCurveY[0]", e.ROTATE_CURVE_Z = "u_rotationCurveZ[0]", e.ROTATE_CURVE_W = "u_rotationCurveW[0]", e.ROTATION_CONST_MAX = "u_rotationConstMax", e.ROTATION_CONST_MAX_SEPRARATE = "u_rotationConstMaxSeprarate", e.ROTATION_CURVE_MAX = "u_rotationCurveMax[0]", e.ROTATION_CURVE_MAX_X = "u_rotationCurveMaxX[0]", e.ROTATION_CURVE_MAX_Y = "u_rotationCurveMaxY[0]", e.ROTATION_CURVE_MAX_Z = "u_rotationCurveMaxZ[0]", e.ROTATION_CURVE_MAX_W = "u_rotationCurveMaxW[0]", e.CYCLES = "u_cycles", e.SUB_UV = "u_subUV", e.UV_CURVE = "u_uvCurve[0]", e.UV_CURVE_MAX = "u_uvCurveMax[0]", e.LENGTH_SCALE = "u_lengthScale", e.SPEED_SCALE = "u_speeaScale"
    }(i || (i = {})), function (e) {
        e.SPHERHBILLBOARD = "SPHERHBILLBOARD", e.STRETCHEDBILLBOARD = "STRETCHEDBILLBOARD", e.HORIZONTALBILLBOARD = "HORIZONTALBILLBOARD", e.VERTICALBILLBOARD = "VERTICALBILLBOARD", e.ROTATIONOVERLIFETIME = "ROTATIONOVERLIFETIME", e.ROTATIONCONSTANT = "ROTATIONCONSTANT", e.ROTATIONTWOCONSTANTS = "ROTATIONTWOCONSTANTS", e.ROTATIONSEPERATE = "ROTATIONSEPERATE", e.ROTATIONCURVE = "ROTATIONCURVE", e.ROTATIONTWOCURVES = "ROTATIONTWOCURVES", e.TEXTURESHEETANIMATIONCURVE = "TEXTURESHEETANIMATIONCURVE", e.TEXTURESHEETANIMATIONTWOCURVE = "TEXTURESHEETANIMATIONTWOCURVE", e.VELOCITYCONSTANT = "VELOCITYCONSTANT", e.VELOCITYCURVE = "VELOCITYCURVE", e.VELOCITYTWOCONSTANT = "VELOCITYTWOCONSTANT", e.VELOCITYTWOCURVE = "VELOCITYTWOCURVE", e.COLOROGRADIENT = "COLOROGRADIENT", e.COLORTWOGRADIENTS = "COLORTWOGRADIENTS", e.SIZECURVE = "SIZECURVE", e.SIZETWOCURVES = "SIZETWOCURVES", e.SIZECURVESEPERATE = "SIZECURVESEPERATE", e.SIZETWOCURVESSEPERATE = "SIZETWOCURVESSEPERATE", e.RENDERMESH = "RENDERMESH", e.SHAPE = "SHAPE"
    }(o || (o = {})), function (e) {
        e[e.Constant = 0] = "Constant", e[e.Curve = 1] = "Curve", e[e.TwoCurves = 2] = "TwoCurves", e[e.TwoConstants = 3] = "TwoConstants"
    }(a || (a = {})), function (e) {
        e[e.Color = 0] = "Color", e[e.Gradient = 1] = "Gradient", e[e.TwoColors = 2] = "TwoColors", e[e.TwoGradients = 3] = "TwoGradients", e[e.RandomColor = 4] = "RandomColor"
    }(s || (s = {})), function (e) {
        e[e.Local = 0] = "Local", e[e.World = 1] = "World", e[e.Custom = 2] = "Custom"
    }(l || (l = {})), function (e) {
        e[e.Hierarchy = 0] = "Hierarchy", e[e.Local = 1] = "Local", e[e.Shape = 2] = "Shape"
    }(u || (u = {})), function (e) {
        e[e.None = -1] = "None", e[e.Sphere = 0] = "Sphere", e[e.SphereShell = 1] = "SphereShell", e[e.Hemisphere = 2] = "Hemisphere", e[e.HemisphereShell = 3] = "HemisphereShell", e[e.Cone = 4] = "Cone", e[e.Box = 5] = "Box", e[e.Mesh = 6] = "Mesh", e[e.ConeShell = 7] = "ConeShell", e[e.ConeVolume = 8] = "ConeVolume", e[e.ConeVolumeShell = 9] = "ConeVolumeShell", e[e.Circle = 10] = "Circle", e[e.CircleEdge = 11] = "CircleEdge", e[e.SingleSidedEdge = 12] = "SingleSidedEdge", e[e.MeshRenderer = 13] = "MeshRenderer", e[e.SkinnedMeshRenderer = 14] = "SkinnedMeshRenderer", e[e.BoxShell = 15] = "BoxShell", e[e.BoxEdge = 16] = "BoxEdge"
    }(c || (c = {})), function (e) {
        e[e.Random = 0] = "Random", e[e.Loop = 1] = "Loop", e[e.PingPong = 2] = "PingPong", e[e.BurstSpread = 3] = "BurstSpread"
    }(p || (p = {})), function (e) {
        e[e.WholeSheet = 0] = "WholeSheet", e[e.SingleRow = 1] = "SingleRow"
    }(d || (d = {})), function (e) {
        e[e.UV0 = 1] = "UV0", e[e.UV1 = 2] = "UV1", e[e.UV2 = 4] = "UV2", e[e.UV3 = 8] = "UV3"
    }(h || (h = {})), function (e) {
        e[e.Blend = 0] = "Blend", e[e.Fixed = 1] = "Fixed"
    }(f || (f = {})), function (e) {
        e[e.Billboard = 0] = "Billboard", e[e.Stretch = 1] = "Stretch", e[e.HorizontalBillboard = 2] = "HorizontalBillboard", e[e.VerticalBillboard = 3] = "VerticalBillboard", e[e.Mesh = 4] = "Mesh", e[e.None = 5] = "None"
    }(m || (m = {})), function (e) {
        e[e.Main = 0] = "Main", e[e.Color = 1] = "Color", e[e.Velocity = 2] = "Velocity", e[e.Size = 3] = "Size", e[e.Rotation = 4] = "Rotation", e[e.TextureSheet = 5] = "TextureSheet", e[e.Shape = 6] = "Shape", e[e.StartSize3D = 7] = "StartSize3D", e[e.StartRotation3D = 8] = "StartRotation3D", e[e.SimulationSpace = 9] = "SimulationSpace", e[e.ScaleMode = 10] = "ScaleMode", e[e.MaxParticles = 11] = "MaxParticles", e[e.Mesh = 12] = "Mesh", e[e.Material = 13] = "Material", e[e.RenderMode = 14] = "RenderMode", e[e.VelocityScale = 15] = "VelocityScale", e[e.LengthScale = 16] = "LengthScale"
    }(_ || (_ = {}));
    var S = [{key: "POSITION", type: "VEC3"}, {key: "COLOR_0", type: "VEC4"}, {
            key: "TEXCOORD_0",
            type: "VEC2"
        }, {key: "_START_POSITION", type: "VEC3"}, {key: "_START_VELOCITY", type: "VEC3"}, {
            key: "_START_COLOR",
            type: "VEC4"
        }, {key: "_START_SIZE", type: "VEC3"}, {key: "_START_ROTATION", type: "VEC3"}, {
            key: "_TIME",
            type: "VEC2"
        }, {key: "_RANDOM0", type: "VEC4"}, {key: "_RANDOM1", type: "VEC4"}, {
            key: "_WORLD_POSITION",
            type: "VEC3"
        }, {key: "_WORLD_ROTATION", type: "VEC4"}],
        M = [{key: "TEXCOORD_0", type: "VEC2"}, {key: "_CORNER", type: "VEC2"}, {
            key: "_START_POSITION",
            type: "VEC3"
        }, {key: "_START_VELOCITY", type: "VEC3"}, {key: "_START_COLOR", type: "VEC4"}, {
            key: "_START_SIZE",
            type: "VEC3"
        }, {key: "_START_ROTATION", type: "VEC3"}, {key: "_TIME", type: "VEC2"}, {
            key: "_RANDOM0",
            type: "VEC4"
        }, {key: "_RANDOM1", type: "VEC4"}, {key: "_WORLD_POSITION", type: "VEC3"}, {
            key: "_WORLD_ROTATION",
            type: "VEC4"
        }], A = function (e) {
            function t() {
                var t = null !== e && e.apply(this, arguments) || this;
                return t.changes = [], t
            }

            return T(t, e), t = E([Object(v.hideFlag)(28), Object(g.component)({isAbstract: !1})], t)
        }(g.Component);
    __reflect(A, "@egret/particle/_ParticleUpdate");
    var O = function (e) {
        function t() {
            return this
        }

        return T(t, DebuggerClass), t._randomPostionCircle = function (e) {
            var t = 6.283185307179586 * Math.random();
            e.x = Math.cos(t), e.y = Math.sin(t)
        }, t._randomPositionInsideCircle = function (e) {
            this._randomPostionCircle(e);
            var t = Math.pow(Math.random(), .5);
            e.x = e.x * t, e.y = e.y * t
        }, t._randomPositionArcCircle = function (e, t) {
            e *= .017453292519943295;
            var n = Math.random() * e;
            t.x = Math.cos(n), t.y = Math.sin(n)
        }, t._randomPositionInsideArcCircle = function (e, t) {
            this._randomPositionArcCircle(e, t);
            var n = Math.pow(Math.random(), .5);
            t.x = t.x * n, t.y = t.y * n
        }, t._randomPositionSphere = function (e) {
            var t = 2 * Math.random() - 1, n = 6.283185307179586 * Math.random(), r = Math.sqrt(1 - t * t);
            e.x = Math.cos(n) * r, e.y = Math.sin(n) * r, e.z = t
        }, t._randomPositionInsideSphere = function (e) {
            this._randomPositionSphere(e);
            var t = Math.pow(Math.random(), 1 / 3);
            e.x = e.x * t, e.y = e.y * t, e.z = e.z * t
        }, t._generateConeParticlePosition = function (e, t, n) {
            var r = y.Vector3.create().release();
            4 === e.shapeType ? this._randomPositionInsideCircle(r) : this._randomPostionCircle(r), t.x = r.x * e.radius, t.y = r.y * e.radius, t.z = r.z * e.radius;
            var i = .017453292519943295 * e.angle, o = Math.sin(i), a = Math.cos(i);
            e.randomDirection ? (this._randomPositionInsideCircle(n), n.x = n.x * o, n.y = n.y * o, n.z = a) : (n.x = r.x * o, n.y = r.y * o, n.z = a)
        }, t._generateConeVolumeParticlePosition = function (e, t, n) {
            var r = y.Vector3.create().release();
            8 === e.shapeType ? this._randomPositionInsideCircle(r) : this._randomPostionCircle(r), t.x = r.x * e.radius, t.y = r.y * e.radius, t.z = 0;
            var i = .017453292519943295 * e.angle, o = Math.sin(i), a = Math.cos(i);
            n.x = r.x * o, n.y = r.y * o, n.z = a, n.normalize();
            var s = Math.random() * e.length;
            n.x = n.x * s, n.y = n.y * s, n.z = n.z * s, t.x += n.x, t.y += n.y, t.z += n.z, e.randomDirection && this._randomPositionSphere(n)
        }, t._generateBoxParticlePosition = function (e, t, n) {
            t.x = e.box.x * (Math.random() - .5), t.y = e.box.y * (Math.random() - .5), t.z = e.box.z * (Math.random() - .5), e.randomDirection, n.x = 0, n.y = 0, n.z = 1
        }, t._generateSphereParticlePosition = function (e, t, n) {
            e.spherizeDirection || (0 === e.shapeType ? this._randomPositionInsideSphere(t) : this._randomPositionSphere(t)), t.x = t.x * e.radius, t.y = t.y * e.radius, t.z = t.z * e.radius, e.randomDirection || e.spherizeDirection ? this._randomPositionSphere(n) : (n.x = t.x, n.y = t.y, n.z = t.z)
        }, t._generateCircleParticlePosition = function (e, t, n) {
            var r = y.Vector3.create().release();
            this._randomPositionArcCircle(e.arc, r), t.x = -r.x * e.radius, t.y = r.y * e.radius, t.z = 0, e.randomDirection ? this._randomPositionSphere(n) : (n.x = t.x, n.y = t.y, n.z = t.z)
        }, t.createBatchMesh = function (e, t) {
            var n = {}, r = 4 === e.renderMode, i = r ? e.mesh.vertexCount * t : 4 * t;
            if (null !== e._batchMesh && e._batchMesh.vertexCount === i) return e._batchMesh;
            if (null !== e._batchMesh && e._batchMesh.entity.destroy(), r) {
                for (var o = e.mesh, a = (O = o.getIndices()).length, s = 0, l = S; s < l.length; s++) {
                    n[(P = l[s]).key] = P.type
                }
                var u = a * t;
                (L = b.Mesh.create(i, u, n)).drawMode = 35048;
                for (var c = 0, p = o.getAttribute("POSITION"), d = o.getAttribute("TEXCOORD_0"), h = o.getAttribute("COLOR_0"), f = L.getAttribute("POSITION"), m = L.getAttribute("COLOR_0"), _ = L.getAttribute("TEXCOORD_0"), g = 0; g < i; g++) {
                    var v = 2 * g, y = 3 * g, x = 4 * g, T = g % o.vertexCount;
                    f[y] = p[3 * T], f[y + 1] = p[3 * T + 1], f[y + 2] = p[3 * T + 2], d && (_[v] = d[2 * T], _[v + 1] = d[2 * T + 1]), h ? (m[x] = h[4 * T], m[x + 1] = h[4 * T + 1], m[x + 2] = h[4 * T + 2], m[x + 3] = h[4 * T + 3]) : (m[x] = 1, m[x + 1] = 1, m[x + 2] = 1, m[x + 3] = 1)
                }
                var E = L.getIndices();
                for (g = 0; g < t; g++) for (var C = g * o.vertexCount, A = 0; A < a; A++) E[c++] = O[A] + C;
                return L
            }
            a = (O = [0, 2, 1, 1, 2, 3]).length;
            for (var O, w = 0, R = M; w < R.length; w++) {
                var P;
                n[(P = R[w]).key] = P.type
            }
            var L;
            u = a * t;
            (L = b.Mesh.create(i, u, n)).drawMode = 35048;
            _ = L.getAttribute("TEXCOORD_0");
            var D = L.getAttribute("_CORNER");
            for (g = 0; g < i; g++) {
                v = 2 * g;
                switch (T = g % 4) {
                    case 0:
                        _[v] = 0, _[v + 1] = 0, D[v] = -.5, D[v + 1] = .5;
                        break;
                    case 1:
                        _[v] = 1, _[v + 1] = 0, D[v] = .5, D[v + 1] = .5;
                        break;
                    case 2:
                        _[v] = 0, _[v + 1] = 1, D[v] = -.5, D[v + 1] = -.5;
                        break;
                    case 3:
                        _[v] = 1, _[v + 1] = 1, D[v] = .5, D[v + 1] = -.5
                }
            }
            for (E = L.getIndices(), g = 0; g < t; g++) {
                var I = 4 * g, N = I + 2;
                E[(C = 6 * g) + 0] = I, E[C + 1] = N, E[C + 2] = I + 1, E[C + 3] = I + 1, E[C + 4] = N, E[C + 5] = I + 3
            }
            return L
        }, t.generatePositionAndDirection = function (e, t, n) {
            switch (e.x = e.y = e.z = 0, t.x = t.y = 0, t.z = 1, n.shapeType) {
                case 4:
                case 7:
                    this._generateConeParticlePosition(n, e, t);
                    break;
                case 8:
                case 9:
                    this._generateConeVolumeParticlePosition(n, e, t);
                    break;
                case 5:
                    this._generateBoxParticlePosition(n, e, t);
                    break;
                case 0:
                case 1:
                    this._generateSphereParticlePosition(n, e, t);
                    break;
                case 10:
                    this._generateCircleParticlePosition(n, e, t)
            }
            t.normalize()
        }, t._onChanged = function (e, t) {
            var n = e.getOrAddComponent(A);
            n.changes.indexOf(t) < 0 && n.changes.push(t)
        }, t
    }();
    __reflect(O, "@egret/particle/ParticleUtil");
    var w = function (e) {
        function t() {
            var t = null !== e && e.apply(this, arguments) || this;
            return t._batchMesh = null, t._batchMaterial = null, t._mesh = null, t._velocityScale = 1, t._lengthScale = 1, t._renderMode = 0, t
        }

        return T(t, e), t.prototype._getlocalBoundingBox = function () {
            return null
        }, t.prototype.uninitialize = function () {
            e.prototype.uninitialize.call(this), this._nativeLocalBoundingBox = !0, this._renderMode = 0, this._velocityScale = 1, this._lengthScale = 1, this._mesh = null, this._batchMesh = null, this._batchMaterial = null
        }, t.prototype.raycast = function (e, t) {
            return !1
        }, Object.defineProperty(t.prototype, "mesh", {
            get: function () {
                return this._mesh
            }, set: function (e) {
                this._mesh !== e && (this._mesh = e, O._onChanged(this.entity, 12))
            }, enumerable: !0, configurable: !0
        }), Object.defineProperty(t.prototype, "materials", {
            get: function () {
                return this._materials
            }, set: function (e) {
                var t = this._materials;
                if (e !== t) {
                    t.length = 0;
                    for (var n = 0, r = e; n < r.length; n++) {
                        var i = r[n];
                        t.push(i)
                    }
                } else console.warn("Potentially risky operation.");
                O._onChanged(this.entity, 13)
            }, enumerable: !0, configurable: !0
        }), Object.defineProperty(t.prototype, "material", {
            get: function () {
                var e = this._materials;
                return e.length > 0 ? e[0] : null
            }, set: function (e) {
                var t = !1, n = this._materials;
                n.length > 0 ? n[0] !== e && (t = !0) : null !== e && (t = !0), t && (n[0] = e, O._onChanged(this.entity, 13))
            }, enumerable: !0, configurable: !0
        }), Object.defineProperty(t.prototype, "renderMode", {
            get: function () {
                return this._renderMode
            }, set: function (e) {
                this._renderMode !== e && (this._renderMode = e, O._onChanged(this.entity, 14))
            }, enumerable: !0, configurable: !0
        }), Object.defineProperty(t.prototype, "velocityScale", {
            get: function () {
                return this._velocityScale
            }, set: function (e) {
                this._velocityScale !== e && (this._velocityScale = e, O._onChanged(this.entity, 15))
            }, enumerable: !0, configurable: !0
        }), Object.defineProperty(t.prototype, "lengthScale", {
            get: function () {
                return this._lengthScale
            }, set: function (e) {
                this._lengthScale !== e && (this._lengthScale = e, O._onChanged(this.entity, 16))
            }, enumerable: !0, configurable: !0
        }), E([v.serializedField, Object(v.property)("asset", {assetType: "mesh"})], t.prototype, "mesh", null), E([Object(v.property)("enum", {listItems: Object(v.getItemsFromEnum)(m)}), v.serializedField], t.prototype, "renderMode", null), E([Object(v.property)("float"), v.serializedField], t.prototype, "velocityScale", null), E([Object(v.property)("float"), v.serializedField], t.prototype, "lengthScale", null), t = E([Object(g.component)({isAbstract: !1})], t)
    }(b.BaseRenderer);
    __reflect(w, "@egret/particle/ParticleRenderer");
    var R = y.Vector3.create(), P = y.Vector3.create(), L = y.Vector3.create(), D = y.Color.create(),
        I = y.Vector3.create(), N = y.Vector3.create(0, -9.81, 0), z = function (e) {
            function t() {
                var t = null !== e && e.apply(this, arguments) || this;
                return t._dirty = !1, t._time = 0, t._emittsionTime = 0, t._frameRateTime = 0, t._firstAliveCursor = 0, t._lastFrameFirstCursor = 0, t._lastAliveCursor = 0, t._forceUpdate = !1, t._vertexStride = 0, t._burstIndex = 0, t._readEmitCount = 0, t._finalGravity = y.Vector3.create(), t._vertexAttributes = [], t._startPositionBuffer = null, t._startVelocityBuffer = null, t._startColorBuffer = null, t._startSizeBuffer = null, t._startRotationBuffer = null, t._startTimeBuffer = null, t._random0Buffer = null, t._random1Buffer = null, t._worldPostionBuffer = null, t._worldRoationBuffer = null, t._worldPostionCache = y.Vector3.create(), t._worldRotationCache = y.Quaternion.create(), t._comp = null, t._renderer = null, t
            }

            return T(t, e), t.prototype._createBatchMesh = function () {
            }, t.prototype._getBurstCount = function (e, t) {
                for (var n = 0, r = this._comp.emission.bursts, i = r.length; this._burstIndex < i; this._burstIndex++) {
                    var o = r[this._burstIndex];
                    if (!(o.time >= e && o.time < t)) break;
                    n += o.maxCount
                }
                return n
            }, t.prototype._isParticleExpired = function (e) {
                var t = e * this._vertexStride * 2;
                return this._time - this._startTimeBuffer[t + 1] + 1e-4 > this._startTimeBuffer[t]
            }, t.prototype._addParticles = function (e, t, n, r) {
                for (var i = this._comp, o = i.main, a = i.velocityOverLifetime, s = i.colorOverLifetime, l = i.sizeOverLifetime, u = i.rotationOverLifetime, c = i.textureSheetAnimation, p = a.enable && (3 === a.mode || 2 === a.mode), d = s.enable && 3 === s.color.mode, h = l.enable && (3 === l.size.mode || 2 === l.size.mode), f = u.enable && (3 === u.x.mode || 2 === u.x.mode), m = c.enable && (3 === c.startFrame.mode || 2 === c.startFrame.mode), _ = d || h || f || m, g = this._worldPostionCache, v = this._worldRotationCache, y = 1 === o.simulationSpace, b = this._startPositionBuffer, x = this._startVelocityBuffer, T = this._startColorBuffer, E = this._startSizeBuffer, C = this._startRotationBuffer, S = this._startTimeBuffer, M = this._random0Buffer, A = this._random1Buffer, w = this._worldPostionBuffer, z = this._worldRoationBuffer, U = o.startSize3D, F = o.startRotation3D, k = Math.min(r / o.duration, 1), V = this._vertexStride, B = 0, G = 0, j = 0, H = 0, W = 0, X = 0, Y = 0, q = 0, Z = 0, K = 0, Q = 0, J = 0, $ = 0, ee = 0, te = 0, ne = 0; B !== n;) {
                    for (O.generatePositionAndDirection(R, P, i.shape), o.startColor.evaluate(k, D), H = o.startLifetime.evaluate(k), W = o.startSpeed.evaluate(k), P.x *= W, P.y *= W, P.z *= W, U ? (L.x = o.startSizeX.evaluate(k), L.y = o.startSizeY.evaluate(k), L.z = o.startSizeZ.evaluate(k)) : (X = o.startSizeX.evaluate(k), L.x = X, L.y = X, L.z = X), F ? (I.x = o.startRotationX.evaluate(k), I.y = o.startRotationY.evaluate(k), I.z = o.startRotationZ.evaluate(k)) : I.x = o.startRotationX.evaluate(k), Y = p ? Math.random() : 0, q = p ? Math.random() : 0, Z = p ? Math.random() : 0, K = d ? Math.random() : 0, Q = h ? Math.random() : 0, J = f ? Math.random() : 0, $ = m ? Math.random() : 0, j = (G = t * V) + V; G < j; G++) ee = 2 * G, ne = 4 * G, b[te = 3 * G] = R.x, b[te + 1] = R.y, b[te + 2] = R.z, x[te] = P.x, x[te + 1] = P.y, x[te + 2] = P.z, T[ne] = D.r, T[ne + 1] = D.g, T[ne + 2] = D.b, T[ne + 3] = D.a, E[te] = L.x, E[te + 1] = L.y, E[te + 2] = L.z, C[te] = I.x, C[te + 1] = I.y, C[te + 2] = I.z, S[ee] = H, S[ee + 1] = e, _ && (M[ne] = K, M[ne + 1] = Q, M[ne + 2] = J, M[ne + 3] = $), p && (A[ne] = Y, A[ne + 1] = q, A[ne + 2] = Z, A[ne + 3] = 0), y && (w[te] = g.x, w[te + 1] = g.y, w[te + 2] = g.z, z[ne] = v.rawData[0], z[ne + 1] = v.rawData[1], z[ne + 2] = v.rawData[2], z[ne + 3] = v.rawData[3]);
                    ++t >= o.maxParticles && (t = 0), B++
                }
                var re = o.gravityModifier.constant;
                this._finalGravity.x = N.x * re, this._finalGravity.y = N.y * re, this._finalGravity.z = N.z * re
            }, t.prototype._tryEmit = function () {
                if (!this._isParticleExpired(this._firstAliveCursor)) return !1;
                var e = this._comp.main.maxParticles, t = this._firstAliveCursor + 1 >= e ? 0 : this._firstAliveCursor + 1;
                return t === this._lastAliveCursor && (this._forceUpdate = !0), this._firstAliveCursor = t, !0
            }, t.prototype.clean = function () {
                this._time = 0, this._dirty = !1, this._emittsionTime = 0, this._frameRateTime = 0, this._firstAliveCursor = 0, this._lastFrameFirstCursor = 0, this._lastAliveCursor = 0, this._forceUpdate = !1, this._vertexStride = 0, this._vertexAttributes = null, this._burstIndex = 0, this._readEmitCount = 0, this._startPositionBuffer = null, this._startVelocityBuffer = null, this._startColorBuffer = null, this._startSizeBuffer = null, this._startRotationBuffer = null, this._startTimeBuffer = null, this._random0Buffer = null, this._random1Buffer = null, this._worldPostionBuffer = null, this._worldRoationBuffer = null, this._comp = null, this._renderer = null
            }, t.prototype.resetTime = function () {
                this._burstIndex = 0, this._emittsionTime = 0, this._readEmitCount = 0
            }, t.prototype.init = function (e, t) {
                this._comp = e, this._renderer = t;
                var n = O.createBatchMesh(t, e.main.maxParticles);
                this._vertexStride = 4 === t.renderMode ? t.mesh.vertexCount : 4, this._startPositionBuffer = n.getAttribute("_START_POSITION"), this._startVelocityBuffer = n.getAttribute("_START_VELOCITY"), this._startColorBuffer = n.getAttribute("_START_COLOR"), this._startSizeBuffer = n.getAttribute("_START_SIZE"), this._startRotationBuffer = n.getAttribute("_START_ROTATION"), this._startTimeBuffer = n.getAttribute("_TIME"), this._random0Buffer = n.getAttribute("_RANDOM0"), this._random1Buffer = n.getAttribute("_RANDOM1"), this._worldPostionBuffer = n.getAttribute("_WORLD_POSITION"), this._worldRoationBuffer = n.getAttribute("_WORLD_ROTATION");
                var r = n.glTFMesh.primitives[0];
                for (var i in this._vertexAttributes = [], r.attributes) this._vertexAttributes.push(i);
                for (var o = 0, a = this._startTimeBuffer.length; o < a; o++) this._startTimeBuffer[o] = 0;
                t._batchMesh = n;
                var s = t.materials[0];
                null !== t._batchMaterial && t._batchMaterial === s || (null !== t._batchMaterial && t._batchMaterial.entity.destroy(), t._batchMaterial = b.Material.create(s)), n.needUpdate(28, 0)
            }, t.prototype.update = function (e) {
                if (this._comp && !this._comp.isPaused) {
                    this._time += e;
                    for (var t = this._comp, n = t.main; (this._lastAliveCursor !== this._firstAliveCursor || this._forceUpdate) && this._isParticleExpired(this._lastAliveCursor);) this._forceUpdate = !1, this._lastAliveCursor++, this._lastAliveCursor >= n.maxParticles && (this._lastAliveCursor = 0);
                    var r = t.entity.transform;
                    this._worldPostionCache.copy(r.position), this._worldRotationCache.copy(r.rotation), t._isPlaying && this._time >= n.startDelay.constant && t.emission.enable && this._updateEmission(e), this._updateRender()
                }
            }, t.prototype._updateEmission = function (e) {
                var t = this._comp, n = t.main, r = this._emittsionTime;
                this._emittsionTime += e;
                var i = this._emittsionTime > n.duration, o = this.aliveParticleCount, a = 0;
                i ? n.loop ? (this._readEmitCount = 0, this._readEmitCount += this._getBurstCount(r, this._emittsionTime), this._emittsionTime -= n.duration, this._burstIndex = 0, this._readEmitCount += this._getBurstCount(0, this._emittsionTime)) : t.stop(!1) : t.emission.bursts.length > 0 && (this._readEmitCount += this._getBurstCount(r, this._emittsionTime));
                for (var s = 0, l = this._readEmitCount; s < l; s++) this._tryEmit() && (a++, this._readEmitCount--);
                var u = t.emission.rateOverTime.constant;
                if (u > 0) {
                    var c = 1 / u;
                    for (this._frameRateTime += e; this._frameRateTime > c && this._tryEmit();) a++, this._frameRateTime -= c
                }
                (a = Math.min(n.maxParticles - o, a)) > 0 && t._isPlaying && (this._addParticles(this._time, this._lastFrameFirstCursor, a, r), this._dirty = !0)
            }, t.prototype._updateRender = function () {
                var e = this._renderer, t = this._comp, n = t.main;
                if (this._dirty) {
                    var r = this._lastFrameFirstCursor * this._vertexStride;
                    if (this._firstAliveCursor > this._lastFrameFirstCursor) {
                        var i = (this._firstAliveCursor - this._lastFrameFirstCursor) * this._vertexStride;
                        e._batchMesh.uploadVertexBuffer(this._vertexAttributes, r, i)
                    } else {
                        var o = n.maxParticles - this._lastFrameFirstCursor;
                        e._batchMesh.uploadVertexBuffer(this._vertexAttributes, r, o * this._vertexStride), e._batchMesh.uploadVertexBuffer(this._vertexAttributes, 0, this._firstAliveCursor * this._vertexStride)
                    }
                    this._lastFrameFirstCursor = this._firstAliveCursor, this._dirty = !1
                }
                var a = t.entity.transform, s = e._batchMaterial;
                switch (0 === n.simulationSpace && (s.setVector3("u_worldPosition", this._worldPostionCache), s.setTypedArray("u_worldRotation", this._worldRotationCache.rawData)), n.scaleMode) {
                    case 1:
                        var l = a.localScale;
                        s.setVector3("u_positionScale", l), s.setVector3("u_sizeScale", l);
                        break;
                    case 2:
                        l = a.scale;
                        s.setVector3("u_positionScale", l), s.setVector3("u_sizeScale", y.Vector3.ONE);
                        break;
                    case 0:
                        l = a.scale;
                        s.setVector3("u_positionScale", l), s.setVector3("u_sizeScale", l)
                }
                s.setFloat("u_currentTime", this._time), s.setVector3("u_gravity", this._finalGravity)
            }, Object.defineProperty(t.prototype, "aliveParticleCount", {
                get: function () {
                    return this._firstAliveCursor >= this._lastAliveCursor ? this._firstAliveCursor - this._lastAliveCursor : this._comp.main.maxParticles - this._lastAliveCursor + this._firstAliveCursor
                }, enumerable: !0, configurable: !0
            }), t
        }(DebuggerClass);
    __reflect(z, "@egret/particle/ParticleBatcher");
    var U = y.Color.create(), F = y.Color.create(), k = function (e) {
        function t() {
            var t = null !== e && e.apply(this, arguments) || this;
            return t.time = 0, t.value = 0, t
        }

        return T(t, e), t.prototype.serialize = function () {
            return [this.time, this.value]
        }, t.prototype.deserialize = function (e) {
            return this.time = e[0], this.value = e[1], this
        }, t.prototype.copy = function (e) {
            this.time = e.time, this.value = e.value
        }, E([Object(v.property)("float")], t.prototype, "time", void 0), E([Object(v.property)("float")], t.prototype, "value", void 0), t
    }(DebuggerClass);
    __reflect(k, "@egret/particle/Keyframe");
    var V = function (e) {
        function t() {
            this._keys = new Array, this._floatValues = new Float32Array(8);
            var e = new k, t = new k, n = new k, r = new k;
            return this._keys.push(e, t, n, r), this
        }

        return T(t, DebuggerClass), t.prototype.serialize = function () {
            return this._keys.map((function (e) {
                return e.serialize()
            }))
        }, t.prototype.deserialize = function (e) {
            this._keys.length = 0;
            for (var t = 0, n = e.length; t < n; t++) {
                var r = new k;
                r.deserialize(e[t]), this._keys.push(r)
            }
            return this
        }, t.prototype.evaluate = function (e) {
            void 0 === e && (e = 0);
            for (var t = 0, n = this._keys.length; t < n; t++) {
                var r = this._keys[t];
                if (!(r.time < e)) {
                    var i = 0 === t ? 0 : t - 1, o = this._keys[i], a = (e - o.time) / (r.time - o.time);
                    return y.MathUtil.lerp(o.value, r.value, a)
                }
            }
            throw"AnimationCurve: invalid t or keys.length is 0"
        }, Object.defineProperty(t.prototype, "floatValues", {
            get: function () {
                for (var e = this._floatValues, t = 0, n = 0, r = this._keys; n < r.length; n++) {
                    var i = r[n];
                    e[t++] = i.time, e[t++] = i.value
                }
                return e
            }, enumerable: !0, configurable: !0
        }), t.prototype.copy = function (e) {
            this._keys.length = 0;
            for (var t = e._keys, n = 0, r = t.length; n < r; n++) {
                var i = new k;
                i.time = t[n].time, i.value = t[n].value, this._keys.push(i)
            }
        }, Object.defineProperty(t.prototype, "keys", {
            get: function () {
                return this._keys
            }, enumerable: !0, configurable: !0
        }), t
    }();
    __reflect(V, "@egret/particle/AnimationCurve");
    var B = function (e) {
        function t() {
            var t = null !== e && e.apply(this, arguments) || this;
            return t.time = 0, t.minCount = 0, t.maxCount = 100, t.cycleCount = 1, t.repeatInterval = 1, t
        }

        return T(t, e), t.prototype.serialize = function () {
            return [this.time, this.minCount, this.maxCount, this.cycleCount, this.repeatInterval]
        }, t.prototype.deserialize = function (e) {
            return this.time = e[0], this.minCount = e[1], this.maxCount = e[2], this.cycleCount = e[3], this.repeatInterval = e[4], this
        }, t
    }(DebuggerClass);
    __reflect(B, "@egret/particle/Burst");
    var G = function (e) {
        function t() {
            var t = null !== e && e.apply(this, arguments) || this;
            return t.time = 0, t.color = y.Color.create(), t
        }

        return T(t, e), t.prototype.serialize = function () {
            return {time: this.time, color: this.color.serialize()}
        }, t.prototype.deserialize = function (e) {
            return this.time = e.time, this.color.deserialize(e.color), this
        }, t
    }(DebuggerClass);
    __reflect(G, "@egret/particle/GradientColorKey");
    var j = function (e) {
        function t() {
            var t = null !== e && e.apply(this, arguments) || this;
            return t.time = 0, t.alpha = 0, t
        }

        return T(t, e), t.prototype.serialize = function () {
            return {time: this.time, alpha: this.alpha}
        }, t.prototype.deserialize = function (e) {
            return this.alpha = e.alpha, this.time = e.time, this
        }, t
    }(DebuggerClass);
    __reflect(j, "@egret/particle/GradientAlphaKey");
    var H = function (e) {
        function t() {
            var t = null !== e && e.apply(this, arguments) || this;
            return t.mode = 0, t.alphaKeys = new Array, t.colorKeys = new Array, t._alphaValue = new Float32Array(8), t._colorValue = new Float32Array(16), t
        }

        return T(t, e), t.prototype.serialize = function () {
            return {
                mode: this.mode, alphaKeys: this.alphaKeys.map((function (e) {
                    return e.serialize()
                })), colorKeys: this.colorKeys.map((function (e) {
                    return e.serialize()
                }))
            }
        }, t.prototype.deserialize = function (e) {
            this.colorKeys.length = 0;
            for (var t = 0, n = e.colorKeys.length; t < n; t++) {
                var r = new G;
                r.deserialize(e.colorKeys[t]), this.colorKeys.push(r)
            }
            this.alphaKeys.length = 0;
            for (t = 0, n = e.alphaKeys.length; t < n; t++) {
                var i = new j;
                i.deserialize(e.alphaKeys[t]), this.alphaKeys.push(i)
            }
            return this
        }, t.prototype.evaluate = function (e, t) {
            void 0 === e && (e = 0);
            for (var n = 0, r = this.alphaKeys.length; n < r; n++) {
                var i = this.alphaKeys[n];
                if (i.time > e) {
                    var o = 0 === n ? 0 : n - 1, a = (e - (l = this.alphaKeys[o]).time) / (i.time - l.time);
                    t.a = y.MathUtil.lerp(l.alpha, i.alpha, a);
                    break
                }
            }
            for (n = 0, r = this.colorKeys.length; n < r; n++) {
                var s = this.colorKeys[n];
                if (s.time > e) {
                    var l;
                    o = 0 === n ? 0 : n - 1, a = (e - (l = this.colorKeys[o]).time) / (s.time - l.time);
                    t.r = y.MathUtil.lerp(l.color.r, s.color.r, a), t.g = y.MathUtil.lerp(l.color.g, s.color.g, a), t.b = y.MathUtil.lerp(l.color.b, s.color.b, a);
                    break
                }
            }
            return t
        }, Object.defineProperty(t.prototype, "alphaValues", {
            get: function () {
                for (var e = this._alphaValue, t = 0, n = 0, r = this.alphaKeys; n < r.length; n++) {
                    var i = r[n];
                    e[t++] = i.time, e[t++] = i.alpha
                }
                return e
            }, enumerable: !0, configurable: !0
        }), Object.defineProperty(t.prototype, "colorValues", {
            get: function () {
                for (var e = this._colorValue, t = 0, n = 0, r = this.colorKeys; n < r.length; n++) {
                    var i = r[n];
                    e[t++] = i.time, e[t++] = i.color.r, e[t++] = i.color.g, e[t++] = i.color.b
                }
                return e
            }, enumerable: !0, configurable: !0
        }), t
    }(DebuggerClass);
    __reflect(H, "@egret/particle/Gradient");
    var W = function (e) {
        function t() {
            var t = null !== e && e.apply(this, arguments) || this;
            return t.mode = 0, t.constant = 0, t.constantMin = 0, t.constantMax = 1, t.curve = new V, t.curveMin = new V, t.curveMax = new V, t
        }

        return T(t, e), t.prototype.serialize = function () {
            return {
                mode: this.mode,
                constant: this.constant,
                constantMin: this.constantMin,
                constantMax: this.constantMax,
                curve: this.curve.serialize(),
                curveMin: this.curveMin.serialize(),
                curveMax: this.curveMax.serialize()
            }
        }, t.prototype.deserialize = function (e) {
            return this.mode = e.mode, this.constant = e.constant || 0, this.constantMin = e.constantMin || 0, this.constantMax = e.constantMax || 0, e.curve && this.curve.deserialize(e.curve), e.curveMin && this.curveMin.deserialize(e.curveMin), e.curveMax && this.curveMax.deserialize(e.curveMax), this
        }, t.prototype.evaluate = function (e) {
            if (void 0 === e && (e = 0), 0 === this.mode) return this.constant;
            if (3 === this.mode) return Math.random() * (this.constantMax - this.constantMin) + this.constantMin;
            if (1 === this.mode) return this.curve.evaluate(e);
            var t = this.curveMin.evaluate(e), n = this.curveMax.evaluate(e);
            return Math.random() * (t - n) + t
        }, t.prototype.copy = function (e) {
            this.mode = e.mode, this.constant = e.constant, this.constantMin = e.constantMin, this.constantMax = e.constantMax, this.curve.copy(e.curve), this.curveMin.copy(e.curveMin), this.curveMax.copy(e.curveMax)
        }, E([Object(v.property)("enum", {listItems: Object(v.getItemsFromEnum)(a)})], t.prototype, "mode", void 0), E([Object(v.property)("float")], t.prototype, "constant", void 0), E([Object(v.property)("float")], t.prototype, "constantMin", void 0), E([Object(v.property)("float")], t.prototype, "constantMax", void 0), t
    }(DebuggerClass);
    __reflect(W, "@egret/particle/MinMaxCurve");
    var X = function (e) {
        function t() {
            var t = null !== e && e.apply(this, arguments) || this;
            return t.mode = 1, t.color = y.Color.create(), t.colorMin = y.Color.create(), t.colorMax = y.Color.create(), t.gradient = new H, t.gradientMin = new H, t.gradientMax = new H, t
        }

        return T(t, e), t.prototype.serialize = function () {
            return {
                mode: this.mode,
                color: this.color.serialize(),
                colorMin: this.colorMin.serialize(),
                colorMax: this.colorMax.serialize(),
                gradient: this.gradient.serialize(),
                gradientMin: this.gradientMin.serialize(),
                gradientMax: this.gradientMax.serialize()
            }
        }, t.prototype.deserialize = function (e) {
            return this.mode = e.mode, e.color && this.color.deserialize(e.color), e.colorMin && this.colorMin.deserialize(e.colorMin), e.colorMax && this.colorMax.deserialize(e.colorMax), e.gradient && this.gradient.deserialize(e.gradient), e.gradientMin && this.gradientMin.deserialize(e.gradientMin), e.gradientMax && this.gradientMax.deserialize(e.gradientMax), this
        }, t.prototype.evaluate = function (e, t) {
            if (void 0 === e && (e = 0), 0 === this.mode) t.r = this.color.r, t.g = this.color.g, t.b = this.color.b, t.a = this.color.a; else if (2 === this.mode) t.r = Math.random() * (this.colorMax.r - this.colorMin.r) + this.colorMin.r, t.g = Math.random() * (this.colorMax.g - this.colorMin.g) + this.colorMin.g, t.b = Math.random() * (this.colorMax.b - this.colorMin.b) + this.colorMin.b, t.a = Math.random() * (this.colorMax.a - this.colorMin.a) + this.colorMin.a; else {
                if (1 === this.mode) return this.gradient.evaluate(e, t);
                3 === this.mode ? (this.gradientMin.evaluate(e, U), this.gradientMax.evaluate(e, F), t.r = Math.random() * (U.r - F.r) + U.r, t.g = Math.random() * (U.g - F.g) + U.g, t.b = Math.random() * (U.b - F.b) + U.b, t.a = Math.random() * (U.a - F.a) + U.a) : (t.r = Math.random(), t.g = Math.random(), t.b = Math.random(), t.a = Math.random())
            }
            return t
        }, E([Object(v.property)("enum", {listItems: Object(v.getItemsFromEnum)(s)})], t.prototype, "mode", void 0), E([Object(v.property)("color")], t.prototype, "color", void 0), E([Object(v.property)("color")], t.prototype, "colorMin", void 0), E([Object(v.property)("color")], t.prototype, "colorMax", void 0), t
    }(DebuggerClass);
    __reflect(X, "@egret/particle/MinMaxGradient");
    var Y = function (e) {
        function t(e) {
            return this.enable = !1, this._component = e, this
        }

        return T(t, DebuggerClass), t.prototype.serialize = function () {
            return {enable: this.enable}
        }, t.prototype.deserialize = function (e) {
            return this.enable = !0, this
        }, E([Object(v.property)("boolean")], t.prototype, "enable", void 0), t
    }();
    __reflect(Y, "@egret/particle/ParticleModule");
    var q = function (e) {
        function t() {
            var t = null !== e && e.apply(this, arguments) || this;
            return t.loop = !1, t.playOnAwake = !1, t.duration = 0, t.startDelay = new W, t.startLifetime = new W, t.startSpeed = new W, t.startSizeX = new W, t.startSizeY = new W, t.startSizeZ = new W, t.startRotationX = new W, t.startRotationY = new W, t.startRotationZ = new W, t.startColor = new X, t.gravityModifier = new W, t._startSize3D = !1, t._startRotation3D = !1, t._simulationSpace = 0, t._scaleMode = 0, t._maxParticles = 1, t
        }

        return T(t, e), t.prototype.serialize = function () {
            return {
                enable: this.enable,
                loop: this.loop,
                playOnAwake: this.playOnAwake,
                duration: this.duration,
                startDelay: this.startDelay.serialize(),
                startLifetime: this.startLifetime.serialize(),
                startSpeed: this.startSpeed.serialize(),
                startSizeX: this.startSizeX.serialize(),
                startSizeY: this.startSizeY.serialize(),
                startSizeZ: this.startSizeZ.serialize(),
                startRotationX: this.startRotationX.serialize(),
                startRotationY: this.startRotationY.serialize(),
                startRotationZ: this.startRotationZ.serialize(),
                startColor: this.startColor.serialize(),
                gravityModifier: this.gravityModifier.serialize(),
                startSize3D: this._startSize3D,
                startRotation3D: this._startRotation3D,
                simulationSpace: this.simulationSpace,
                scaleMode: this._scaleMode,
                maxParticles: this._maxParticles
            }
        }, t.prototype.deserialize = function (t) {
            return e.prototype.deserialize.call(this, t), this.duration = t.duration, this.loop = t.loop || t.looping, this.startDelay.deserialize(t.startDelay), this.startLifetime.deserialize(t.startLifetime), this.startSpeed.deserialize(t.startSpeed), this._startSize3D = t.startSize3D || !1, this.startSizeX.deserialize(t.startSizeX), this.startSizeY.deserialize(t.startSizeY), this.startSizeZ.deserialize(t.startSizeZ), this._startRotation3D = t._startRotation3D || t.startRotation3D || !1, this.startRotationX.deserialize(t.startRotationX), this.startRotationY.deserialize(t.startRotationY), this.startRotationZ.deserialize(t.startRotationZ), this.startColor.deserialize(t.startColor), this.gravityModifier.deserialize(t.gravityModifier), this._simulationSpace = t._simulationSpace || t.simulationSpace || 0, this._scaleMode = t._scaleMode || t.scaleMode || 0, this.playOnAwake = t.playOnAwake, this._maxParticles = t._maxParticles || t.maxParticles || 0, this
        }, Object.defineProperty(t.prototype, "startSize3D", {
            get: function () {
                return this._startSize3D
            }, set: function (e) {
                this._startSize3D !== e && (this._startSize3D = e, O._onChanged(this._component.entity, 7))
            }, enumerable: !0, configurable: !0
        }), Object.defineProperty(t.prototype, "startRotation3D", {
            get: function () {
                return this._startRotation3D
            }, set: function (e) {
                this._startRotation3D !== e && (this._startRotation3D = e, O._onChanged(this._component.entity, 8))
            }, enumerable: !0, configurable: !0
        }), Object.defineProperty(t.prototype, "simulationSpace", {
            get: function () {
                return this._simulationSpace
            }, set: function (e) {
                this._simulationSpace !== e && (this._simulationSpace = e, O._onChanged(this._component.entity, 9))
            }, enumerable: !0, configurable: !0
        }), Object.defineProperty(t.prototype, "scaleMode", {
            get: function () {
                return this._scaleMode
            }, set: function (e) {
                this._scaleMode !== e && (this._scaleMode = e, O._onChanged(this._component.entity, 10))
            }, enumerable: !0, configurable: !0
        }), Object.defineProperty(t.prototype, "maxParticles", {
            get: function () {
                return this._maxParticles
            }, set: function (e) {
                this._maxParticles !== e && (this._maxParticles = e, O._onChanged(this._component.entity, 11))
            }, enumerable: !0, configurable: !0
        }), E([Object(v.property)("boolean")], t.prototype, "loop", void 0), E([Object(v.property)("boolean")], t.prototype, "playOnAwake", void 0), E([Object(v.property)("float")], t.prototype, "duration", void 0), E([Object(v.property)("nested")], t.prototype, "startDelay", void 0), E([Object(v.property)("nested")], t.prototype, "startLifetime", void 0), E([Object(v.property)("nested")], t.prototype, "startSpeed", void 0), E([Object(v.property)("nested")], t.prototype, "startSizeX", void 0), E([Object(v.property)("nested")], t.prototype, "startSizeY", void 0), E([Object(v.property)("nested")], t.prototype, "startSizeZ", void 0), E([Object(v.property)("nested")], t.prototype, "startRotationX", void 0), E([Object(v.property)("nested")], t.prototype, "startRotationY", void 0), E([Object(v.property)("nested")], t.prototype, "startRotationZ", void 0), E([Object(v.property)("nested")], t.prototype, "startColor", void 0), E([Object(v.property)("nested")], t.prototype, "gravityModifier", void 0), E([Object(v.property)("boolean")], t.prototype, "startSize3D", null), E([Object(v.property)("boolean")], t.prototype, "startRotation3D", null), E([Object(v.property)("enum", {listItems: Object(v.getItemsFromEnum)(l)})], t.prototype, "simulationSpace", null), E([Object(v.property)("enum", {listItems: Object(v.getItemsFromEnum)(u)})], t.prototype, "scaleMode", null), E([Object(v.property)("int")], t.prototype, "maxParticles", null), t
    }(Y);
    __reflect(q, "@egret/particle/MainModule");
    var Z = function (e) {
        function t() {
            var t = null !== e && e.apply(this, arguments) || this;
            return t.rateOverTime = new W, t.bursts = [], t
        }

        return T(t, e), t.prototype.serialize = function () {
            return {
                enable: this.enable,
                rateOverTime: this.rateOverTime.serialize(),
                bursts: this.bursts.map((function (e) {
                    return e.serialize()
                }))
            }
        }, t.prototype.deserialize = function (t) {
            if (e.prototype.deserialize.call(this, t), this.rateOverTime.deserialize(t.rateOverTime), t.bursts) {
                this.bursts.length = 0;
                for (var n = 0, r = t.bursts.length; n < r; n++) {
                    var i = new B;
                    i.deserialize(t.bursts[n]), this.bursts.push(i)
                }
            }
            return this
        }, E([Object(v.property)("nested")], t.prototype, "rateOverTime", void 0), t
    }(Y);
    __reflect(Z, "@egret/particle/EmissionModule");
    var K = function (e) {
        function t() {
            var t = null !== e && e.apply(this, arguments) || this;
            return t.shapeType = 0, t.radius = 0, t.angle = 0, t.length = 0, t.arcSpeed = new W, t.arcMode = 0, t.arc = 0, t.radiusSpread = 0, t.radiusMode = 0, t.box = y.Vector3.create(), t.randomDirection = !1, t.spherizeDirection = !1, t
        }

        return T(t, e), t.prototype.serialize = function () {
            return {
                enable: this.enable,
                shapeType: this.shapeType,
                radius: this.radius,
                angle: this.angle,
                length: this.length,
                arcSpeed: this.arcSpeed.serialize(),
                arcMode: this.arcMode,
                arc: this.arc,
                radiusSpread: this.radiusSpread,
                radiusMode: this.radiusMode,
                box: this.box.serialize(),
                randomDirection: this.randomDirection,
                spherizeDirection: this.spherizeDirection
            }
        }, t.prototype.deserialize = function (t) {
            return e.prototype.deserialize.call(this, t), this.shapeType = t.shapeType, this.radius = t.radius, this.angle = t.angle, this.length = t.length, this.arc = t.arc || 0, this.arcSpeed.deserialize(t.arcSpeed), this.arcMode = t.arcMode, this.radiusSpread = t.radiusSpread, this.radiusMode = t.radiusMode, this.box.deserialize(t.box), this.randomDirection = t.randomDirection, this.spherizeDirection = t.spherizeDirection, this
        }, t.prototype.invalidUpdate = function () {
            O._onChanged(this._component.entity, 5)
        }, E([Object(v.property)("enum", {listItems: Object(v.getItemsFromEnum)(c)})], t.prototype, "shapeType", void 0), E([Object(v.property)("float")], t.prototype, "radius", void 0), E([Object(v.property)("float")], t.prototype, "angle", void 0), E([Object(v.property)("float")], t.prototype, "length", void 0), E([Object(v.property)("nested")], t.prototype, "arcSpeed", void 0), E([Object(v.property)("enum", {listItems: Object(v.getItemsFromEnum)(p)})], t.prototype, "arcMode", void 0), E([Object(v.property)("float")], t.prototype, "arc", void 0), E([Object(v.property)("float")], t.prototype, "radiusSpread", void 0), E([Object(v.property)("enum", {listItems: Object(v.getItemsFromEnum)(p)})], t.prototype, "radiusMode", void 0), E([Object(v.property)("vector3")], t.prototype, "box", void 0), E([Object(v.property)("boolean")], t.prototype, "randomDirection", void 0), E([Object(v.property)("boolean")], t.prototype, "spherizeDirection", void 0), t
    }(Y);
    __reflect(K, "@egret/particle/ShapeModule");
    var Q = function (e) {
        function t() {
            var t = null !== e && e.apply(this, arguments) || this;
            return t._mode = 0, t._space = 0, t._x = new W, t._y = new W, t._z = new W, t
        }

        return T(t, e), t.prototype.serialize = function () {
            return {
                enable: this.enable,
                mode: this._mode,
                space: this._space,
                x: this._x.serialize(),
                y: this._y.serialize(),
                z: this._z.serialize()
            }
        }, t.prototype.deserialize = function (t) {
            return e.prototype.deserialize.call(this, t), this._mode = t._mode || t.mode || 0, this._space = t._space || t.space || 0, this._x.deserialize(t._x || t.x), this._y.deserialize(t._y || t.y), this._z.deserialize(t._z || t.z), this
        }, Object.defineProperty(t.prototype, "mode", {
            get: function () {
                return this._mode
            }, set: function (e) {
                this._mode !== e && (this._mode = e, O._onChanged(this._component.entity, 2))
            }, enumerable: !0, configurable: !0
        }), Object.defineProperty(t.prototype, "space", {
            get: function () {
                return this._space
            }, set: function (e) {
                this._space !== e && (this._space = e, O._onChanged(this._component.entity, 2))
            }, enumerable: !0, configurable: !0
        }), Object.defineProperty(t.prototype, "x", {
            get: function () {
                return this._x
            }, set: function (e) {
                this._x.copy(e), O._onChanged(this._component.entity, 2)
            }, enumerable: !0, configurable: !0
        }), Object.defineProperty(t.prototype, "y", {
            get: function () {
                return this._y
            }, set: function (e) {
                this._y.copy(e), O._onChanged(this._component.entity, 2)
            }, enumerable: !0, configurable: !0
        }), Object.defineProperty(t.prototype, "z", {
            get: function () {
                return this._z
            }, set: function (e) {
                this._z.copy(e), O._onChanged(this._component.entity, 2)
            }, enumerable: !0, configurable: !0
        }), E([Object(v.property)("enum", {listItems: Object(v.getItemsFromEnum)(a)})], t.prototype, "mode", null), E([Object(v.property)("enum", {listItems: Object(v.getItemsFromEnum)(l)})], t.prototype, "space", null), E([Object(v.property)("nested")], t.prototype, "x", null), E([Object(v.property)("nested")], t.prototype, "y", null), E([Object(v.property)("nested")], t.prototype, "z", null), t
    }(Y);
    __reflect(Q, "@egret/particle/VelocityOverLifetimeModule");
    var J = function (e) {
        function t() {
            var t = null !== e && e.apply(this, arguments) || this;
            return t._color = new X, t
        }

        return T(t, e), t.prototype.serialize = function () {
            return {enable: this.enable, color: this._color.serialize()}
        }, t.prototype.deserialize = function (t) {
            return e.prototype.deserialize.call(this, t), this._color.deserialize(t._color || t.color), this
        }, Object.defineProperty(t.prototype, "color", {
            get: function () {
                return this._color
            }, set: function (e) {
                this._color = e, O._onChanged(this._component.entity, 1)
            }, enumerable: !0, configurable: !0
        }), E([Object(v.property)("nested")], t.prototype, "color", null), t
    }(Y);
    __reflect(J, "@egret/particle/ColorOverLifetimeModule");
    var $ = function (e) {
        function t() {
            var t = null !== e && e.apply(this, arguments) || this;
            return t._separateAxes = !1, t._size = new W, t._x = new W, t._y = new W, t._z = new W, t
        }

        return T(t, e), t.prototype.serialize = function () {
            return {
                enable: this.enable,
                separateAxes: this._separateAxes,
                size: this._size,
                x: this._x.serialize(),
                y: this._y.serialize(),
                z: this._z.serialize()
            }
        }, t.prototype.deserialize = function (t) {
            return e.prototype.deserialize.call(this, t), this._separateAxes = t._separateAxes || t.separateAxes || !1, this._size.deserialize(t._size || t.size), this._x.deserialize(t._x || t.x), this._y.deserialize(t._y || t.y), this._z.deserialize(t._z || t.z), this
        }, Object.defineProperty(t.prototype, "separateAxes", {
            get: function () {
                return this._separateAxes
            }, set: function (e) {
                this._separateAxes !== e && (this._separateAxes = e, O._onChanged(this._component.entity, 3))
            }, enumerable: !0, configurable: !0
        }), Object.defineProperty(t.prototype, "size", {
            get: function () {
                return this._size
            }, set: function (e) {
                this._size.copy(e), O._onChanged(this._component.entity, 3)
            }, enumerable: !0, configurable: !0
        }), Object.defineProperty(t.prototype, "x", {
            get: function () {
                return this._x
            }, set: function (e) {
                this._x.copy(e), O._onChanged(this._component.entity, 3)
            }, enumerable: !0, configurable: !0
        }), Object.defineProperty(t.prototype, "y", {
            get: function () {
                return this._y
            }, set: function (e) {
                this._y.copy(e), O._onChanged(this._component.entity, 3)
            }, enumerable: !0, configurable: !0
        }), Object.defineProperty(t.prototype, "z", {
            get: function () {
                return this._z
            }, set: function (e) {
                this._z.copy(e), O._onChanged(this._component.entity, 3)
            }, enumerable: !0, configurable: !0
        }), E([Object(v.property)("boolean")], t.prototype, "separateAxes", null), E([Object(v.property)("nested")], t.prototype, "size", null), E([Object(v.property)("nested")], t.prototype, "x", null), E([Object(v.property)("nested")], t.prototype, "y", null), E([Object(v.property)("nested")], t.prototype, "z", null), t
    }(Y);
    __reflect($, "@egret/particle/SizeOverLifetimeModule");
    var ee = function (e) {
        function t() {
            var t = null !== e && e.apply(this, arguments) || this;
            return t._separateAxes = !1, t._x = new W, t._y = new W, t._z = new W, t
        }

        return T(t, e), t.prototype.serialize = function () {
            return {
                enable: this.enable,
                separateAxes: this._separateAxes,
                x: this._x.serialize(),
                y: this._y.serialize(),
                z: this._z.serialize()
            }
        }, t.prototype.deserialize = function (t) {
            return e.prototype.deserialize.call(this, t), this._separateAxes = t._separateAxes || t.separateAxes || !1, this._x.deserialize(t._x || t.x), this._y.deserialize(t._y || t.y), this._z.deserialize(t._z || t.z), this
        }, Object.defineProperty(t.prototype, "separateAxes", {
            get: function () {
                return this._separateAxes
            }, set: function (e) {
                this._separateAxes !== e && (this._separateAxes = e, O._onChanged(this._component.entity, 4))
            }, enumerable: !0, configurable: !0
        }), Object.defineProperty(t.prototype, "x", {
            get: function () {
                return this._x
            }, set: function (e) {
                this._x.copy(e), O._onChanged(this._component.entity, 4)
            }, enumerable: !0, configurable: !0
        }), Object.defineProperty(t.prototype, "y", {
            get: function () {
                return this._y
            }, set: function (e) {
                this._y.copy(e), O._onChanged(this._component.entity, 4)
            }, enumerable: !0, configurable: !0
        }), Object.defineProperty(t.prototype, "z", {
            get: function () {
                return this._z
            }, set: function (e) {
                this._z.copy(e), O._onChanged(this._component.entity, 4)
            }, enumerable: !0, configurable: !0
        }), E([Object(v.property)("boolean")], t.prototype, "separateAxes", null), E([Object(v.property)("nested")], t.prototype, "x", null), E([Object(v.property)("nested")], t.prototype, "y", null), E([Object(v.property)("nested")], t.prototype, "z", null), t
    }(Y);
    __reflect(ee, "@egret/particle/RotationOverLifetimeModule");
    var te = function (e) {
        function t() {
            var t = null !== e && e.apply(this, arguments) || this;
            return t._useRandomRow = !1, t._animation = 0, t._numTilesX = 1, t._numTilesY = 1, t._cycleCount = 1, t._rowIndex = 0, t._frameOverTime = new W, t._startFrame = new W, t._floatValues = new Float32Array(4), t
        }

        return T(t, e), t.prototype.serialize = function () {
            return {
                enable: this.enable,
                numTilesX: this._numTilesX,
                numTilesY: this._numTilesY,
                animation: this._animation,
                useRandomRow: this._useRandomRow,
                frameOverTime: this._frameOverTime.serialize(),
                startFrame: this._startFrame.serialize(),
                cycleCount: this._cycleCount,
                rowIndex: this._rowIndex
            }
        }, t.prototype.deserialize = function (t) {
            return e.prototype.deserialize.call(this, t), this._numTilesX = t._numTilesX || t.numTilesX || 0, this._numTilesY = t._numTilesY || t.numTilesY || 0, this._animation = t._animation || t.animation || 0, this._useRandomRow = t._useRandomRow || t.useRandomRow || !1, this._frameOverTime.deserialize(t._frameOverTime || t.frameOverTime), this._startFrame.deserialize(t._startFrame || t.startFrame), this._cycleCount = t._cycleCount || t.cycleCount || 0, this._rowIndex = t._rowIndex || t.rowIndex || 0, this
        }, Object.defineProperty(t.prototype, "numTilesX", {
            get: function () {
                return this._numTilesX
            }, set: function (e) {
                this._numTilesX !== e && (this._numTilesX = e, O._onChanged(this._component.entity, 5))
            }, enumerable: !0, configurable: !0
        }), Object.defineProperty(t.prototype, "numTilesY", {
            get: function () {
                return this._numTilesY
            }, set: function (e) {
                this._numTilesY !== e && (this._numTilesY = e, O._onChanged(this._component.entity, 5))
            }, enumerable: !0, configurable: !0
        }), Object.defineProperty(t.prototype, "animation", {
            get: function () {
                return this._animation
            }, set: function (e) {
                this._animation !== e && (this._animation = e, O._onChanged(this._component.entity, 5))
            }, enumerable: !0, configurable: !0
        }), Object.defineProperty(t.prototype, "useRandomRow", {
            get: function () {
                return this._useRandomRow
            }, set: function (e) {
                this._useRandomRow !== e && (this._useRandomRow = e, O._onChanged(this._component.entity, 5))
            }, enumerable: !0, configurable: !0
        }), Object.defineProperty(t.prototype, "frameOverTime", {
            get: function () {
                return this._frameOverTime
            }, set: function (e) {
                this._frameOverTime.copy(e), O._onChanged(this._component.entity, 5)
            }, enumerable: !0, configurable: !0
        }), Object.defineProperty(t.prototype, "startFrame", {
            get: function () {
                return this._startFrame
            }, set: function (e) {
                this._startFrame.copy(e), O._onChanged(this._component.entity, 5)
            }, enumerable: !0, configurable: !0
        }), Object.defineProperty(t.prototype, "cycleCount", {
            get: function () {
                return this._cycleCount
            }, set: function (e) {
                this._cycleCount !== e && (this._cycleCount = e, O._onChanged(this._component.entity, 5))
            }, enumerable: !0, configurable: !0
        }), Object.defineProperty(t.prototype, "rowIndex", {
            get: function () {
                return this._rowIndex
            }, set: function (e) {
                this._rowIndex !== e && (this._rowIndex = e, O._onChanged(this._component.entity, 5))
            }, enumerable: !0, configurable: !0
        }), Object.defineProperty(t.prototype, "floatValues", {
            get: function () {
                var e = this._floatValues;
                if (this.enable) {
                    var t = 1 / this._numTilesX, n = 1 / this._numTilesY, r = Math.floor(this._startFrame.constant),
                        i = 0;
                    switch (this._animation) {
                        case 1:
                            i = this._useRandomRow ? Math.floor(Math.random() * this._numTilesY) : this._rowIndex;
                            break;
                        case 0:
                            i = Math.floor(r / this._numTilesX)
                    }
                    var o = Math.floor(r % this._numTilesX);
                    e[0] = t, e[1] = n, e[2] = o * t, e[3] = i * n
                } else e[0] = 1, e[1] = 1, e[2] = 0, e[3] = 0;
                return e
            }, enumerable: !0, configurable: !0
        }), E([Object(v.property)("int")], t.prototype, "numTilesX", null), E([Object(v.property)("int")], t.prototype, "numTilesY", null), E([Object(v.property)("enum", {listItems: Object(v.getItemsFromEnum)(d)})], t.prototype, "animation", null), E([Object(v.property)("boolean")], t.prototype, "useRandomRow", null), E([Object(v.property)("nested")], t.prototype, "frameOverTime", null), E([Object(v.property)("nested")], t.prototype, "startFrame", null), E([Object(v.property)("int")], t.prototype, "cycleCount", null), E([Object(v.property)("int")], t.prototype, "rowIndex", null), t
    }(Y);
    __reflect(te, "@egret/particle/TextureSheetAnimationModule");
    var ne = function (e) {
        function t() {
            var t = null !== e && e.apply(this, arguments) || this;
            return t.main = new q(t), t.emission = new Z(t), t.shape = new K(t), t.velocityOverLifetime = new Q(t), t.rotationOverLifetime = new ee(t), t.sizeOverLifetime = new $(t), t.colorOverLifetime = new J(t), t.textureSheetAnimation = new te(t), t._isPlaying = !1, t._isPaused = !1, t._timeScale = 1, t._batcher = new z, t
        }

        var n;
        return T(t, e), n = t, t.prototype._clean = function (e) {
            void 0 === e && (e = !1), e && (this._isPlaying = !1, this._isPaused = !1), this._batcher.clean()
        }, t.prototype.initialize = function (t, n, r) {
            void 0 === r && (r = null), e.prototype.initialize.call(this, t, n, r), this._clean()
        }, t.prototype.uninitialize = function () {
            e.prototype.uninitialize.call(this), this._clean()
        }, t.prototype.initBatcher = function (e) {
            void 0 === e && (e = !1), this._clean(e), this._batcher.init(this, this.entity.getComponent(w))
        }, t.prototype.update = function (e) {
            this._batcher.update(e * this._timeScale)
        }, t.prototype.play = function (e) {
            if (void 0 === e && (e = !0), this._isPaused ? this._isPaused = !1 : (this._isPlaying = !0, this._isPaused = !1, this._batcher.resetTime()), e) for (var t = 0, r = this.entity.node.children; t < r.length; t++) {
                var i = r[t].entity.getComponent(n);
                i && i.isActiveAndEnabled && i.play(e)
            }
        }, t.prototype.pause = function (e) {
            if (void 0 === e && (e = !0), this._isPaused = !0, e) for (var t = 0, r = this.entity.node.children; t < r.length; t++) {
                var i = r[t].entity.getComponent(n);
                i && i.isActiveAndEnabled && i.pause(e)
            }
        }, t.prototype.stop = function (e) {
            if (void 0 === e && (e = !0), this._isPlaying = !1, this._batcher.resetTime(), e) for (var t = 0, r = this.entity.node.children; t < r.length; t++) {
                var i = r[t].entity.getComponent(n);
                i && i.isActiveAndEnabled && i.stop(e)
            }
        }, Object.defineProperty(t.prototype, "timeScale", {
            get: function () {
                return this._timeScale
            }, set: function (e) {
                e < 0 && (e = 0), this._timeScale = e;
                for (var t = 0, r = this.entity.node.children; t < r.length; t++) {
                    var i = r[t].entity.getComponent(n);
                    i && (i.timeScale = e)
                }
            }, enumerable: !0, configurable: !0
        }), Object.defineProperty(t.prototype, "isPlaying", {
            get: function () {
                return this._isPlaying
            }, enumerable: !0, configurable: !0
        }), Object.defineProperty(t.prototype, "isPaused", {
            get: function () {
                return this._isPaused
            }, enumerable: !0, configurable: !0
        }), Object.defineProperty(t.prototype, "loop", {
            get: function () {
                return this.main.loop
            }, enumerable: !0, configurable: !0
        }), E([Object(v.property)("nested"), v.serializedField], t.prototype, "main", void 0), E([Object(v.property)("nested"), v.serializedField], t.prototype, "emission", void 0), E([Object(v.property)("nested"), v.serializedField], t.prototype, "shape", void 0), E([Object(v.property)("nested"), v.serializedField], t.prototype, "velocityOverLifetime", void 0), E([Object(v.property)("nested"), v.serializedField], t.prototype, "rotationOverLifetime", void 0), E([Object(v.property)("nested"), v.serializedField], t.prototype, "sizeOverLifetime", void 0), E([Object(v.property)("nested"), v.serializedField], t.prototype, "colorOverLifetime", void 0), E([Object(v.property)("nested"), v.serializedField], t.prototype, "textureSheetAnimation", void 0), E([Object(v.property)("float", {minimum: 0})], t.prototype, "timeScale", null), t = n = E([Object(g.component)({isAbstract: !1})], t)
    }(y.GameComponent);
    __reflect(ne, "@egret/particle/ParticleComponent");
    var re = function (e) {
        function t() {
            var t = null !== e && e.apply(this, arguments) || this;
            return t._added = {}, t._drawCallCollecter = y.Application.instance.globalEntity.getComponent(b.DrawCallCollector), t
        }

        return T(t, e), t.prototype._onUpdateBatchMesh = function (e, t) {
            void 0 === t && (t = !0);
            var n = e.entity.getComponent(w);
            e.initBatcher(t), this._onRenderUpdate(n, 14), this._onRenderUpdate(n, 15), this._onRenderUpdate(n, 16), this._onMainUpdate(e, 3), this._onMainUpdate(e, 8), this._onMainUpdate(e, 9), this._onMainUpdate(e, 10), this._onShapeChanged(e), this._onVelocityOverLifetime(e), this._onColorOverLifetime(e), this._onSizeOverLifetime(e), this._onRotationOverLifetime(e), this._onTextureSheetAnimation(e)
        }, t.prototype._onRenderUpdate = function (e, t) {
            if (this.enabled && this.groups[0].containsEntity(e.entity) && this._added[e.entity.uuid]) {
                var n = e._batchMaterial;
                switch (t) {
                    case 14:
                        this._onRenderMode(e);
                        break;
                    case 16:
                        n.setFloat("u_lengthScale", e.lengthScale);
                        break;
                    case 15:
                        n.setFloat("u_speeaScale", e.velocityScale)
                }
            }
        }, t.prototype._onRenderMode = function (e) {
            var t = e._batchMaterial;
            switch (t.removeDefine("SPHERHBILLBOARD"), t.removeDefine("STRETCHEDBILLBOARD"), t.removeDefine("HORIZONTALBILLBOARD"), t.removeDefine("VERTICALBILLBOARD"), t.removeDefine("RENDERMESH"), e.renderMode) {
                case 0:
                    t.addDefine("SPHERHBILLBOARD");
                    break;
                case 1:
                    t.addDefine("STRETCHEDBILLBOARD");
                    break;
                case 2:
                    t.addDefine("HORIZONTALBILLBOARD");
                    break;
                case 3:
                    t.addDefine("VERTICALBILLBOARD");
                    break;
                case 4:
                    t.addDefine("RENDERMESH");
                    break;
                default:
                    throw"_onRenderMode:invalid renderMode"
            }
        }, t.prototype._onMainUpdate = function (e, t) {
            if (this.enabled && this.groups[0].containsEntity(e.entity) && this._added[e.entity.uuid]) {
                var n = e.entity.getComponent(w)._batchMaterial, r = e.main;
                switch (t) {
                    case 7:
                        n.setBoolean("START_SIZE3D", r.startSize3D);
                        break;
                    case 8:
                        n.setBoolean("u_startRotation3D", r.startRotation3D);
                        break;
                    case 9:
                        n.setInt("u_simulationSpace", r.simulationSpace);
                        break;
                    case 10:
                        n.setInt("u_scalingMode", r.scaleMode)
                }
            }
        }, t.prototype._onShapeChanged = function (e) {
            if (this.enabled && this.groups[0].containsEntity(e.entity) && this._added[e.entity.uuid]) {
                var t = e.entity.getComponent(w)._batchMaterial;
                t.removeDefine("SHAPE"), e.shape.enable && t.addDefine("SHAPE")
            }
        }, t.prototype._onVelocityOverLifetime = function (e) {
            if (this.enabled && this.groups[0].containsEntity(e.entity) && this._added[e.entity.uuid]) {
                var t = e.entity.getComponent(w)._batchMaterial;
                t.removeDefine("VELOCITYCONSTANT"), t.removeDefine("VELOCITYCURVE"), t.removeDefine("VELOCITYTWOCONSTANT"), t.removeDefine("VELOCITYTWOCURVE");
                var n = e.velocityOverLifetime;
                if (n.enable) {
                    switch (n.mode) {
                        case 0:
                            t.addDefine("VELOCITYCONSTANT");
                            var r = y.Vector3.create(n.x.evaluate(), n.y.evaluate(), n.z.evaluate());
                            t.setVector3("u_velocityConst", r);
                            break;
                        case 1:
                            t.addDefine("VELOCITYCURVE"), t.setTypedArray("u_velocityCurveX[0]", n.x.curve.floatValues), t.setTypedArray("u_velocityCurveY[0]", n.y.curve.floatValues), t.setTypedArray("u_velocityCurveZ[0]", n.z.curve.floatValues);
                            break;
                        case 3:
                            t.addDefine("VELOCITYTWOCONSTANT");
                            var i = y.Vector3.create(n.x.constantMin, n.y.constantMin, n.z.constantMin),
                                o = y.Vector3.create(n.x.constantMax, n.y.constantMax, n.z.constantMax);
                            t.setVector3("u_velocityConst", i), t.setVector3("u_velocityConstMax", o);
                            break;
                        case 2:
                            t.addDefine("VELOCITYTWOCURVE"), t.setTypedArray("u_velocityCurveX[0]", n.x.curveMin.floatValues), t.setTypedArray("u_velocityCurveY[0]", n.y.curveMin.floatValues), t.setTypedArray("u_velocityCurveZ[0]", n.z.curveMin.floatValues), t.setTypedArray("u_velocityCurveMaxX[0]", n.x.curveMax.floatValues), t.setTypedArray("u_velocityCurveMaxY[0]", n.y.curveMax.floatValues), t.setTypedArray("u_velocityCurveMaxZ[0]", n.z.curveMax.floatValues)
                    }
                    t.setInt("u_spaceType", n.space)
                }
            }
        }, t.prototype._onColorOverLifetime = function (e) {
            if (this.enabled && this.groups[0].containsEntity(e.entity) && this._added[e.entity.uuid]) {
                var t = e.entity.getComponent(w)._batchMaterial;
                t.removeDefine("COLOROGRADIENT"), t.removeDefine("COLORTWOGRADIENTS");
                var n = e.colorOverLifetime;
                if (n.enable) {
                    var r = n.color;
                    switch (r.mode) {
                        case 1:
                            t.addDefine("COLOROGRADIENT"), t.setTypedArray("u_alphaGradient[0]", r.gradient.alphaValues), t.setTypedArray("u_colorGradient[0]", r.gradient.colorValues);
                            break;
                        case 3:
                            t.addDefine("COLORTWOGRADIENTS"), t.setTypedArray("u_alphaGradient[0]", r.gradientMin.alphaValues), t.setTypedArray("u_alphaGradientMax[0]", r.gradientMax.alphaValues), t.setTypedArray("u_colorGradient[0]", r.gradientMin.colorValues), t.setTypedArray("u_colorGradientMax[0]", r.gradientMax.colorValues)
                    }
                }
            }
        }, t.prototype._onSizeOverLifetime = function (e) {
            if (this.enabled && this.groups[0].containsEntity(e.entity) && this._added[e.entity.uuid]) {
                var t = e.entity.getComponent(w)._batchMaterial;
                t.removeDefine("SIZECURVE"), t.removeDefine("SIZECURVESEPERATE"), t.removeDefine("SIZETWOCURVES"), t.removeDefine("SIZETWOCURVESSEPERATE");
                var n = e.sizeOverLifetime;
                if (n.enable) {
                    var r = n.separateAxes;
                    switch (n.x.mode) {
                        case 1:
                            r ? (t.addDefine("SIZECURVESEPERATE"), t.setTypedArray("u_sizeCurveX[0]", n.x.curve.floatValues), t.setTypedArray("u_sizeCurveY[0]", n.y.curve.floatValues), t.setTypedArray("u_sizeCurveZ[0]", n.z.curve.floatValues)) : (t.addDefine("SIZECURVE"), t.setTypedArray("u_sizeCurve[0]", n.size.curve.floatValues));
                            break;
                        case 2:
                            r ? (t.addDefine("SIZETWOCURVESSEPERATE"), t.setTypedArray("u_sizeCurveX[0]", n.x.curveMin.floatValues), t.setTypedArray("u_sizeCurveY[0]", n.y.curveMin.floatValues), t.setTypedArray("u_sizeCurveZ[0]", n.z.curveMin.floatValues), t.setTypedArray("u_sizeCurveMaxX[0]", n.x.curveMax.floatValues), t.setTypedArray("u_sizeCurveMaxY[0]", n.y.curveMax.floatValues), t.setTypedArray("u_sizeCurveMaxZ[0]", n.z.curveMax.floatValues)) : (t.addDefine("SIZETWOCURVES"), t.setTypedArray("u_sizeCurve[0]", n.size.curveMin.floatValues), t.setTypedArray("u_sizeCurveMax[0]", n.size.curveMax.floatValues))
                    }
                }
            }
        }, t.prototype._onRotationOverLifetime = function (e) {
            if (this.enabled && this.groups[0].containsEntity(e.entity) && this._added[e.entity.uuid]) {
                var t = e.entity.getComponent(w)._batchMaterial;
                t.removeDefine("ROTATIONOVERLIFETIME"), t.removeDefine("ROTATIONCONSTANT"), t.removeDefine("ROTATIONTWOCONSTANTS"), t.removeDefine("ROTATIONSEPERATE"), t.removeDefine("ROTATIONCURVE"), t.removeDefine("ROTATIONTWOCURVES");
                var n = e.rotationOverLifetime;
                if (n.enable) {
                    var r = e.rotationOverLifetime.x.mode, i = n.separateAxes;
                    switch (i ? t.addDefine("ROTATIONSEPERATE") : t.addDefine("ROTATIONOVERLIFETIME"), r) {
                        case 0:
                            t.addDefine("ROTATIONCONSTANT"), i ? t.setVector3("u_rotationConstSeprarate", y.Vector3.create(n.x.constant, n.y.constant, n.z.constant)) : t.setFloat("u_rotationConst", n.z.constant);
                            break;
                        case 3:
                            t.addDefine("ROTATIONTWOCONSTANTS"), i ? (t.setVector3("u_rotationConstSeprarate", y.Vector3.create(n.x.constantMin, n.y.constantMin, n.z.constantMin)), t.setVector3("u_rotationConstMaxSeprarate", y.Vector3.create(n.x.constantMax, n.y.constantMax, n.z.constantMax))) : (t.setFloat("u_rotationConst", n.z.constantMin), t.setFloat("u_rotationConstMax", n.z.constantMax));
                            break;
                        case 1:
                            t.addDefine("ROTATIONCURVE"), i ? (t.setTypedArray("u_rotationCurveX[0]", n.x.curve.floatValues), t.setTypedArray("u_rotationCurveY[0]", n.y.curve.floatValues), t.setTypedArray("u_rotationCurveZ[0]", n.z.curve.floatValues)) : t.setTypedArray("u_rotationCurve[0]", n.z.curve.floatValues);
                            break;
                        case 2:
                            t.addDefine("ROTATIONTWOCURVES"), i ? (t.setTypedArray("u_rotationCurveX[0]", n.x.curveMin.floatValues), t.setTypedArray("u_rotationCurveY[0]", n.y.curveMin.floatValues), t.setTypedArray("u_rotationCurveZ[0]", n.z.curveMin.floatValues), t.setTypedArray("u_rotationCurveMaxX[0]", n.x.curveMax.floatValues), t.setTypedArray("u_rotationCurveMaxY[0]", n.y.curveMax.floatValues), t.setTypedArray("u_rotationCurveMaxZ[0]", n.z.curveMax.floatValues)) : (t.setTypedArray("u_rotationCurve[0]", n.z.curveMin.floatValues), t.setTypedArray("u_rotationCurveMax[0]", n.z.curveMin.floatValues))
                    }
                }
            }
        }, t.prototype._onTextureSheetAnimation = function (e) {
            if (this.enabled && this.groups[0].containsEntity(e.entity) && this._added[e.entity.uuid]) {
                var t = e.entity.getComponent(w)._batchMaterial;
                t.removeDefine("TEXTURESHEETANIMATIONCURVE"), t.removeDefine("TEXTURESHEETANIMATIONTWOCURVE");
                var n = e.textureSheetAnimation;
                if (n.enable) {
                    var r = n.frameOverTime.mode;
                    switch (r) {
                        case 1:
                            t.addDefine("TEXTURESHEETANIMATIONCURVE"), t.setTypedArray("u_uvCurve[0]", n.frameOverTime.curve.floatValues);
                            break;
                        case 2:
                            t.addDefine("TEXTURESHEETANIMATIONTWOCURVE"), t.setTypedArray("u_uvCurve[0]", n.frameOverTime.curveMin.floatValues), t.setTypedArray("u_uvCurveMax[0]", n.frameOverTime.curveMax.floatValues)
                    }
                    1 !== r && 2 !== r || (t.setFloat("u_cycles", n.cycleCount), t.setTypedArray("u_subUV", n.floatValues))
                }
            }
        }, t.prototype._updateDrawCalls = function (e, t) {
            if (void 0 === t && (t = !0), this.enabled && this.groups[0].containsEntity(e) && this._added[e.uuid]) {
                var n = this._drawCallCollecter, r = e.getComponent(ne), i = e.getComponent(w), o = i.renderMode,
                    a = r.main, s = a.enable, l = a.maxParticles, u = a.playOnAwake;
                if (n.destroyDrawCall(e.uuid), null !== i.material && s && 0 !== l && 5 !== o && (4 !== o || null !== i.mesh)) {
                    this._onUpdateBatchMesh(r, t);
                    for (var c = 0, p = 0, d = i._batchMesh.glTFMesh.primitives; p < d.length; p++) {
                        d[p];
                        var h = n.createDrawCall(e.uuid);
                        h.renderer = i, h.matrix = e.transform.localToWorldMatrix, h.subMeshIndex = c++, h.mesh = i._batchMesh, h.material = i._batchMaterial
                    }
                    u && r.play()
                }
            }
        }, t.prototype._onUpdate = function (e) {
            var t = e.getComponent(A);
            if (null !== t) {
                for (var n = e.getComponent(ne), r = e.getComponent(w), i = 0, o = t.changes; i < o.length; i++) {
                    var a = o[i];
                    switch (a) {
                        case 7:
                        case 8:
                        case 9:
                        case 10:
                            this._onMainUpdate(n, a);
                            break;
                        case 2:
                            this._onVelocityOverLifetime(n);
                            break;
                        case 1:
                            this._onColorOverLifetime(n);
                            break;
                        case 3:
                            this._onSizeOverLifetime(n);
                            break;
                        case 4:
                            this._onRotationOverLifetime(n);
                            break;
                        case 5:
                            this._onTextureSheetAnimation(n);
                            break;
                        case 11:
                        case 12:
                        case 13:
                            this._updateDrawCalls(e, !0);
                            break;
                        case 14:
                        case 15:
                        case 16:
                            this._onRenderUpdate(r, a)
                    }
                }
                e.removeComponent(t)
            }
        }, t.prototype.getMatchers = function () {
            return [g.Matcher.create(y.GameEntity, !0, w, ne), g.Matcher.create(y.GameEntity, !0, w, ne, A)]
        }, t.prototype.onEntityAdded = function (e, t) {
            var n = this.groups;
            if (t === n[0]) {
                this._added[e.uuid] = !0, this._updateDrawCalls(e, !1);
                var r = e.getComponent(A);
                null !== r && e.removeComponent(r)
            } else t === n[1] && this._onUpdate(e)
        }, t.prototype.onEntityRemoved = function (e, t) {
            t === this.groups[0] && (delete this._added[e.uuid], this._drawCallCollecter.destroyDrawCall(e.uuid))
        }, t.prototype.onFrame = function (e) {
            var t = this.groups[0].entities;
            if (t.length > 0) for (var n = Math.min(e, .33), r = 0, i = t; r < i.length; r++) {
                i[r].getComponent(ne).update(n)
            }
        }, t = E([Object(g.system)({noneOfExecuteMode: 32})], t)
    }(g.System);

    function ie() {
        return e = this, t = void 0, r = function () {
            return C(this, (function (e) {
                return y.SystemManager.preRegisterSystem(re, 7e3), console.debug("Egret particle registered."), [2]
            }))
        }, new ((n = void 0) || (n = Promise))((function (i, o) {
            function a(e) {
                try {
                    l(r.next(e))
                } catch (e) {
                    o(e)
                }
            }

            function s(e) {
                try {
                    l(r.throw(e))
                } catch (e) {
                    o(e)
                }
            }

            function l(e) {
                e.done ? i(e.value) : new n((function (t) {
                    t(e.value)
                })).then(a, s)
            }

            l((r = r.apply(e, t || [])).next())
        }));
        var e, t, n, r
    }

    __reflect(re, "@egret/particle/ParticleSystem")
}, function (e, t, n) {
    "use strict";
    n.r(t), n.d(t, "AbortType", (function () {
        return h
    })), n.d(t, "BehaviourSuffix", (function () {
        return m
    })), n.d(t, "BehaviourTree", (function () {
        return y
    })), n.d(t, "BehaviourTreeBuilder", (function () {
        return H
    })), n.d(t, "BehaviourTreeSystem", (function () {
        return A
    })), n.d(t, "ChangedType", (function () {
        return f
    })), n.d(t, "ComponentType", (function () {
        return p
    })), n.d(t, "Composite", (function () {
        return C
    })), n.d(t, "Conditional", (function () {
        return x
    })), n.d(t, "Decorator", (function () {
        return S
    })), n.d(t, "EntryTask", (function () {
        return M
    })), n.d(t, "Inverter", (function () {
        return U
    })), n.d(t, "LogAction", (function () {
        return O
    })), n.d(t, "Parallel", (function () {
        return L
    })), n.d(t, "ParentTask", (function () {
        return T
    })), n.d(t, "RandomParallel", (function () {
        return N
    })), n.d(t, "RandomProbability", (function () {
        return z
    })), n.d(t, "RandomSelector", (function () {
        return D
    })), n.d(t, "RandomSequence", (function () {
        return I
    })), n.d(t, "Repeater", (function () {
        return F
    })), n.d(t, "ReturnFailure", (function () {
        return k
    })), n.d(t, "ReturnSuccess", (function () {
        return V
    })), n.d(t, "Selector", (function () {
        return R
    })), n.d(t, "Sequence", (function () {
        return P
    })), n.d(t, "Task", (function () {
        return b
    })), n.d(t, "TaskStatus", (function () {
        return d
    })), n.d(t, "TreeNodeInfo", (function () {
        return j
    })), n.d(t, "UtillFailure", (function () {
        return B
    })), n.d(t, "UtillSuccess", (function () {
        return G
    })), n.d(t, "WaitAction", (function () {
        return w
    })), n.d(t, "_BehaviorSourceChanged", (function () {
        return _
    })), n.d(t, "_PausingStateChanged", (function () {
        return v
    })), n.d(t, "_PlayingStateChanged", (function () {
        return g
    })), n.d(t, "_ResourceType", (function () {
        return c
    })), n.d(t, "startup", (function () {
        return W
    }));
    var r = n(2), i = n(0), o = n(1), a = function (e, t) {
        return (a = Object.setPrototypeOf || {__proto__: []} instanceof Array && function (e, t) {
            e.__proto__ = t
        } || function (e, t) {
            for (var n in t) t.hasOwnProperty(n) && (e[n] = t[n])
        })(e, t)
    };

    function s(e, t) {
        function n() {
            this.constructor = e
        }

        a(e, t), e.prototype = null === t ? Object.create(t) : (n.prototype = t.prototype, new n)
    }

    function l(e, t, n, r) {
        var i, o = arguments.length, a = o < 3 ? t : null === r ? r = Object.getOwnPropertyDescriptor(t, n) : r;
        if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) a = Reflect.decorate(e, t, n, r); else for (var s = e.length - 1; s >= 0; s--) (i = e[s]) && (a = (o < 3 ? i(a) : o > 3 ? i(t, n, a) : i(t, n)) || a);
        return o > 3 && a && Object.defineProperty(t, n, a), a
    }

    function u(e, t) {
        var n, r, i, o, a = {
            label: 0, sent: function () {
                if (1 & i[0]) throw i[1];
                return i[1]
            }, trys: [], ops: []
        };
        return o = {
            next: s(0),
            throw: s(1),
            return: s(2)
        }, "function" == typeof Symbol && (o[Symbol.iterator] = function () {
            return this
        }), o;

        function s(o) {
            return function (s) {
                return function (o) {
                    if (n) throw new TypeError("Generator is already executing.");
                    for (; a;) try {
                        if (n = 1, r && (i = 2 & o[0] ? r.return : o[0] ? r.throw || ((i = r.return) && i.call(r), 0) : r.next) && !(i = i.call(r, o[1])).done) return i;
                        switch (r = 0, i && (o = [2 & o[0], i.value]), o[0]) {
                            case 0:
                            case 1:
                                i = o;
                                break;
                            case 4:
                                return a.label++, {value: o[1], done: !1};
                            case 5:
                                a.label++, r = o[1], o = [0];
                                continue;
                            case 7:
                                o = a.ops.pop(), a.trys.pop();
                                continue;
                            default:
                                if (!(i = a.trys, (i = i.length > 0 && i[i.length - 1]) || 6 !== o[0] && 2 !== o[0])) {
                                    a = 0;
                                    continue
                                }
                                if (3 === o[0] && (!i || o[1] > i[0] && o[1] < i[3])) {
                                    a.label = o[1];
                                    break
                                }
                                if (6 === o[0] && a.label < i[1]) {
                                    a.label = i[1], i = o;
                                    break
                                }
                                if (i && a.label < i[2]) {
                                    a.label = i[2], a.ops.push(o);
                                    break
                                }
                                i[2] && a.ops.pop(), a.trys.pop();
                                continue
                        }
                        o = t.call(e, a)
                    } catch (e) {
                        o = [6, e], r = 0
                    } finally {
                        n = i = 0
                    }
                    if (5 & o[0]) throw o[1];
                    return {value: o[0] ? o[1] : void 0, done: !0}
                }([o, s])
            }
        }
    }

    var c, p, d, h, f, m = "behaviourtree";
    !function (e) {
        e.BehaviourTree = "BehaviourTree"
    }(c || (c = {})), function (e) {
        e.Task = "task"
    }(p || (p = {})), function (e) {
        e[e.Inactive = 0] = "Inactive", e[e.Failure = 1] = "Failure", e[e.Success = 2] = "Success", e[e.Running = 3] = "Running"
    }(d || (d = {})), function (e) {
        e[e.None = 0] = "None", e[e.LowerPriority = 1] = "LowerPriority", e[e.Self = 2] = "Self", e[e.Both = 3] = "Both"
    }(h || (h = {})), function (e) {
        e[e.BehaviorSourceChanged = 0] = "BehaviorSourceChanged", e[e.PlayingStateChanged = 1] = "PlayingStateChanged", e[e.PausingStateChanged = 2] = "PausingStateChanged"
    }(f || (f = {}));
    var _ = function (e) {
        function t() {
            return null !== e && e.apply(this, arguments) || this
        }

        return s(t, e), t = l([Object(i.hideFlag)(28), Object(r.component)({isAbstract: !1})], t)
    }(r.Component);
    __reflect(_, "@egret/behaviour-tree/_BehaviorSourceChanged");
    var g = function (e) {
        function t() {
            return null !== e && e.apply(this, arguments) || this
        }

        return s(t, e), t = l([Object(i.hideFlag)(28), Object(r.component)({isAbstract: !1})], t)
    }(r.Component);
    __reflect(g, "@egret/behaviour-tree/_PlayingStateChanged");
    var v = function (e) {
        function t() {
            return null !== e && e.apply(this, arguments) || this
        }

        return s(t, e), t = l([Object(i.hideFlag)(28), Object(r.component)({isAbstract: !1})], t)
    }(r.Component);
    __reflect(v, "@egret/behaviour-tree/_PausingStateChanged");
    var y = function (e) {
        function t() {
            var t = null !== e && e.apply(this, arguments) || this;
            return t.tickInterval = .2, t.timeScale = 1, t.autoPlay = !0, t._time = 0, t._entryTask = null, t._sourceData = null, t._isPlaying = !1, t._isPausing = !1, t
        }

        return s(t, e), t.prototype._destroy = function () {
            e.prototype._destroy.call(this), null !== this._entryTask && this._entryTask.entity.destroy(), this._sourceData = null
        }, t.prototype.uninitialize = function () {
            e.prototype.uninitialize.call(this), this.tickInterval = .2, this.timeScale = 1, this._time = 0, this._isPlaying = !1, this._isPausing = !1, this._entryTask = null
        }, t.prototype.play = function () {
            if (this._isPausing) this._isPausing = !1, this.entity.addComponent(v); else {
                if (this._isPlaying) return;
                this._isPlaying = !0, this.entity.addComponent(g)
            }
        }, t.prototype.pause = function () {
            this._isPausing || (this._isPausing = !0, this.entity.addComponent(v))
        }, t.prototype.stop = function () {
            this._isPlaying && (this._isPlaying = !1, this._isPausing = !1, this.entity.addComponent(g))
        }, Object.defineProperty(t.prototype, "behaviour", {
            get: function () {
                return this._sourceData
            }, set: function (e) {
                this._sourceData !== e && (this._sourceData = e, this.entity.addComponent(_))
            }, enumerable: !0, configurable: !0
        }), Object.defineProperty(t.prototype, "isPlaying", {
            get: function () {
                return this._isPlaying
            }, enumerable: !0, configurable: !0
        }), Object.defineProperty(t.prototype, "isPausing", {
            get: function () {
                return this._isPausing
            }, enumerable: !0, configurable: !0
        }), l([Object(i.property)("float"), i.serializedField], t.prototype, "tickInterval", void 0), l([Object(i.property)("float"), i.serializedField], t.prototype, "timeScale", void 0), l([Object(i.property)("boolean"), i.serializedField], t.prototype, "autoPlay", void 0), l([i.serializedField, Object(i.property)("asset", {assetType: "BehaviourTree"})], t.prototype, "behaviour", null), t = l([Object(r.component)({isAbstract: !1})], t)
    }(r.Component);
    __reflect(y, "@egret/behaviour-tree/BehaviourTree");
    var b = function (e) {
        function t() {
            var t = null !== e && e.apply(this, arguments) || this;
            return t.status = 0, t.parent = null, t._owner = null, t
        }

        return s(t, e), t.prototype.initialize = function (t, n, r) {
            e.prototype.initialize.call(this, t, n, r), this.onAwake()
        }, t.prototype.uninitialize = function () {
            e.prototype.uninitialize.call(this);
            this.status = 0, this.parent = null, this._owner = null
        }, t.prototype.tick = function () {
            return 0 === this.status && this.onStart(), this.onUpdate && (this.status = this.onUpdate()), 3 !== this.status && this.onEnd(), this.status
        }, t.prototype.onReset = function () {
            this.status = 0
        }, t.prototype.onAwake = function () {
            this.status = 0
        }, t.prototype.onStart = function () {
        }, t.prototype.onUpdate = function () {
            return 1
        }, t.prototype.onPause = function (e) {
        }, t.prototype.onEnd = function () {
        }, Object.defineProperty(t.prototype, "owner", {
            get: function () {
                return this._owner
            }, enumerable: !0, configurable: !0
        }), t = l([Object(i.hideFlag)(16), Object(r.component)({type: "task", isAbstract: !0})], t)
    }(r.Component);
    __reflect(b, "@egret/behaviour-tree/Task");
    var x = function (e) {
        function t() {
            return null !== e && e.apply(this, arguments) || this
        }

        return s(t, e), t = l([Object(r.component)({isAbstract: !0})], t)
    }(b);
    __reflect(x, "@egret/behaviour-tree/Conditional");
    var T = function (e) {
        function t() {
            var t = null !== e && e.apply(this, arguments) || this;
            return t._children = [], t._currentChildIndex = 0, t.executeChildren = [], t
        }

        var n;
        return s(t, e), n = t, t.prototype._collectExecuteChildren = function () {
            for (var e = this.children, t = this.executeChildren, r = 0, i = 0, o = e; i < o.length; i++) {
                var a = o[i];
                (a.isActiveAndEnabled || a instanceof n && a.executeChildren.length > 0) && (t[r++] = a)
            }
            t.length !== r && (t.length = r)
        }, t.prototype._destroy = function () {
            var t = this.parent;
            null !== t && t instanceof n && t.removeChild(this), this.removeChildren(), e.prototype._destroy.call(this)
        }, t.prototype.uninitialize = function () {
            e.prototype.uninitialize.call(this), this._currentChildIndex = 0, this._children.length = 0, this.executeChildren.length = 0
        }, t.prototype.onReset = function () {
            for (var t = this.children, n = 0, r = t.length; n < r; n++) {
                t[n].onReset()
            }
            this._currentChildIndex = 0, this.executeChildren.length = 0, e.prototype.onReset.call(this)
        }, t.prototype.onStart = function () {
            e.prototype.onStart.call(this), this._currentChildIndex = 0, 0 === this.executeChildren.length && this._collectExecuteChildren()
        }, t.prototype.addChild = function (e) {
            var t = this._children;
            e.parent = this, t.indexOf(e) < 0 && (t[t.length] = e)
        }, t.prototype.removeChild = function (e, t) {
            void 0 === t && (t = !0);
            var n = this._children, r = n.indexOf(e);
            return e.parent = null, r >= 0 ? (n.splice(r, 1), !0) : (t && e.entity.destroy(), !1)
        }, t.prototype.removeChildren = function (e) {
            void 0 === e && (e = !0);
            for (var t = this._children, n = t.length; n > 0; n--) {
                var r = t[n - 1];
                r && this.removeChild(r, e)
            }
        }, t.prototype.getChildIndex = function (e) {
            return this._children.indexOf(e)
        }, t.prototype.setChildIndex = function (e, t) {
            var n = this._children;
            if (0 <= t && t < n.length) {
                var r = n.indexOf(e);
                if (r !== t) return n.splice(r, 1), n.splice(t, 0, e), !0
            }
            return !1
        }, t.prototype.getChildAt = function (e) {
            var t = this._children;
            return 0 <= e && e < t.length ? t[e] : null
        }, Object.defineProperty(t.prototype, "children", {
            get: function () {
                return this._children
            }, set: function (e) {
                this.removeChildren();
                for (var t = 0, n = e; t < n.length; t++) {
                    var r = n[t];
                    this.addChild(r)
                }
            }, enumerable: !0, configurable: !0
        }), l([i.serializeAsObject], t.prototype, "children", null), t = n = l([Object(r.component)({isAbstract: !0})], t)
    }(b);
    __reflect(T, "@egret/behaviour-tree/ParentTask");
    var E = function (e) {
        function t() {
            return null !== e && e.apply(this, arguments) || this
        }

        return s(t, e), t.shuffleArray = function (e) {
            for (var t = e.length; t > 0; t--) {
                var n = Math.random() * t, r = e[n];
                e[n] = e[t], e[t] = r
            }
        }, t.is = function (e, t) {
            if (!e || "object" != typeof e) return !1;
            var n = Object.getPrototypeOf(e), r = n ? n.__types__ : null;
            return !!r && -1 !== r.indexOf(t)
        }, t
    }(DebuggerClass);
    __reflect(E, "@egret/behaviour-tree/BehaviourTreeUtil");
    var C = function (e) {
        function t() {
            var t = null !== e && e.apply(this, arguments) || this;
            return t.abortType = 0, t._hasAnyLowerPriorityAbort = !1, t
        }

        var n;
        return s(t, e), n = t, t.prototype._calLowerPriorityAbort = function () {
            var e = this.executeChildren;
            if (e.length > 0 && e[0] instanceof x) for (var t = 0, r = e.length; t < r; t++) {
                var i = e[t];
                if (i instanceof n && 0 != (1 & i.abortType) && i.executeChildren.length > 0 && i.executeChildren[0] instanceof x) return !0
            }
            return !1
        }, t.prototype._updateSelfAbortConditional = function (e) {
            for (var t = 0; t < this._currentChildIndex; t++) {
                var n = this.executeChildren[t];
                if (E.is(n, "IConditional")) if (n.onUpdate() !== e) {
                    this._currentChildIndex = t;
                    for (var r = t; r < this.executeChildren.length; r++) this.executeChildren[r].onReset();
                    break
                }
            }
        }, t.prototype._updateLowerPriorityAbortConditional = function (e) {
            for (var t = 0; t < this._currentChildIndex; t++) {
                var r = this.executeChildren[t];
                if (r instanceof n && 0 != (1 & r.abortType)) if (r.executeChildren[0].onUpdate() !== e) {
                    this._currentChildIndex = t;
                    for (var i = t; i < this.executeChildren.length; i++) this.executeChildren[i].onReset();
                    break
                }
            }
        }, t.prototype.onReset = function () {
            e.prototype.onReset.call(this), this.abortType = 0, this._hasAnyLowerPriorityAbort = !1
        }, t.prototype.onStart = function () {
            e.prototype.onStart.call(this), this._hasAnyLowerPriorityAbort = this._calLowerPriorityAbort()
        }, t.prototype.onEnd = function () {
            for (var e = this.executeChildren, t = 0, n = e.length; t < n; t++) {
                e[t].onReset()
            }
        }, l([Object(i.property)("enum", {listItems: Object(i.getItemsFromEnum)(h)}), i.serializedField], t.prototype, "abortType", void 0), t = n = l([Object(r.component)({isAbstract: !0})], t)
    }(T);
    __reflect(C, "@egret/behaviour-tree/Composite");
    var S = function (e) {
        function t() {
            var t = null !== e && e.apply(this, arguments) || this;
            return t.firstChild = null, t
        }

        return s(t, e), t.prototype.onStart = function () {
            e.prototype.onStart.call(this), 1 !== this.children.length && console.warn("Decorator children count must be 1"), this.firstChild = this.executeChildren[0]
        }, t = l([Object(r.component)({isAbstract: !0})], t)
    }(T);
    __reflect(S, "@egret/behaviour-tree/Decorator");
    var M = function (e) {
        function t() {
            return null !== e && e.apply(this, arguments) || this
        }

        return s(t, e), t = l([Object(r.component)({isAbstract: !1})], t)
    }(T);
    __reflect(M, "@egret/behaviour-tree/EntryTask");
    var A = function (e) {
        function t() {
            return null !== e && e.apply(this, arguments) || this
        }

        return s(t, e), t.prototype._updateTaskOwner = function (e, t) {
            if (e._owner = t, e instanceof T) for (var n = 0, r = e.children; n < r.length; n++) {
                var i = r[n];
                this._updateTaskOwner(i, t)
            }
        }, t.prototype._updateBehaviourPausingState = function (e, t) {
            if (e instanceof T) {
                e.onPause(t);
                for (var n = 0, r = e.children; n < r.length; n++) {
                    var i = r[n];
                    this._updateBehaviourPausingState(i, t)
                }
            } else e.onPause(t)
        }, t.prototype._updateBehaviorTree = function (e) {
            var t = e.getComponent(y), n = t._entryTask, r = t._sourceData;
            if (null !== n && n.entity.destroy(), null !== r) {
                var i = o.EntityModelAssetEntity.createInstance(r.entity.uri);
                null !== i ? (t._entryTask = i.getComponent(M), this._updateTaskOwner(t._entryTask, e), t.autoPlay && t.play()) : console.warn("invalid behaviorName:" + r.entity.uri)
            }
        }, t.prototype._onBehaviorTreeChanged = function (e) {
            var t = e.getComponent(y), n = t._entryTask, r = t.isPausing, i = e.getComponent(_);
            null !== i && (this._updateBehaviorTree(e), e.removeComponent(i));
            var o = e.getComponent(g);
            null !== o && (!t.isPlaying && n && n.onReset(), e.removeComponent(o));
            var a = e.getComponent(v);
            null !== a && (n && this._updateBehaviourPausingState(n, r), e.removeComponent(a))
        }, t.prototype._update = function (e, t) {
            var n = e.getComponent(y), r = n._entryTask, i = n.isPlaying;
            if (!n.isPausing && i && null !== r && 0 !== r.children.length) {
                var o = n.tickInterval;
                t *= n.timeScale, n._time += t;
                var a = r.children[0];
                if (o > 0) for (; n._time > o;) a.isActiveAndEnabled && a.tick(), n._time -= o; else a.isActiveAndEnabled && a.tick()
            }
        }, t.prototype.getMatchers = function () {
            var e;
            return [r.Matcher.create(o.GameEntity, !0, y), (e = r.Matcher.create(o.GameEntity, !0, y)).anyOf.apply(e, [_, g, v])]
        }, t.prototype.onEntityAdded = function (e, t) {
            var n = this.groups;
            t === n[0] || t === n[1] && this._onBehaviorTreeChanged(e)
        }, t.prototype.onEntityRemoved = function (e, t) {
        }, t.prototype.onFrame = function (e) {
            for (var t = 0, n = this.groups[0].entities; t < n.length; t++) {
                var r = n[t];
                this._update(r, e)
            }
        }, t = l([Object(r.system)({anyOfExecuteMode: 1})], t)
    }(r.System);
    __reflect(A, "@egret/behaviour-tree/BehaviourTreeSystem");
    var O = function (e) {
        function t() {
            var t = null !== e && e.apply(this, arguments) || this;
            return t.text = "", t
        }

        return s(t, e), t.prototype.onUpdate = function () {
            return console.log(this.text), 2
        }, l([Object(i.property)("string"), i.serializedField], t.prototype, "text", void 0), t = l([Object(r.component)({isAbstract: !1})], t)
    }(b);
    __reflect(O, "@egret/behaviour-tree/LogAction");
    var w = function (e) {
        function t() {
            var t = null !== e && e.apply(this, arguments) || this;
            return t.waitTime = 1, t._clock = null, t._endTime = 0, t._pauseTime = 0, t
        }

        return s(t, e), t.prototype.onAwake = function () {
            e.prototype.onAwake && e.prototype.onAwake.call(this), this._clock = o.Application.instance.clock
        }, t.prototype.onStart = function () {
            e.prototype.onStart && e.prototype.onStart.call(this), this._endTime = this._clock.frameTime + this.waitTime
        }, t.prototype.onPause = function (t) {
            e.prototype.onPause && e.prototype.onPause.call(this, t);
            var n = this._clock.frameTime;
            t ? this._pauseTime = n : this._endTime += n - this._pauseTime
        }, t.prototype.onUpdate = function () {
            return this._endTime > this._clock.frameTime ? 3 : 2
        }, l([Object(i.property)("float"), i.serializedField], t.prototype, "waitTime", void 0), t = l([Object(r.component)({isAbstract: !1})], t)
    }(b);
    __reflect(w, "@egret/behaviour-tree/WaitAction");
    var R = function (e) {
        function t() {
            return null !== e && e.apply(this, arguments) || this
        }

        return s(t, e), t.prototype._handleConditionalAborts = function () {
            this._hasAnyLowerPriorityAbort && this._updateLowerPriorityAbortConditional(1), 0 != (2 & this.abortType) && this._updateSelfAbortConditional(1)
        }, t.prototype.onUpdate = function () {
            0 !== this._currentChildIndex && this._handleConditionalAborts();
            var e = this.executeChildren, t = e[this._currentChildIndex].tick();
            return 1 !== t ? t : (this._currentChildIndex++, this._currentChildIndex >= e.length ? (this._currentChildIndex = 0, 1) : 3)
        }, t = l([Object(r.component)({isAbstract: !1})], t)
    }(C);
    __reflect(R, "@egret/behaviour-tree/Selector");
    var P = function (e) {
        function t() {
            return null !== e && e.apply(this, arguments) || this
        }

        return s(t, e), t.prototype._handleConditionalAborts = function () {
            this._hasAnyLowerPriorityAbort && this._updateLowerPriorityAbortConditional(2), 0 != (2 & this.abortType) && this._updateSelfAbortConditional(2)
        }, t.prototype.removeChildren = function () {
            e.prototype.removeChildren.call(this)
        }, t.prototype.onUpdate = function () {
            0 !== this._currentChildIndex && this._handleConditionalAborts();
            var e = this.executeChildren, t = e[this._currentChildIndex].tick();
            return 2 !== t ? t : (this._currentChildIndex++, this._currentChildIndex >= e.length ? (this._currentChildIndex = 0, 2) : 3)
        }, t = l([Object(r.component)({isAbstract: !1})], t)
    }(C);
    __reflect(P, "@egret/behaviour-tree/Sequence");
    var L = function (e) {
        function t() {
            return null !== e && e.apply(this, arguments) || this
        }

        return s(t, e), t.prototype.onUpdate = function () {
            for (var e = !0, t = 0, n = this.executeChildren; t < n.length; t++) {
                var r = n[t].tick();
                if (1 === r) return 1;
                3 === r && (e = !1)
            }
            return e ? 2 : 3
        }, t = l([Object(r.component)({isAbstract: !1})], t)
    }(C);
    __reflect(L, "@egret/behaviour-tree/Parallel");
    var D = function (e) {
        function t() {
            return null !== e && e.apply(this, arguments) || this
        }

        return s(t, e), t.prototype.onStart = function () {
            e.prototype.onStart.call(this), E.shuffleArray(this.executeChildren)
        }, t = l([Object(r.component)({isAbstract: !1})], t)
    }(C);
    __reflect(D, "@egret/behaviour-tree/RandomSelector");
    var I = function (e) {
        function t() {
            return null !== e && e.apply(this, arguments) || this
        }

        return s(t, e), t.prototype.onStart = function () {
            e.prototype.onStart.call(this), E.shuffleArray(this.executeChildren)
        }, t = l([Object(r.component)({isAbstract: !1})], t)
    }(C);
    __reflect(I, "@egret/behaviour-tree/RandomSequence");
    var N = function (e) {
        function t() {
            return null !== e && e.apply(this, arguments) || this
        }

        return s(t, e), t.prototype.onStart = function () {
            e.prototype.onStart.call(this), E.shuffleArray(this.executeChildren)
        }, t = l([Object(r.component)({isAbstract: !1})], t)
    }(C);
    __reflect(N, "@egret/behaviour-tree/RandomParallel");
    var z = function (e) {
        function t() {
            var t = null !== e && e.apply(this, arguments) || this;
            return t.successProbability = .5, t
        }

        return s(t, e), t.prototype.onUpdate = function () {
            return Math.random() < this.successProbability ? 2 : 1
        }, l([Object(i.property)("float", {
            minimum: 0,
            maximum: 1
        }), i.serializedField], t.prototype, "successProbability", void 0), t = l([Object(r.component)({isAbstract: !1})], t)
    }(x);
    __reflect(z, "@egret/behaviour-tree/RandomProbability");
    var U = function (e) {
        function t() {
            return null !== e && e.apply(this, arguments) || this
        }

        return s(t, e), t.prototype.onUpdate = function () {
            var e = this.firstChild.tick();
            return 3 !== e ? 2 === e ? 1 : 2 : e
        }, t = l([Object(r.component)({isAbstract: !1})], t)
    }(S);
    __reflect(U, "@egret/behaviour-tree/Inverter");
    var F = function (e) {
        function t() {
            var t = null !== e && e.apply(this, arguments) || this;
            return t.count = 0, t.repeatForever = !1, t.endOnFailure = !1, t._executionCount = 0, t
        }

        return s(t, e), t.prototype.onStart = function () {
            e.prototype.onStart.call(this), this._executionCount = 0
        }, t.prototype.onUpdate = function () {
            if (!this.repeatForever && this._executionCount === this.count) return 2;
            var e = this.firstChild.tick();
            return this._executionCount++, this.endOnFailure && 1 === e ? 2 : this.repeatForever || this._executionCount !== this.count ? 3 : 2
        }, l([i.serializedField], t.prototype, "count", void 0), l([i.serializedField], t.prototype, "repeatForever", void 0), l([i.serializedField], t.prototype, "endOnFailure", void 0), t = l([Object(r.component)({isAbstract: !1})], t)
    }(S);
    __reflect(F, "@egret/behaviour-tree/Repeater");
    var k = function (e) {
        function t() {
            return null !== e && e.apply(this, arguments) || this
        }

        return s(t, e), t.prototype.onUpdate = function () {
            var e = this.firstChild.tick();
            return 2 === e ? 1 : e
        }, t = l([Object(r.component)({isAbstract: !1})], t)
    }(S);
    __reflect(k, "@egret/behaviour-tree/ReturnFailure");
    var V = function (e) {
        function t() {
            return null !== e && e.apply(this, arguments) || this
        }

        return s(t, e), t.prototype.onUpdate = function () {
            var e = this.firstChild.tick();
            return 1 === e ? 2 : e
        }, t = l([Object(r.component)({isAbstract: !1})], t)
    }(S);
    __reflect(V, "@egret/behaviour-tree/ReturnSuccess");
    var B = function (e) {
        function t() {
            return null !== e && e.apply(this, arguments) || this
        }

        return s(t, e), t.prototype.onUpdate = function () {
            return 1 !== this.firstChild.tick() ? 3 : 2
        }, t = l([Object(r.component)({isAbstract: !1})], t)
    }(S);
    __reflect(B, "@egret/behaviour-tree/UtillFailure");
    var G = function (e) {
        function t() {
            return null !== e && e.apply(this, arguments) || this
        }

        return s(t, e), t.prototype.onUpdate = function () {
            return 2 !== this.firstChild.tick() ? 3 : 2
        }, t = l([Object(r.component)({isAbstract: !1})], t)
    }(S);
    __reflect(G, "@egret/behaviour-tree/UtillSuccess");
    var j = function (e) {
        function t() {
            var t = null !== e && e.apply(this, arguments) || this;
            return t.posX = 250, t.posY = 100, t.canLink = !1, t.isInTree = !1, t.task = null, t.nodeLength = 70, t.nodeWidth = 50, t.slotLength = 30, t.slotWidth = 10, t.name = "", t.canDrag = !1, t.isInit = !1, t.PosXCompensation = 0, t.PosYCompensation = 0, t.canSeeChildren = !0, t
        }

        return s(t, e), l([i.serializedField], t.prototype, "posX", void 0), l([i.serializedField], t.prototype, "posY", void 0), t = l([Object(i.hideFlag)(24), Object(r.component)({isAbstract: !1})], t)
    }(r.Component);
    __reflect(j, "@egret/behaviour-tree/TreeNodeInfo");
    var H = function (e) {
        function t() {
            return null !== e && e.apply(this, arguments) || this
        }

        return s(t, e), t.createEntryTask = function () {
            var e = o.Application.instance.assetContext.createEntity(), t = e.addComponent(M);
            return e.addComponent(j), t
        }, t.createTask = function (e) {
            var t = o.Application.instance.entityContext.createEntity(), n = t.addComponent(e);
            return t.addComponent(j), n
        }, t
    }(DebuggerClass);

    function W() {
        return e = this, t = void 0, r = function () {
            return u(this, (function (e) {
                return i.ResourceManager.instance.setProcessor("BehaviourTree", new o.EntityModelLoader, "json", m), o.SystemManager.preRegisterSystem(A, 7e3), console.debug("Egret behaviourTree registered."), [2]
            }))
        }, new ((n = void 0) || (n = Promise))((function (i, o) {
            function a(e) {
                try {
                    l(r.next(e))
                } catch (e) {
                    o(e)
                }
            }

            function s(e) {
                try {
                    l(r.throw(e))
                } catch (e) {
                    o(e)
                }
            }

            function l(e) {
                e.done ? i(e.value) : new n((function (t) {
                    t(e.value)
                })).then(a, s)
            }

            l((r = r.apply(e, t || [])).next())
        }));
        var e, t, n, r
    }

    __reflect(H, "@egret/behaviour-tree/BehaviourTreeBuilder")
}, function (e, t, n) {
    "use strict";
    n.r(t), function (e, r) {
        n.d(t, "Back", (function () {
            return F
        })), n.d(t, "Bounce", (function () {
            return V
        })), n.d(t, "Elastic", (function () {
            return k
        })), n.d(t, "Power4", (function () {
            return d
        })), n.d(t, "Sine", (function () {
            return X
        })), n.d(t, "Tween", (function () {
            return K
        })), n.d(t, "TweenLite", (function () {
            return a
        })), n.d(t, "TweenMax", (function () {
            return q
        }));
        var i = n(1), o = "undefined" != typeof window ? window : e.exports && void 0 !== r ? r : window || {},
            a = function (e) {
                var t = {}, n = e.document, r = e.GreenSockGlobals = e.GreenSockGlobals || e;
                if (r.TweenLite) return r.TweenLite;
                var i, o, a, s, l, u, c, p = function (e) {
                    var t, n = e.split("."), i = r;
                    for (t = 0; t < n.length; t++) i[n[t]] = i = i[n[t]] || {};
                    return i
                }, d = p("com.greensock"), h = function (e) {
                    var t, n = [], r = e.length;
                    for (t = 0; t !== r; n.push(e[t++])) ;
                    return n
                }, f = function () {
                }, m = (u = Object.prototype.toString, c = u.call([]), function (e) {
                    return null != e && (e instanceof Array || "object" == typeof e && !!e.push && u.call(e) === c)
                }), _ = {}, g = function (e, n, i, o) {
                    this.sc = _[e] ? _[e].sc : [], _[e] = this, this.gsClass = null, this.func = i;
                    var a = [];
                    this.check = function (s) {
                        for (var l, u, c, d, h = n.length, f = h; --h > -1;) (l = _[n[h]] || new g(n[h], [])).gsClass ? (a[h] = l.gsClass, f--) : s && l.sc.push(this);
                        if (0 === f && i) for (c = (u = ("com.greensock." + e).split(".")).pop(), d = p(u.join("."))[c] = this.gsClass = i.apply(i, a), o && (r[c] = t[c] = d), h = 0; h < this.sc.length; h++) this.sc[h].check()
                    }, this.check(!0)
                }, v = e._gsDefine = function (e, t, n, r) {
                    return new g(e, t, n, r)
                }, y = d._class = function (e, t, n) {
                    return t = t || function () {
                    }, v(e, [], (function () {
                        return t
                    }), n), t
                };
                v.globals = r;
                var b = [0, 0, 1, 1], x = y("easing.Ease", (function (e, t, n, r) {
                    this._func = e, this._type = n || 0, this._power = r || 0, this._params = t ? b.concat(t) : b
                }), !0), T = x.map = {}, E = x.register = function (e, t, n, r) {
                    for (var i, o, a, s, l = t.split(","), u = l.length, c = (n || "easeIn,easeOut,easeInOut").split(","); --u > -1;) for (o = l[u], i = r ? y("easing." + o, null, !0) : d.easing[o] || {}, a = c.length; --a > -1;) s = c[a], T[o + "." + s] = T[s + o] = i[s] = e.getRatio ? e : e[s] || new e
                };
                for ((a = x.prototype)._calcEnd = !1, a.getRatio = function (e) {
                    if (this._func) return this._params[0] = e, this._func.apply(null, this._params);
                    var t = this._type, n = this._power,
                        r = 1 === t ? 1 - e : 2 === t ? e : e < .5 ? 2 * e : 2 * (1 - e);
                    return 1 === n ? r *= r : 2 === n ? r *= r * r : 3 === n ? r *= r * r * r : 4 === n && (r *= r * r * r * r), 1 === t ? 1 - r : 2 === t ? r : e < .5 ? r / 2 : 1 - r / 2
                }, o = (i = ["Linear", "Quad", "Cubic", "Quart", "Quint,Strong"]).length; --o > -1;) a = i[o] + ",Power" + o, E(new x(null, null, 1, o), a, "easeOut", !0), E(new x(null, null, 2, o), a, "easeIn" + (0 === o ? ",easeNone" : "")), E(new x(null, null, 3, o), a, "easeInOut");
                T.linear = d.easing.Linear.easeIn, T.swing = d.easing.Quad.easeInOut;
                var C = y("events.EventDispatcher", (function (e) {
                    this._listeners = {}, this._eventTarget = e || this
                }));
                (a = C.prototype).addEventListener = function (e, t, n, r, i) {
                    i = i || 0;
                    var o, a, u = this._listeners[e], c = 0;
                    for (this !== s || l || s.wake(), null == u && (this._listeners[e] = u = []), a = u.length; --a > -1;) (o = u[a]).c === t && o.s === n ? u.splice(a, 1) : 0 === c && o.pr < i && (c = a + 1);
                    u.splice(c, 0, {c: t, s: n, up: r, pr: i})
                }, a.removeEventListener = function (e, t) {
                    var n, r = this._listeners[e];
                    if (r) for (n = r.length; --n > -1;) if (r[n].c === t) return void r.splice(n, 1)
                }, a.dispatchEvent = function (e) {
                    var t, n, r, i = this._listeners[e];
                    if (i) for ((t = i.length) > 1 && (i = i.slice(0)), n = this._eventTarget; --t > -1;) (r = i[t]) && (r.up ? r.c.call(r.s || n, {
                        type: e,
                        target: n
                    }) : r.c.call(r.s || n))
                };
                var S = e.requestAnimationFrame, M = e.cancelAnimationFrame, A = Date.now || function () {
                    return (new Date).getTime()
                }, O = A();
                for (o = (i = ["ms", "moz", "webkit", "o"]).length; --o > -1 && !S;) S = e[i[o] + "RequestAnimationFrame"], M = e[i[o] + "CancelAnimationFrame"] || e[i[o] + "CancelRequestAnimationFrame"];
                y("Ticker", (function (e, t) {
                    var r, i, o, a, u, c = this, p = A(), d = !(!1 === t || !S) && "auto", h = 500, m = 33,
                        _ = function (e) {
                            var t, n, s = A() - O;
                            s > h && (p += s - m), O += s, c.time = (O - p) / 1e3, t = c.time - u, (!r || t > 0 || !0 === e) && (c.frame++, u += t + (t >= a ? .004 : a - t), n = !0), !0 !== e && (o = i(_)), n && c.dispatchEvent("tick")
                        };
                    C.call(c), c.time = c.frame = 0, c.tick = function () {
                        _(!0)
                    }, c.lagSmoothing = function (e, t) {
                        if (!arguments.length) return h < 1 / 1e-8;
                        h = e || 1 / 1e-8, m = Math.min(t, h, 0)
                    }, c.sleep = function () {
                        null != o && (d && M ? M(o) : clearTimeout(o), i = f, o = null, c === s && (l = !1))
                    }, c.wake = function (e) {
                        null !== o ? c.sleep() : e ? p += -O + (O = A()) : c.frame > 10 && (O = A() - h + 5), i = 0 === r ? f : d && S ? S : function (e) {
                            return setTimeout(e, 1e3 * (u - c.time) + 1 | 0)
                        }, c === s && (l = !0), _(2)
                    }, c.fps = function (e) {
                        if (!arguments.length) return r;
                        a = 1 / ((r = e) || 60), u = this.time + a, c.wake()
                    }, c.useRAF = function (e) {
                        if (!arguments.length) return d;
                        c.sleep(), d = e, c.fps(r)
                    }, c.fps(e), setTimeout((function () {
                        "auto" === d && c.frame < 5 && "hidden" !== (n || {}).visibilityState && c.useRAF(!1)
                    }), 1500)
                })), (a = d.Ticker.prototype = new d.events.EventDispatcher).constructor = d.Ticker;
                var w = y("core.Animation", (function (e, t) {
                    if (this.vars = t = t || {}, this._duration = this._totalDuration = e || 0, this._delay = Number(t.delay) || 0, this._timeScale = 1, this._active = !!t.immediateRender, this.data = t.data, this._reversed = !!t.reversed, Z) {
                        l || s.wake();
                        var n = this.vars.useFrames ? q : Z;
                        n.add(this, n._time), this.vars.paused && this.paused(!0)
                    }
                }));
                s = w.ticker = new d.Ticker, (a = w.prototype)._dirty = a._gc = a._initted = a._paused = !1, a._totalTime = a._time = 0, a._rawPrevTime = -1, a._next = a._last = a._onUpdate = a._timeline = a.timeline = null, a._paused = !1;
                var R = function () {
                    l && A() - O > 2e3 && ("hidden" !== (n || {}).visibilityState || !s.lagSmoothing()) && s.wake();
                    var e = setTimeout(R, 2e3);
                    e.unref && e.unref()
                };
                R(), a.play = function (e, t) {
                    return null != e && this.seek(e, t), this.reversed(!1).paused(!1)
                }, a.pause = function (e, t) {
                    return null != e && this.seek(e, t), this.paused(!0)
                }, a.resume = function (e, t) {
                    return null != e && this.seek(e, t), this.paused(!1)
                }, a.seek = function (e, t) {
                    return this.totalTime(Number(e), !1 !== t)
                }, a.restart = function (e, t) {
                    return this.reversed(!1).paused(!1).totalTime(e ? -this._delay : 0, !1 !== t, !0)
                }, a.reverse = function (e, t) {
                    return null != e && this.seek(e || this.totalDuration(), t), this.reversed(!0).paused(!1)
                }, a.render = function (e, t, n) {
                }, a.invalidate = function () {
                    return this._time = this._totalTime = 0, this._initted = this._gc = !1, this._rawPrevTime = -1, !this._gc && this.timeline || this._enabled(!0), this
                }, a.isActive = function () {
                    var e, t = this._timeline, n = this._startTime;
                    return !t || !this._gc && !this._paused && t.isActive() && (e = t.rawTime(!0)) >= n && e < n + this.totalDuration() / this._timeScale - 1e-8
                }, a._enabled = function (e, t) {
                    return l || s.wake(), this._gc = !e, this._active = this.isActive(), !0 !== t && (e && !this.timeline ? this._timeline.add(this, this._startTime - this._delay) : !e && this.timeline && this._timeline._remove(this, !0)), !1
                }, a._kill = function (e, t) {
                    return this._enabled(!1, !1)
                }, a.kill = function (e, t) {
                    return this._kill(e, t), this
                }, a._uncache = function (e) {
                    for (var t = e ? this : this.timeline; t;) t._dirty = !0, t = t.timeline;
                    return this
                }, a._swapSelfInParams = function (e) {
                    for (var t = e.length, n = e.concat(); --t > -1;) "{self}" === e[t] && (n[t] = this);
                    return n
                }, a._callback = function (e) {
                    var t = this.vars, n = t[e], r = t[e + "Params"], i = t[e + "Scope"] || t.callbackScope || this;
                    switch (r ? r.length : 0) {
                        case 0:
                            n.call(i);
                            break;
                        case 1:
                            n.call(i, r[0]);
                            break;
                        case 2:
                            n.call(i, r[0], r[1]);
                            break;
                        default:
                            n.apply(i, r)
                    }
                }, a.eventCallback = function (e, t, n, r) {
                    if ("on" === (e || "").substr(0, 2)) {
                        var i = this.vars;
                        if (1 === arguments.length) return i[e];
                        null == t ? delete i[e] : (i[e] = t, i[e + "Params"] = m(n) && -1 !== n.join("").indexOf("{self}") ? this._swapSelfInParams(n) : n, i[e + "Scope"] = r), "onUpdate" === e && (this._onUpdate = t)
                    }
                    return this
                }, a.delay = function (e) {
                    return arguments.length ? (this._timeline.smoothChildTiming && this.startTime(this._startTime + e - this._delay), this._delay = e, this) : this._delay
                }, a.duration = function (e) {
                    return arguments.length ? (this._duration = this._totalDuration = e, this._uncache(!0), this._timeline.smoothChildTiming && this._time > 0 && this._time < this._duration && 0 !== e && this.totalTime(this._totalTime * (e / this._duration), !0), this) : (this._dirty = !1, this._duration)
                }, a.totalDuration = function (e) {
                    return this._dirty = !1, arguments.length ? this.duration(e) : this._totalDuration
                }, a.time = function (e, t) {
                    return arguments.length ? (this._dirty && this.totalDuration(), this.totalTime(e > this._duration ? this._duration : e, t)) : this._time
                }, a.totalTime = function (e, t, n) {
                    if (l || s.wake(), !arguments.length) return this._totalTime;
                    if (this._timeline) {
                        if (e < 0 && !n && (e += this.totalDuration()), this._timeline.smoothChildTiming) {
                            this._dirty && this.totalDuration();
                            var r = this._totalDuration, i = this._timeline;
                            if (e > r && !n && (e = r), this._startTime = (this._paused ? this._pauseTime : i._time) - (this._reversed ? r - e : e) / this._timeScale, i._dirty || this._uncache(!1), i._timeline) for (; i._timeline;) i._timeline._time !== (i._startTime + i._totalTime) / i._timeScale && i.totalTime(i._totalTime, !0), i = i._timeline
                        }
                        this._gc && this._enabled(!0, !1), this._totalTime === e && 0 !== this._duration || (I.length && Q(), this.render(e, t, !1), I.length && Q())
                    }
                    return this
                }, a.progress = a.totalProgress = function (e, t) {
                    var n = this.duration();
                    return arguments.length ? this.totalTime(n * e, t) : n ? this._time / n : this.ratio
                }, a.startTime = function (e) {
                    return arguments.length ? (e !== this._startTime && (this._startTime = e, this.timeline && this.timeline._sortChildren && this.timeline.add(this, e - this._delay)), this) : this._startTime
                }, a.endTime = function (e) {
                    return this._startTime + (0 != e ? this.totalDuration() : this.duration()) / this._timeScale
                }, a.timeScale = function (e) {
                    if (!arguments.length) return this._timeScale;
                    var t, n;
                    for (e = e || 1e-8, this._timeline && this._timeline.smoothChildTiming && (n = (t = this._pauseTime) || 0 === t ? t : this._timeline.totalTime(), this._startTime = n - (n - this._startTime) * this._timeScale / e), this._timeScale = e, n = this.timeline; n && n.timeline;) n._dirty = !0, n.totalDuration(), n = n.timeline;
                    return this
                }, a.reversed = function (e) {
                    return arguments.length ? (e != this._reversed && (this._reversed = e, this.totalTime(this._timeline && !this._timeline.smoothChildTiming ? this.totalDuration() - this._totalTime : this._totalTime, !0)), this) : this._reversed
                }, a.paused = function (e) {
                    if (!arguments.length) return this._paused;
                    var t, n, r = this._timeline;
                    return e != this._paused && r && (l || e || s.wake(), n = (t = r.rawTime()) - this._pauseTime, !e && r.smoothChildTiming && (this._startTime += n, this._uncache(!1)), this._pauseTime = e ? t : null, this._paused = e, this._active = this.isActive(), !e && 0 !== n && this._initted && this.duration() && (t = r.smoothChildTiming ? this._totalTime : (t - this._startTime) / this._timeScale, this.render(t, t === this._totalTime, !0))), this._gc && !e && this._enabled(!0, !1), this
                };
                var P = y("core.SimpleTimeline", (function (e) {
                    w.call(this, 0, e), this.autoRemoveChildren = this.smoothChildTiming = !0
                }));
                (a = P.prototype = new w).constructor = P, a.kill()._gc = !1, a._first = a._last = a._recent = null, a._sortChildren = !1, a.add = a.insert = function (e, t, n, r) {
                    var i, o;
                    if (e._startTime = Number(t || 0) + e._delay, e._paused && this !== e._timeline && (e._pauseTime = this.rawTime() - (e._timeline.rawTime() - e._pauseTime)), e.timeline && e.timeline._remove(e, !0), e.timeline = e._timeline = this, e._gc && e._enabled(!0, !0), i = this._last, this._sortChildren) for (o = e._startTime; i && i._startTime > o;) i = i._prev;
                    return i ? (e._next = i._next, i._next = e) : (e._next = this._first, this._first = e), e._next ? e._next._prev = e : this._last = e, e._prev = i, this._recent = e, this._timeline && this._uncache(!0), this
                }, a._remove = function (e, t) {
                    return e.timeline === this && (t || e._enabled(!1, !0), e._prev ? e._prev._next = e._next : this._first === e && (this._first = e._next), e._next ? e._next._prev = e._prev : this._last === e && (this._last = e._prev), e._next = e._prev = e.timeline = null, e === this._recent && (this._recent = this._last), this._timeline && this._uncache(!0)), this
                }, a.render = function (e, t, n) {
                    var r, i = this._first;
                    for (this._totalTime = this._time = this._rawPrevTime = e; i;) r = i._next, (i._active || e >= i._startTime && !i._paused && !i._gc) && (i._reversed ? i.render((i._dirty ? i.totalDuration() : i._totalDuration) - (e - i._startTime) * i._timeScale, t, n) : i.render((e - i._startTime) * i._timeScale, t, n)), i = r
                }, a.rawTime = function () {
                    return l || s.wake(), this._totalTime
                };
                var L = y("TweenLite", (function (t, n, r) {
                    if (w.call(this, n, r), this.render = L.prototype.render, null == t) throw"Cannot tween a null target.";
                    this.target = t = "string" != typeof t ? t : L.selector(t) || t;
                    var i, o, a,
                        s = t.jquery || t.length && t !== e && t[0] && (t[0] === e || t[0].nodeType && t[0].style && !t.nodeType),
                        l = this.vars.overwrite;
                    if (this._overwrite = l = null == l ? Y[L.defaultOverwrite] : "number" == typeof l ? l >> 0 : Y[l], (s || t instanceof Array || t.push && m(t)) && "number" != typeof t[0]) for (this._targets = a = h(t), this._propLookup = [], this._siblings = [], i = 0; i < a.length; i++) (o = a[i]) ? "string" != typeof o ? o.length && o !== e && o[0] && (o[0] === e || o[0].nodeType && o[0].style && !o.nodeType) ? (a.splice(i--, 1), this._targets = a = a.concat(h(o))) : (this._siblings[i] = J(o, this, !1), 1 === l && this._siblings[i].length > 1 && ee(o, this, null, 1, this._siblings[i])) : "string" == typeof (o = a[i--] = L.selector(o)) && a.splice(i + 1, 1) : a.splice(i--, 1); else this._propLookup = {}, this._siblings = J(t, this, !1), 1 === l && this._siblings.length > 1 && ee(t, this, null, 1, this._siblings);
                    (this.vars.immediateRender || 0 === n && 0 === this._delay && !1 !== this.vars.immediateRender) && (this._time = -1e-8, this.render(Math.min(0, -this._delay)))
                }), !0), D = function (t) {
                    return t && t.length && t !== e && t[0] && (t[0] === e || t[0].nodeType && t[0].style && !t.nodeType)
                };
                (a = L.prototype = new w).constructor = L, a.kill()._gc = !1, a.ratio = 0, a._firstPT = a._targets = a._overwrittenProps = a._startAt = null, a._notifyPluginsOfEnabled = a._lazy = !1, L.version = "2.1.3", L.defaultEase = a._ease = new x(null, null, 1, 1), L.defaultOverwrite = "auto", L.ticker = s, L.autoSleep = 120, L.lagSmoothing = function (e, t) {
                    s.lagSmoothing(e, t)
                }, L.selector = e.$ || e.jQuery || function (t) {
                    var r = e.$ || e.jQuery;
                    return r ? (L.selector = r, r(t)) : (n || (n = e.document), n ? n.querySelectorAll ? n.querySelectorAll(t) : n.getElementById("#" === t.charAt(0) ? t.substr(1) : t) : t)
                };
                var I = [], N = {}, z = /(?:(-|-=|\+=)?\d*\.?\d*(?:e[\-+]?\d+)?)[0-9]/gi, U = /[\+-]=-?[\.\d]/,
                    F = function (e) {
                        for (var t, n = this._firstPT; n;) t = n.blob ? 1 === e && null != this.end ? this.end : e ? this.join("") : this.start : n.c * e + n.s, n.m ? t = n.m.call(this._tween, t, this._target || n.t, this._tween) : t < 1e-6 && t > -1e-6 && !n.blob && (t = 0), n.f ? n.fp ? n.t[n.p](n.fp, t) : n.t[n.p](t) : n.t[n.p] = t, n = n._next
                    }, k = function (e) {
                        return (1e3 * e | 0) / 1e3 + ""
                    }, V = function (e, t, n, r) {
                        var i, o, a, s, l, u, c, p = [], d = 0, h = "", f = 0;
                        for (p.start = e, p.end = t, e = p[0] = e + "", t = p[1] = t + "", n && (n(p), e = p[0], t = p[1]), p.length = 0, i = e.match(z) || [], o = t.match(z) || [], r && (r._next = null, r.blob = 1, p._firstPT = p._applyPT = r), l = o.length, s = 0; s < l; s++) c = o[s], h += (u = t.substr(d, t.indexOf(c, d) - d)) || !s ? u : ",", d += u.length, f ? f = (f + 1) % 5 : "rgba(" === u.substr(-5) && (f = 1), c === i[s] || i.length <= s ? h += c : (h && (p.push(h), h = ""), a = parseFloat(i[s]), p.push(a), p._firstPT = {
                            _next: p._firstPT,
                            t: p,
                            p: p.length - 1,
                            s: a,
                            c: ("=" === c.charAt(1) ? parseInt(c.charAt(0) + "1", 10) * parseFloat(c.substr(2)) : parseFloat(c) - a) || 0,
                            f: 0,
                            m: f && f < 4 ? Math.round : k
                        }), d += c.length;
                        return (h += t.substr(d)) && p.push(h), p.setRatio = F, U.test(t) && (p.end = null), p
                    }, B = function (e, t, n, r, i, o, a, s, l) {
                        "function" == typeof r && (r = r(l || 0, e));
                        var u = typeof e[t],
                            c = "function" !== u ? "" : t.indexOf("set") || "function" != typeof e["get" + t.substr(3)] ? t : "get" + t.substr(3),
                            p = "get" !== n ? n : c ? a ? e[c](a) : e[c]() : e[t],
                            d = "string" == typeof r && "=" === r.charAt(1), h = {
                                t: e,
                                p: t,
                                s: p,
                                f: "function" === u,
                                pg: 0,
                                n: i || t,
                                m: o ? "function" == typeof o ? o : Math.round : 0,
                                pr: 0,
                                c: d ? parseInt(r.charAt(0) + "1", 10) * parseFloat(r.substr(2)) : parseFloat(r) - p || 0
                            };
                        if (("number" != typeof p || "number" != typeof r && !d) && (a || isNaN(p) || !d && isNaN(r) || "boolean" == typeof p || "boolean" == typeof r ? (h.fp = a, h = {
                            t: V(p, d ? parseFloat(h.s) + h.c + (h.s + "").replace(/[0-9\-\.]/g, "") : r, s || L.defaultStringFilter, h),
                            p: "setRatio",
                            s: 0,
                            c: 1,
                            f: 2,
                            pg: 0,
                            n: i || t,
                            pr: 0,
                            m: 0
                        }) : (h.s = parseFloat(p), d || (h.c = parseFloat(r) - h.s || 0))), h.c) return (h._next = this._firstPT) && (h._next._prev = h), this._firstPT = h, h
                    }, G = L._internals = {isArray: m, isSelector: D, lazyTweens: I, blobDif: V}, j = L._plugins = {},
                    H = G.tweenLookup = {}, W = 0, X = G.reservedProps = {
                        ease: 1,
                        delay: 1,
                        overwrite: 1,
                        onComplete: 1,
                        onCompleteParams: 1,
                        onCompleteScope: 1,
                        useFrames: 1,
                        runBackwards: 1,
                        startAt: 1,
                        onUpdate: 1,
                        onUpdateParams: 1,
                        onUpdateScope: 1,
                        onStart: 1,
                        onStartParams: 1,
                        onStartScope: 1,
                        onReverseComplete: 1,
                        onReverseCompleteParams: 1,
                        onReverseCompleteScope: 1,
                        onRepeat: 1,
                        onRepeatParams: 1,
                        onRepeatScope: 1,
                        easeParams: 1,
                        yoyo: 1,
                        immediateRender: 1,
                        repeat: 1,
                        repeatDelay: 1,
                        data: 1,
                        paused: 1,
                        reversed: 1,
                        autoCSS: 1,
                        lazy: 1,
                        onOverwrite: 1,
                        callbackScope: 1,
                        stringFilter: 1,
                        id: 1,
                        yoyoEase: 1,
                        stagger: 1
                    }, Y = {none: 0, all: 1, auto: 2, concurrent: 3, allOnStart: 4, preexisting: 5, true: 1, false: 0},
                    q = w._rootFramesTimeline = new P, Z = w._rootTimeline = new P, K = 30,
                    Q = G.lazyRender = function () {
                        var e, t, n = I.length;
                        for (N = {}, e = 0; e < n; e++) (t = I[e]) && !1 !== t._lazy && (t.render(t._lazy[0], t._lazy[1], !0), t._lazy = !1);
                        I.length = 0
                    };
                Z._startTime = s.time, q._startTime = s.frame, Z._active = q._active = !0, setTimeout(Q, 1), w._updateRoot = L.render = function () {
                    var e, t, n;
                    if (I.length && Q(), Z.render((s.time - Z._startTime) * Z._timeScale, !1, !1), q.render((s.frame - q._startTime) * q._timeScale, !1, !1), I.length && Q(), s.frame >= K) {
                        for (n in K = s.frame + (parseInt(L.autoSleep, 10) || 120), H) {
                            for (e = (t = H[n].tweens).length; --e > -1;) t[e]._gc && t.splice(e, 1);
                            0 === t.length && delete H[n]
                        }
                        if ((!(n = Z._first) || n._paused) && L.autoSleep && !q._first && 1 === s._listeners.tick.length) {
                            for (; n && n._paused;) n = n._next;
                            n || s.sleep()
                        }
                    }
                }, s.addEventListener("tick", w._updateRoot);
                var J = function (e, t, n) {
                    var r, i, o = e._gsTweenID;
                    if (H[o || (e._gsTweenID = o = "t" + W++)] || (H[o] = {
                        target: e,
                        tweens: []
                    }), t && ((r = H[o].tweens)[i = r.length] = t, n)) for (; --i > -1;) r[i] === t && r.splice(i, 1);
                    return H[o].tweens
                }, $ = function (e, t, n, r) {
                    var i, o, a = e.vars.onOverwrite;
                    return a && (i = a(e, t, n, r)), (a = L.onOverwrite) && (o = a(e, t, n, r)), !1 !== i && !1 !== o
                }, ee = function (e, t, n, r, i) {
                    var o, a, s, l;
                    if (1 === r || r >= 4) {
                        for (l = i.length, o = 0; o < l; o++) if ((s = i[o]) !== t) s._gc || s._kill(null, e, t) && (a = !0); else if (5 === r) break;
                        return a
                    }
                    var u, c = t._startTime + 1e-8, p = [], d = 0, h = 0 === t._duration;
                    for (o = i.length; --o > -1;) (s = i[o]) === t || s._gc || s._paused || (s._timeline !== t._timeline ? (u = u || te(t, 0, h), 0 === te(s, u, h) && (p[d++] = s)) : s._startTime <= c && s._startTime + s.totalDuration() / s._timeScale > c && ((h || !s._initted) && c - s._startTime <= 2e-8 || (p[d++] = s)));
                    for (o = d; --o > -1;) if (l = (s = p[o])._firstPT, 2 === r && s._kill(n, e, t) && (a = !0), 2 !== r || !s._firstPT && s._initted && l) {
                        if (2 !== r && !$(s, t)) continue;
                        s._enabled(!1, !1) && (a = !0)
                    }
                    return a
                }, te = function (e, t, n) {
                    for (var r = e._timeline, i = r._timeScale, o = e._startTime; r._timeline;) {
                        if (o += r._startTime, i *= r._timeScale, r._paused) return -100;
                        r = r._timeline
                    }
                    return (o /= i) > t ? o - t : n && o === t || !e._initted && o - t < 2e-8 ? 1e-8 : (o += e.totalDuration() / e._timeScale / i) > t + 1e-8 ? 0 : o - t - 1e-8
                };
                a._init = function () {
                    var e, t, n, r, i, o, a = this.vars, s = this._overwrittenProps, l = this._duration,
                        u = !!a.immediateRender, c = a.ease, p = this._startAt;
                    if (a.startAt) {
                        for (r in p && (p.render(-1, !0), p.kill()), i = {}, a.startAt) i[r] = a.startAt[r];
                        if (i.data = "isStart", i.overwrite = !1, i.immediateRender = !0, i.lazy = u && !1 !== a.lazy, i.startAt = i.delay = null, i.onUpdate = a.onUpdate, i.onUpdateParams = a.onUpdateParams, i.onUpdateScope = a.onUpdateScope || a.callbackScope || this, this._startAt = L.to(this.target || {}, 0, i), u) if (this._time > 0) this._startAt = null; else if (0 !== l) return
                    } else if (a.runBackwards && 0 !== l) if (p) p.render(-1, !0), p.kill(), this._startAt = null; else {
                        for (r in 0 !== this._time && (u = !1), n = {}, a) X[r] && "autoCSS" !== r || (n[r] = a[r]);
                        if (n.overwrite = 0, n.data = "isFromStart", n.lazy = u && !1 !== a.lazy, n.immediateRender = u, this._startAt = L.to(this.target, 0, n), u) {
                            if (0 === this._time) return
                        } else this._startAt._init(), this._startAt._enabled(!1), this.vars.immediateRender && (this._startAt = null)
                    }
                    if (this._ease = c = c ? c instanceof x ? c : "function" == typeof c ? new x(c, a.easeParams) : T[c] || L.defaultEase : L.defaultEase, a.easeParams instanceof Array && c.config && (this._ease = c.config.apply(c, a.easeParams)), this._easeType = this._ease._type, this._easePower = this._ease._power, this._firstPT = null, this._targets) for (o = this._targets.length, e = 0; e < o; e++) this._initProps(this._targets[e], this._propLookup[e] = {}, this._siblings[e], s ? s[e] : null, e) && (t = !0); else t = this._initProps(this.target, this._propLookup, this._siblings, s, 0);
                    if (t && L._onPluginEvent("_onInitAllProps", this), s && (this._firstPT || "function" != typeof this.target && this._enabled(!1, !1)), a.runBackwards) for (n = this._firstPT; n;) n.s += n.c, n.c = -n.c, n = n._next;
                    this._onUpdate = a.onUpdate, this._initted = !0
                }, a._initProps = function (t, n, r, i, o) {
                    var a, s, l, u, c, p;
                    if (null == t) return !1;
                    for (a in N[t._gsTweenID] && Q(), this.vars.css || t.style && t !== e && t.nodeType && j.css && !1 !== this.vars.autoCSS && function (e, t) {
                        var n, r = {};
                        for (n in e) X[n] || n in t && "transform" !== n && "x" !== n && "y" !== n && "width" !== n && "height" !== n && "className" !== n && "border" !== n || !(!j[n] || j[n] && j[n]._autoCSS) || (r[n] = e[n], delete e[n]);
                        e.css = r
                    }(this.vars, t), this.vars) if (p = this.vars[a], X[a]) p && (p instanceof Array || p.push && m(p)) && -1 !== p.join("").indexOf("{self}") && (this.vars[a] = p = this._swapSelfInParams(p, this)); else if (j[a] && (u = new j[a])._onInitTween(t, this.vars[a], this, o)) {
                        for (this._firstPT = c = {
                            _next: this._firstPT,
                            t: u,
                            p: "setRatio",
                            s: 0,
                            c: 1,
                            f: 1,
                            n: a,
                            pg: 1,
                            pr: u._priority,
                            m: 0
                        }, s = u._overwriteProps.length; --s > -1;) n[u._overwriteProps[s]] = this._firstPT;
                        (u._priority || u._onInitAllProps) && (l = !0), (u._onDisable || u._onEnable) && (this._notifyPluginsOfEnabled = !0), c._next && (c._next._prev = c)
                    } else n[a] = B.call(this, t, a, "get", p, a, 0, null, this.vars.stringFilter, o);
                    return i && this._kill(i, t) ? this._initProps(t, n, r, i, o) : this._overwrite > 1 && this._firstPT && r.length > 1 && ee(t, this, n, this._overwrite, r) ? (this._kill(n, t), this._initProps(t, n, r, i, o)) : (this._firstPT && (!1 !== this.vars.lazy && this._duration || this.vars.lazy && !this._duration) && (N[t._gsTweenID] = !0), l)
                }, a.render = function (e, t, n) {
                    var r, i, o, a, s = this._time, l = this._duration, u = this._rawPrevTime;
                    if (e >= l - 1e-8 && e >= 0) this._totalTime = this._time = l, this.ratio = this._ease._calcEnd ? this._ease.getRatio(1) : 1, this._reversed || (r = !0, i = "onComplete", n = n || this._timeline.autoRemoveChildren), 0 === l && (this._initted || !this.vars.lazy || n) && (this._startTime === this._timeline._duration && (e = 0), (u < 0 || e <= 0 && e >= -1e-8 || 1e-8 === u && "isPause" !== this.data) && u !== e && (n = !0, u > 1e-8 && (i = "onReverseComplete")), this._rawPrevTime = a = !t || e || u === e ? e : 1e-8); else if (e < 1e-8) this._totalTime = this._time = 0, this.ratio = this._ease._calcEnd ? this._ease.getRatio(0) : 0, (0 !== s || 0 === l && u > 0) && (i = "onReverseComplete", r = this._reversed), e > -1e-8 ? e = 0 : e < 0 && (this._active = !1, 0 === l && (this._initted || !this.vars.lazy || n) && (u >= 0 && (1e-8 !== u || "isPause" !== this.data) && (n = !0), this._rawPrevTime = a = !t || e || u === e ? e : 1e-8)), (!this._initted || this._startAt && this._startAt.progress()) && (n = !0); else if (this._totalTime = this._time = e, this._easeType) {
                        var c = e / l, p = this._easeType, d = this._easePower;
                        (1 === p || 3 === p && c >= .5) && (c = 1 - c), 3 === p && (c *= 2), 1 === d ? c *= c : 2 === d ? c *= c * c : 3 === d ? c *= c * c * c : 4 === d && (c *= c * c * c * c), this.ratio = 1 === p ? 1 - c : 2 === p ? c : e / l < .5 ? c / 2 : 1 - c / 2
                    } else this.ratio = this._ease.getRatio(e / l);
                    if (this._time !== s || n) {
                        if (!this._initted) {
                            if (this._init(), !this._initted || this._gc) return;
                            if (!n && this._firstPT && (!1 !== this.vars.lazy && this._duration || this.vars.lazy && !this._duration)) return this._time = this._totalTime = s, this._rawPrevTime = u, I.push(this), void (this._lazy = [e, t]);
                            this._time && !r ? this.ratio = this._ease.getRatio(this._time / l) : r && this._ease._calcEnd && (this.ratio = this._ease.getRatio(0 === this._time ? 0 : 1))
                        }
                        for (!1 !== this._lazy && (this._lazy = !1), this._active || !this._paused && this._time !== s && e >= 0 && (this._active = !0), 0 === s && (this._startAt && (e >= 0 ? this._startAt.render(e, !0, n) : i || (i = "_dummyGS")), this.vars.onStart && (0 === this._time && 0 !== l || t || this._callback("onStart"))), o = this._firstPT; o;) o.f ? o.t[o.p](o.c * this.ratio + o.s) : o.t[o.p] = o.c * this.ratio + o.s, o = o._next;
                        this._onUpdate && (e < 0 && this._startAt && -1e-4 !== e && this._startAt.render(e, !0, n), t || (this._time !== s || r || n) && this._callback("onUpdate")), i && (this._gc && !n || (e < 0 && this._startAt && !this._onUpdate && -1e-4 !== e && this._startAt.render(e, !0, n), r && (this._timeline.autoRemoveChildren && this._enabled(!1, !1), this._active = !1), !t && this.vars[i] && this._callback(i), 0 === l && 1e-8 === this._rawPrevTime && 1e-8 !== a && (this._rawPrevTime = 0)))
                    }
                }, a._kill = function (e, t, n) {
                    if ("all" === e && (e = null), null == e && (null == t || t === this.target)) return this._lazy = !1, this._enabled(!1, !1);
                    t = "string" != typeof t ? t || this._targets || this.target : L.selector(t) || t;
                    var r, i, o, a, s, l, u, c, p,
                        d = n && this._time && n._startTime === this._startTime && this._timeline === n._timeline,
                        h = this._firstPT;
                    if ((m(t) || D(t)) && "number" != typeof t[0]) for (r = t.length; --r > -1;) this._kill(e, t[r], n) && (l = !0); else {
                        if (this._targets) {
                            for (r = this._targets.length; --r > -1;) if (t === this._targets[r]) {
                                s = this._propLookup[r] || {}, this._overwrittenProps = this._overwrittenProps || [], i = this._overwrittenProps[r] = e ? this._overwrittenProps[r] || {} : "all";
                                break
                            }
                        } else {
                            if (t !== this.target) return !1;
                            s = this._propLookup, i = this._overwrittenProps = e ? this._overwrittenProps || {} : "all"
                        }
                        if (s) {
                            if (u = e || s, c = e !== i && "all" !== i && e !== s && ("object" != typeof e || !e._tempKill), n && (L.onOverwrite || this.vars.onOverwrite)) {
                                for (o in u) s[o] && (p || (p = []), p.push(o));
                                if ((p || !e) && !$(this, n, t, p)) return !1
                            }
                            for (o in u) (a = s[o]) && (d && (a.f ? a.t[a.p](a.s) : a.t[a.p] = a.s, l = !0), a.pg && a.t._kill(u) && (l = !0), a.pg && 0 !== a.t._overwriteProps.length || (a._prev ? a._prev._next = a._next : a === this._firstPT && (this._firstPT = a._next), a._next && (a._next._prev = a._prev), a._next = a._prev = null), delete s[o]), c && (i[o] = 1);
                            !this._firstPT && this._initted && h && this._enabled(!1, !1)
                        }
                    }
                    return l
                }, a.invalidate = function () {
                    this._notifyPluginsOfEnabled && L._onPluginEvent("_onDisable", this);
                    var e = this._time;
                    return this._firstPT = this._overwrittenProps = this._startAt = this._onUpdate = null, this._notifyPluginsOfEnabled = this._active = this._lazy = !1, this._propLookup = this._targets ? {} : [], w.prototype.invalidate.call(this), this.vars.immediateRender && (this._time = -1e-8, this.render(e, !1, !1 !== this.vars.lazy)), this
                }, a._enabled = function (e, t) {
                    if (l || s.wake(), e && this._gc) {
                        var n, r = this._targets;
                        if (r) for (n = r.length; --n > -1;) this._siblings[n] = J(r[n], this, !0); else this._siblings = J(this.target, this, !0)
                    }
                    return w.prototype._enabled.call(this, e, t), !(!this._notifyPluginsOfEnabled || !this._firstPT) && L._onPluginEvent(e ? "_onEnable" : "_onDisable", this)
                }, L.to = function (e, t, n) {
                    return new L(e, t, n)
                }, L.from = function (e, t, n) {
                    return n.runBackwards = !0, n.immediateRender = 0 != n.immediateRender, new L(e, t, n)
                }, L.fromTo = function (e, t, n, r) {
                    return r.startAt = n, r.immediateRender = 0 != r.immediateRender && 0 != n.immediateRender, new L(e, t, r)
                }, L.delayedCall = function (e, t, n, r, i) {
                    return new L(t, 0, {
                        delay: e,
                        onComplete: t,
                        onCompleteParams: n,
                        callbackScope: r,
                        onReverseComplete: t,
                        onReverseCompleteParams: n,
                        immediateRender: !1,
                        lazy: !1,
                        useFrames: i,
                        overwrite: 0
                    })
                }, L.set = function (e, t) {
                    return new L(e, 0, t)
                }, L.getTweensOf = function (e, t) {
                    if (null == e) return [];
                    var n, r, i, o;
                    if (e = "string" != typeof e ? e : L.selector(e) || e, (m(e) || D(e)) && "number" != typeof e[0]) {
                        for (n = e.length, r = []; --n > -1;) r = r.concat(L.getTweensOf(e[n], t));
                        for (n = r.length; --n > -1;) for (o = r[n], i = n; --i > -1;) o === r[i] && r.splice(n, 1)
                    } else if (e._gsTweenID) for (n = (r = J(e).concat()).length; --n > -1;) (r[n]._gc || t && !r[n].isActive()) && r.splice(n, 1);
                    return r || []
                }, L.killTweensOf = L.killDelayedCallsTo = function (e, t, n) {
                    "object" == typeof t && (n = t, t = !1);
                    for (var r = L.getTweensOf(e, t), i = r.length; --i > -1;) r[i]._kill(n, e)
                };
                var ne = y("plugins.TweenPlugin", (function (e, t) {
                    this._overwriteProps = (e || "").split(","), this._propName = this._overwriteProps[0], this._priority = t || 0, this._super = ne.prototype
                }), !0);
                if (a = ne.prototype, ne.version = "1.19.0", ne.API = 2, a._firstPT = null, a._addTween = B, a.setRatio = F, a._kill = function (e) {
                    var t, n = this._overwriteProps, r = this._firstPT;
                    if (null != e[this._propName]) this._overwriteProps = []; else for (t = n.length; --t > -1;) null != e[n[t]] && n.splice(t, 1);
                    for (; r;) null != e[r.n] && (r._next && (r._next._prev = r._prev), r._prev ? (r._prev._next = r._next, r._prev = null) : this._firstPT === r && (this._firstPT = r._next)), r = r._next;
                    return !1
                }, a._mod = a._roundProps = function (e) {
                    for (var t, n = this._firstPT; n;) (t = e[this._propName] || null != n.n && e[n.n.split(this._propName + "_").join("")]) && "function" == typeof t && (2 === n.f ? n.t._applyPT.m = t : n.m = t), n = n._next
                }, L._onPluginEvent = function (e, t) {
                    var n, r, i, o, a, s = t._firstPT;
                    if ("_onInitAllProps" === e) {
                        for (; s;) {
                            for (a = s._next, r = i; r && r.pr > s.pr;) r = r._next;
                            (s._prev = r ? r._prev : o) ? s._prev._next = s : i = s, (s._next = r) ? r._prev = s : o = s, s = a
                        }
                        s = t._firstPT = i
                    }
                    for (; s;) s.pg && "function" == typeof s.t[e] && s.t[e]() && (n = !0), s = s._next;
                    return n
                }, ne.activate = function (e) {
                    for (var t = e.length; --t > -1;) e[t].API === ne.API && (j[(new e[t])._propName] = e[t]);
                    return !0
                }, v.plugin = function (e) {
                    if (!(e && e.propName && e.init && e.API)) throw"illegal plugin definition.";
                    var t, n = e.propName, r = e.priority || 0, i = e.overwriteProps, o = {
                        init: "_onInitTween",
                        set: "setRatio",
                        kill: "_kill",
                        round: "_mod",
                        mod: "_mod",
                        initAll: "_onInitAllProps"
                    }, a = y("plugins." + n.charAt(0).toUpperCase() + n.substr(1) + "Plugin", (function () {
                        ne.call(this, n, r), this._overwriteProps = i || []
                    }), !0 === e.global), s = a.prototype = new ne(n);
                    for (t in s.constructor = a, a.API = e.API, o) "function" == typeof e[t] && (s[o[t]] = e[t]);
                    return a.version = e.version, ne.activate([a]), a
                }, i = e._gsQueue) {
                    for (o = 0; o < i.length; o++) i[o]();
                    for (a in _) _[a].func || e.console.log("GSAP encountered missing dependency: " + a)
                }
                return l = !1, L
            }(o), s = o.GreenSockGlobals, l = s.com.greensock, u = l.core.SimpleTimeline, c = l.core.Animation,
            p = s.Ease, d = (s.Linear, s.Power1, s.Power2, s.Power3, s.Power4), h = s.TweenPlugin;
        /*!
 * VERSION: 2.1.3
 * DATE: 2019-05-17
 * UPDATES AND DOCS AT: http://greensock.com
 *
 * @license Copyright (c) 2008-2019, GreenSock. All rights reserved.
 * This work is subject to the terms at http://greensock.com/standard-license or for
 * Club GreenSock members, the software agreement that was issued with your membership.
 *
 * @author: Jack Doyle, jack@greensock.com
 */
        l.events.EventDispatcher;
        /*!
 * VERSION: 2.1.3
 * DATE: 2019-05-17
 * UPDATES AND DOCS AT: http://greensock.com
 *
 * @license Copyright (c) 2008-2019, GreenSock. All rights reserved.
 * This work is subject to the terms at http://greensock.com/standard-license or for
 * Club GreenSock members, the software agreement that was issued with your membership.
 *
 * @author: Jack Doyle, jack@greensock.com
 */
        o._gsDefine("TimelineLite", ["core.Animation", "core.SimpleTimeline", "TweenLite"], (function () {
            var e = function (e) {
                    u.call(this, e);
                    var t, n, r = this.vars;
                    for (n in this._labels = {}, this.autoRemoveChildren = !!r.autoRemoveChildren, this.smoothChildTiming = !!r.smoothChildTiming, this._sortChildren = !0, this._onUpdate = r.onUpdate, r) t = r[n], i(t) && -1 !== t.join("").indexOf("{self}") && (r[n] = this._swapSelfInParams(t));
                    i(r.tweens) && this.add(r.tweens, 0, r.align, r.stagger)
                }, t = a._internals, n = e._internals = {}, r = t.isSelector, i = t.isArray, s = t.lazyTweens,
                l = t.lazyRender, p = o._gsDefine.globals, d = function (e) {
                    var t, n = {};
                    for (t in e) n[t] = e[t];
                    return n
                }, h = function (e, t, n) {
                    var r, i, o = e.cycle;
                    for (r in o) i = o[r], e[r] = "function" == typeof i ? i(n, t[n], t) : i[n % i.length];
                    delete e.cycle
                }, f = n.pauseCallback = function () {
                }, m = function (e, t, n, r) {
                    var i = "immediateRender";
                    return i in t || (t[i] = !(n && !1 === n[i] || r)), t
                }, _ = function (e) {
                    if ("function" == typeof e) return e;
                    var t = "object" == typeof e ? e : {each: e}, n = t.ease, r = t.from || 0, i = t.base || 0, o = {},
                        a = isNaN(r), s = t.axis, l = {center: .5, end: 1}[r] || 0;
                    return function (e, u, c) {
                        var p, d, h, f, m, _, g, v, y, b = (c || t).length, x = o[b];
                        if (!x) {
                            if (!(y = "auto" === t.grid ? 0 : (t.grid || [1 / 0])[0])) {
                                for (g = -1 / 0; g < (g = c[y++].getBoundingClientRect().left) && y < b;) ;
                                y--
                            }
                            for (x = o[b] = [], p = a ? Math.min(y, b) * l - .5 : r % y, d = a ? b * l / y - .5 : r / y | 0, g = 0, v = 1 / 0, _ = 0; _ < b; _++) h = _ % y - p, f = d - (_ / y | 0), x[_] = m = s ? Math.abs("y" === s ? f : h) : Math.sqrt(h * h + f * f), m > g && (g = m), m < v && (v = m);
                            x.max = g - v, x.min = v, x.v = b = t.amount || t.each * (y > b ? b - 1 : s ? "y" === s ? b / y : y : Math.max(y, b / y)) || 0, x.b = b < 0 ? i - b : i
                        }
                        return b = (x[e] - x.min) / x.max, x.b + (n ? n.getRatio(b) : b) * x.v
                    }
                }, g = e.prototype = new u;
            return e.version = "2.1.3", e.distribute = _, g.constructor = e, g.kill()._gc = g._forcingPlayhead = g._hasPause = !1, g.to = function (e, t, n, r) {
                var i = n.repeat && p.TweenMax || a;
                return t ? this.add(new i(e, t, n), r) : this.set(e, n, r)
            }, g.from = function (e, t, n, r) {
                return this.add((n.repeat && p.TweenMax || a).from(e, t, m(0, n)), r)
            }, g.fromTo = function (e, t, n, r, i) {
                var o = r.repeat && p.TweenMax || a;
                return r = m(0, r, n), t ? this.add(o.fromTo(e, t, n, r), i) : this.set(e, r, i)
            }, g.staggerTo = function (t, n, i, o, s, l, u, c) {
                var p, f, m = new e({
                    onComplete: l,
                    onCompleteParams: u,
                    callbackScope: c,
                    smoothChildTiming: this.smoothChildTiming
                }), g = _(i.stagger || o), v = i.startAt, y = i.cycle;
                for ("string" == typeof t && (t = a.selector(t) || t), r(t = t || []) && (t = function (e) {
                    var t, n = [], r = e.length;
                    for (t = 0; t !== r; n.push(e[t++])) ;
                    return n
                }(t)), f = 0; f < t.length; f++) p = d(i), v && (p.startAt = d(v), v.cycle && h(p.startAt, t, f)), y && (h(p, t, f), null != p.duration && (n = p.duration, delete p.duration)), m.to(t[f], n, p, g(f, t[f], t));
                return this.add(m, s)
            }, g.staggerFrom = function (e, t, n, r, i, o, a, s) {
                return n.runBackwards = !0, this.staggerTo(e, t, m(0, n), r, i, o, a, s)
            }, g.staggerFromTo = function (e, t, n, r, i, o, a, s, l) {
                return r.startAt = n, this.staggerTo(e, t, m(0, r, n), i, o, a, s, l)
            }, g.call = function (e, t, n, r) {
                return this.add(a.delayedCall(0, e, t, n), r)
            }, g.set = function (e, t, n) {
                return this.add(new a(e, 0, m(0, t, null, !0)), n)
            }, e.exportRoot = function (t, n) {
                null == (t = t || {}).smoothChildTiming && (t.smoothChildTiming = !0);
                var r, i, o, s, l = new e(t), u = l._timeline;
                for (null == n && (n = !0), u._remove(l, !0), l._startTime = 0, l._rawPrevTime = l._time = l._totalTime = u._time, o = u._first; o;) s = o._next, n && o instanceof a && o.target === o.vars.onComplete || ((i = o._startTime - o._delay) < 0 && (r = 1), l.add(o, i)), o = s;
                return u.add(l, 0), r && l.totalDuration(), l
            }, g.add = function (t, n, r, o) {
                var s, l, p, d, h, f;
                if ("number" != typeof n && (n = this._parseTimeOrLabel(n, 0, !0, t)), !(t instanceof c)) {
                    if (t instanceof Array || t && t.push && i(t)) {
                        for (r = r || "normal", o = o || 0, s = n, l = t.length, p = 0; p < l; p++) i(d = t[p]) && (d = new e({tweens: d})), this.add(d, s), "string" != typeof d && "function" != typeof d && ("sequence" === r ? s = d._startTime + d.totalDuration() / d._timeScale : "start" === r && (d._startTime -= d.delay())), s += o;
                        return this._uncache(!0)
                    }
                    if ("string" == typeof t) return this.addLabel(t, n);
                    if ("function" != typeof t) throw"Cannot add " + t + " into the timeline; it is not a tween, timeline, function, or string.";
                    t = a.delayedCall(0, t)
                }
                if (u.prototype.add.call(this, t, n), (t._time || !t._duration && t._initted) && (s = (this.rawTime() - t._startTime) * t._timeScale, (!t._duration || Math.abs(Math.max(0, Math.min(t.totalDuration(), s))) - t._totalTime > 1e-5) && t.render(s, !1, !1)), (this._gc || this._time === this._duration) && !this._paused && this._duration < this.duration()) for (f = (h = this).rawTime() > t._startTime; h._timeline;) f && h._timeline.smoothChildTiming ? h.totalTime(h._totalTime, !0) : h._gc && h._enabled(!0, !1), h = h._timeline;
                return this
            }, g.remove = function (e) {
                if (e instanceof c) {
                    this._remove(e, !1);
                    var t = e._timeline = e.vars.useFrames ? c._rootFramesTimeline : c._rootTimeline;
                    return e._startTime = (e._paused ? e._pauseTime : t._time) - (e._reversed ? e.totalDuration() - e._totalTime : e._totalTime) / e._timeScale, this
                }
                if (e instanceof Array || e && e.push && i(e)) {
                    for (var n = e.length; --n > -1;) this.remove(e[n]);
                    return this
                }
                return "string" == typeof e ? this.removeLabel(e) : this.kill(null, e)
            }, g._remove = function (e, t) {
                return u.prototype._remove.call(this, e, t), this._last ? this._time > this.duration() && (this._time = this._duration, this._totalTime = this._totalDuration) : this._time = this._totalTime = this._duration = this._totalDuration = 0, this
            }, g.append = function (e, t) {
                return this.add(e, this._parseTimeOrLabel(null, t, !0, e))
            }, g.insert = g.insertMultiple = function (e, t, n, r) {
                return this.add(e, t || 0, n, r)
            }, g.appendMultiple = function (e, t, n, r) {
                return this.add(e, this._parseTimeOrLabel(null, t, !0, e), n, r)
            }, g.addLabel = function (e, t) {
                return this._labels[e] = this._parseTimeOrLabel(t), this
            }, g.addPause = function (e, t, n, r) {
                var i = a.delayedCall(0, f, n, r || this);
                return i.vars.onComplete = i.vars.onReverseComplete = t, i.data = "isPause", this._hasPause = !0, this.add(i, e)
            }, g.removeLabel = function (e) {
                return delete this._labels[e], this
            }, g.getLabelTime = function (e) {
                return null != this._labels[e] ? this._labels[e] : -1
            }, g._parseTimeOrLabel = function (e, t, n, r) {
                var o, a;
                if (r instanceof c && r.timeline === this) this.remove(r); else if (r && (r instanceof Array || r.push && i(r))) for (a = r.length; --a > -1;) r[a] instanceof c && r[a].timeline === this && this.remove(r[a]);
                if (o = "number" != typeof e || t ? this.duration() > 99999999999 ? this.recent().endTime(!1) : this._duration : 0, "string" == typeof t) return this._parseTimeOrLabel(t, n && "number" == typeof e && null == this._labels[t] ? e - o : 0, n);
                if (t = t || 0, "string" != typeof e || !isNaN(e) && null == this._labels[e]) null == e && (e = o); else {
                    if (-1 === (a = e.indexOf("="))) return null == this._labels[e] ? n ? this._labels[e] = o + t : t : this._labels[e] + t;
                    t = parseInt(e.charAt(a - 1) + "1", 10) * Number(e.substr(a + 1)), e = a > 1 ? this._parseTimeOrLabel(e.substr(0, a - 1), 0, n) : o
                }
                return Number(e) + t
            }, g.seek = function (e, t) {
                return this.totalTime("number" == typeof e ? e : this._parseTimeOrLabel(e), !1 !== t)
            }, g.stop = function () {
                return this.paused(!0)
            }, g.gotoAndPlay = function (e, t) {
                return this.play(e, t)
            }, g.gotoAndStop = function (e, t) {
                return this.pause(e, t)
            }, g.render = function (e, t, n) {
                this._gc && this._enabled(!0, !1);
                var r, i, o, a, u, c, p, d, h = this._time,
                    f = this._dirty ? this.totalDuration() : this._totalDuration, m = this._startTime,
                    _ = this._timeScale, g = this._paused;
                if (h !== this._time && (e += this._time - h), this._hasPause && !this._forcingPlayhead && !t) {
                    if (e > h) for (r = this._first; r && r._startTime <= e && !c;) r._duration || "isPause" !== r.data || r.ratio || 0 === r._startTime && 0 === this._rawPrevTime || (c = r), r = r._next; else for (r = this._last; r && r._startTime >= e && !c;) r._duration || "isPause" === r.data && r._rawPrevTime > 0 && (c = r), r = r._prev;
                    c && (this._time = this._totalTime = e = c._startTime, d = this._startTime + (this._reversed ? this._duration - e : e) / this._timeScale)
                }
                if (e >= f - 1e-8 && e >= 0) this._totalTime = this._time = f, this._reversed || this._hasPausedChild() || (i = !0, a = "onComplete", u = !!this._timeline.autoRemoveChildren, 0 === this._duration && (e <= 0 && e >= -1e-8 || this._rawPrevTime < 0 || 1e-8 === this._rawPrevTime) && this._rawPrevTime !== e && this._first && (u = !0, this._rawPrevTime > 1e-8 && (a = "onReverseComplete"))), this._rawPrevTime = this._duration || !t || e || this._rawPrevTime === e ? e : 1e-8, e = f + 1e-4; else if (e < 1e-8) if (this._totalTime = this._time = 0, e > -1e-8 && (e = 0), (0 !== h || 0 === this._duration && 1e-8 !== this._rawPrevTime && (this._rawPrevTime > 0 || e < 0 && this._rawPrevTime >= 0)) && (a = "onReverseComplete", i = this._reversed), e < 0) this._active = !1, this._timeline.autoRemoveChildren && this._reversed ? (u = i = !0, a = "onReverseComplete") : this._rawPrevTime >= 0 && this._first && (u = !0), this._rawPrevTime = e; else {
                    if (this._rawPrevTime = this._duration || !t || e || this._rawPrevTime === e ? e : 1e-8, 0 === e && i) for (r = this._first; r && 0 === r._startTime;) r._duration || (i = !1), r = r._next;
                    e = 0, this._initted || (u = !0)
                } else this._totalTime = this._time = this._rawPrevTime = e;
                if (this._time !== h && this._first || n || u || c) {
                    if (this._initted || (this._initted = !0), this._active || !this._paused && this._time !== h && e > 0 && (this._active = !0), 0 === h && this.vars.onStart && (0 === this._time && this._duration || t || this._callback("onStart")), (p = this._time) >= h) for (r = this._first; r && (o = r._next, p === this._time && (!this._paused || g));) (r._active || r._startTime <= p && !r._paused && !r._gc) && (c === r && (this.pause(), this._pauseTime = d), r._reversed ? r.render((r._dirty ? r.totalDuration() : r._totalDuration) - (e - r._startTime) * r._timeScale, t, n) : r.render((e - r._startTime) * r._timeScale, t, n)), r = o; else for (r = this._last; r && (o = r._prev, p === this._time && (!this._paused || g));) {
                        if (r._active || r._startTime <= h && !r._paused && !r._gc) {
                            if (c === r) {
                                for (c = r._prev; c && c.endTime() > this._time;) c.render(c._reversed ? c.totalDuration() - (e - c._startTime) * c._timeScale : (e - c._startTime) * c._timeScale, t, n), c = c._prev;
                                c = null, this.pause(), this._pauseTime = d
                            }
                            r._reversed ? r.render((r._dirty ? r.totalDuration() : r._totalDuration) - (e - r._startTime) * r._timeScale, t, n) : r.render((e - r._startTime) * r._timeScale, t, n)
                        }
                        r = o
                    }
                    this._onUpdate && (t || (s.length && l(), this._callback("onUpdate"))), a && (this._gc || m !== this._startTime && _ === this._timeScale || (0 === this._time || f >= this.totalDuration()) && (i && (s.length && l(), this._timeline.autoRemoveChildren && this._enabled(!1, !1), this._active = !1), !t && this.vars[a] && this._callback(a)))
                }
            }, g._hasPausedChild = function () {
                for (var t = this._first; t;) {
                    if (t._paused || t instanceof e && t._hasPausedChild()) return !0;
                    t = t._next
                }
                return !1
            }, g.getChildren = function (e, t, n, r) {
                r = r || -9999999999;
                for (var i = [], o = this._first, s = 0; o;) o._startTime < r || (o instanceof a ? !1 !== t && (i[s++] = o) : (!1 !== n && (i[s++] = o), !1 !== e && (s = (i = i.concat(o.getChildren(!0, t, n))).length))), o = o._next;
                return i
            }, g.getTweensOf = function (e, t) {
                var n, r, i = this._gc, o = [], s = 0;
                for (i && this._enabled(!0, !0), r = (n = a.getTweensOf(e)).length; --r > -1;) (n[r].timeline === this || t && this._contains(n[r])) && (o[s++] = n[r]);
                return i && this._enabled(!1, !0), o
            }, g.recent = function () {
                return this._recent
            }, g._contains = function (e) {
                for (var t = e.timeline; t;) {
                    if (t === this) return !0;
                    t = t.timeline
                }
                return !1
            }, g.shiftChildren = function (e, t, n) {
                n = n || 0;
                for (var r, i = this._first, o = this._labels; i;) i._startTime >= n && (i._startTime += e), i = i._next;
                if (t) for (r in o) o[r] >= n && (o[r] += e);
                return this._uncache(!0)
            }, g._kill = function (e, t) {
                if (!e && !t) return this._enabled(!1, !1);
                for (var n = t ? this.getTweensOf(t) : this.getChildren(!0, !0, !1), r = n.length, i = !1; --r > -1;) n[r]._kill(e, t) && (i = !0);
                return i
            }, g.clear = function (e) {
                var t = this.getChildren(!1, !0, !0), n = t.length;
                for (this._time = this._totalTime = 0; --n > -1;) t[n]._enabled(!1, !1);
                return !1 !== e && (this._labels = {}), this._uncache(!0)
            }, g.invalidate = function () {
                for (var e = this._first; e;) e.invalidate(), e = e._next;
                return c.prototype.invalidate.call(this)
            }, g._enabled = function (e, t) {
                if (e === this._gc) for (var n = this._first; n;) n._enabled(e, !0), n = n._next;
                return u.prototype._enabled.call(this, e, t)
            }, g.totalTime = function (e, t, n) {
                this._forcingPlayhead = !0;
                var r = c.prototype.totalTime.apply(this, arguments);
                return this._forcingPlayhead = !1, r
            }, g.duration = function (e) {
                return arguments.length ? (0 !== this.duration() && 0 !== e && this.timeScale(this._duration / e), this) : (this._dirty && this.totalDuration(), this._duration)
            }, g.totalDuration = function (e) {
                if (!arguments.length) {
                    if (this._dirty) {
                        for (var t, n, r = 0, i = this, o = i._last, a = 999999999999; o;) t = o._prev, o._dirty && o.totalDuration(), o._startTime > a && i._sortChildren && !o._paused && !i._calculatingDuration ? (i._calculatingDuration = 1, i.add(o, o._startTime - o._delay), i._calculatingDuration = 0) : a = o._startTime, o._startTime < 0 && !o._paused && (r -= o._startTime, i._timeline.smoothChildTiming && (i._startTime += o._startTime / i._timeScale, i._time -= o._startTime, i._totalTime -= o._startTime, i._rawPrevTime -= o._startTime), i.shiftChildren(-o._startTime, !1, -9999999999), a = 0), (n = o._startTime + o._totalDuration / o._timeScale) > r && (r = n), o = t;
                        i._duration = i._totalDuration = r, i._dirty = !1
                    }
                    return this._totalDuration
                }
                return e && this.totalDuration() ? this.timeScale(this._totalDuration / e) : this
            }, g.paused = function (e) {
                if (!1 === e && this._paused) for (var t = this._first; t;) t._startTime === this._time && "isPause" === t.data && (t._rawPrevTime = 0), t = t._next;
                return c.prototype.paused.apply(this, arguments)
            }, g.usesFrames = function () {
                for (var e = this._timeline; e._timeline;) e = e._timeline;
                return e === c._rootFramesTimeline
            }, g.rawTime = function (e) {
                return e && (this._paused || this._repeat && this.time() > 0 && this.totalProgress() < 1) ? this._totalTime % (this._duration + this._repeatDelay) : this._paused ? this._totalTime : (this._timeline.rawTime(e) - this._startTime) * this._timeScale
            }, e
        }), !0);
        var f = s.TimelineLite;
        /*!
 * VERSION: 2.1.3
 * DATE: 2019-05-17
 * UPDATES AND DOCS AT: http://greensock.com
 *
 * @license Copyright (c) 2008-2019, GreenSock. All rights reserved.
 * This work is subject to the terms at http://greensock.com/standard-license or for
 * Club GreenSock members, the software agreement that was issued with your membership.
 *
 * @author: Jack Doyle, jack@greensock.com
 */
        o._gsDefine("TimelineMax", ["TimelineLite", "TweenLite", "easing.Ease"], (function () {
            var e = function (e) {
                    f.call(this, e), this._repeat = this.vars.repeat || 0, this._repeatDelay = this.vars.repeatDelay || 0, this._cycle = 0, this._yoyo = !!this.vars.yoyo, this._dirty = !0
                }, t = a._internals, n = t.lazyTweens, r = t.lazyRender, i = o._gsDefine.globals,
                s = new p(null, null, 1, 0), l = e.prototype = new f;
            return l.constructor = e, l.kill()._gc = !1, e.version = "2.1.3", l.invalidate = function () {
                return this._yoyo = !!this.vars.yoyo, this._repeat = this.vars.repeat || 0, this._repeatDelay = this.vars.repeatDelay || 0, this._uncache(!0), f.prototype.invalidate.call(this)
            }, l.addCallback = function (e, t, n, r) {
                return this.add(a.delayedCall(0, e, n, r), t)
            }, l.removeCallback = function (e, t) {
                if (e) if (null == t) this._kill(null, e); else for (var n = this.getTweensOf(e, !1), r = n.length, i = this._parseTimeOrLabel(t); --r > -1;) n[r]._startTime === i && n[r]._enabled(!1, !1);
                return this
            }, l.removePause = function (e) {
                return this.removeCallback(f._internals.pauseCallback, e)
            }, l.tweenTo = function (e, t) {
                t = t || {};
                var n, r, o, l = {ease: s, useFrames: this.usesFrames(), immediateRender: !1, lazy: !1},
                    u = t.repeat && i.TweenMax || a;
                for (r in t) l[r] = t[r];
                return l.time = this._parseTimeOrLabel(e), n = Math.abs(Number(l.time) - this._time) / this._timeScale || .001, o = new u(this, n, l), l.onStart = function () {
                    o.target.paused(!0), o.vars.time === o.target.time() || n !== o.duration() || o.isFromTo || o.duration(Math.abs(o.vars.time - o.target.time()) / o.target._timeScale).render(o.time(), !0, !0), t.onStart && t.onStart.apply(t.onStartScope || t.callbackScope || o, t.onStartParams || [])
                }, o
            }, l.tweenFromTo = function (e, t, n) {
                n = n || {}, e = this._parseTimeOrLabel(e), n.startAt = {
                    onComplete: this.seek,
                    onCompleteParams: [e],
                    callbackScope: this
                }, n.immediateRender = !1 !== n.immediateRender;
                var r = this.tweenTo(t, n);
                return r.isFromTo = 1, r.duration(Math.abs(r.vars.time - e) / this._timeScale || .001)
            }, l.render = function (e, t, i) {
                this._gc && this._enabled(!0, !1);
                var o, a, s, l, u, c, p, d, h, f = this._time,
                    m = this._dirty ? this.totalDuration() : this._totalDuration, _ = this._duration,
                    g = this._totalTime, v = this._startTime, y = this._timeScale, b = this._rawPrevTime,
                    x = this._paused, T = this._cycle;
                if (f !== this._time && (e += this._time - f), e >= m - 1e-8 && e >= 0) this._locked || (this._totalTime = m, this._cycle = this._repeat), this._reversed || this._hasPausedChild() || (a = !0, l = "onComplete", u = !!this._timeline.autoRemoveChildren, 0 === this._duration && (e <= 0 && e >= -1e-8 || b < 0 || 1e-8 === b) && b !== e && this._first && (u = !0, b > 1e-8 && (l = "onReverseComplete"))), this._rawPrevTime = this._duration || !t || e || this._rawPrevTime === e ? e : 1e-8, this._yoyo && 1 & this._cycle ? this._time = e = 0 : (this._time = _, e = _ + 1e-4); else if (e < 1e-8) if (this._locked || (this._totalTime = this._cycle = 0), this._time = 0, e > -1e-8 && (e = 0), (0 !== f || 0 === _ && 1e-8 !== b && (b > 0 || e < 0 && b >= 0) && !this._locked) && (l = "onReverseComplete", a = this._reversed), e < 0) this._active = !1, this._timeline.autoRemoveChildren && this._reversed ? (u = a = !0, l = "onReverseComplete") : b >= 0 && this._first && (u = !0), this._rawPrevTime = e; else {
                    if (this._rawPrevTime = _ || !t || e || this._rawPrevTime === e ? e : 1e-8, 0 === e && a) for (o = this._first; o && 0 === o._startTime;) o._duration || (a = !1), o = o._next;
                    e = 0, this._initted || (u = !0)
                } else 0 === _ && b < 0 && (u = !0), this._time = this._rawPrevTime = e, this._locked || (this._totalTime = e, 0 !== this._repeat && (c = _ + this._repeatDelay, this._cycle = this._totalTime / c >> 0, this._cycle && this._cycle === this._totalTime / c && g <= e && this._cycle--, this._time = this._totalTime - this._cycle * c, this._yoyo && 1 & this._cycle && (this._time = _ - this._time), this._time > _ ? (this._time = _, e = _ + 1e-4) : this._time < 0 ? this._time = e = 0 : e = this._time));
                if (this._hasPause && !this._forcingPlayhead && !t) {
                    if ((e = this._time) > f || this._repeat && T !== this._cycle) for (o = this._first; o && o._startTime <= e && !p;) o._duration || "isPause" !== o.data || o.ratio || 0 === o._startTime && 0 === this._rawPrevTime || (p = o), o = o._next; else for (o = this._last; o && o._startTime >= e && !p;) o._duration || "isPause" === o.data && o._rawPrevTime > 0 && (p = o), o = o._prev;
                    p && (h = this._startTime + (this._reversed ? this._duration - p._startTime : p._startTime) / this._timeScale, p._startTime < _ && (this._time = this._rawPrevTime = e = p._startTime, this._totalTime = e + this._cycle * (this._totalDuration + this._repeatDelay)))
                }
                if (this._cycle !== T && !this._locked) {
                    var E = this._yoyo && 0 != (1 & T), C = E === (this._yoyo && 0 != (1 & this._cycle)),
                        S = this._totalTime, M = this._cycle, A = this._rawPrevTime, O = this._time;
                    if (this._totalTime = T * _, this._cycle < T ? E = !E : this._totalTime += _, this._time = f, this._rawPrevTime = 0 === _ ? b - 1e-4 : b, this._cycle = T, this._locked = !0, f = E ? 0 : _, this.render(f, t, 0 === _), t || this._gc || this.vars.onRepeat && (this._cycle = M, this._locked = !1, this._callback("onRepeat")), f !== this._time) return;
                    if (C && (this._cycle = T, this._locked = !0, f = E ? _ + 1e-4 : -1e-4, this.render(f, !0, !1)), this._locked = !1, this._paused && !x) return;
                    this._time = O, this._totalTime = S, this._cycle = M, this._rawPrevTime = A
                }
                if (this._time !== f && this._first || i || u || p) {
                    if (this._initted || (this._initted = !0), this._active || !this._paused && this._totalTime !== g && e > 0 && (this._active = !0), 0 === g && this.vars.onStart && (0 === this._totalTime && this._totalDuration || t || this._callback("onStart")), (d = this._time) >= f) for (o = this._first; o && (s = o._next, d === this._time && (!this._paused || x));) (o._active || o._startTime <= this._time && !o._paused && !o._gc) && (p === o && (this.pause(), this._pauseTime = h), o._reversed ? o.render((o._dirty ? o.totalDuration() : o._totalDuration) - (e - o._startTime) * o._timeScale, t, i) : o.render((e - o._startTime) * o._timeScale, t, i)), o = s; else for (o = this._last; o && (s = o._prev, d === this._time && (!this._paused || x));) {
                        if (o._active || o._startTime <= f && !o._paused && !o._gc) {
                            if (p === o) {
                                for (p = o._prev; p && p.endTime() > this._time;) p.render(p._reversed ? p.totalDuration() - (e - p._startTime) * p._timeScale : (e - p._startTime) * p._timeScale, t, i), p = p._prev;
                                p = null, this.pause(), this._pauseTime = h
                            }
                            o._reversed ? o.render((o._dirty ? o.totalDuration() : o._totalDuration) - (e - o._startTime) * o._timeScale, t, i) : o.render((e - o._startTime) * o._timeScale, t, i)
                        }
                        o = s
                    }
                    this._onUpdate && (t || (n.length && r(), this._callback("onUpdate"))), l && (this._locked || this._gc || v !== this._startTime && y === this._timeScale || (0 === this._time || m >= this.totalDuration()) && (a && (n.length && r(), this._timeline.autoRemoveChildren && this._enabled(!1, !1), this._active = !1), !t && this.vars[l] && this._callback(l)))
                } else g !== this._totalTime && this._onUpdate && (t || this._callback("onUpdate"))
            }, l.getActive = function (e, t, n) {
                var r, i, o = [], a = this.getChildren(e || null == e, t || null == e, !!n), s = 0, l = a.length;
                for (r = 0; r < l; r++) (i = a[r]).isActive() && (o[s++] = i);
                return o
            }, l.getLabelAfter = function (e) {
                e || 0 !== e && (e = this._time);
                var t, n = this.getLabelsArray(), r = n.length;
                for (t = 0; t < r; t++) if (n[t].time > e) return n[t].name;
                return null
            }, l.getLabelBefore = function (e) {
                null == e && (e = this._time);
                for (var t = this.getLabelsArray(), n = t.length; --n > -1;) if (t[n].time < e) return t[n].name;
                return null
            }, l.getLabelsArray = function () {
                var e, t = [], n = 0;
                for (e in this._labels) t[n++] = {time: this._labels[e], name: e};
                return t.sort((function (e, t) {
                    return e.time - t.time
                })), t
            }, l.invalidate = function () {
                return this._locked = !1, f.prototype.invalidate.call(this)
            }, l.progress = function (e, t) {
                return arguments.length ? this.totalTime(this.duration() * (this._yoyo && 0 != (1 & this._cycle) ? 1 - e : e) + this._cycle * (this._duration + this._repeatDelay), t) : this._time / this.duration() || 0
            }, l.totalProgress = function (e, t) {
                return arguments.length ? this.totalTime(this.totalDuration() * e, t) : this._totalTime / this.totalDuration() || 0
            }, l.totalDuration = function (e) {
                return arguments.length ? -1 !== this._repeat && e ? this.timeScale(this.totalDuration() / e) : this : (this._dirty && (f.prototype.totalDuration.call(this), this._totalDuration = -1 === this._repeat ? 999999999999 : this._duration * (this._repeat + 1) + this._repeatDelay * this._repeat), this._totalDuration)
            }, l.time = function (e, t) {
                if (!arguments.length) return this._time;
                this._dirty && this.totalDuration();
                var n = this._duration, r = this._cycle, i = r * (n + this._repeatDelay);
                return e > n && (e = n), this.totalTime(this._yoyo && 1 & r ? n - e + i : this._repeat ? e + i : e, t)
            }, l.repeat = function (e) {
                return arguments.length ? (this._repeat = e, this._uncache(!0)) : this._repeat
            }, l.repeatDelay = function (e) {
                return arguments.length ? (this._repeatDelay = e, this._uncache(!0)) : this._repeatDelay
            }, l.yoyo = function (e) {
                return arguments.length ? (this._yoyo = e, this) : this._yoyo
            }, l.currentLabel = function (e) {
                return arguments.length ? this.seek(e, !0) : this.getLabelBefore(this._time + 1e-8)
            }, e
        }), !0);
        var m = s.TimelineMax;
        /*!
 * VERSION: 2.1.3
 * DATE: 2019-05-17
 * UPDATES AND DOCS AT: http://greensock.com
 *
 * @license Copyright (c) 2008-2019, GreenSock. All rights reserved.
 * This work is subject to the terms at http://greensock.com/standard-license or for
 * Club GreenSock members, the software agreement that was issued with your membership.
 *
 * @author: Jack Doyle, jack@greensock.com
 **/
        o._gsDefine("TweenMax", ["core.Animation", "core.SimpleTimeline", "TweenLite"], (function () {
            var e = function (e) {
                var t, n = [], r = e.length;
                for (t = 0; t !== r; n.push(e[t++])) ;
                return n
            }, t = function (e, t, n) {
                var r, i, o = e.cycle;
                for (r in o) i = o[r], e[r] = "function" == typeof i ? i(n, t[n], t) : i[n % i.length];
                delete e.cycle
            }, n = function (e) {
                if ("function" == typeof e) return e;
                var t = "object" == typeof e ? e : {each: e}, n = t.ease, r = t.from || 0, i = t.base || 0, o = {},
                    a = isNaN(r), s = t.axis, l = {center: .5, end: 1}[r] || 0;
                return function (e, u, c) {
                    var p, d, h, f, m, _, g, v, y, b = (c || t).length, x = o[b];
                    if (!x) {
                        if (!(y = "auto" === t.grid ? 0 : (t.grid || [1 / 0])[0])) {
                            for (g = -1 / 0; g < (g = c[y++].getBoundingClientRect().left) && y < b;) ;
                            y--
                        }
                        for (x = o[b] = [], p = a ? Math.min(y, b) * l - .5 : r % y, d = a ? b * l / y - .5 : r / y | 0, g = 0, v = 1 / 0, _ = 0; _ < b; _++) h = _ % y - p, f = d - (_ / y | 0), x[_] = m = s ? Math.abs("y" === s ? f : h) : Math.sqrt(h * h + f * f), m > g && (g = m), m < v && (v = m);
                        x.max = g - v, x.min = v, x.v = b = t.amount || t.each * (y > b ? b - 1 : s ? "y" === s ? b / y : y : Math.max(y, b / y)) || 0, x.b = b < 0 ? i - b : i
                    }
                    return b = (x[e] - x.min) / x.max, x.b + (n ? n.getRatio(b) : b) * x.v
                }
            }, r = function (e, t, n) {
                a.call(this, e, t, n), this._cycle = 0, this._yoyo = !0 === this.vars.yoyo || !!this.vars.yoyoEase, this._repeat = this.vars.repeat || 0, this._repeatDelay = this.vars.repeatDelay || 0, this._repeat && this._uncache(!0), this.render = r.prototype.render
            }, i = a._internals, o = i.isSelector, s = i.isArray, l = r.prototype = a.to({}, .1, {}), d = [];
            r.version = "2.1.3", l.constructor = r, l.kill()._gc = !1, r.killTweensOf = r.killDelayedCallsTo = a.killTweensOf, r.getTweensOf = a.getTweensOf, r.lagSmoothing = a.lagSmoothing, r.ticker = a.ticker, r.render = a.render, r.distribute = n, l.invalidate = function () {
                return this._yoyo = !0 === this.vars.yoyo || !!this.vars.yoyoEase, this._repeat = this.vars.repeat || 0, this._repeatDelay = this.vars.repeatDelay || 0, this._yoyoEase = null, this._uncache(!0), a.prototype.invalidate.call(this)
            }, l.updateTo = function (e, t) {
                var n, r = this.ratio, i = this.vars.immediateRender || e.immediateRender;
                for (n in t && this._startTime < this._timeline._time && (this._startTime = this._timeline._time, this._uncache(!1), this._gc ? this._enabled(!0, !1) : this._timeline.insert(this, this._startTime - this._delay)), e) this.vars[n] = e[n];
                if (this._initted || i) if (t) this._initted = !1, i && this.render(0, !0, !0); else if (this._gc && this._enabled(!0, !1), this._notifyPluginsOfEnabled && this._firstPT && a._onPluginEvent("_onDisable", this), this._time / this._duration > .998) {
                    var o = this._totalTime;
                    this.render(0, !0, !1), this._initted = !1, this.render(o, !0, !1)
                } else if (this._initted = !1, this._init(), this._time > 0 || i) for (var s, l = 1 / (1 - r), u = this._firstPT; u;) s = u.s + u.c, u.c *= l, u.s = s - u.c, u = u._next;
                return this
            }, l.render = function (e, t, n) {
                this._initted || 0 === this._duration && this.vars.repeat && this.invalidate();
                var r, o, s, l, u, c, d, h, f, m = this._dirty ? this.totalDuration() : this._totalDuration,
                    _ = this._time, g = this._totalTime, v = this._cycle, y = this._duration, b = this._rawPrevTime;
                if (e >= m - 1e-8 && e >= 0 ? (this._totalTime = m, this._cycle = this._repeat, this._yoyo && 0 != (1 & this._cycle) ? (this._time = 0, this.ratio = this._ease._calcEnd ? this._ease.getRatio(0) : 0) : (this._time = y, this.ratio = this._ease._calcEnd ? this._ease.getRatio(1) : 1), this._reversed || (r = !0, o = "onComplete", n = n || this._timeline.autoRemoveChildren), 0 === y && (this._initted || !this.vars.lazy || n) && (this._startTime === this._timeline._duration && (e = 0), (b < 0 || e <= 0 && e >= -1e-8 || 1e-8 === b && "isPause" !== this.data) && b !== e && (n = !0, b > 1e-8 && (o = "onReverseComplete")), this._rawPrevTime = h = !t || e || b === e ? e : 1e-8)) : e < 1e-8 ? (this._totalTime = this._time = this._cycle = 0, this.ratio = this._ease._calcEnd ? this._ease.getRatio(0) : 0, (0 !== g || 0 === y && b > 0) && (o = "onReverseComplete", r = this._reversed), e > -1e-8 ? e = 0 : e < 0 && (this._active = !1, 0 === y && (this._initted || !this.vars.lazy || n) && (b >= 0 && (n = !0), this._rawPrevTime = h = !t || e || b === e ? e : 1e-8)), this._initted || (n = !0)) : (this._totalTime = this._time = e, 0 !== this._repeat && (l = y + this._repeatDelay, this._cycle = this._totalTime / l >> 0, 0 !== this._cycle && this._cycle === this._totalTime / l && g <= e && this._cycle--, this._time = this._totalTime - this._cycle * l, this._yoyo && 0 != (1 & this._cycle) && (this._time = y - this._time, (f = this._yoyoEase || this.vars.yoyoEase) && (this._yoyoEase || (!0 !== f || this._initted ? this._yoyoEase = f = !0 === f ? this._ease : f instanceof p ? f : p.map[f] : (f = this.vars.ease, this._yoyoEase = f = f ? f instanceof p ? f : "function" == typeof f ? new p(f, this.vars.easeParams) : p.map[f] || a.defaultEase : a.defaultEase)), this.ratio = f ? 1 - f.getRatio((y - this._time) / y) : 0)), this._time > y ? this._time = y : this._time < 0 && (this._time = 0)), this._easeType && !f ? (u = this._time / y, (1 === (c = this._easeType) || 3 === c && u >= .5) && (u = 1 - u), 3 === c && (u *= 2), 1 === (d = this._easePower) ? u *= u : 2 === d ? u *= u * u : 3 === d ? u *= u * u * u : 4 === d && (u *= u * u * u * u), this.ratio = 1 === c ? 1 - u : 2 === c ? u : this._time / y < .5 ? u / 2 : 1 - u / 2) : f || (this.ratio = this._ease.getRatio(this._time / y))), _ !== this._time || n || v !== this._cycle) {
                    if (!this._initted) {
                        if (this._init(), !this._initted || this._gc) return;
                        if (!n && this._firstPT && (!1 !== this.vars.lazy && this._duration || this.vars.lazy && !this._duration)) return this._time = _, this._totalTime = g, this._rawPrevTime = b, this._cycle = v, i.lazyTweens.push(this), void (this._lazy = [e, t]);
                        !this._time || r || f ? r && this._ease._calcEnd && !f && (this.ratio = this._ease.getRatio(0 === this._time ? 0 : 1)) : this.ratio = this._ease.getRatio(this._time / y)
                    }
                    for (!1 !== this._lazy && (this._lazy = !1), this._active || !this._paused && this._time !== _ && e >= 0 && (this._active = !0), 0 === g && (2 === this._initted && e > 0 && this._init(), this._startAt && (e >= 0 ? this._startAt.render(e, !0, n) : o || (o = "_dummyGS")), this.vars.onStart && (0 === this._totalTime && 0 !== y || t || this._callback("onStart"))), s = this._firstPT; s;) s.f ? s.t[s.p](s.c * this.ratio + s.s) : s.t[s.p] = s.c * this.ratio + s.s, s = s._next;
                    this._onUpdate && (e < 0 && this._startAt && this._startTime && this._startAt.render(e, !0, n), t || (this._totalTime !== g || o) && this._callback("onUpdate")), this._cycle !== v && (t || this._gc || this.vars.onRepeat && this._callback("onRepeat")), o && (this._gc && !n || (e < 0 && this._startAt && !this._onUpdate && this._startTime && this._startAt.render(e, !0, n), r && (this._timeline.autoRemoveChildren && this._enabled(!1, !1), this._active = !1), !t && this.vars[o] && this._callback(o), 0 === y && 1e-8 === this._rawPrevTime && 1e-8 !== h && (this._rawPrevTime = 0)))
                } else g !== this._totalTime && this._onUpdate && (t || this._callback("onUpdate"))
            }, r.to = function (e, t, n) {
                return new r(e, t, n)
            }, r.from = function (e, t, n) {
                return n.runBackwards = !0, n.immediateRender = 0 != n.immediateRender, new r(e, t, n)
            }, r.fromTo = function (e, t, n, i) {
                return i.startAt = n, i.immediateRender = 0 != i.immediateRender && 0 != n.immediateRender, new r(e, t, i)
            }, r.staggerTo = r.allTo = function (i, l, u, c, p, h, f) {
                var m, _, g, v, y = [], b = n(u.stagger || c), x = u.cycle, T = (u.startAt || d).cycle;
                for (s(i) || ("string" == typeof i && (i = a.selector(i) || i), o(i) && (i = e(i))), m = (i = i || []).length - 1, g = 0; g <= m; g++) {
                    for (v in _ = {}, u) _[v] = u[v];
                    if (x && (t(_, i, g), null != _.duration && (l = _.duration, delete _.duration)), T) {
                        for (v in T = _.startAt = {}, u.startAt) T[v] = u.startAt[v];
                        t(_.startAt, i, g)
                    }
                    _.delay = b(g, i[g], i) + (_.delay || 0), g === m && p && (_.onComplete = function () {
                        u.onComplete && u.onComplete.apply(u.onCompleteScope || this, arguments), p.apply(f || u.callbackScope || this, h || d)
                    }), y[g] = new r(i[g], l, _)
                }
                return y
            }, r.staggerFrom = r.allFrom = function (e, t, n, i, o, a, s) {
                return n.runBackwards = !0, n.immediateRender = 0 != n.immediateRender, r.staggerTo(e, t, n, i, o, a, s)
            }, r.staggerFromTo = r.allFromTo = function (e, t, n, i, o, a, s, l) {
                return i.startAt = n, i.immediateRender = 0 != i.immediateRender && 0 != n.immediateRender, r.staggerTo(e, t, i, o, a, s, l)
            }, r.delayedCall = function (e, t, n, i, o) {
                return new r(t, 0, {
                    delay: e,
                    onComplete: t,
                    onCompleteParams: n,
                    callbackScope: i,
                    onReverseComplete: t,
                    onReverseCompleteParams: n,
                    immediateRender: !1,
                    useFrames: o,
                    overwrite: 0
                })
            }, r.set = function (e, t) {
                return new r(e, 0, t)
            }, r.isTweening = function (e) {
                return a.getTweensOf(e, !0).length > 0
            };
            var h = function (e, t) {
                for (var n = [], r = 0, i = e._first; i;) i instanceof a ? n[r++] = i : (t && (n[r++] = i), r = (n = n.concat(h(i, t))).length), i = i._next;
                return n
            }, f = r.getAllTweens = function (e) {
                return h(c._rootTimeline, e).concat(h(c._rootFramesTimeline, e))
            };
            r.killAll = function (e, t, n, r) {
                null == t && (t = !0), null == n && (n = !0);
                var i, o, a, s = f(0 != r), l = s.length, c = t && n && r;
                for (a = 0; a < l; a++) o = s[a], (c || o instanceof u || (i = o.target === o.vars.onComplete) && n || t && !i) && (e ? o.totalTime(o._reversed ? 0 : o.totalDuration()) : o._enabled(!1, !1))
            }, r.killChildTweensOf = function (t, n) {
                if (null != t) {
                    var l, u, c, p, d, h = i.tweenLookup;
                    if ("string" == typeof t && (t = a.selector(t) || t), o(t) && (t = e(t)), s(t)) for (p = t.length; --p > -1;) r.killChildTweensOf(t[p], n); else {
                        for (c in l = [], h) for (u = h[c].target.parentNode; u;) u === t && (l = l.concat(h[c].tweens)), u = u.parentNode;
                        for (d = l.length, p = 0; p < d; p++) n && l[p].totalTime(l[p].totalDuration()), l[p]._enabled(!1, !1)
                    }
                }
            };
            var m = function (e, t, n, r) {
                t = !1 !== t, n = !1 !== n;
                for (var i, o, a = f(r = !1 !== r), s = t && n && r, l = a.length; --l > -1;) o = a[l], (s || o instanceof u || (i = o.target === o.vars.onComplete) && n || t && !i) && o.paused(e)
            };
            return r.pauseAll = function (e, t, n) {
                m(!0, e, t, n)
            }, r.resumeAll = function (e, t, n) {
                m(!1, e, t, n)
            }, r.globalTimeScale = function (e) {
                var t = c._rootTimeline, n = a.ticker.time;
                return arguments.length ? (e = e || 1e-8, t._startTime = n - (n - t._startTime) * t._timeScale / e, t = c._rootFramesTimeline, n = a.ticker.frame, t._startTime = n - (n - t._startTime) * t._timeScale / e, t._timeScale = c._rootTimeline._timeScale = e, e) : t._timeScale
            }, l.progress = function (e, t) {
                return arguments.length ? this.totalTime(this.duration() * (this._yoyo && 0 != (1 & this._cycle) ? 1 - e : e) + this._cycle * (this._duration + this._repeatDelay), t) : this.duration() ? this._time / this._duration : this.ratio
            }, l.totalProgress = function (e, t) {
                return arguments.length ? this.totalTime(this.totalDuration() * e, t) : this._totalTime / this.totalDuration()
            }, l.time = function (e, t) {
                if (!arguments.length) return this._time;
                this._dirty && this.totalDuration();
                var n = this._duration, r = this._cycle, i = r * (n + this._repeatDelay);
                return e > n && (e = n), this.totalTime(this._yoyo && 1 & r ? n - e + i : this._repeat ? e + i : e, t)
            }, l.duration = function (e) {
                return arguments.length ? c.prototype.duration.call(this, e) : this._duration
            }, l.totalDuration = function (e) {
                return arguments.length ? -1 === this._repeat ? this : this.duration((e - this._repeat * this._repeatDelay) / (this._repeat + 1)) : (this._dirty && (this._totalDuration = -1 === this._repeat ? 999999999999 : this._duration * (this._repeat + 1) + this._repeatDelay * this._repeat, this._dirty = !1), this._totalDuration)
            }, l.repeat = function (e) {
                return arguments.length ? (this._repeat = e, this._uncache(!0)) : this._repeat
            }, l.repeatDelay = function (e) {
                return arguments.length ? (this._repeatDelay = e, this._uncache(!0)) : this._repeatDelay
            }, l.yoyo = function (e) {
                return arguments.length ? (this._yoyo = e, this) : this._yoyo
            }, r
        }), !0);
        var _ = s.TweenMax;
        /*!
 * VERSION: 2.1.3
 * DATE: 2019-05-17
 * UPDATES AND DOCS AT: http://greensock.com
 *
 * @license Copyright (c) 2008-2019, GreenSock. All rights reserved.
 * This work is subject to the terms at http://greensock.com/standard-license or for
 * Club GreenSock members, the software agreement that was issued with your membership.
 *
 * @author: Jack Doyle, jack@greensock.com
 */
        o._gsDefine("plugins.CSSPlugin", ["plugins.TweenPlugin", "TweenLite"], (function () {
            var e, t, n, r, i = function () {
                h.call(this, "css"), this._overwriteProps.length = 0, this.setRatio = i.prototype.setRatio
            }, s = o._gsDefine.globals, l = {}, u = i.prototype = new h("css");
            u.constructor = i, i.version = "2.1.3", i.API = 2, i.defaultTransformPerspective = 0, i.defaultSkewType = "compensated", i.defaultSmoothOrigin = !0, u = "px", i.suffixMap = {
                top: u,
                right: u,
                bottom: u,
                left: u,
                width: u,
                height: u,
                fontSize: u,
                padding: u,
                margin: u,
                perspective: u,
                lineHeight: ""
            };
            var c, p, d, f, m, _, g, v, y = /(?:\-|\.|\b)(\d|\.|e\-)+/g,
                b = /(?:\d|\-\d|\.\d|\-\.\d|\+=\d|\-=\d|\+=.\d|\-=\.\d)+/g,
                x = /(?:\+=|\-=|\-|\b)[\d\-\.]+[a-zA-Z0-9]*(?:%|\b)/gi,
                T = /(?:\+=|\-=|\-|\b)[\d\-\.]+[a-zA-Z0-9]*(?:%|\b),?/gi, E = /(?![+-]?\d*\.?\d+|[+-]|e[+-]\d+)[^0-9]/g,
                C = /(?:\d|\-|\+|=|#|\.)*/g, S = /opacity *= *([^)]*)/i, M = /opacity:([^;]*)/i,
                A = /alpha\(opacity *=.+?\)/i, O = /^(rgb|hsl)/, w = /([A-Z])/g, R = /-([a-z])/gi,
                P = /(^(?:url\(\"|url\())|(?:(\"\))$|\)$)/gi, L = function (e, t) {
                    return t.toUpperCase()
                }, D = /(?:Left|Right|Width)/i, I = /(M11|M12|M21|M22)=[\d\-\.e]+/gi,
                N = /progid\:DXImageTransform\.Microsoft\.Matrix\(.+?\)/i, z = /,(?=[^\)]*(?:\(|$))/gi, U = /[\s,\(]/i,
                F = Math.PI / 180, k = 180 / Math.PI, V = {}, B = {style: {}}, G = o.document || {
                    createElement: function () {
                        return B
                    }
                }, j = function (e, t) {
                    var n = G.createElementNS ? G.createElementNS(t || "http://www.w3.org/1999/xhtml", e) : G.createElement(e);
                    return n.style ? n : G.createElement(e)
                }, H = j("div"), W = j("img"), X = i._internals = {_specialProps: l},
                Y = (o.navigator || {}).userAgent || "", q = function () {
                    var e = Y.indexOf("Android"), t = j("a");
                    return d = -1 !== Y.indexOf("Safari") && -1 === Y.indexOf("Chrome") && (-1 === e || parseFloat(Y.substr(e + 8, 2)) > 3), m = d && parseFloat(Y.substr(Y.indexOf("Version/") + 8, 2)) < 6, f = -1 !== Y.indexOf("Firefox"), (/MSIE ([0-9]{1,}[\.0-9]{0,})/.exec(Y) || /Trident\/.*rv:([0-9]{1,}[\.0-9]{0,})/.exec(Y)) && (_ = parseFloat(RegExp.$1)), !!t && (t.style.cssText = "top:1px;opacity:.55;", /^0.55/.test(t.style.opacity))
                }(), Z = function (e) {
                    return S.test("string" == typeof e ? e : (e.currentStyle ? e.currentStyle.filter : e.style.filter) || "") ? parseFloat(RegExp.$1) / 100 : 1
                }, K = function (e) {
                    o.console && console.log(e)
                }, Q = "", J = "", $ = function (e, t) {
                    var n, r, i = (t = t || H).style;
                    if (void 0 !== i[e]) return e;
                    for (e = e.charAt(0).toUpperCase() + e.substr(1), n = ["O", "Moz", "ms", "Ms", "Webkit"], r = 5; --r > -1 && void 0 === i[n[r] + e];) ;
                    return r >= 0 ? (Q = "-" + (J = 3 === r ? "ms" : n[r]).toLowerCase() + "-", J + e) : null
                }, ee = "undefined" != typeof window ? window : G.defaultView || {
                    getComputedStyle: function () {
                    }
                }, te = function (e) {
                    return ee.getComputedStyle(e)
                }, ne = i.getStyle = function (e, t, n, r, i) {
                    var o;
                    return q || "opacity" !== t ? (!r && e.style[t] ? o = e.style[t] : (n = n || te(e)) ? o = n[t] || n.getPropertyValue(t) || n.getPropertyValue(t.replace(w, "-$1").toLowerCase()) : e.currentStyle && (o = e.currentStyle[t]), null == i || o && "none" !== o && "auto" !== o && "auto auto" !== o ? o : i) : Z(e)
                }, re = X.convertToPixels = function (e, t, n, r, o) {
                    if ("px" === r || !r && "lineHeight" !== t) return n;
                    if ("auto" === r || !n) return 0;
                    var s, l, u, c = D.test(t), p = e, d = H.style, h = n < 0, f = 1 === n;
                    if (h && (n = -n), f && (n *= 100), "lineHeight" !== t || r) if ("%" === r && -1 !== t.indexOf("border")) s = n / 100 * (c ? e.clientWidth : e.clientHeight); else {
                        if (d.cssText = "border:0 solid red;position:" + ne(e, "position") + ";line-height:0;", "%" !== r && p.appendChild && "v" !== r.charAt(0) && "rem" !== r) d[c ? "borderLeftWidth" : "borderTopWidth"] = n + r; else {
                            if (p = e.parentNode || G.body, -1 !== ne(p, "display").indexOf("flex") && (d.position = "absolute"), l = p._gsCache, u = a.ticker.frame, l && c && l.time === u) return l.width * n / 100;
                            d[c ? "width" : "height"] = n + r
                        }
                        p.appendChild(H), s = parseFloat(H[c ? "offsetWidth" : "offsetHeight"]), p.removeChild(H), c && "%" === r && !1 !== i.cacheWidths && ((l = p._gsCache = p._gsCache || {}).time = u, l.width = s / n * 100), 0 !== s || o || (s = re(e, t, n, r, !0))
                    } else l = te(e).lineHeight, e.style.lineHeight = n, s = parseFloat(te(e).lineHeight), e.style.lineHeight = l;
                    return f && (s /= 100), h ? -s : s
                }, ie = X.calculateOffset = function (e, t, n) {
                    if ("absolute" !== ne(e, "position", n)) return 0;
                    var r = "left" === t ? "Left" : "Top", i = ne(e, "margin" + r, n);
                    return e["offset" + r] - (re(e, t, parseFloat(i), i.replace(C, "")) || 0)
                }, oe = function (e, t) {
                    var n, r, i, o = {};
                    if (t = t || te(e)) if (n = t.length) for (; --n > -1;) -1 !== (i = t[n]).indexOf("-transform") && ze !== i || (o[i.replace(R, L)] = t.getPropertyValue(i)); else for (n in t) -1 !== n.indexOf("Transform") && Ne !== n || (o[n] = t[n]); else if (t = e.currentStyle || e.style) for (n in t) "string" == typeof n && void 0 === o[n] && (o[n.replace(R, L)] = t[n]);
                    return q || (o.opacity = Z(e)), r = Ze(e, t, !1), o.rotation = r.rotation, o.skewX = r.skewX, o.scaleX = r.scaleX, o.scaleY = r.scaleY, o.x = r.x, o.y = r.y, Fe && (o.z = r.z, o.rotationX = r.rotationX, o.rotationY = r.rotationY, o.scaleZ = r.scaleZ), o.filters && delete o.filters, o
                }, ae = function (e, t, n, r, i) {
                    var o, a, s, l = {}, u = e.style;
                    for (a in n) "cssText" !== a && "length" !== a && isNaN(a) && (t[a] !== (o = n[a]) || i && i[a]) && -1 === a.indexOf("Origin") && ("number" != typeof o && "string" != typeof o || (l[a] = "auto" !== o || "left" !== a && "top" !== a ? "" !== o && "auto" !== o && "none" !== o || "string" != typeof t[a] || "" === t[a].replace(E, "") ? o : 0 : ie(e, a), void 0 !== u[a] && (s = new xe(u, a, u[a], s))));
                    if (r) for (a in r) "className" !== a && (l[a] = r[a]);
                    return {difs: l, firstMPT: s}
                }, se = {width: ["Left", "Right"], height: ["Top", "Bottom"]},
                le = ["marginLeft", "marginRight", "marginTop", "marginBottom"], ue = function (e, t, n) {
                    if ("svg" === (e.nodeName + "").toLowerCase()) return (n || te(e))[t] || 0;
                    if (e.getCTM && Xe(e)) return e.getBBox()[t] || 0;
                    var r = parseFloat("width" === t ? e.offsetWidth : e.offsetHeight), i = se[t], o = i.length;
                    for (n = n || te(e); --o > -1;) r -= parseFloat(ne(e, "padding" + i[o], n, !0)) || 0, r -= parseFloat(ne(e, "border" + i[o] + "Width", n, !0)) || 0;
                    return r
                }, ce = function (e, t) {
                    if ("contain" === e || "auto" === e || "auto auto" === e) return e + " ";
                    null != e && "" !== e || (e = "0 0");
                    var n, r = e.split(" "),
                        i = -1 !== e.indexOf("left") ? "0%" : -1 !== e.indexOf("right") ? "100%" : r[0],
                        o = -1 !== e.indexOf("top") ? "0%" : -1 !== e.indexOf("bottom") ? "100%" : r[1];
                    if (r.length > 3 && !t) {
                        for (r = e.split(", ").join(",").split(","), e = [], n = 0; n < r.length; n++) e.push(ce(r[n]));
                        return e.join(",")
                    }
                    return null == o ? o = "center" === i ? "50%" : "0" : "center" === o && (o = "50%"), ("center" === i || isNaN(parseFloat(i)) && -1 === (i + "").indexOf("=")) && (i = "50%"), e = i + " " + o + (r.length > 2 ? " " + r[2] : ""), t && (t.oxp = -1 !== i.indexOf("%"), t.oyp = -1 !== o.indexOf("%"), t.oxr = "=" === i.charAt(1), t.oyr = "=" === o.charAt(1), t.ox = parseFloat(i.replace(E, "")), t.oy = parseFloat(o.replace(E, "")), t.v = e), t || e
                }, pe = function (e, t) {
                    return "function" == typeof e && (e = e(v, g)), "string" == typeof e && "=" === e.charAt(1) ? parseInt(e.charAt(0) + "1", 10) * parseFloat(e.substr(2)) : parseFloat(e) - parseFloat(t) || 0
                }, de = function (e, t) {
                    "function" == typeof e && (e = e(v, g));
                    var n = "string" == typeof e && "=" === e.charAt(1);
                    return "string" == typeof e && "v" === e.charAt(e.length - 2) && (e = (n ? e.substr(0, 2) : 0) + window["inner" + ("vh" === e.substr(-2) ? "Height" : "Width")] * (parseFloat(n ? e.substr(2) : e) / 100)), null == e ? t : n ? parseInt(e.charAt(0) + "1", 10) * parseFloat(e.substr(2)) + t : parseFloat(e) || 0
                }, he = function (e, t, n, r) {
                    var i, o, a, s;
                    return "function" == typeof e && (e = e(v, g)), null == e ? a = t : "number" == typeof e ? a = e : (360, i = e.split("_"), o = ((s = "=" === e.charAt(1)) ? parseInt(e.charAt(0) + "1", 10) * parseFloat(i[0].substr(2)) : parseFloat(i[0])) * (-1 === e.indexOf("rad") ? 1 : k) - (s ? 0 : t), i.length && (r && (r[n] = t + o), -1 !== e.indexOf("short") && (o %= 360) !== o % 180 && (o = o < 0 ? o + 360 : o - 360), -1 !== e.indexOf("_cw") && o < 0 ? o = (o + 3599999999640) % 360 - 360 * (o / 360 | 0) : -1 !== e.indexOf("ccw") && o > 0 && (o = (o - 3599999999640) % 360 - 360 * (o / 360 | 0))), a = t + o), a < 1e-6 && a > -1e-6 && (a = 0), a
                }, fe = {
                    aqua: [0, 255, 255],
                    lime: [0, 255, 0],
                    silver: [192, 192, 192],
                    black: [0, 0, 0],
                    maroon: [128, 0, 0],
                    teal: [0, 128, 128],
                    blue: [0, 0, 255],
                    navy: [0, 0, 128],
                    white: [255, 255, 255],
                    fuchsia: [255, 0, 255],
                    olive: [128, 128, 0],
                    yellow: [255, 255, 0],
                    orange: [255, 165, 0],
                    gray: [128, 128, 128],
                    purple: [128, 0, 128],
                    green: [0, 128, 0],
                    red: [255, 0, 0],
                    pink: [255, 192, 203],
                    cyan: [0, 255, 255],
                    transparent: [255, 255, 255, 0]
                }, me = function (e, t, n) {
                    return 255 * (6 * (e = e < 0 ? e + 1 : e > 1 ? e - 1 : e) < 1 ? t + (n - t) * e * 6 : e < .5 ? n : 3 * e < 2 ? t + (n - t) * (2 / 3 - e) * 6 : t) + .5 | 0
                }, _e = i.parseColor = function (e, t) {
                    var n, r, i, o, a, s, l, u, c, p, d;
                    if (e) if ("number" == typeof e) n = [e >> 16, e >> 8 & 255, 255 & e]; else {
                        if ("," === e.charAt(e.length - 1) && (e = e.substr(0, e.length - 1)), fe[e]) n = fe[e]; else if ("#" === e.charAt(0)) 4 === e.length && (r = e.charAt(1), i = e.charAt(2), o = e.charAt(3), e = "#" + r + r + i + i + o + o), n = [(e = parseInt(e.substr(1), 16)) >> 16, e >> 8 & 255, 255 & e]; else if ("hsl" === e.substr(0, 3)) if (n = d = e.match(y), t) {
                            if (-1 !== e.indexOf("=")) return e.match(b)
                        } else a = Number(n[0]) % 360 / 360, s = Number(n[1]) / 100, r = 2 * (l = Number(n[2]) / 100) - (i = l <= .5 ? l * (s + 1) : l + s - l * s), n.length > 3 && (n[3] = Number(n[3])), n[0] = me(a + 1 / 3, r, i), n[1] = me(a, r, i), n[2] = me(a - 1 / 3, r, i); else n = e.match(y) || fe.transparent;
                        n[0] = Number(n[0]), n[1] = Number(n[1]), n[2] = Number(n[2]), n.length > 3 && (n[3] = Number(n[3]))
                    } else n = fe.black;
                    return t && !d && (r = n[0] / 255, i = n[1] / 255, o = n[2] / 255, l = ((u = Math.max(r, i, o)) + (c = Math.min(r, i, o))) / 2, u === c ? a = s = 0 : (p = u - c, s = l > .5 ? p / (2 - u - c) : p / (u + c), a = u === r ? (i - o) / p + (i < o ? 6 : 0) : u === i ? (o - r) / p + 2 : (r - i) / p + 4, a *= 60), n[0] = a + .5 | 0, n[1] = 100 * s + .5 | 0, n[2] = 100 * l + .5 | 0), n
                }, ge = function (e, t) {
                    var n, r, i, o = e.match(ve) || [], a = 0, s = "";
                    if (!o.length) return e;
                    for (n = 0; n < o.length; n++) r = o[n], a += (i = e.substr(a, e.indexOf(r, a) - a)).length + r.length, 3 === (r = _e(r, t)).length && r.push(1), s += i + (t ? "hsla(" + r[0] + "," + r[1] + "%," + r[2] + "%," + r[3] : "rgba(" + r.join(",")) + ")";
                    return s + e.substr(a)
                }, ve = "(?:\\b(?:(?:rgb|rgba|hsl|hsla)\\(.+?\\))|\\B#(?:[0-9a-f]{3}){1,2}\\b";
            for (u in fe) ve += "|" + u + "\\b";
            ve = new RegExp(ve + ")", "gi"), i.colorStringFilter = function (e) {
                var t, n = e[0] + " " + e[1];
                ve.test(n) && (t = -1 !== n.indexOf("hsl(") || -1 !== n.indexOf("hsla("), e[0] = ge(e[0], t), e[1] = ge(e[1], t)), ve.lastIndex = 0
            }, a.defaultStringFilter || (a.defaultStringFilter = i.colorStringFilter);
            var ye = function (e, t, n, r) {
                if (null == e) return function (e) {
                    return e
                };
                var i, o = t ? (e.match(ve) || [""])[0] : "", a = e.split(o).join("").match(x) || [],
                    s = e.substr(0, e.indexOf(a[0])), l = ")" === e.charAt(e.length - 1) ? ")" : "",
                    u = -1 !== e.indexOf(" ") ? " " : ",", c = a.length, p = c > 0 ? a[0].replace(y, "") : "";
                return c ? i = t ? function (e) {
                    var t, d, h, f;
                    if ("number" == typeof e) e += p; else if (r && z.test(e)) {
                        for (f = e.replace(z, "|").split("|"), h = 0; h < f.length; h++) f[h] = i(f[h]);
                        return f.join(",")
                    }
                    if (t = (e.match(ve) || [o])[0], h = (d = e.split(t).join("").match(x) || []).length, c > h--) for (; ++h < c;) d[h] = n ? d[(h - 1) / 2 | 0] : a[h];
                    return s + d.join(u) + u + t + l + (-1 !== e.indexOf("inset") ? " inset" : "")
                } : function (e) {
                    var t, o, d;
                    if ("number" == typeof e) e += p; else if (r && z.test(e)) {
                        for (o = e.replace(z, "|").split("|"), d = 0; d < o.length; d++) o[d] = i(o[d]);
                        return o.join(",")
                    }
                    if (d = (t = e.match("," === u ? x : T) || []).length, c > d--) for (; ++d < c;) t[d] = n ? t[(d - 1) / 2 | 0] : a[d];
                    return (s && "none" !== e && e.substr(0, e.indexOf(t[0])) || s) + t.join(u) + l
                } : function (e) {
                    return e
                }
            }, be = function (e) {
                return e = e.split(","), function (t, n, r, i, o, a, s) {
                    var l, u = (n + "").split(" ");
                    for (s = {}, l = 0; l < 4; l++) s[e[l]] = u[l] = u[l] || u[(l - 1) / 2 >> 0];
                    return i.parse(t, s, o, a)
                }
            }, xe = (X._setPluginRatio = function (e) {
                this.plugin.setRatio(e);
                for (var t, n, r, i, o, a = this.data, s = a.proxy, l = a.firstMPT; l;) t = s[l.v], l.r ? t = l.r(t) : t < 1e-6 && t > -1e-6 && (t = 0), l.t[l.p] = t, l = l._next;
                if (a.autoRotate && (a.autoRotate.rotation = a.mod ? a.mod.call(this._tween, s.rotation, this.t, this._tween) : s.rotation), 1 === e || 0 === e) for (l = a.firstMPT, o = 1 === e ? "e" : "b"; l;) {
                    if ((n = l.t).type) {
                        if (1 === n.type) {
                            for (i = n.xs0 + n.s + n.xs1, r = 1; r < n.l; r++) i += n["xn" + r] + n["xs" + (r + 1)];
                            n[o] = i
                        }
                    } else n[o] = n.s + n.xs0;
                    l = l._next
                }
            }, function (e, t, n, r, i) {
                this.t = e, this.p = t, this.v = n, this.r = i, r && (r._prev = this, this._next = r)
            }), Te = (X._parseToProxy = function (e, t, n, r, i, o) {
                var a, s, l, u, c, p = r, d = {}, h = {}, f = n._transform, m = V;
                for (n._transform = null, V = t, r = c = n.parse(e, t, r, i), V = m, o && (n._transform = f, p && (p._prev = null, p._prev && (p._prev._next = null))); r && r !== p;) {
                    if (r.type <= 1 && (h[s = r.p] = r.s + r.c, d[s] = r.s, o || (u = new xe(r, "s", s, u, r.r), r.c = 0), 1 === r.type)) for (a = r.l; --a > 0;) l = "xn" + a, h[s = r.p + "_" + l] = r.data[l], d[s] = r[l], o || (u = new xe(r, l, s, u, r.rxp[l]));
                    r = r._next
                }
                return {proxy: d, end: h, firstMPT: u, pt: c}
            }, X.CSSPropTween = function (t, n, i, o, a, s, l, u, c, p, d) {
                this.t = t, this.p = n, this.s = i, this.c = o, this.n = l || n, t instanceof Te || r.push(this.n), this.r = u ? "function" == typeof u ? u : Math.round : u, this.type = s || 0, c && (this.pr = c, e = !0), this.b = void 0 === p ? i : p, this.e = void 0 === d ? i + o : d, a && (this._next = a, a._prev = this)
            }), Ee = function (e, t, n, r, i, o) {
                var a = new Te(e, t, n, r - n, i, -1, o);
                return a.b = n, a.e = a.xs0 = r, a
            }, Ce = i.parseComplex = function (e, t, n, r, o, a, s, l, u, p) {
                n = n || a || "", "function" == typeof r && (r = r(v, g)), s = new Te(e, t, 0, 0, s, p ? 2 : 1, null, !1, l, n, r), r += "", o && ve.test(r + n) && (r = [n, r], i.colorStringFilter(r), n = r[0], r = r[1]);
                var d, h, f, m, _, x, T, E, C, S, M, A, O, w = n.split(", ").join(",").split(" "),
                    R = r.split(", ").join(",").split(" "), P = w.length, L = !1 !== c;
                for (-1 === r.indexOf(",") && -1 === n.indexOf(",") || (-1 !== (r + n).indexOf("rgb") || -1 !== (r + n).indexOf("hsl") ? (w = w.join(" ").replace(z, ", ").split(" "), R = R.join(" ").replace(z, ", ").split(" ")) : (w = w.join(" ").split(",").join(", ").split(" "), R = R.join(" ").split(",").join(", ").split(" ")), P = w.length), P !== R.length && (P = (w = (a || "").split(" ")).length), s.plugin = u, s.setRatio = p, ve.lastIndex = 0, d = 0; d < P; d++) if (m = w[d], _ = R[d] + "", (E = parseFloat(m)) || 0 === E) s.appendXtra("", E, pe(_, E), _.replace(b, ""), !(!L || -1 === _.indexOf("px")) && Math.round, !0); else if (o && ve.test(m)) A = ")" + ((A = _.indexOf(")") + 1) ? _.substr(A) : ""), O = -1 !== _.indexOf("hsl") && q, S = _, m = _e(m, O), _ = _e(_, O), (C = m.length + _.length > 6) && !q && 0 === _[3] ? (s["xs" + s.l] += s.l ? " transparent" : "transparent", s.e = s.e.split(R[d]).join("transparent")) : (q || (C = !1), O ? s.appendXtra(S.substr(0, S.indexOf("hsl")) + (C ? "hsla(" : "hsl("), m[0], pe(_[0], m[0]), ",", !1, !0).appendXtra("", m[1], pe(_[1], m[1]), "%,", !1).appendXtra("", m[2], pe(_[2], m[2]), C ? "%," : "%" + A, !1) : s.appendXtra(S.substr(0, S.indexOf("rgb")) + (C ? "rgba(" : "rgb("), m[0], _[0] - m[0], ",", Math.round, !0).appendXtra("", m[1], _[1] - m[1], ",", Math.round).appendXtra("", m[2], _[2] - m[2], C ? "," : A, Math.round), C && (m = m.length < 4 ? 1 : m[3], s.appendXtra("", m, (_.length < 4 ? 1 : _[3]) - m, A, !1))), ve.lastIndex = 0; else if (x = m.match(y)) {
                    if (!(T = _.match(b)) || T.length !== x.length) return s;
                    for (f = 0, h = 0; h < x.length; h++) M = x[h], S = m.indexOf(M, f), s.appendXtra(m.substr(f, S - f), Number(M), pe(T[h], M), "", !(!L || "px" !== m.substr(S + M.length, 2)) && Math.round, 0 === h), f = S + M.length;
                    s["xs" + s.l] += m.substr(f)
                } else s["xs" + s.l] += s.l || s["xs" + s.l] ? " " + _ : _;
                if (-1 !== r.indexOf("=") && s.data) {
                    for (A = s.xs0 + s.data.s, d = 1; d < s.l; d++) A += s["xs" + d] + s.data["xn" + d];
                    s.e = A + s["xs" + d]
                }
                return s.l || (s.type = -1, s.xs0 = s.e), s.xfirst || s
            }, Se = 9;
            for ((u = Te.prototype).l = u.pr = 0; --Se > 0;) u["xn" + Se] = 0, u["xs" + Se] = "";
            u.xs0 = "", u._next = u._prev = u.xfirst = u.data = u.plugin = u.setRatio = u.rxp = null, u.appendXtra = function (e, t, n, r, i, o) {
                var a = this, s = a.l;
                return a["xs" + s] += o && (s || a["xs" + s]) ? " " + e : e || "", n || 0 === s || a.plugin ? (a.l++, a.type = a.setRatio ? 2 : 1, a["xs" + a.l] = r || "", s > 0 ? (a.data["xn" + s] = t + n, a.rxp["xn" + s] = i, a["xn" + s] = t, a.plugin || (a.xfirst = new Te(a, "xn" + s, t, n, a.xfirst || a, 0, a.n, i, a.pr), a.xfirst.xs0 = 0), a) : (a.data = {s: t + n}, a.rxp = {}, a.s = t, a.c = n, a.r = i, a)) : (a["xs" + s] += t + (r || ""), a)
            };
            var Me = function (e, t) {
                t = t || {}, this.p = t.prefix && $(e) || e, l[e] = l[this.p] = this, this.format = t.formatter || ye(t.defaultValue, t.color, t.collapsible, t.multi), t.parser && (this.parse = t.parser), this.clrs = t.color, this.multi = t.multi, this.keyword = t.keyword, this.dflt = t.defaultValue, this.allowFunc = t.allowFunc, this.pr = t.priority || 0
            }, Ae = X._registerComplexSpecialProp = function (e, t, n) {
                "object" != typeof t && (t = {parser: n});
                var r, i = e.split(","), o = t.defaultValue;
                for (n = n || [o], r = 0; r < i.length; r++) t.prefix = 0 === r && t.prefix, t.defaultValue = n[r] || o, new Me(i[r], t)
            }, Oe = X._registerPluginProp = function (e) {
                if (!l[e]) {
                    var t = e.charAt(0).toUpperCase() + e.substr(1) + "Plugin";
                    Ae(e, {
                        parser: function (e, n, r, i, o, a, u) {
                            var c = s.com.greensock.plugins[t];
                            return c ? (c._cssRegister(), l[r].parse(e, n, r, i, o, a, u)) : (K("Error: " + t + " js file not loaded."), o)
                        }
                    })
                }
            };
            (u = Me.prototype).parseComplex = function (e, t, n, r, i, o) {
                var a, s, l, u, c, p, d = this.keyword;
                if (this.multi && (z.test(n) || z.test(t) ? (s = t.replace(z, "|").split("|"), l = n.replace(z, "|").split("|")) : d && (s = [t], l = [n])), l) {
                    for (u = l.length > s.length ? l.length : s.length, a = 0; a < u; a++) t = s[a] = s[a] || this.dflt, n = l[a] = l[a] || this.dflt, d && (c = t.indexOf(d)) !== (p = n.indexOf(d)) && (-1 === p ? s[a] = s[a].split(d).join("") : -1 === c && (s[a] += " " + d));
                    t = s.join(", "), n = l.join(", ")
                }
                return Ce(e, this.p, t, n, this.clrs, this.dflt, r, this.pr, i, o)
            }, u.parse = function (e, t, r, i, o, a, s) {
                return this.parseComplex(e.style, this.format(ne(e, this.p, n, !1, this.dflt)), this.format(t), o, a)
            }, i.registerSpecialProp = function (e, t, n) {
                Ae(e, {
                    parser: function (e, r, i, o, a, s, l) {
                        var u = new Te(e, i, 0, 0, a, 2, i, !1, n);
                        return u.plugin = s, u.setRatio = t(e, r, o._tween, i), u
                    }, priority: n
                })
            }, i.useSVGTransformAttr = !0;
            var we, Re, Pe, Le, De,
                Ie = "scaleX,scaleY,scaleZ,x,y,z,skewX,skewY,rotation,rotationX,rotationY,perspective,xPercent,yPercent".split(","),
                Ne = $("transform"), ze = Q + "transform", Ue = $("transformOrigin"), Fe = null !== $("perspective"),
                ke = X.Transform = function () {
                    this.perspective = parseFloat(i.defaultTransformPerspective) || 0, this.force3D = !(!1 === i.defaultForce3D || !Fe) && (i.defaultForce3D || "auto")
                }, Ve = o.SVGElement, Be = function (e, t, n) {
                    var r, i = G.createElementNS("http://www.w3.org/2000/svg", e), o = /([a-z])([A-Z])/g;
                    for (r in n) i.setAttributeNS(null, r.replace(o, "$1-$2").toLowerCase(), n[r]);
                    return t.appendChild(i), i
                }, Ge = G.documentElement || {},
                je = (De = _ || /Android/i.test(Y) && !o.chrome, G.createElementNS && Ge.appendChild && !De && (Re = Be("svg", Ge), Le = (Pe = Be("rect", Re, {
                    width: 100,
                    height: 50,
                    x: 100
                })).getBoundingClientRect().width, Pe.style[Ue] = "50% 50%", Pe.style[Ne] = "scaleX(0.5)", De = Le === Pe.getBoundingClientRect().width && !(f && Fe), Ge.removeChild(Re)), De),
                He = function (e, t, n, r, o, a) {
                    var s, l, u, c, p, d, h, f, m, _, g, v, y, b, x = e._gsTransform, T = qe(e, !0);
                    x && (y = x.xOrigin, b = x.yOrigin), (!r || (s = r.split(" ")).length < 2) && (0 === (h = e.getBBox()).x && 0 === h.y && h.width + h.height === 0 && (h = {
                        x: parseFloat(e.hasAttribute("x") ? e.getAttribute("x") : e.hasAttribute("cx") ? e.getAttribute("cx") : 0) || 0,
                        y: parseFloat(e.hasAttribute("y") ? e.getAttribute("y") : e.hasAttribute("cy") ? e.getAttribute("cy") : 0) || 0,
                        width: 0,
                        height: 0
                    }), s = [(-1 !== (t = ce(t).split(" "))[0].indexOf("%") ? parseFloat(t[0]) / 100 * h.width : parseFloat(t[0])) + h.x, (-1 !== t[1].indexOf("%") ? parseFloat(t[1]) / 100 * h.height : parseFloat(t[1])) + h.y]), n.xOrigin = c = parseFloat(s[0]), n.yOrigin = p = parseFloat(s[1]), r && T !== Ye && (d = T[0], h = T[1], f = T[2], m = T[3], _ = T[4], g = T[5], (v = d * m - h * f) && (l = c * (m / v) + p * (-f / v) + (f * g - m * _) / v, u = c * (-h / v) + p * (d / v) - (d * g - h * _) / v, c = n.xOrigin = s[0] = l, p = n.yOrigin = s[1] = u)), x && (a && (n.xOffset = x.xOffset, n.yOffset = x.yOffset, x = n), o || !1 !== o && !1 !== i.defaultSmoothOrigin ? (l = c - y, u = p - b, x.xOffset += l * T[0] + u * T[2] - l, x.yOffset += l * T[1] + u * T[3] - u) : x.xOffset = x.yOffset = 0), a || e.setAttribute("data-svg-origin", s.join(" "))
                }, We = function (e) {
                    var t,
                        n = j("svg", this.ownerSVGElement && this.ownerSVGElement.getAttribute("xmlns") || "http://www.w3.org/2000/svg"),
                        r = this.parentNode, i = this.nextSibling, o = this.style.cssText;
                    if (Ge.appendChild(n), n.appendChild(this), this.style.display = "block", e) try {
                        t = this.getBBox(), this._originalGetBBox = this.getBBox, this.getBBox = We
                    } catch (e) {
                    } else this._originalGetBBox && (t = this._originalGetBBox());
                    return i ? r.insertBefore(this, i) : r.appendChild(this), Ge.removeChild(n), this.style.cssText = o, t
                }, Xe = function (e) {
                    return !(!Ve || !e.getCTM || e.parentNode && !e.ownerSVGElement || !function (e) {
                        try {
                            return e.getBBox()
                        } catch (t) {
                            return We.call(e, !0)
                        }
                    }(e))
                }, Ye = [1, 0, 0, 1, 0, 0], qe = function (e, t) {
                    var n, r, i, o, a, s, l, u = e._gsTransform || new ke, c = e.style;
                    if (Ne ? r = ne(e, ze, null, !0) : e.currentStyle && (r = (r = e.currentStyle.filter.match(I)) && 4 === r.length ? [r[0].substr(4), Number(r[2].substr(4)), Number(r[1].substr(4)), r[3].substr(4), u.x || 0, u.y || 0].join(",") : ""), n = !r || "none" === r || "matrix(1, 0, 0, 1, 0, 0)" === r, Ne && n && !e.offsetParent && e !== Ge && (o = c.display, c.display = "block", (l = e.parentNode) && e.offsetParent || (a = 1, s = e.nextSibling, Ge.appendChild(e)), n = !(r = ne(e, ze, null, !0)) || "none" === r || "matrix(1, 0, 0, 1, 0, 0)" === r, o ? c.display = o : $e(c, "display"), a && (s ? l.insertBefore(e, s) : l ? l.appendChild(e) : Ge.removeChild(e))), (u.svg || e.getCTM && Xe(e)) && (n && -1 !== (c[Ne] + "").indexOf("matrix") && (r = c[Ne], n = 0), i = e.getAttribute("transform"), n && i && (r = "matrix(" + (i = e.transform.baseVal.consolidate().matrix).a + "," + i.b + "," + i.c + "," + i.d + "," + i.e + "," + i.f + ")", n = 0)), n) return Ye;
                    for (i = (r || "").match(y) || [], Se = i.length; --Se > -1;) o = Number(i[Se]), i[Se] = (a = o - (o |= 0)) ? (1e5 * a + (a < 0 ? -.5 : .5) | 0) / 1e5 + o : o;
                    return t && i.length > 6 ? [i[0], i[1], i[4], i[5], i[12], i[13]] : i
                }, Ze = X.getTransform = function (e, t, n, r) {
                    if (e._gsTransform && n && !r) return e._gsTransform;
                    var o, s, l, u, c, p, d = n && e._gsTransform || new ke, h = d.scaleX < 0, f = 1e5,
                        m = Fe && (parseFloat(ne(e, Ue, t, !1, "0 0 0").split(" ")[2]) || d.zOrigin) || 0,
                        _ = parseFloat(i.defaultTransformPerspective) || 0;
                    if (d.svg = !(!e.getCTM || !Xe(e)), d.svg && (He(e, ne(e, Ue, t, !1, "50% 50%") + "", d, e.getAttribute("data-svg-origin")), we = i.useSVGTransformAttr || je), (o = qe(e)) !== Ye) {
                        if (16 === o.length) {
                            var g, v, y, b, x, T = o[0], E = o[1], C = o[2], S = o[3], M = o[4], A = o[5], O = o[6],
                                w = o[7], R = o[8], P = o[9], L = o[10], D = o[12], I = o[13], N = o[14], z = o[11],
                                U = Math.atan2(O, L);
                            d.zOrigin && (D = R * (N = -d.zOrigin) - o[12], I = P * N - o[13], N = L * N + d.zOrigin - o[14]), d.rotationX = U * k, U && (g = M * (b = Math.cos(-U)) + R * (x = Math.sin(-U)), v = A * b + P * x, y = O * b + L * x, R = M * -x + R * b, P = A * -x + P * b, L = O * -x + L * b, z = w * -x + z * b, M = g, A = v, O = y), U = Math.atan2(-C, L), d.rotationY = U * k, U && (v = E * (b = Math.cos(-U)) - P * (x = Math.sin(-U)), y = C * b - L * x, P = E * x + P * b, L = C * x + L * b, z = S * x + z * b, T = g = T * b - R * x, E = v, C = y), U = Math.atan2(E, T), d.rotation = U * k, U && (g = T * (b = Math.cos(U)) + E * (x = Math.sin(U)), v = M * b + A * x, y = R * b + P * x, E = E * b - T * x, A = A * b - M * x, P = P * b - R * x, T = g, M = v, R = y), d.rotationX && Math.abs(d.rotationX) + Math.abs(d.rotation) > 359.9 && (d.rotationX = d.rotation = 0, d.rotationY = 180 - d.rotationY), U = Math.atan2(M, A), d.scaleX = (Math.sqrt(T * T + E * E + C * C) * f + .5 | 0) / f, d.scaleY = (Math.sqrt(A * A + O * O) * f + .5 | 0) / f, d.scaleZ = (Math.sqrt(R * R + P * P + L * L) * f + .5 | 0) / f, T /= d.scaleX, M /= d.scaleY, E /= d.scaleX, A /= d.scaleY, Math.abs(U) > 2e-5 ? (d.skewX = U * k, M = 0, "simple" !== d.skewType && (d.scaleY *= 1 / Math.cos(U))) : d.skewX = 0, d.perspective = z ? 1 / (z < 0 ? -z : z) : 0, d.x = D, d.y = I, d.z = N, d.svg && (d.x -= d.xOrigin - (d.xOrigin * T - d.yOrigin * M), d.y -= d.yOrigin - (d.yOrigin * E - d.xOrigin * A))
                        } else if (!Fe || r || !o.length || d.x !== o[4] || d.y !== o[5] || !d.rotationX && !d.rotationY) {
                            var F = o.length >= 6, V = F ? o[0] : 1, B = o[1] || 0, G = o[2] || 0, j = F ? o[3] : 1;
                            d.x = o[4] || 0, d.y = o[5] || 0, l = Math.sqrt(V * V + B * B), u = Math.sqrt(j * j + G * G), c = V || B ? Math.atan2(B, V) * k : d.rotation || 0, p = G || j ? Math.atan2(G, j) * k + c : d.skewX || 0, d.scaleX = l, d.scaleY = u, d.rotation = c, d.skewX = p, Fe && (d.rotationX = d.rotationY = d.z = 0, d.perspective = _, d.scaleZ = 1), d.svg && (d.x -= d.xOrigin - (d.xOrigin * V + d.yOrigin * G), d.y -= d.yOrigin - (d.xOrigin * B + d.yOrigin * j))
                        }
                        for (s in Math.abs(d.skewX) > 90 && Math.abs(d.skewX) < 270 && (h ? (d.scaleX *= -1, d.skewX += d.rotation <= 0 ? 180 : -180, d.rotation += d.rotation <= 0 ? 180 : -180) : (d.scaleY *= -1, d.skewX += d.skewX <= 0 ? 180 : -180)), d.zOrigin = m, d) d[s] < 2e-5 && d[s] > -2e-5 && (d[s] = 0)
                    }
                    return n && (e._gsTransform = d, d.svg && (we && e.style[Ne] ? a.delayedCall(.001, (function () {
                        $e(e.style, Ne)
                    })) : !we && e.getAttribute("transform") && a.delayedCall(.001, (function () {
                        e.removeAttribute("transform")
                    })))), d
                }, Ke = function (e) {
                    var t, n, r = this.data, i = -r.rotation * F, o = i + r.skewX * F, a = 1e5,
                        s = (Math.cos(i) * r.scaleX * a | 0) / a, l = (Math.sin(i) * r.scaleX * a | 0) / a,
                        u = (Math.sin(o) * -r.scaleY * a | 0) / a, c = (Math.cos(o) * r.scaleY * a | 0) / a,
                        p = this.t.style, d = this.t.currentStyle;
                    if (d) {
                        n = l, l = -u, u = -n, t = d.filter, p.filter = "";
                        var h, f, m = this.t.offsetWidth, g = this.t.offsetHeight, v = "absolute" !== d.position,
                            y = "progid:DXImageTransform.Microsoft.Matrix(M11=" + s + ", M12=" + l + ", M21=" + u + ", M22=" + c,
                            b = r.x + m * r.xPercent / 100, x = r.y + g * r.yPercent / 100;
                        if (null != r.ox && (b += (h = (r.oxp ? m * r.ox * .01 : r.ox) - m / 2) - (h * s + (f = (r.oyp ? g * r.oy * .01 : r.oy) - g / 2) * l), x += f - (h * u + f * c)), y += v ? ", Dx=" + ((h = m / 2) - (h * s + (f = g / 2) * l) + b) + ", Dy=" + (f - (h * u + f * c) + x) + ")" : ", sizingMethod='auto expand')", -1 !== t.indexOf("DXImageTransform.Microsoft.Matrix(") ? p.filter = t.replace(N, y) : p.filter = y + " " + t, 0 !== e && 1 !== e || 1 === s && 0 === l && 0 === u && 1 === c && (v && -1 === y.indexOf("Dx=0, Dy=0") || S.test(t) && 100 !== parseFloat(RegExp.$1) || -1 === t.indexOf(t.indexOf("Alpha")) && p.removeAttribute("filter")), !v) {
                            var T, E, M, A = _ < 8 ? 1 : -1;
                            for (h = r.ieOffsetX || 0, f = r.ieOffsetY || 0, r.ieOffsetX = Math.round((m - ((s < 0 ? -s : s) * m + (l < 0 ? -l : l) * g)) / 2 + b), r.ieOffsetY = Math.round((g - ((c < 0 ? -c : c) * g + (u < 0 ? -u : u) * m)) / 2 + x), Se = 0; Se < 4; Se++) M = (n = -1 !== (T = d[E = le[Se]]).indexOf("px") ? parseFloat(T) : re(this.t, E, parseFloat(T), T.replace(C, "")) || 0) !== r[E] ? Se < 2 ? -r.ieOffsetX : -r.ieOffsetY : Se < 2 ? h - r.ieOffsetX : f - r.ieOffsetY, p[E] = (r[E] = Math.round(n - M * (0 === Se || 2 === Se ? 1 : A))) + "px"
                        }
                    }
                }, Qe = X.set3DTransformRatio = X.setTransformRatio = function (e) {
                    var t, n, r, i, o, a, s, l, u, c, p, d, h, m, _, g, v, y, b, x, T, E = this.data, C = this.t.style,
                        S = E.rotation, M = E.rotationX, A = E.rotationY, O = E.scaleX, w = E.scaleY, R = E.scaleZ, P = E.x,
                        L = E.y, D = E.z, I = E.svg, N = E.perspective, z = E.force3D, U = E.skewY, k = E.skewX;
                    if (U && (k += U, S += U), !((1 !== e && 0 !== e || "auto" !== z || this.tween._totalTime !== this.tween._totalDuration && this.tween._totalTime) && z || D || N || A || M || 1 !== R) || we && I || !Fe) S || k || I ? (S *= F, x = k * F, T = 1e5, n = Math.cos(S) * O, o = Math.sin(S) * O, r = Math.sin(S - x) * -w, a = Math.cos(S - x) * w, x && "simple" === E.skewType && (t = Math.tan(x - U * F), r *= t = Math.sqrt(1 + t * t), a *= t, U && (t = Math.tan(U * F), n *= t = Math.sqrt(1 + t * t), o *= t)), I && (P += E.xOrigin - (E.xOrigin * n + E.yOrigin * r) + E.xOffset, L += E.yOrigin - (E.xOrigin * o + E.yOrigin * a) + E.yOffset, we && (E.xPercent || E.yPercent) && (_ = this.t.getBBox(), P += .01 * E.xPercent * _.width, L += .01 * E.yPercent * _.height), P < (_ = 1e-6) && P > -_ && (P = 0), L < _ && L > -_ && (L = 0)), b = (n * T | 0) / T + "," + (o * T | 0) / T + "," + (r * T | 0) / T + "," + (a * T | 0) / T + "," + P + "," + L + ")", I && we ? this.t.setAttribute("transform", "matrix(" + b) : C[Ne] = (E.xPercent || E.yPercent ? "translate(" + E.xPercent + "%," + E.yPercent + "%) matrix(" : "matrix(") + b) : C[Ne] = (E.xPercent || E.yPercent ? "translate(" + E.xPercent + "%," + E.yPercent + "%) matrix(" : "matrix(") + O + ",0,0," + w + "," + P + "," + L + ")"; else {
                        if (f && (O < (_ = 1e-4) && O > -_ && (O = R = 2e-5), w < _ && w > -_ && (w = R = 2e-5), !N || E.z || E.rotationX || E.rotationY || (N = 0)), S || k) S *= F, g = n = Math.cos(S), v = o = Math.sin(S), k && (S -= k * F, g = Math.cos(S), v = Math.sin(S), "simple" === E.skewType && (t = Math.tan((k - U) * F), g *= t = Math.sqrt(1 + t * t), v *= t, E.skewY && (t = Math.tan(U * F), n *= t = Math.sqrt(1 + t * t), o *= t))), r = -v, a = g; else {
                            if (!(A || M || 1 !== R || N || I)) return void (C[Ne] = (E.xPercent || E.yPercent ? "translate(" + E.xPercent + "%," + E.yPercent + "%) translate3d(" : "translate3d(") + P + "px," + L + "px," + D + "px)" + (1 !== O || 1 !== w ? " scale(" + O + "," + w + ")" : ""));
                            n = a = 1, r = o = 0
                        }
                        c = 1, i = s = l = u = p = d = 0, h = N ? -1 / N : 0, m = E.zOrigin, _ = 1e-6, ",", "0", (S = A * F) && (g = Math.cos(S), l = -(v = Math.sin(S)), p = h * -v, i = n * v, s = o * v, c = g, h *= g, n *= g, o *= g), (S = M * F) && (t = r * (g = Math.cos(S)) + i * (v = Math.sin(S)), y = a * g + s * v, u = c * v, d = h * v, i = r * -v + i * g, s = a * -v + s * g, c *= g, h *= g, r = t, a = y), 1 !== R && (i *= R, s *= R, c *= R, h *= R), 1 !== w && (r *= w, a *= w, u *= w, d *= w), 1 !== O && (n *= O, o *= O, l *= O, p *= O), (m || I) && (m && (P += i * -m, L += s * -m, D += c * -m + m), I && (P += E.xOrigin - (E.xOrigin * n + E.yOrigin * r) + E.xOffset, L += E.yOrigin - (E.xOrigin * o + E.yOrigin * a) + E.yOffset), P < _ && P > -_ && (P = "0"), L < _ && L > -_ && (L = "0"), D < _ && D > -_ && (D = 0)), b = E.xPercent || E.yPercent ? "translate(" + E.xPercent + "%," + E.yPercent + "%) matrix3d(" : "matrix3d(", b += (n < _ && n > -_ ? "0" : n) + "," + (o < _ && o > -_ ? "0" : o) + "," + (l < _ && l > -_ ? "0" : l), b += "," + (p < _ && p > -_ ? "0" : p) + "," + (r < _ && r > -_ ? "0" : r) + "," + (a < _ && a > -_ ? "0" : a), M || A || 1 !== R ? (b += "," + (u < _ && u > -_ ? "0" : u) + "," + (d < _ && d > -_ ? "0" : d) + "," + (i < _ && i > -_ ? "0" : i), b += "," + (s < _ && s > -_ ? "0" : s) + "," + (c < _ && c > -_ ? "0" : c) + "," + (h < _ && h > -_ ? "0" : h) + ",") : b += ",0,0,0,0,1,0,", b += P + "," + L + "," + D + "," + (N ? 1 + -D / N : 1) + ")", C[Ne] = b
                    }
                };
            (u = ke.prototype).x = u.y = u.z = u.skewX = u.skewY = u.rotation = u.rotationX = u.rotationY = u.zOrigin = u.xPercent = u.yPercent = u.xOffset = u.yOffset = 0, u.scaleX = u.scaleY = u.scaleZ = 1, Ae("transform,scale,scaleX,scaleY,scaleZ,x,y,z,rotation,rotationX,rotationY,rotationZ,skewX,skewY,shortRotation,shortRotationX,shortRotationY,shortRotationZ,transformOrigin,svgOrigin,transformPerspective,directionalRotation,parseTransform,force3D,skewType,xPercent,yPercent,smoothOrigin", {
                parser: function (e, t, r, o, a, s, l) {
                    if (o._lastParsedTransform === l) return a;
                    o._lastParsedTransform = l;
                    var u = l.scale && "function" == typeof l.scale ? l.scale : 0;
                    u && (l.scale = u(v, e));
                    var c, p, d, h, f, m, _, y, b, x = e._gsTransform, T = e.style, E = Ie.length, C = l, S = {},
                        M = Ze(e, n, !0, C.parseTransform),
                        A = C.transform && ("function" == typeof C.transform ? C.transform(v, g) : C.transform);
                    if (M.skewType = C.skewType || M.skewType || i.defaultSkewType, o._transform = M, "rotationZ" in C && (C.rotation = C.rotationZ), A && "string" == typeof A && Ne) (p = H.style)[Ne] = A, p.display = "block", p.position = "absolute", -1 !== A.indexOf("%") && (p.width = ne(e, "width"), p.height = ne(e, "height")), G.body.appendChild(H), c = Ze(H, null, !1), "simple" === M.skewType && (c.scaleY *= Math.cos(c.skewX * F)), M.svg && (m = M.xOrigin, _ = M.yOrigin, c.x -= M.xOffset, c.y -= M.yOffset, (C.transformOrigin || C.svgOrigin) && (A = {}, He(e, ce(C.transformOrigin), A, C.svgOrigin, C.smoothOrigin, !0), m = A.xOrigin, _ = A.yOrigin, c.x -= A.xOffset - M.xOffset, c.y -= A.yOffset - M.yOffset), (m || _) && (y = qe(H, !0), c.x -= m - (m * y[0] + _ * y[2]), c.y -= _ - (m * y[1] + _ * y[3]))), G.body.removeChild(H), c.perspective || (c.perspective = M.perspective), null != C.xPercent && (c.xPercent = de(C.xPercent, M.xPercent)), null != C.yPercent && (c.yPercent = de(C.yPercent, M.yPercent)); else if ("object" == typeof C) {
                        if (c = {
                            scaleX: de(null != C.scaleX ? C.scaleX : C.scale, M.scaleX),
                            scaleY: de(null != C.scaleY ? C.scaleY : C.scale, M.scaleY),
                            scaleZ: de(C.scaleZ, M.scaleZ),
                            x: de(C.x, M.x),
                            y: de(C.y, M.y),
                            z: de(C.z, M.z),
                            xPercent: de(C.xPercent, M.xPercent),
                            yPercent: de(C.yPercent, M.yPercent),
                            perspective: de(C.transformPerspective, M.perspective)
                        }, null != (f = C.directionalRotation)) if ("object" == typeof f) for (p in f) C[p] = f[p]; else C.rotation = f;
                        "string" == typeof C.x && -1 !== C.x.indexOf("%") && (c.x = 0, c.xPercent = de(C.x, M.xPercent)), "string" == typeof C.y && -1 !== C.y.indexOf("%") && (c.y = 0, c.yPercent = de(C.y, M.yPercent)), c.rotation = he("rotation" in C ? C.rotation : "shortRotation" in C ? C.shortRotation + "_short" : M.rotation, M.rotation, "rotation", S), Fe && (c.rotationX = he("rotationX" in C ? C.rotationX : "shortRotationX" in C ? C.shortRotationX + "_short" : M.rotationX || 0, M.rotationX, "rotationX", S), c.rotationY = he("rotationY" in C ? C.rotationY : "shortRotationY" in C ? C.shortRotationY + "_short" : M.rotationY || 0, M.rotationY, "rotationY", S)), c.skewX = he(C.skewX, M.skewX), c.skewY = he(C.skewY, M.skewY)
                    }
                    for (Fe && null != C.force3D && (M.force3D = C.force3D, h = !0), (d = M.force3D || M.z || M.rotationX || M.rotationY || c.z || c.rotationX || c.rotationY || c.perspective) || null == C.scale || (c.scaleZ = 1); --E > -1;) ((A = c[b = Ie[E]] - M[b]) > 1e-6 || A < -1e-6 || null != C[b] || null != V[b]) && (h = !0, a = new Te(M, b, M[b], A, a), b in S && (a.e = S[b]), a.xs0 = 0, a.plugin = s, o._overwriteProps.push(a.n));
                    return A = "function" == typeof C.transformOrigin ? C.transformOrigin(v, g) : C.transformOrigin, M.svg && (A || C.svgOrigin) && (m = M.xOffset, _ = M.yOffset, He(e, ce(A), c, C.svgOrigin, C.smoothOrigin), a = Ee(M, "xOrigin", (x ? M : c).xOrigin, c.xOrigin, a, "transformOrigin"), a = Ee(M, "yOrigin", (x ? M : c).yOrigin, c.yOrigin, a, "transformOrigin"), m === M.xOffset && _ === M.yOffset || (a = Ee(M, "xOffset", x ? m : M.xOffset, M.xOffset, a, "transformOrigin"), a = Ee(M, "yOffset", x ? _ : M.yOffset, M.yOffset, a, "transformOrigin")), A = "0px 0px"), (A || Fe && d && M.zOrigin) && (Ne ? (h = !0, b = Ue, A || (A = (A = (ne(e, b, n, !1, "50% 50%") + "").split(" "))[0] + " " + A[1] + " " + M.zOrigin + "px"), A += "", (a = new Te(T, b, 0, 0, a, -1, "transformOrigin")).b = T[b], a.plugin = s, Fe ? (p = M.zOrigin, A = A.split(" "), M.zOrigin = (A.length > 2 ? parseFloat(A[2]) : p) || 0, a.xs0 = a.e = A[0] + " " + (A[1] || "50%") + " 0px", (a = new Te(M, "zOrigin", 0, 0, a, -1, a.n)).b = p, a.xs0 = a.e = M.zOrigin) : a.xs0 = a.e = A) : ce(A + "", M)), h && (o._transformType = M.svg && we || !d && 3 !== this._transformType ? 2 : 3), u && (l.scale = u), a
                }, allowFunc: !0, prefix: !0
            }), Ae("boxShadow", {
                defaultValue: "0px 0px 0px 0px #999",
                prefix: !0,
                color: !0,
                multi: !0,
                keyword: "inset"
            }), Ae("clipPath", {
                defaultValue: "inset(0%)",
                prefix: !0,
                multi: !0,
                formatter: ye("inset(0% 0% 0% 0%)", !1, !0)
            }), Ae("borderRadius", {
                defaultValue: "0px", parser: function (e, r, i, o, a, s) {
                    r = this.format(r);
                    var l, u, c, p, d, h, f, m, _, g, v, y, b, x, T, E,
                        C = ["borderTopLeftRadius", "borderTopRightRadius", "borderBottomRightRadius", "borderBottomLeftRadius"],
                        S = e.style;
                    for (_ = parseFloat(e.offsetWidth), g = parseFloat(e.offsetHeight), l = r.split(" "), u = 0; u < C.length; u++) this.p.indexOf("border") && (C[u] = $(C[u])), -1 !== (d = p = ne(e, C[u], n, !1, "0px")).indexOf(" ") && (p = d.split(" "), d = p[0], p = p[1]), h = c = l[u], f = parseFloat(d), y = d.substr((f + "").length), (b = "=" === h.charAt(1)) ? (m = parseInt(h.charAt(0) + "1", 10), h = h.substr(2), m *= parseFloat(h), v = h.substr((m + "").length - (m < 0 ? 1 : 0)) || "") : (m = parseFloat(h), v = h.substr((m + "").length)), "" === v && (v = t[i] || y), v !== y && (x = re(e, "borderLeft", f, y), T = re(e, "borderTop", f, y), "%" === v ? (d = x / _ * 100 + "%", p = T / g * 100 + "%") : "em" === v ? (d = x / (E = re(e, "borderLeft", 1, "em")) + "em", p = T / E + "em") : (d = x + "px", p = T + "px"), b && (h = parseFloat(d) + m + v, c = parseFloat(p) + m + v)), a = Ce(S, C[u], d + " " + p, h + " " + c, !1, "0px", a);
                    return a
                }, prefix: !0, formatter: ye("0px 0px 0px 0px", !1, !0)
            }), Ae("borderBottomLeftRadius,borderBottomRightRadius,borderTopLeftRadius,borderTopRightRadius", {
                defaultValue: "0px",
                parser: function (e, t, r, i, o, a) {
                    return Ce(e.style, r, this.format(ne(e, r, n, !1, "0px 0px")), this.format(t), !1, "0px", o)
                },
                prefix: !0,
                formatter: ye("0px 0px", !1, !0)
            }), Ae("backgroundPosition", {
                defaultValue: "0 0", parser: function (e, t, r, i, o, a) {
                    var s, l, u, c, p, d, h = "background-position", f = n || te(e),
                        m = this.format((f ? _ ? f.getPropertyValue(h + "-x") + " " + f.getPropertyValue(h + "-y") : f.getPropertyValue(h) : e.currentStyle.backgroundPositionX + " " + e.currentStyle.backgroundPositionY) || "0 0"),
                        g = this.format(t);
                    if (-1 !== m.indexOf("%") != (-1 !== g.indexOf("%")) && g.split(",").length < 2 && (d = ne(e, "backgroundImage").replace(P, "")) && "none" !== d) {
                        for (s = m.split(" "), l = g.split(" "), W.setAttribute("src", d), u = 2; --u > -1;) (c = -1 !== (m = s[u]).indexOf("%")) !== (-1 !== l[u].indexOf("%")) && (p = 0 === u ? e.offsetWidth - W.width : e.offsetHeight - W.height, s[u] = c ? parseFloat(m) / 100 * p + "px" : parseFloat(m) / p * 100 + "%");
                        m = s.join(" ")
                    }
                    return this.parseComplex(e.style, m, g, o, a)
                }, formatter: ce
            }), Ae("backgroundSize", {
                defaultValue: "0 0", formatter: function (e) {
                    return "co" === (e += "").substr(0, 2) ? e : ce(-1 === e.indexOf(" ") ? e + " " + e : e)
                }
            }), Ae("perspective", {defaultValue: "0px", prefix: !0}), Ae("perspectiveOrigin", {
                defaultValue: "50% 50%",
                prefix: !0
            }), Ae("transformStyle", {prefix: !0}), Ae("backfaceVisibility", {prefix: !0}), Ae("userSelect", {prefix: !0}), Ae("margin", {parser: be("marginTop,marginRight,marginBottom,marginLeft")}), Ae("padding", {parser: be("paddingTop,paddingRight,paddingBottom,paddingLeft")}), Ae("clip", {
                defaultValue: "rect(0px,0px,0px,0px)",
                parser: function (e, t, r, i, o, a) {
                    var s, l, u;
                    return _ < 9 ? (l = e.currentStyle, u = _ < 8 ? " " : ",", s = "rect(" + l.clipTop + u + l.clipRight + u + l.clipBottom + u + l.clipLeft + ")", t = this.format(t).split(",").join(u)) : (s = this.format(ne(e, this.p, n, !1, this.dflt)), t = this.format(t)), this.parseComplex(e.style, s, t, o, a)
                }
            }), Ae("textShadow", {
                defaultValue: "0px 0px 0px #999",
                color: !0,
                multi: !0
            }), Ae("autoRound,strictUnits", {
                parser: function (e, t, n, r, i) {
                    return i
                }
            }), Ae("border", {
                defaultValue: "0px solid #000", parser: function (e, t, r, i, o, a) {
                    var s = ne(e, "borderTopWidth", n, !1, "0px"), l = this.format(t).split(" "),
                        u = l[0].replace(C, "");
                    return "px" !== u && (s = parseFloat(s) / re(e, "borderTopWidth", 1, u) + u), this.parseComplex(e.style, this.format(s + " " + ne(e, "borderTopStyle", n, !1, "solid") + " " + ne(e, "borderTopColor", n, !1, "#000")), l.join(" "), o, a)
                }, color: !0, formatter: function (e) {
                    var t = e.split(" ");
                    return t[0] + " " + (t[1] || "solid") + " " + (e.match(ve) || ["#000"])[0]
                }
            }), Ae("borderWidth", {parser: be("borderTopWidth,borderRightWidth,borderBottomWidth,borderLeftWidth")}), Ae("float,cssFloat,styleFloat", {
                parser: function (e, t, n, r, i, o) {
                    var a = e.style, s = "cssFloat" in a ? "cssFloat" : "styleFloat";
                    return new Te(a, s, 0, 0, i, -1, n, !1, 0, a[s], t)
                }
            });
            var Je = function (e) {
                var t, n = this.t, r = n.filter || ne(this.data, "filter") || "", i = this.s + this.c * e | 0;
                100 === i && (-1 === r.indexOf("atrix(") && -1 === r.indexOf("radient(") && -1 === r.indexOf("oader(") ? (n.removeAttribute("filter"), t = !ne(this.data, "filter")) : (n.filter = r.replace(A, ""), t = !0)), t || (this.xn1 && (n.filter = r = r || "alpha(opacity=" + i + ")"), -1 === r.indexOf("pacity") ? 0 === i && this.xn1 || (n.filter = r + " alpha(opacity=" + i + ")") : n.filter = r.replace(S, "opacity=" + i))
            };
            Ae("opacity,alpha,autoAlpha", {
                defaultValue: "1", parser: function (e, t, r, i, o, a) {
                    var s = parseFloat(ne(e, "opacity", n, !1, "1")), l = e.style, u = "autoAlpha" === r;
                    return "string" == typeof t && "=" === t.charAt(1) && (t = ("-" === t.charAt(0) ? -1 : 1) * parseFloat(t.substr(2)) + s), u && 1 === s && "hidden" === ne(e, "visibility", n) && 0 !== t && (s = 0), q ? o = new Te(l, "opacity", s, t - s, o) : ((o = new Te(l, "opacity", 100 * s, 100 * (t - s), o)).xn1 = u ? 1 : 0, l.zoom = 1, o.type = 2, o.b = "alpha(opacity=" + o.s + ")", o.e = "alpha(opacity=" + (o.s + o.c) + ")", o.data = e, o.plugin = a, o.setRatio = Je), u && ((o = new Te(l, "visibility", 0, 0, o, -1, null, !1, 0, 0 !== s ? "inherit" : "hidden", 0 === t ? "hidden" : "inherit")).xs0 = "inherit", i._overwriteProps.push(o.n), i._overwriteProps.push(r)), o
                }
            });
            var $e = function (e, t) {
                t && (e.removeProperty ? ("ms" !== t.substr(0, 2) && "webkit" !== t.substr(0, 6) || (t = "-" + t), e.removeProperty(t.replace(w, "-$1").toLowerCase())) : e.removeAttribute(t))
            }, et = function (e) {
                if (this.t._gsClassPT = this, 1 === e || 0 === e) {
                    this.t.setAttribute("class", 0 === e ? this.b : this.e);
                    for (var t = this.data, n = this.t.style; t;) t.v ? n[t.p] = t.v : $e(n, t.p), t = t._next;
                    1 === e && this.t._gsClassPT === this && (this.t._gsClassPT = null)
                } else this.t.getAttribute("class") !== this.e && this.t.setAttribute("class", this.e)
            };
            Ae("className", {
                parser: function (t, r, i, o, a, s, l) {
                    var u, c, p, d, h, f = t.getAttribute("class") || "", m = t.style.cssText;
                    if ((a = o._classNamePT = new Te(t, i, 0, 0, a, 2)).setRatio = et, a.pr = -11, e = !0, a.b = f, c = oe(t, n), p = t._gsClassPT) {
                        for (d = {}, h = p.data; h;) d[h.p] = 1, h = h._next;
                        p.setRatio(1)
                    }
                    return t._gsClassPT = a, a.e = "=" !== r.charAt(1) ? r : f.replace(new RegExp("(?:\\s|^)" + r.substr(2) + "(?![\\w-])"), "") + ("+" === r.charAt(0) ? " " + r.substr(2) : ""), t.setAttribute("class", a.e), u = ae(t, c, oe(t), l, d), t.setAttribute("class", f), a.data = u.firstMPT, t.style.cssText !== m && (t.style.cssText = m), a = a.xfirst = o.parse(t, u.difs, a, s)
                }
            });
            var tt = function (e) {
                if ((1 === e || 0 === e) && this.data._totalTime === this.data._totalDuration && "isFromStart" !== this.data.data) {
                    var t, n, r, i, o, a = this.t.style, s = l.transform.parse;
                    if ("all" === this.e) a.cssText = "", i = !0; else for (r = (t = this.e.split(" ").join("").split(",")).length; --r > -1;) n = t[r], l[n] && (l[n].parse === s ? i = !0 : n = "transformOrigin" === n ? Ue : l[n].p), $e(a, n);
                    i && ($e(a, Ne), (o = this.t._gsTransform) && (o.svg && (this.t.removeAttribute("data-svg-origin"), this.t.removeAttribute("transform")), delete this.t._gsTransform))
                }
            };
            for (Ae("clearProps", {
                parser: function (t, n, r, i, o) {
                    return (o = new Te(t, r, 0, 0, o, 2)).setRatio = tt, o.e = n, o.pr = -10, o.data = i._tween, e = !0, o
                }
            }), u = "bezier,throwProps,physicsProps,physics2D".split(","), Se = u.length; Se--;) Oe(u[Se]);
            (u = i.prototype)._firstPT = u._lastParsedTransform = u._transform = null, u._onInitTween = function (o, a, s, u) {
                if (!o.nodeType) return !1;
                this._target = g = o, this._tween = s, this._vars = a, v = u, c = a.autoRound, e = !1, t = a.suffixMap || i.suffixMap, n = te(o), r = this._overwriteProps;
                var h, f, _, y, b, x, T, E, C, S = o.style;
                if (p && "" === S.zIndex && ("auto" !== (h = ne(o, "zIndex", n)) && "" !== h || this._addLazySet(S, "zIndex", 0)), "string" == typeof a && (y = S.cssText, h = oe(o, n), S.cssText = y + ";" + a, h = ae(o, h, oe(o)).difs, !q && M.test(a) && (h.opacity = parseFloat(RegExp.$1)), a = h, S.cssText = y), a.className ? this._firstPT = f = l.className.parse(o, a.className, "className", this, null, null, a) : this._firstPT = f = this.parse(o, a, null), this._transformType) {
                    for (C = 3 === this._transformType, Ne ? d && (p = !0, "" === S.zIndex && ("auto" !== (T = ne(o, "zIndex", n)) && "" !== T || this._addLazySet(S, "zIndex", 0)), m && this._addLazySet(S, "WebkitBackfaceVisibility", this._vars.WebkitBackfaceVisibility || (C ? "visible" : "hidden"))) : S.zoom = 1, _ = f; _ && _._next;) _ = _._next;
                    E = new Te(o, "transform", 0, 0, null, 2), this._linkCSSP(E, null, _), E.setRatio = Ne ? Qe : Ke, E.data = this._transform || Ze(o, n, !0), E.tween = s, E.pr = -1, r.pop()
                }
                if (e) {
                    for (; f;) {
                        for (x = f._next, _ = y; _ && _.pr > f.pr;) _ = _._next;
                        (f._prev = _ ? _._prev : b) ? f._prev._next = f : y = f, (f._next = _) ? _._prev = f : b = f, f = x
                    }
                    this._firstPT = y
                }
                return !0
            }, u.parse = function (e, r, i, o) {
                var a, s, u, p, d, h, f, m, _, y, b = e.style;
                for (a in r) {
                    if (h = r[a], s = l[a], "function" != typeof h || s && s.allowFunc || (h = h(v, g)), s) i = s.parse(e, h, a, this, i, o, r); else {
                        if ("--" === a.substr(0, 2)) {
                            this._tween._propLookup[a] = this._addTween.call(this._tween, e.style, "setProperty", te(e).getPropertyValue(a) + "", h + "", a, !1, a);
                            continue
                        }
                        d = ne(e, a, n) + "", _ = "string" == typeof h, "color" === a || "fill" === a || "stroke" === a || -1 !== a.indexOf("Color") || _ && O.test(h) ? (_ || (h = ((h = _e(h)).length > 3 ? "rgba(" : "rgb(") + h.join(",") + ")"), i = Ce(b, a, d, h, !0, "transparent", i, 0, o)) : _ && U.test(h) ? i = Ce(b, a, d, h, !0, null, i, 0, o) : (f = (u = parseFloat(d)) || 0 === u ? d.substr((u + "").length) : "", "" !== d && "auto" !== d || ("width" === a || "height" === a ? (u = ue(e, a, n), f = "px") : "left" === a || "top" === a ? (u = ie(e, a, n), f = "px") : (u = "opacity" !== a ? 0 : 1, f = "")), (y = _ && "=" === h.charAt(1)) ? (p = parseInt(h.charAt(0) + "1", 10), h = h.substr(2), p *= parseFloat(h), m = h.replace(C, "")) : (p = parseFloat(h), m = _ ? h.replace(C, "") : ""), "" === m && (m = a in t ? t[a] : f), h = p || 0 === p ? (y ? p + u : p) + m : r[a], f !== m && ("" === m && "lineHeight" !== a || (p || 0 === p) && u && (u = re(e, a, u, f), "%" === m ? (u /= re(e, a, 100, "%") / 100, !0 !== r.strictUnits && (d = u + "%")) : "em" === m || "rem" === m || "vw" === m || "vh" === m ? u /= re(e, a, 1, m) : "px" !== m && (p = re(e, a, p, m), m = "px"), y && (p || 0 === p) && (h = p + u + m))), y && (p += u), !u && 0 !== u || !p && 0 !== p ? void 0 !== b[a] && (h || h + "" != "NaN" && null != h) ? (i = new Te(b, a, p || u || 0, 0, i, -1, a, !1, 0, d, h)).xs0 = "none" !== h || "display" !== a && -1 === a.indexOf("Style") ? h : d : K("invalid " + a + " tween value: " + r[a]) : (i = new Te(b, a, u, p - u, i, 0, a, !1 !== c && ("px" === m || "zIndex" === a), 0, d, h)).xs0 = m)
                    }
                    o && i && !i.plugin && (i.plugin = o)
                }
                return i
            }, u.setRatio = function (e) {
                var t, n, r, i = this._firstPT;
                if (1 !== e || this._tween._time !== this._tween._duration && 0 !== this._tween._time) if (e || this._tween._time !== this._tween._duration && 0 !== this._tween._time || -1e-6 === this._tween._rawPrevTime) for (; i;) {
                    if (t = i.c * e + i.s, i.r ? t = i.r(t) : t < 1e-6 && t > -1e-6 && (t = 0), i.type) if (1 === i.type) if (2 === (r = i.l)) i.t[i.p] = i.xs0 + t + i.xs1 + i.xn1 + i.xs2; else if (3 === r) i.t[i.p] = i.xs0 + t + i.xs1 + i.xn1 + i.xs2 + i.xn2 + i.xs3; else if (4 === r) i.t[i.p] = i.xs0 + t + i.xs1 + i.xn1 + i.xs2 + i.xn2 + i.xs3 + i.xn3 + i.xs4; else if (5 === r) i.t[i.p] = i.xs0 + t + i.xs1 + i.xn1 + i.xs2 + i.xn2 + i.xs3 + i.xn3 + i.xs4 + i.xn4 + i.xs5; else {
                        for (n = i.xs0 + t + i.xs1, r = 1; r < i.l; r++) n += i["xn" + r] + i["xs" + (r + 1)];
                        i.t[i.p] = n
                    } else -1 === i.type ? i.t[i.p] = i.xs0 : i.setRatio && i.setRatio(e); else i.t[i.p] = t + i.xs0;
                    i = i._next
                } else for (; i;) 2 !== i.type ? i.t[i.p] = i.b : i.setRatio(e), i = i._next; else for (; i;) {
                    if (2 !== i.type) if (i.r && -1 !== i.type) if (t = i.r(i.s + i.c), i.type) {
                        if (1 === i.type) {
                            for (r = i.l, n = i.xs0 + t + i.xs1, r = 1; r < i.l; r++) n += i["xn" + r] + i["xs" + (r + 1)];
                            i.t[i.p] = n
                        }
                    } else i.t[i.p] = t + i.xs0; else i.t[i.p] = i.e; else i.setRatio(e);
                    i = i._next
                }
            }, u._enableTransforms = function (e) {
                this._transform = this._transform || Ze(this._target, n, !0), this._transformType = this._transform.svg && we || !e && 3 !== this._transformType ? 2 : 3
            };
            var nt = function (e) {
                this.t[this.p] = this.e, this.data._linkCSSP(this, this._next, null, !0)
            };
            u._addLazySet = function (e, t, n) {
                var r = this._firstPT = new Te(e, t, 0, 0, this._firstPT, 2);
                r.e = n, r.setRatio = nt, r.data = this
            }, u._linkCSSP = function (e, t, n, r) {
                return e && (t && (t._prev = e), e._next && (e._next._prev = e._prev), e._prev ? e._prev._next = e._next : this._firstPT === e && (this._firstPT = e._next, r = !0), n ? n._next = e : r || null !== this._firstPT || (this._firstPT = e), e._next = t, e._prev = n), e
            }, u._mod = function (e) {
                for (var t = this._firstPT; t;) "function" == typeof e[t.p] && (t.r = e[t.p]), t = t._next
            }, u._kill = function (e) {
                var t, n, r, i = e;
                if (e.autoAlpha || e.alpha) {
                    for (n in i = {}, e) i[n] = e[n];
                    i.opacity = 1, i.autoAlpha && (i.visibility = 1)
                }
                for (e.className && (t = this._classNamePT) && ((r = t.xfirst) && r._prev ? this._linkCSSP(r._prev, t._next, r._prev._prev) : r === this._firstPT && (this._firstPT = t._next), t._next && this._linkCSSP(t._next, t._next._next, r._prev), this._classNamePT = null), t = this._firstPT; t;) t.plugin && t.plugin !== n && t.plugin._kill && (t.plugin._kill(e), n = t.plugin), t = t._next;
                return h.prototype._kill.call(this, i)
            };
            var rt = function (e, t, n) {
                var r, i, o, a;
                if (e.slice) for (i = e.length; --i > -1;) rt(e[i], t, n); else for (i = (r = e.childNodes).length; --i > -1;) a = (o = r[i]).type, o.style && (t.push(oe(o)), n && n.push(o)), 1 !== a && 9 !== a && 11 !== a || !o.childNodes.length || rt(o, t, n)
            };
            return i.cascadeTo = function (e, t, n) {
                var r, i, o, s, l = a.to(e, t, n), u = [l], c = [], p = [], d = [], h = a._internals.reservedProps;
                for (e = l._targets || l.target, rt(e, c, d), l.render(t, !0, !0), rt(e, p), l.render(0, !0, !0), l._enabled(!0), r = d.length; --r > -1;) if ((i = ae(d[r], c[r], p[r])).firstMPT) {
                    for (o in i = i.difs, n) h[o] && (i[o] = n[o]);
                    for (o in s = {}, i) s[o] = c[r][o];
                    u.push(a.fromTo(d[r], t, s, i))
                }
                return u
            }, h.activate([i]), i
        }), !0);
        var g = s.CSSPlugin, v = o._gsDefine.plugin({
            propName: "attr", API: 2, version: "0.6.1", init: function (e, t, n, r) {
                var i, o;
                if ("function" != typeof e.setAttribute) return !1;
                for (i in t) "function" == typeof (o = t[i]) && (o = o(r, e)), this._addTween(e, "setAttribute", e.getAttribute(i) + "", o + "", i, !1, i), this._overwriteProps.push(i);
                return !0
            }
        }), y = o._gsDefine.plugin({
            propName: "roundProps",
            version: "1.7.0",
            priority: -1,
            API: 2,
            init: function (e, t, n) {
                return this._tween = n, !0
            }
        }), b = function (e) {
            var t = e < 1 ? Math.pow(10, (e + "").length - 2) : 1;
            return function (n) {
                return (Math.round(n / e) * e * t | 0) / t
            }
        }, x = function (e, t) {
            for (; e;) e.f || e.blob || (e.m = t || Math.round), e = e._next
        }, T = y.prototype;
        /*!
 * VERSION: 0.6.1
 * DATE: 2018-08-27
 * UPDATES AND DOCS AT: http://greensock.com
 *
 * @license Copyright (c) 2008-2019, GreenSock. All rights reserved.
 * This work is subject to the terms at http://greensock.com/standard-license or for
 * Club GreenSock members, the software agreement that was issued with your membership.
 *
 * @author: Jack Doyle, jack@greensock.com
 */
        T._onInitAllProps = function () {
            var e, t, n, r, i = this._tween, o = i.vars.roundProps, a = {}, s = i._propLookup.roundProps;
            if ("object" != typeof o || o.push) for ("string" == typeof o && (o = o.split(",")), n = o.length; --n > -1;) a[o[n]] = Math.round; else for (r in o) a[r] = b(o[r]);
            for (r in a) for (e = i._firstPT; e;) t = e._next, e.pg ? e.t._mod(a) : e.n === r && (2 === e.f && e.t ? x(e.t._firstPT, a[r]) : (this._add(e.t, r, e.s, e.c, a[r]), t && (t._prev = e._prev), e._prev ? e._prev._next = t : i._firstPT === e && (i._firstPT = t), e._next = e._prev = null, i._propLookup[r] = s)), e = t;
            return !1
        }, T._add = function (e, t, n, r, i) {
            this._addTween(e, t, n, n + r, t, i || Math.round), this._overwriteProps.push(t)
        };
        /*!
 * VERSION: 0.3.1
 * DATE: 2018-08-27
 * UPDATES AND DOCS AT: http://greensock.com
 *
 * @license Copyright (c) 2008-2019, GreenSock. All rights reserved.
 * This work is subject to the terms at http://greensock.com/standard-license or for
 * Club GreenSock members, the software agreement that was issued with your membership.
 *
 * @author: Jack Doyle, jack@greensock.com
 **/
        var E = o._gsDefine.plugin({
            propName: "directionalRotation",
            version: "0.3.1",
            API: 2,
            init: function (e, t, n, r) {
                "object" != typeof t && (t = {rotation: t}), this.finals = {};
                var i, o, a, s, l, u, c = !0 === t.useRadians ? 2 * Math.PI : 360;
                for (i in t) "useRadians" !== i && ("function" == typeof (s = t[i]) && (s = s(r, e)), o = (u = (s + "").split("_"))[0], a = parseFloat("function" != typeof e[i] ? e[i] : e[i.indexOf("set") || "function" != typeof e["get" + i.substr(3)] ? i : "get" + i.substr(3)]()), l = (s = this.finals[i] = "string" == typeof o && "=" === o.charAt(1) ? a + parseInt(o.charAt(0) + "1", 10) * Number(o.substr(2)) : Number(o) || 0) - a, u.length && (-1 !== (o = u.join("_")).indexOf("short") && (l %= c) !== l % (c / 2) && (l = l < 0 ? l + c : l - c), -1 !== o.indexOf("_cw") && l < 0 ? l = (l + 9999999999 * c) % c - (l / c | 0) * c : -1 !== o.indexOf("ccw") && l > 0 && (l = (l - 9999999999 * c) % c - (l / c | 0) * c)), (l > 1e-6 || l < -1e-6) && (this._addTween(e, i, a, a + l, i), this._overwriteProps.push(i)));
                return !0
            },
            set: function (e) {
                var t;
                if (1 !== e) this._super.setRatio.call(this, e); else for (t = this._firstPT; t;) t.f ? t.t[t.p](this.finals[t.p]) : t.t[t.p] = this.finals[t.p], t = t._next
            }
        });
        E._autoCSS = !0;
        /*!
 * VERSION: 1.3.9
 * DATE: 2019-05-17
 * UPDATES AND DOCS AT: http://greensock.com
 *
 * @license Copyright (c) 2008-2019, GreenSock. All rights reserved.
 * This work is subject to the terms at http://greensock.com/standard-license or for
 * Club GreenSock members, the software agreement that was issued with your membership.
 *
 * @author: Jack Doyle, jack@greensock.com
 **/
        var C = 180 / Math.PI, S = [], M = [], A = [], O = {}, w = o._gsDefine.globals, R = function (e, t, n, r) {
            n === r && (n = r - (r - t) / 1e6), e === t && (t = e + (n - e) / 1e6), this.a = e, this.b = t, this.c = n, this.d = r, this.da = r - e, this.ca = n - e, this.ba = t - e
        }, P = function (e, t, n, r) {
            var i = {a: e}, o = {}, a = {}, s = {c: r}, l = (e + t) / 2, u = (t + n) / 2, c = (n + r) / 2,
                p = (l + u) / 2, d = (u + c) / 2, h = (d - p) / 8;
            return i.b = l + (e - l) / 4, o.b = p + h, i.c = o.a = (i.b + o.b) / 2, o.c = a.a = (p + d) / 2, a.b = d - h, s.b = c + (r - c) / 4, a.c = s.a = (a.b + s.b) / 2, [i, o, a, s]
        }, L = function (e, t, n, r, i) {
            var o, a, s, l, u, c, p, d, h, f, m, _, g, v = e.length - 1, y = 0, b = e[0].a;
            for (o = 0; o < v; o++) a = (u = e[y]).a, s = u.d, l = e[y + 1].d, i ? (m = S[o], g = ((_ = M[o]) + m) * t * .25 / (r ? .5 : A[o] || .5), d = s - ((c = s - (s - a) * (r ? .5 * t : 0 !== m ? g / m : 0)) + (((p = s + (l - s) * (r ? .5 * t : 0 !== _ ? g / _ : 0)) - c) * (3 * m / (m + _) + .5) / 4 || 0))) : d = s - ((c = s - (s - a) * t * .5) + (p = s + (l - s) * t * .5)) / 2, c += d, p += d, u.c = h = c, u.b = 0 !== o ? b : b = u.a + .6 * (u.c - u.a), u.da = s - a, u.ca = h - a, u.ba = b - a, n ? (f = P(a, b, h, s), e.splice(y, 1, f[0], f[1], f[2], f[3]), y += 4) : y++, b = p;
            (u = e[y]).b = b, u.c = b + .4 * (u.d - b), u.da = u.d - u.a, u.ca = u.c - u.a, u.ba = b - u.a, n && (f = P(u.a, b, u.c, u.d), e.splice(y, 1, f[0], f[1], f[2], f[3]))
        }, D = function (e, t, n, r) {
            var i, o, a, s, l, u, c = [];
            if (r) for (o = (e = [r].concat(e)).length; --o > -1;) "string" == typeof (u = e[o][t]) && "=" === u.charAt(1) && (e[o][t] = r[t] + Number(u.charAt(0) + u.substr(2)));
            if ((i = e.length - 2) < 0) return c[0] = new R(e[0][t], 0, 0, e[0][t]), c;
            for (o = 0; o < i; o++) a = e[o][t], s = e[o + 1][t], c[o] = new R(a, 0, 0, s), n && (l = e[o + 2][t], S[o] = (S[o] || 0) + (s - a) * (s - a), M[o] = (M[o] || 0) + (l - s) * (l - s));
            return c[o] = new R(e[o][t], 0, 0, e[o + 1][t]), c
        }, I = function (e, t, n, r, i, o) {
            var a, s, l, u, c, p, d, h, f = {}, m = [], _ = o || e[0];
            for (s in i = "string" == typeof i ? "," + i + "," : ",x,y,z,left,top,right,bottom,marginTop,marginLeft,marginRight,marginBottom,paddingLeft,paddingTop,paddingRight,paddingBottom,backgroundPosition,backgroundPosition_y,", null == t && (t = 1), e[0]) m.push(s);
            if (e.length > 1) {
                for (h = e[e.length - 1], d = !0, a = m.length; --a > -1;) if (s = m[a], Math.abs(_[s] - h[s]) > .05) {
                    d = !1;
                    break
                }
                d && (e = e.concat(), o && e.unshift(o), e.push(e[1]), o = e[e.length - 3])
            }
            for (S.length = M.length = A.length = 0, a = m.length; --a > -1;) s = m[a], O[s] = -1 !== i.indexOf("," + s + ","), f[s] = D(e, s, O[s], o);
            for (a = S.length; --a > -1;) S[a] = Math.sqrt(S[a]), M[a] = Math.sqrt(M[a]);
            if (!r) {
                for (a = m.length; --a > -1;) if (O[s]) for (p = (l = f[m[a]]).length - 1, u = 0; u < p; u++) c = l[u + 1].da / M[u] + l[u].da / S[u] || 0, A[u] = (A[u] || 0) + c * c;
                for (a = A.length; --a > -1;) A[a] = Math.sqrt(A[a])
            }
            for (a = m.length, u = n ? 4 : 1; --a > -1;) l = f[s = m[a]], L(l, t, n, r, O[s]), d && (l.splice(0, u), l.splice(l.length - u, u));
            return f
        }, N = function (e, t, n) {
            for (var r, i, o, a, s, l, u, c, p, d, h, f = 1 / n, m = e.length; --m > -1;) for (o = (d = e[m]).a, a = d.d - o, s = d.c - o, l = d.b - o, r = i = 0, c = 1; c <= n; c++) r = i - (i = ((u = f * c) * u * a + 3 * (p = 1 - u) * (u * s + p * l)) * u), t[h = m * n + c - 1] = (t[h] || 0) + r * r
        }, z = o._gsDefine.plugin({
            propName: "bezier", priority: -1, version: "1.3.9", API: 2, global: !0, init: function (e, t, n) {
                this._target = e, t instanceof Array && (t = {values: t}), this._func = {}, this._mod = {}, this._props = [], this._timeRes = null == t.timeResolution ? 6 : parseInt(t.timeResolution, 10);
                var r, i, o, a, s, l = t.values || [], u = {}, c = l[0], p = t.autoRotate || n.vars.orientToBezier;
                for (r in this._autoRotate = p ? p instanceof Array ? p : [["x", "y", "rotation", !0 === p ? 0 : Number(p) || 0]] : null, c) this._props.push(r);
                for (o = this._props.length; --o > -1;) r = this._props[o], this._overwriteProps.push(r), i = this._func[r] = "function" == typeof e[r], u[r] = i ? e[r.indexOf("set") || "function" != typeof e["get" + r.substr(3)] ? r : "get" + r.substr(3)]() : parseFloat(e[r]), s || u[r] !== l[0][r] && (s = u);
                if (this._beziers = "cubic" !== t.type && "quadratic" !== t.type && "soft" !== t.type ? I(l, isNaN(t.curviness) ? 1 : t.curviness, !1, "thruBasic" === t.type, t.correlate, s) : function (e, t, n) {
                    var r, i, o, a, s, l, u, c, p, d, h, f = {}, m = "cubic" === (t = t || "soft") ? 3 : 2,
                        _ = "soft" === t, g = [];
                    if (_ && n && (e = [n].concat(e)), null == e || e.length < m + 1) throw"invalid Bezier data";
                    for (p in e[0]) g.push(p);
                    for (l = g.length; --l > -1;) {
                        for (f[p = g[l]] = s = [], d = 0, c = e.length, u = 0; u < c; u++) r = null == n ? e[u][p] : "string" == typeof (h = e[u][p]) && "=" === h.charAt(1) ? n[p] + Number(h.charAt(0) + h.substr(2)) : Number(h), _ && u > 1 && u < c - 1 && (s[d++] = (r + s[d - 2]) / 2), s[d++] = r;
                        for (c = d - m + 1, d = 0, u = 0; u < c; u += m) r = s[u], i = s[u + 1], o = s[u + 2], a = 2 === m ? 0 : s[u + 3], s[d++] = h = 3 === m ? new R(r, i, o, a) : new R(r, (2 * i + r) / 3, (2 * i + o) / 3, o);
                        s.length = d
                    }
                    return f
                }(l, t.type, u), this._segCount = this._beziers[r].length, this._timeRes) {
                    var d = function (e, t) {
                        var n, r, i, o, a = [], s = [], l = 0, u = 0, c = (t = t >> 0 || 6) - 1, p = [], d = [];
                        for (n in e) N(e[n], a, t);
                        for (i = a.length, r = 0; r < i; r++) l += Math.sqrt(a[r]), d[o = r % t] = l, o === c && (u += l, p[o = r / t >> 0] = d, s[o] = u, l = 0, d = []);
                        return {length: u, lengths: s, segments: p}
                    }(this._beziers, this._timeRes);
                    this._length = d.length, this._lengths = d.lengths, this._segments = d.segments, this._l1 = this._li = this._s1 = this._si = 0, this._l2 = this._lengths[0], this._curSeg = this._segments[0], this._s2 = this._curSeg[0], this._prec = 1 / this._curSeg.length
                }
                if (p = this._autoRotate) for (this._initialRotations = [], p[0] instanceof Array || (this._autoRotate = p = [p]), o = p.length; --o > -1;) {
                    for (a = 0; a < 3; a++) r = p[o][a], this._func[r] = "function" == typeof e[r] && e[r.indexOf("set") || "function" != typeof e["get" + r.substr(3)] ? r : "get" + r.substr(3)];
                    r = p[o][2], this._initialRotations[o] = (this._func[r] ? this._func[r].call(this._target) : this._target[r]) || 0, this._overwriteProps.push(r)
                }
                return this._startRatio = n.vars.runBackwards ? 1 : 0, !0
            }, set: function (e) {
                var t, n, r, i, o, a, s, l, u, c, p, d = this._segCount, h = this._func, f = this._target,
                    m = e !== this._startRatio;
                if (this._timeRes) {
                    if (u = this._lengths, c = this._curSeg, p = e * this._length, r = this._li, p > this._l2 && r < d - 1) {
                        for (l = d - 1; r < l && (this._l2 = u[++r]) <= p;) ;
                        this._l1 = u[r - 1], this._li = r, this._curSeg = c = this._segments[r], this._s2 = c[this._s1 = this._si = 0]
                    } else if (p < this._l1 && r > 0) {
                        for (; r > 0 && (this._l1 = u[--r]) >= p;) ;
                        0 === r && p < this._l1 ? this._l1 = 0 : r++, this._l2 = u[r], this._li = r, this._curSeg = c = this._segments[r], this._s1 = c[(this._si = c.length - 1) - 1] || 0, this._s2 = c[this._si]
                    }
                    if (t = r, p -= this._l1, r = this._si, p > this._s2 && r < c.length - 1) {
                        for (l = c.length - 1; r < l && (this._s2 = c[++r]) <= p;) ;
                        this._s1 = c[r - 1], this._si = r
                    } else if (p < this._s1 && r > 0) {
                        for (; r > 0 && (this._s1 = c[--r]) >= p;) ;
                        0 === r && p < this._s1 ? this._s1 = 0 : r++, this._s2 = c[r], this._si = r
                    }
                    a = 1 === e ? 1 : (r + (p - this._s1) / (this._s2 - this._s1)) * this._prec || 0
                } else a = (e - (t = e < 0 ? 0 : e >= 1 ? d - 1 : d * e >> 0) * (1 / d)) * d;
                for (n = 1 - a, r = this._props.length; --r > -1;) i = this._props[r], s = (a * a * (o = this._beziers[i][t]).da + 3 * n * (a * o.ca + n * o.ba)) * a + o.a, this._mod[i] && (s = this._mod[i](s, f)), h[i] ? f[i](s) : f[i] = s;
                if (this._autoRotate) {
                    var _, g, v, y, b, x, T, E = this._autoRotate;
                    for (r = E.length; --r > -1;) i = E[r][2], x = E[r][3] || 0, T = !0 === E[r][4] ? 1 : C, o = this._beziers[E[r][0]], _ = this._beziers[E[r][1]], o && _ && (o = o[t], _ = _[t], g = o.a + (o.b - o.a) * a, g += ((y = o.b + (o.c - o.b) * a) - g) * a, y += (o.c + (o.d - o.c) * a - y) * a, v = _.a + (_.b - _.a) * a, v += ((b = _.b + (_.c - _.b) * a) - v) * a, b += (_.c + (_.d - _.c) * a - b) * a, s = m ? Math.atan2(b - v, y - g) * T + x : this._initialRotations[r], this._mod[i] && (s = this._mod[i](s, f)), h[i] ? f[i](s) : f[i] = s)
                }
            }
        }), U = z.prototype;
        z.bezierThrough = I, z.cubicToQuadratic = P, z._autoCSS = !0, z.quadraticToCubic = function (e, t, n) {
            return new R(e, (2 * t + e) / 3, (2 * t + n) / 3, n)
        }, z._cssRegister = function () {
            var e = w.CSSPlugin;
            if (e) {
                var t = e._internals, n = t._parseToProxy, r = t._setPluginRatio, i = t.CSSPropTween;
                t._registerComplexSpecialProp("bezier", {
                    parser: function (e, t, o, a, s, l) {
                        t instanceof Array && (t = {values: t}), l = new z;
                        var u, c, p, d = t.values, h = d.length - 1, f = [], m = {};
                        if (h < 0) return s;
                        for (u = 0; u <= h; u++) p = n(e, d[u], a, s, l, h !== u), f[u] = p.end;
                        for (c in t) m[c] = t[c];
                        return m.values = f, (s = new i(e, "bezier", 0, 0, p.pt, 2)).data = p, s.plugin = l, s.setRatio = r, 0 === m.autoRotate && (m.autoRotate = !0), !m.autoRotate || m.autoRotate instanceof Array || (u = !0 === m.autoRotate ? 0 : Number(m.autoRotate), m.autoRotate = null != p.end.left ? [["left", "top", "rotation", u, !1]] : null != p.end.x && [["x", "y", "rotation", u, !1]]), m.autoRotate && (a._transform || a._enableTransforms(!1), p.autoRotate = a._target._gsTransform, p.proxy.rotation = p.autoRotate.rotation || 0, a._overwriteProps.push("rotation")), l._onInitTween(p.proxy, m, a._tween), s
                    }
                })
            }
        }, U._mod = function (e) {
            for (var t, n = this._overwriteProps, r = n.length; --r > -1;) (t = e[n[r]]) && "function" == typeof t && (this._mod[n[r]] = t)
        }, U._kill = function (e) {
            var t, n, r = this._props;
            for (t in this._beziers) if (t in e) for (delete this._beziers[t], delete this._func[t], n = r.length; --n > -1;) r[n] === t && r.splice(n, 1);
            if (r = this._autoRotate) for (n = r.length; --n > -1;) e[r[n][2]] && r.splice(n, 1);
            return this._super._kill.call(this, e)
        },
            /*!
 * VERSION: 1.16.1
 * DATE: 2018-08-27
 * UPDATES AND DOCS AT: http://greensock.com
 *
 * @license Copyright (c) 2008-2019, GreenSock. All rights reserved.
 * This work is subject to the terms at http://greensock.com/standard-license or for
 * Club GreenSock members, the software agreement that was issued with your membership.
 *
 * @author: Jack Doyle, jack@greensock.com
 **/
            o._gsDefine("easing.Back", ["easing.Ease"], (function () {
                var e, t, n, r, i = o.GreenSockGlobals || o, a = i.com.greensock, s = 2 * Math.PI, l = Math.PI / 2,
                    u = a._class, c = function (e, t) {
                        var n = u("easing." + e, (function () {
                        }), !0), r = n.prototype = new p;
                        return r.constructor = n, r.getRatio = t, n
                    }, d = p.register || function () {
                    }, h = function (e, t, n, r, i) {
                        var o = u("easing." + e, {easeOut: new t, easeIn: new n, easeInOut: new r}, !0);
                        return d(o, e), o
                    }, f = function (e, t, n) {
                        this.t = e, this.v = t, n && (this.next = n, n.prev = this, this.c = n.v - t, this.gap = n.t - e)
                    }, m = function (e, t) {
                        var n = u("easing." + e, (function (e) {
                            this._p1 = e || 0 === e ? e : 1.70158, this._p2 = 1.525 * this._p1
                        }), !0), r = n.prototype = new p;
                        return r.constructor = n, r.getRatio = t, r.config = function (e) {
                            return new n(e)
                        }, n
                    }, _ = h("Back", m("BackOut", (function (e) {
                        return (e -= 1) * e * ((this._p1 + 1) * e + this._p1) + 1
                    })), m("BackIn", (function (e) {
                        return e * e * ((this._p1 + 1) * e - this._p1)
                    })), m("BackInOut", (function (e) {
                        return (e *= 2) < 1 ? .5 * e * e * ((this._p2 + 1) * e - this._p2) : .5 * ((e -= 2) * e * ((this._p2 + 1) * e + this._p2) + 2)
                    }))), g = u("easing.SlowMo", (function (e, t, n) {
                        t = t || 0 === t ? t : .7, null == e ? e = .7 : e > 1 && (e = 1), this._p = 1 !== e ? t : 0, this._p1 = (1 - e) / 2, this._p2 = e, this._p3 = this._p1 + this._p2, this._calcEnd = !0 === n
                    }), !0), v = g.prototype = new p;
                return v.constructor = g, v.getRatio = function (e) {
                    var t = e + (.5 - e) * this._p;
                    return e < this._p1 ? this._calcEnd ? 1 - (e = 1 - e / this._p1) * e : t - (e = 1 - e / this._p1) * e * e * e * t : e > this._p3 ? this._calcEnd ? 1 === e ? 0 : 1 - (e = (e - this._p3) / this._p1) * e : t + (e - t) * (e = (e - this._p3) / this._p1) * e * e * e : this._calcEnd ? 1 : t
                }, g.ease = new g(.7, .7), v.config = g.config = function (e, t, n) {
                    return new g(e, t, n)
                }, (v = (e = u("easing.SteppedEase", (function (e, t) {
                    e = e || 1, this._p1 = 1 / e, this._p2 = e + (t ? 0 : 1), this._p3 = t ? 1 : 0
                }), !0)).prototype = new p).constructor = e, v.getRatio = function (e) {
                    return e < 0 ? e = 0 : e >= 1 && (e = .999999999), ((this._p2 * e | 0) + this._p3) * this._p1
                }, v.config = e.config = function (t, n) {
                    return new e(t, n)
                }, (v = (t = u("easing.ExpoScaleEase", (function (e, t, n) {
                    this._p1 = Math.log(t / e), this._p2 = t - e, this._p3 = e, this._ease = n
                }), !0)).prototype = new p).constructor = t, v.getRatio = function (e) {
                    return this._ease && (e = this._ease.getRatio(e)), (this._p3 * Math.exp(this._p1 * e) - this._p3) / this._p2
                }, v.config = t.config = function (e, n, r) {
                    return new t(e, n, r)
                }, (v = (n = u("easing.RoughEase", (function (e) {
                    for (var t, n, r, i, o, a, s = (e = e || {}).taper || "none", l = [], u = 0, c = 0 | (e.points || 20), d = c, h = !1 !== e.randomize, m = !0 === e.clamp, _ = e.template instanceof p ? e.template : null, g = "number" == typeof e.strength ? .4 * e.strength : .4; --d > -1;) t = h ? Math.random() : 1 / c * d, n = _ ? _.getRatio(t) : t, r = "none" === s ? g : "out" === s ? (i = 1 - t) * i * g : "in" === s ? t * t * g : t < .5 ? (i = 2 * t) * i * .5 * g : (i = 2 * (1 - t)) * i * .5 * g, h ? n += Math.random() * r - .5 * r : d % 2 ? n += .5 * r : n -= .5 * r, m && (n > 1 ? n = 1 : n < 0 && (n = 0)), l[u++] = {
                        x: t,
                        y: n
                    };
                    for (l.sort((function (e, t) {
                        return e.x - t.x
                    })), a = new f(1, 1, null), d = c; --d > -1;) o = l[d], a = new f(o.x, o.y, a);
                    this._prev = new f(0, 0, 0 !== a.t ? a : a.next)
                }), !0)).prototype = new p).constructor = n, v.getRatio = function (e) {
                    var t = this._prev;
                    if (e > t.t) {
                        for (; t.next && e >= t.t;) t = t.next;
                        t = t.prev
                    } else for (; t.prev && e <= t.t;) t = t.prev;
                    return this._prev = t, t.v + (e - t.t) / t.gap * t.c
                }, v.config = function (e) {
                    return new n(e)
                }, n.ease = new n, h("Bounce", c("BounceOut", (function (e) {
                    return e < 1 / 2.75 ? 7.5625 * e * e : e < 2 / 2.75 ? 7.5625 * (e -= 1.5 / 2.75) * e + .75 : e < 2.5 / 2.75 ? 7.5625 * (e -= 2.25 / 2.75) * e + .9375 : 7.5625 * (e -= 2.625 / 2.75) * e + .984375
                })), c("BounceIn", (function (e) {
                    return (e = 1 - e) < 1 / 2.75 ? 1 - 7.5625 * e * e : e < 2 / 2.75 ? 1 - (7.5625 * (e -= 1.5 / 2.75) * e + .75) : e < 2.5 / 2.75 ? 1 - (7.5625 * (e -= 2.25 / 2.75) * e + .9375) : 1 - (7.5625 * (e -= 2.625 / 2.75) * e + .984375)
                })), c("BounceInOut", (function (e) {
                    var t = e < .5;
                    return (e = t ? 1 - 2 * e : 2 * e - 1) < 1 / 2.75 ? e *= 7.5625 * e : e = e < 2 / 2.75 ? 7.5625 * (e -= 1.5 / 2.75) * e + .75 : e < 2.5 / 2.75 ? 7.5625 * (e -= 2.25 / 2.75) * e + .9375 : 7.5625 * (e -= 2.625 / 2.75) * e + .984375, t ? .5 * (1 - e) : .5 * e + .5
                }))), h("Circ", c("CircOut", (function (e) {
                    return Math.sqrt(1 - (e -= 1) * e)
                })), c("CircIn", (function (e) {
                    return -(Math.sqrt(1 - e * e) - 1)
                })), c("CircInOut", (function (e) {
                    return (e *= 2) < 1 ? -.5 * (Math.sqrt(1 - e * e) - 1) : .5 * (Math.sqrt(1 - (e -= 2) * e) + 1)
                }))), h("Elastic", (r = function (e, t, n) {
                    var r = u("easing." + e, (function (e, t) {
                        this._p1 = e >= 1 ? e : 1, this._p2 = (t || n) / (e < 1 ? e : 1), this._p3 = this._p2 / s * (Math.asin(1 / this._p1) || 0), this._p2 = s / this._p2
                    }), !0), i = r.prototype = new p;
                    return i.constructor = r, i.getRatio = t, i.config = function (e, t) {
                        return new r(e, t)
                    }, r
                })("ElasticOut", (function (e) {
                    return this._p1 * Math.pow(2, -10 * e) * Math.sin((e - this._p3) * this._p2) + 1
                }), .3), r("ElasticIn", (function (e) {
                    return -this._p1 * Math.pow(2, 10 * (e -= 1)) * Math.sin((e - this._p3) * this._p2)
                }), .3), r("ElasticInOut", (function (e) {
                    return (e *= 2) < 1 ? this._p1 * Math.pow(2, 10 * (e -= 1)) * Math.sin((e - this._p3) * this._p2) * -.5 : this._p1 * Math.pow(2, -10 * (e -= 1)) * Math.sin((e - this._p3) * this._p2) * .5 + 1
                }), .45)), h("Expo", c("ExpoOut", (function (e) {
                    return 1 - Math.pow(2, -10 * e)
                })), c("ExpoIn", (function (e) {
                    return Math.pow(2, 10 * (e - 1)) - .001
                })), c("ExpoInOut", (function (e) {
                    return (e *= 2) < 1 ? .5 * Math.pow(2, 10 * (e - 1)) : .5 * (2 - Math.pow(2, -10 * (e - 1)))
                }))), h("Sine", c("SineOut", (function (e) {
                    return Math.sin(e * l)
                })), c("SineIn", (function (e) {
                    return 1 - Math.cos(e * l)
                })), c("SineInOut", (function (e) {
                    return -.5 * (Math.cos(Math.PI * e) - 1)
                }))), u("easing.EaseLookup", {
                    find: function (e) {
                        return p.map[e]
                    }
                }, !0), d(i.SlowMo, "SlowMo", "ease,"), d(n, "RoughEase", "ease,"), d(e, "SteppedEase", "ease,"), _
            }), !0);
        var F = s.Back, k = s.Elastic, V = s.Bounce, B = s.RoughEase, G = s.SlowMo, j = s.SteppedEase, H = s.Circ,
            W = s.Expo, X = s.Sine, Y = s.ExpoScaleEase, q = _;
        q._autoActivated = [f, m, g, v, z, y, E, F, k, V, B, G, j, H, W, X, Y];
        /*! *****************************************************************************
Copyright (c) Microsoft Corporation. All rights reserved.
Licensed under the Apache License, Version 2.0 (the "License"); you may not use
this file except in compliance with the License. You may obtain a copy of the
License at http://www.apache.org/licenses/LICENSE-2.0

THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED
WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,
MERCHANTABLITY OR NON-INFRINGEMENT.

See the Apache Version 2.0 License for specific language governing permissions
and limitations under the License.
***************************************************************************** */
        var Z = function (e, t) {
            return (Z = Object.setPrototypeOf || {__proto__: []} instanceof Array && function (e, t) {
                e.__proto__ = t
            } || function (e, t) {
                for (var n in t) t.hasOwnProperty(n) && (e[n] = t[n])
            })(e, t)
        };
        var K = function (e) {
            function t() {
                return this
            }

            return function (e, t) {
                function n() {
                    this.constructor = e
                }

                Z(e, t), e.prototype = null === t ? Object.create(t) : (n.prototype = t.prototype, new n)
            }(t, DebuggerClass), t._onUpdateTargets = function (e) {
                for (var t = 0, n = e; t < n.length; t++) {
                    n[t].updater.update()
                }
            }, t.toPosition = function (e, n, r) {
                if (Array.isArray(e)) {
                    for (var i = [], o = 0, s = e; o < s.length; o++) {
                        var l = s[o], u = r.isWorldSpace ? l.position : l.localPosition;
                        i.push(u)
                    }
                    return delete r.isWorldSpace, r.onUpdate = t._onUpdateTargets, r.onUpdateParams = [i], a.to(i, n, r)
                }
                var c = r.isWorldSpace ? e.position : e.localPosition;
                return delete r.isWorldSpace, r.onUpdate = c.updater.update, r.onUpdateScope = c.updater, a.to(c, n, r)
            }, t.toRotation = function (e, n, r) {
                if (void 0 !== r.x && (r[0] = r.x, delete r.x), void 0 !== r.y && (r[1] = r.y, delete r.y), void 0 !== r.z && (r[2] = r.z, delete r.z), void 0 !== r.w && (r[3] = r.w, delete r.w), Array.isArray(e)) {
                    for (var i = [], o = [], s = 0, l = e; s < l.length; s++) {
                        var u = l[s], c = r.isWorldSpace ? u.rotation : u.localRotation;
                        i.push(c.rawData), o.push(c)
                    }
                    return delete r.isWorldSpace, r.onUpdate = t._onUpdateTargets, r.onUpdateParams = [o], a.to(i, n, r)
                }
                var p = r.isWorldSpace ? e.rotation : e.localRotation;
                return delete r.isWorldSpace, r.onUpdate = p.updater.update, r.onUpdateScope = p.updater, a.to(p.rawData, n, r)
            }, t.toEulerAngles = function (e, n, r) {
                void 0 === r.order && (r.order = 3);
                var i = t._helpQuaternion.fromEuler(r.x, r.y, r.z, r.order);
                if (r[0] = i.rawData[0], r[1] = i.rawData[1], r[2] = i.rawData[2], r[3] = i.rawData[3], delete r.x, delete r.y, delete r.z, delete r.order, Array.isArray(e)) {
                    for (var o = [], s = [], l = 0, u = e; l < u.length; l++) {
                        var c = u[l], p = r.isWorldSpace ? c.rotation : c.localRotation;
                        o.push(p.rawData), s.push(p)
                    }
                    return delete r.isWorldSpace, r.onUpdate = t._onUpdateTargets, r.onUpdateParams = [s], a.to(o, n, r)
                }
                var d = r.isWorldSpace ? e.rotation : e.localRotation;
                return delete r.isWorldSpace, r.onUpdate = d.updater.update, r.onUpdateScope = d.updater, a.to(d.rawData, n, r)
            }, t.toScale = function (e, n, r) {
                if (Array.isArray(e)) {
                    for (var i = [], o = 0, s = e; o < s.length; o++) {
                        var l = s[o];
                        i.push(l.localScale)
                    }
                    return delete r.isWorldSpace, r.onUpdate = t._onUpdateTargets, r.onUpdateParams = [i], a.to(i, n, r)
                }
                var u = e.localScale;
                return r.onUpdate = u.updater.update, r.onUpdateScope = u.updater, a.to(u, n, r)
            }, t.toOpacity = function (e, t, n) {
                if (void 0 === n.blendMode && (n.blendMode = 2), void 0 === n.renderQueue && (n.renderQueue = 3e3), Array.isArray(e)) {
                    for (var r = 0, i = e; r < i.length; r++) {
                        i[r].setBlend(n.blendMode, n.renderQueue)
                    }
                    return delete n.blendMode, delete n.renderQueue, a.to(e, t, n)
                }
                return e.setBlend(n.blendMode, n.renderQueue), delete n.blendMode, delete n.renderQueue, a.to(e, t, n)
            }, t.killPosition = function (e) {
                if (Array.isArray(e)) for (var t = 0, n = e; t < n.length; t++) {
                    var r = n[t];
                    a.killTweensOf(r.localPosition), a.killTweensOf(r.position)
                } else a.killTweensOf(e.localPosition), a.killTweensOf(e.position)
            }, t.killRotation = function (e) {
                if (Array.isArray(e)) for (var t = 0, n = e; t < n.length; t++) {
                    var r = n[t];
                    a.killTweensOf(r.localRotation), a.killTweensOf(r.rotation)
                } else a.killTweensOf(e.localRotation), a.killTweensOf(e.rotation)
            }, t.killEulerAngles = function (e) {
                if (Array.isArray(e)) for (var t = 0, n = e; t < n.length; t++) {
                    var r = n[t];
                    a.killTweensOf(r.localEulerAngles), a.killTweensOf(r.eulerAngles)
                } else a.killTweensOf(e.localEulerAngles), a.killTweensOf(e.eulerAngles)
            }, t.killScale = function (e) {
                if (Array.isArray(e)) for (var t = 0, n = e; t < n.length; t++) {
                    var r = n[t];
                    a.killTweensOf(r.localScale)
                } else a.killTweensOf(e.localScale)
            }, t._helpQuaternion = i.Quaternion.create(), t
        }();
        __reflect(K, "@egret/tween/Tween")
    }.call(this, n(16)(e), n(6))
}, function (e, t) {
    e.exports = function (e) {
        if (!e.webpackPolyfill) {
            var t = Object.create(e);
            t.children || (t.children = []), Object.defineProperty(t, "loaded", {
                enumerable: !0, get: function () {
                    return t.l
                }
            }), Object.defineProperty(t, "id", {
                enumerable: !0, get: function () {
                    return t.i
                }
            }), Object.defineProperty(t, "exports", {enumerable: !0}), t.webpackPolyfill = 1
        }
        return t
    }
}, function (e, t, n) {
    "use strict";
    n.r(t), n.d(t, "AudioChannel", (function () {
        return c
    })), n.d(t, "AudioSystem", (function () {
        return d
    })), n.d(t, "startup", (function () {
        return h
    }));
    var r = n(1), i = n(0), o = n(2), a = function (e, t) {
        return (a = Object.setPrototypeOf || {__proto__: []} instanceof Array && function (e, t) {
            e.__proto__ = t
        } || function (e, t) {
            for (var n in t) t.hasOwnProperty(n) && (e[n] = t[n])
        })(e, t)
    };

    function s(e, t) {
        function n() {
            this.constructor = e
        }

        a(e, t), e.prototype = null === t ? Object.create(t) : (n.prototype = t.prototype, new n)
    }

    function l(e, t, n, r) {
        var i, o = arguments.length, a = o < 3 ? t : null === r ? r = Object.getOwnPropertyDescriptor(t, n) : r;
        if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) a = Reflect.decorate(e, t, n, r); else for (var s = e.length - 1; s >= 0; s--) (i = e[s]) && (a = (o < 3 ? i(a) : o > 3 ? i(t, n, a) : i(t, n)) || a);
        return o > 3 && a && Object.defineProperty(t, n, a), a
    }

    function u(e, t) {
        var n, r, i, o, a = {
            label: 0, sent: function () {
                if (1 & i[0]) throw i[1];
                return i[1]
            }, trys: [], ops: []
        };
        return o = {
            next: s(0),
            throw: s(1),
            return: s(2)
        }, "function" == typeof Symbol && (o[Symbol.iterator] = function () {
            return this
        }), o;

        function s(o) {
            return function (s) {
                return function (o) {
                    if (n) throw new TypeError("Generator is already executing.");
                    for (; a;) try {
                        if (n = 1, r && (i = 2 & o[0] ? r.return : o[0] ? r.throw || ((i = r.return) && i.call(r), 0) : r.next) && !(i = i.call(r, o[1])).done) return i;
                        switch (r = 0, i && (o = [2 & o[0], i.value]), o[0]) {
                            case 0:
                            case 1:
                                i = o;
                                break;
                            case 4:
                                return a.label++, {value: o[1], done: !1};
                            case 5:
                                a.label++, r = o[1], o = [0];
                                continue;
                            case 7:
                                o = a.ops.pop(), a.trys.pop();
                                continue;
                            default:
                                if (!(i = a.trys, (i = i.length > 0 && i[i.length - 1]) || 6 !== o[0] && 2 !== o[0])) {
                                    a = 0;
                                    continue
                                }
                                if (3 === o[0] && (!i || o[1] > i[0] && o[1] < i[3])) {
                                    a.label = o[1];
                                    break
                                }
                                if (6 === o[0] && a.label < i[1]) {
                                    a.label = i[1], i = o;
                                    break
                                }
                                if (i && a.label < i[2]) {
                                    a.label = i[2], a.ops.push(o);
                                    break
                                }
                                i[2] && a.ops.pop(), a.trys.pop();
                                continue
                        }
                        o = t.call(e, a)
                    } catch (e) {
                        o = [6, e], r = 0
                    } finally {
                        n = i = 0
                    }
                    if (5 & o[0]) throw o[1];
                    return {value: o[0] ? o[1] : void 0, done: !0}
                }([o, s])
            }
        }
    }

    var c = function (e) {
        function t() {
            var t = null !== e && e.apply(this, arguments) || this;
            return t.loop = !0, t.source = "", t
        }

        return s(t, e), l([Object(i.property)("boolean"), i.serializedField], t.prototype, "loop", void 0), l([Object(i.property)("string"), i.serializedField], t.prototype, "source", void 0), t = l([Object(o.component)({isAbstract: !1})], t)
    }(r.GameComponent);
    __reflect(c, "@egret/audio/AudioChannel");
    var p = function (e) {
        function t() {
            return null !== e && e.apply(this, arguments) || this
        }

        return s(t, e), t.prototype.load = function (e, t) {
            return new Promise((function (n, r) {
                var i = new Audio;
                i.addEventListener("canplay", (function () {
                    console.log(e, ""), n(i)
                })), i.addEventListener("error", (function () {
                    r("")
                }));
                var o = t.baseUrl + "/" + e;
                i.src = o, console.log(o, ""), i.load()
            }))
        }, t
    }(DebuggerClass);
    __reflect(p, "@egret/audio/SoundLoader");
    var d = function (e) {
        function t() {
            var t = null !== e && e.apply(this, arguments) || this;
            return t._isReady = !1, t._isNotReadyQueue = [], t.clickHandler = function () {
                if (!(t._isNotReadyQueue.length <= 0)) {
                    t._isReady = !0, console.log("_isNotReadyQueue", t._isNotReadyQueue.length);
                    for (var e = 0, n = t._isNotReadyQueue; e < n.length; e++) {
                        var r = n[e];
                        console.log("_isNotReadyQueue", r.src), r.volume = 0, r.play()
                    }
                    t._isNotReadyQueue = [], "undefined" != typeof wx ? wx.offTouchStart(t.clickHandler) : window.removeEventListener("click", t.clickHandler)
                }
            }, t._hasLoadedAudio = [], t._audioUrlList = [], t
        }

        return s(t, e), t.prototype.getMatchers = function () {
            return [o.Matcher.create(r.GameEntity, !1, c)]
        }, t.prototype.onStart = function () {
            i.ResourceManager.instance.setProcessor("sound", new p, "mp3")
        }, t.prototype.addLoadedClickHandeler = function () {
            "undefined" != typeof Document && "undefined" != typeof Window && "undefined" != typeof Navigator && (this._isReady = !1, console.log("_audioUrlList.length:" + this._audioUrlList.length + "\n_hasLoadedAudio.length:" + this._hasLoadedAudio.length), 0 !== this._audioUrlList.length && 0 !== this._hasLoadedAudio.length && this._hasLoadedAudio.sort().toString() === this._audioUrlList.sort().toString() && (console.log("", this._audioUrlList.length), "undefined" != typeof wx ? wx.onTouchStart(this.clickHandler) : window.addEventListener("click", this.clickHandler)))
        }, t.prototype.onEntityAdded = function (e, t) {
            var n = this, r = e.getComponent(c);
            i.ResourceManager.instance.loadUri(r.source).then((function (e) {
                var t = e.data;
                t.loop = r.loop, n._isReady ? (console.log("audio.play()", t.src), t.volume = 1, t.play()) : n._hasLoadedAudio.indexOf(r.source) < 0 && (n._isNotReadyQueue.push(t), n._hasLoadedAudio.push(r.source), n.addLoadedClickHandeler())
            })).catch((function (e) {
                console.log("")
            }))
        }, t.prototype.onEntityRemoved = function (e, t) {
        }, t.prototype.onFrame = function () {
        }, t.prototype.setAllAudioList = function (e) {
            this._audioUrlList = e
        }, t = l([Object(o.system)({noneOfExecuteMode: 164})], t)
    }(o.System);

    function h() {
        return e = this, t = void 0, i = function () {
            return u(this, (function (e) {
                return r.SystemManager.preRegisterSystem(d, 7e3), [2]
            }))
        }, new ((n = void 0) || (n = Promise))((function (r, o) {
            function a(e) {
                try {
                    l(i.next(e))
                } catch (e) {
                    o(e)
                }
            }

            function s(e) {
                try {
                    l(i.throw(e))
                } catch (e) {
                    o(e)
                }
            }

            function l(e) {
                e.done ? r(e.value) : new n((function (t) {
                    t(e.value)
                })).then(a, s)
            }

            l((i = i.apply(e, t || [])).next())
        }));
        var e, t, n, i
    }

    __reflect(d, "@egret/audio/AudioSystem")
}, function (e, t, n) {
    "use strict";
    n.r(t), function (e) {
        n.d(t, "runEgret", (function () {
            return M
        })), n.d(t, "startup", (function () {
            return S
        }));
        var r = n(1), i = n(3), o = n(2), a = n(7), s = n(0), l = n(4), u = function (e, t) {
            return (u = Object.setPrototypeOf || {__proto__: []} instanceof Array && function (e, t) {
                e.__proto__ = t
            } || function (e, t) {
                for (var n in t) t.hasOwnProperty(n) && (e[n] = t[n])
            })(e, t)
        };

        function c(e, t) {
            function n() {
                this.constructor = e
            }

            u(e, t), e.prototype = null === t ? Object.create(t) : (n.prototype = t.prototype, new n)
        }

        function p(e, t, n, r) {
            var i, o = arguments.length, a = o < 3 ? t : null === r ? r = Object.getOwnPropertyDescriptor(t, n) : r;
            if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) a = Reflect.decorate(e, t, n, r); else for (var s = e.length - 1; s >= 0; s--) (i = e[s]) && (a = (o < 3 ? i(a) : o > 3 ? i(t, n, a) : i(t, n)) || a);
            return o > 3 && a && Object.defineProperty(t, n, a), a
        }

        function d(e, t, n, r) {
            return new (n || (n = Promise))((function (i, o) {
                function a(e) {
                    try {
                        l(r.next(e))
                    } catch (e) {
                        o(e)
                    }
                }

                function s(e) {
                    try {
                        l(r.throw(e))
                    } catch (e) {
                        o(e)
                    }
                }

                function l(e) {
                    e.done ? i(e.value) : new n((function (t) {
                        t(e.value)
                    })).then(a, s)
                }

                l((r = r.apply(e, t || [])).next())
            }))
        }

        function h(e, t) {
            var n, r, i, o, a = {
                label: 0, sent: function () {
                    if (1 & i[0]) throw i[1];
                    return i[1]
                }, trys: [], ops: []
            };
            return o = {
                next: s(0),
                throw: s(1),
                return: s(2)
            }, "function" == typeof Symbol && (o[Symbol.iterator] = function () {
                return this
            }), o;

            function s(o) {
                return function (s) {
                    return function (o) {
                        if (n) throw new TypeError("Generator is already executing.");
                        for (; a;) try {
                            if (n = 1, r && (i = 2 & o[0] ? r.return : o[0] ? r.throw || ((i = r.return) && i.call(r), 0) : r.next) && !(i = i.call(r, o[1])).done) return i;
                            switch (r = 0, i && (o = [2 & o[0], i.value]), o[0]) {
                                case 0:
                                case 1:
                                    i = o;
                                    break;
                                case 4:
                                    return a.label++, {value: o[1], done: !1};
                                case 5:
                                    a.label++, r = o[1], o = [0];
                                    continue;
                                case 7:
                                    o = a.ops.pop(), a.trys.pop();
                                    continue;
                                default:
                                    if (!(i = a.trys, (i = i.length > 0 && i[i.length - 1]) || 6 !== o[0] && 2 !== o[0])) {
                                        a = 0;
                                        continue
                                    }
                                    if (3 === o[0] && (!i || o[1] > i[0] && o[1] < i[3])) {
                                        a.label = o[1];
                                        break
                                    }
                                    if (6 === o[0] && a.label < i[1]) {
                                        a.label = i[1], i = o;
                                        break
                                    }
                                    if (i && a.label < i[2]) {
                                        a.label = i[2], a.ops.push(o);
                                        break
                                    }
                                    i[2] && a.ops.pop(), a.trys.pop();
                                    continue
                            }
                            o = t.call(e, a)
                        } catch (e) {
                            o = [6, e], r = 0
                        } finally {
                            n = i = 0
                        }
                        if (5 & o[0]) throw o[1];
                        return {value: o[0] ? o[1] : void 0, done: !0}
                    }([o, s])
                }
            }
        }

        var f = ["webkit", "ms", "Moz", "O"], m = function (e) {
            function t() {
                var t = null !== e && e.apply(this, arguments) || this;
                return t._currentPrefix = "null", t._hasMouse = !1, t._isMouseEntered = !1, t._canvasSizeDirty = !0, t._lastPixelRatio = 0, t._pointerIndices = [], t._pointerIndicesRecord = {}, t._inputsDown = {}, t._application = null, t._inputManager = null, t._onFocus = function (e) {
                    r.Application.instance = t._application, t._inputManager.onFocus.dispatch(e)
                }, t._onBlur = function (e) {
                    r.Application.instance = t._application, t._inputManager.onBlur.dispatch(e)
                }, t._onCopy = function (e) {
                    r.Application.instance = t._application, t._inputManager.onCopy.dispatch(e)
                }, t._onCut = function (e) {
                    r.Application.instance = t._application, t._inputManager.onCut.dispatch(e)
                }, t._onPaste = function (e) {
                    r.Application.instance = t._application, t._inputManager.onPaste.dispatch(e)
                }, t._onKeyEvent = function (e) {
                    r.Application.instance = t._application;
                    var n = t._inputManager, i = t._inputsDown, o = e.code;
                    switch (e.type) {
                        case"keydown":
                            o in i || (n.onKeyDown.dispatch(e), i[o] = !0);
                            break;
                        case"keypress":
                            o in i && n.onKeyPress.dispatch(e);
                            break;
                        case"keyup":
                            o in i && (n.onKeyUp.dispatch(e), delete i[o])
                    }
                }, t._onMouseEvent = function (e) {
                    r.Application.instance = t._application;
                    var n = t._inputManager, i = t._inputsDown, o = {}, s = a.InputUtil.getPointerInputCode(e.button);
                    for (var l in o.isPrimary = !0, o.pointerId = 0, o.pressure = 1, o.tangentialPressure = 0, o.twist = 0, o.width = 1, o.height = 1, o.tiltX = 0, o.tiltY = 0, o.pointerType = "mouse", e) o[l] = e[l];
                    switch (e.type) {
                        case"mouseenter":
                            t._isMouseEntered = !0;
                            break;
                        case"mousedown":
                            s in i || (o.type = "pointerdown", n.onPointerDown.dispatch(o), i[s] = !0, e.preventDefault());
                            break;
                        case"mousemove":
                            (t._isMouseEntered || s in i) && (o.type = "pointermove", n.onPointerMove.dispatch(o), e.preventDefault());
                            break;
                        case"mouseup":
                            s in i && (o.type = "pointerup", n.onPointerUp.dispatch(o), delete i[s], e.preventDefault());
                            break;
                        case"mouseleave":
                            t._isMouseEntered = !1
                    }
                }, t._onTouchEvent = function (e) {
                    r.Application.instance = t._application;
                    for (var n = t._inputManager, i = t._pointerIndices, o = t._pointerIndicesRecord, a = 0, s = e.changedTouches.length; a < s; ++a) {
                        var l = e.changedTouches[a], u = {isPrimary: !0};
                        u.pressure = l.force || 1, u.tangentialPressure = 0, u.twist = 0, u.width = 2 * (l.radiusX || .5), u.height = 2 * (l.radiusY || .5), u.tiltX = 0, u.tiltY = 0, u.pointerType = "touch", u.button = 0, u.clientX = l.clientX, u.clientY = l.clientY, u.pageX = l.pageX, u.pageY = l.pageY, u.screenX = l.screenX, u.screenY = l.screenY;
                        var c = l.identifier;
                        if (!(c in o)) {
                            for (var p = !1, d = 0, h = i.length; d < h; ++d) if (!i[d]) {
                                o[c] = d, i[d] = !0, p = !0;
                                break
                            }
                            p || (o[c] = i.length, i[i.length] = !0)
                        }
                        switch (u.pointerId = o[c], e.type) {
                            case"touchstart":
                                u.type = "pointerdown", n.onPointerDown.dispatch(u);
                                break;
                            case"touchmove":
                                u.type = "pointermove", n.onPointerMove.dispatch(u);
                                break;
                            case"touchend":
                            case"touchcancel":
                                u.type = "pointerup", i[u.pointerId] = !1, delete o[c], n.onPointerUp.dispatch(u), e.type
                        }
                    }
                    0 === e.touches.length && (i.length = 0)
                }, t._onMouseWheelEvent = function (e) {
                    r.Application.instance = t._application, t._inputManager.onWheel.dispatch(e), e.preventDefault()
                }, t._onContextMenu = function (e) {
                    r.Application.instance = t._application, e.preventDefault()
                }, t
            }

            return c(t, e), t.prototype._onScreenResize = function () {
                r.Application.instance.stage._updateViewport()
            }, t.prototype._onStageResize = function () {
                this._canvasSizeDirty = !0
            }, t.prototype._getPrefix = function (e, t) {
                if (e in t) return "";
                e = e.charAt(0).toUpperCase() + e.substring(1, e.length);
                for (var n = 0; n < f.length; ++n) {
                    if (f[n] + e in t) return f[n]
                }
                return ""
            }, t.prototype._getPrefixStyleName = function (e, t) {
                void 0 === t && (t = null);
                var n = "";
                return null !== t ? n = this._getPrefix(e, t) : ("null" === this._currentPrefix && (this._currentPrefix = this._getPrefix("transform", document.createElement("div").style)), n = this._currentPrefix), "" === n ? e : n + e.charAt(0).toUpperCase() + e.substring(1, e.length)
            }, t.prototype._updateCanvas = function (e, t, n) {
                var r = e.canvas, i = t.size, o = n.viewport;
                if (r.width = o.w * this._lastPixelRatio, r.height = o.h * this._lastPixelRatio, r.style.top = o.y + "px", r.style.position = "absolute", r.style[this._getPrefixStyleName("transformOrigin")] = "0% 0% 0px", t.rotated) {
                    r.style.left = o.x + i.w + "px";
                    var a = "matrix(0," + i.h / r.width + "," + -i.w / r.height + ",0,0,0)";
                    r.style[this._getPrefixStyleName("transform")] = a
                } else {
                    r.style.left = o.x + "px";
                    a = "matrix(" + i.w / r.width + ",0,0," + i.h / r.height + ",0,0)";
                    r.style[this._getPrefixStyleName("transform")] = a
                }
            }, t.prototype._addMouseEvent = function (e) {
                this._hasMouse = !0, e.addEventListener("mouseenter", this._onMouseEvent), e.addEventListener("mousedown", this._onMouseEvent), window.addEventListener("mousemove", this._onMouseEvent), window.addEventListener("mouseup", this._onMouseEvent), e.addEventListener("mouseleave", this._onMouseEvent)
            }, t.prototype._removeMouseEvent = function (e) {
                this._hasMouse = !1, e.removeEventListener("mouseenter", this._onMouseEvent), e.removeEventListener("mousedown", this._onMouseEvent), window.removeEventListener("mousemove", this._onMouseEvent), window.removeEventListener("mouseup", this._onMouseEvent), e.removeEventListener("mouseleave", this._onMouseEvent)
            }, t.prototype.onEnable = function () {
                this._application = r.Application.instance, this._inputManager = this._application.globalEntity.getComponent(a.InputManager), this.addEvents()
            }, t.prototype.onFrame = function () {
                var e = this._application, t = e.options, n = e.screen, i = e.stage, o = t.canvas, a = n.size,
                    s = o.parentElement, l = egret.Capabilities.runtimeType !== egret.RuntimeType.RUNTIME2,
                    u = l && s ? s.offsetLeft : 0, c = l && s ? s.offsetTop : 0,
                    p = l && s ? s.clientWidth : window.innerWidth, d = l && s ? s.clientHeight : window.innerHeight;
                r.EngineUtil.isMobile ? (this._application.executeMode |= 8, this._hasMouse && this._removeMouseEvent(o)) : (this._application.executeMode &= -9, this._hasMouse || this._addMouseEvent(o));
                var h = n.useDevicePixelRatio;
                n.devicePixelRatio = window.devicePixelRatio || 1;
                var f = h ? n.devicePixelRatio : n.pixelRatio, m = !1;
                this._lastPixelRatio !== f && (this._lastPixelRatio = f, m = !0);
                var _ = i.viewport;
                _.x === u && _.y === c || (_.x = u, _.y = c, m = !0), (m || a.w !== p || a.h !== d) && (n.size = {
                    w: p,
                    h: d
                }), (m || this._canvasSizeDirty) && (this._updateCanvas(t, n, i), this._canvasSizeDirty = !1)
            }, t.prototype.onDisable = function () {
                this.removeEvents(), this._isMouseEntered = !1, this._canvasSizeDirty = !0, this._lastPixelRatio = 0, Object(i.clearRecord)(this._inputsDown), this._application = null, this._inputManager = null
            }, t.prototype.addEvents = function () {
                this.removeEvents();
                var e = this._application, t = e.options, n = e.screen, r = e.stage, i = t.canvas;
                "undefined" != typeof document && (document.body.addEventListener("copy", this._onCopy), document.body.addEventListener("cut", this._onCut), document.body.addEventListener("paste", this._onPaste)), i.addEventListener("focus", this._onFocus), i.addEventListener("blur", this._onBlur), window.addEventListener("keydown", this._onKeyEvent), window.addEventListener("keypress", this._onKeyEvent), window.addEventListener("keyup", this._onKeyEvent), this._addMouseEvent(i), i.addEventListener("mousewheel", this._onMouseWheelEvent), i.addEventListener("touchstart", this._onTouchEvent), i.addEventListener("touchmove", this._onTouchEvent), i.addEventListener("touchend", this._onTouchEvent), i.addEventListener("touchcancel", this._onTouchEvent), i.addEventListener("contextmenu", this._onContextMenu), n.onResize.add(this._onScreenResize, this), r.onResize.add(this._onStageResize, this)
            }, t.prototype.removeEvents = function () {
                var e = this._application, t = e.options, n = e.screen, r = e.stage, i = t.canvas;
                "undefined" != typeof document && (document.body.removeEventListener("copy", this._onCopy), document.body.removeEventListener("cut", this._onCut), document.body.removeEventListener("paste", this._onPaste)), i.removeEventListener("focus", this._onFocus), i.removeEventListener("blur", this._onBlur), window.removeEventListener("keydown", this._onKeyEvent), window.removeEventListener("keypress", this._onKeyEvent), window.removeEventListener("keyup", this._onKeyEvent), this._removeMouseEvent(i), i.removeEventListener("mousewheel", this._onMouseWheelEvent), i.removeEventListener("touchstart", this._onTouchEvent), i.removeEventListener("touchmove", this._onTouchEvent), i.removeEventListener("touchend", this._onTouchEvent), i.removeEventListener("touchcancel", this._onTouchEvent), i.removeEventListener("contextmenu", this._onContextMenu), n.onResize.remove(this._onScreenResize, this), r.onResize.remove(this._onStageResize, this)
            }, t = p([Object(o.system)({noneOfExecuteMode: 32})], t)
        }(o.System);
        __reflect(m, "@egret/platform-browser/StageSystem");
        var _ = function (e) {
            function t() {
                var t = null !== e && e.apply(this, arguments) || this;
                return t._application = null, t
            }

            return c(t, e), t.prototype.onEnable = function () {
                this._application = r.Application.instance, egret.pro && egret.pro.egret2dDriveMode && (this._application.driveByEgret2d = !0, this._application.egretProUtil.register("createTextureFrom3dScene", (function (e, t, n) {
                    return r.Application.instance.sceneManager.loadScene(e).then((function (r) {
                        if (!r) return null;
                        var i = r.root.getChildByName("Main Camera");
                        if (!i) return console.error("Error!Entity 'Main Camera' do not exist in scene " + e), null;
                        var o = l.RenderTexture.create({width: t, height: n});
                        i.entity.getComponent(l.Camera).renderTarget = o, o.update(7);
                        var a = new egret.Texture,
                            s = new egret.BitmapData({width: t, height: n, texture: o.glTFTexture.extras.texture});
                        return a.bitmapData = s, a
                    }))
                }), this))
            }, t.prototype.onFrame = function () {
                this._application.screen.devicePixelRatio = window.devicePixelRatio || 1
            }, t.prototype.onDisable = function () {
            }, t = p([Object(o.system)({noneOfExecuteMode: 32})], t)
        }(o.System);
        __reflect(_, "@egret/platform-browser/StagePassiveSystem");
        var g = !1, v = 0, y = new r.BasicApplication;

        function b(e, t, n) {
            if (null !== e) {
                var r = e.getAttribute(t);
                if (null !== r && "auto" !== r) return "true" === r
            }
            return n
        }

        function x(e, t, n) {
            if (null !== e) {
                var r = e.getAttribute(t);
                if (null !== r && "auto" !== r) return r
            }
            return n
        }

        function T(e) {
            var t = !window.canvas, n = r.EngineUtil.isMobile, i = navigator.userAgent.toLowerCase();
            i.indexOf("egretnative") >= 0 && -1 === i.indexOf("egretwebview") && (egret.Capabilities.runtimeType = egret.RuntimeType.RUNTIME2);
            var o = egret.Capabilities.runtimeType !== egret.RuntimeType.RUNTIME2,
                a = t && o ? new URLSearchParams(location.search) : null,
                s = t ? document.getElementsByClassName("egret-player")[0] : null, l = function (e, t) {
                    if (window.canvas) return window.canvas;
                    if (egret.pro && egret.pro.mainCanvas) return egret.pro.mainCanvas;
                    if (e.canvas) return e.canvas;
                    var n = document.createElement("canvas");
                    return n.tabIndex = 0, t.appendChild(n), n
                }(e, s);
            if (void 0 === e.executeMode) {
                var u = null !== a ? a.get("executeMode") : "";
                e.executeMode = u ? parseInt(u) : 0
            }
            switch (location.pathname) {
                case"/editor.html":
                    e.executeMode |= 4;
                    break;
                case"/preview.html":
                    e.executeMode |= 3;
                    break;
                default:
                    e.executeMode |= 1
            }
            n && (e.executeMode |= 8), t && (e.executeMode |= 16), void 0 === e.entry && (e.entry = x(s, "data-entry", "")), void 0 === e.scene && (e.scene = x(s, "data-scene", "")), void 0 === e.alpha && (e.alpha = b(s, "data-alpha", !1)), void 0 === e.antialias && (e.antialias = b(s, "data-antialias", !0)), void 0 === e.premultipliedAlpha && (e.premultipliedAlpha = b(s, "data-premultipliedAlpha", !1)), void 0 === e.depth && (e.depth = b(s, "data-depth", !0)), void 0 === e.stencil && (e.stencil = b(s, "data-stencil", !0)), e.canvas = l, e.webgl = l.getContext("webgl", e) || l.getContext("experimental-webgl", e);
            var c = l.parentElement;
            return e.screenWidth = c ? c.clientWidth : window.innerWidth, e.screenHeight = c ? c.clientHeight : window.innerHeight, e
        }

        function E(t) {
            return d(this, void 0, void 0, (function () {
                var n;
                return h(this, (function (r) {
                    switch (r.label) {
                        case 0:
                            return "function" != typeof (n = ("undefined" != typeof window ? window : e)[t]) ? [3, 2] : [4, n()];
                        case 1:
                            r.sent(), r.label = 2;
                        case 2:
                            return [2]
                    }
                }))
            }))
        }

        function C(e) {
            return d(this, void 0, void 0, (function () {
                var t, n, i, o, a, s, l, u;
                return h(this, (function (c) {
                    switch (c.label) {
                        case 0:
                            return y.isRunning ? (r.Application.instance = y, t = y.clock, n = t.update(e), i = n.deltaTickCount, o = n.deltaFrameCount, i > 0 || o > 0 ? (a = 0, a = t.timestamp(), t.wholeCost = a - v, v = a, s = y.executeMode, (l = y.systemManager).startup(s), l.execute(i, o), l.cleanup(o), l.teardown(), g ? [3, 5] : (u = y.options).entry ? [4, E(u.entry)] : [3, 2]) : [3, 6]) : [3, 6];
                        case 1:
                            c.sent(), c.label = 2;
                        case 2:
                            return u.scene && 0 == (6 & s) ? [4, y.sceneManager.loadScene(u.scene)] : [3, 4];
                        case 3:
                            c.sent(), c.label = 4;
                        case 4:
                            g = !0, c.label = 5;
                        case 5:
                            t.totalCost = t.timestamp() - a, c.label = 6;
                        case 6:
                            return requestAnimationFrame(C), [2]
                    }
                }))
            }))
        }

        function S(e) {
            return void 0 === e && (e = {}), d(this, void 0, void 0, (function () {
                return h(this, (function (t) {
                    switch (t.label) {
                        case 0:
                            return e = T(e), s.ResourceManager.instance.loader.loadImage = function (e, t) {
                                return new Promise((function (n, r) {
                                    var i = t + "/" + e, o = new Image;
                                    o.crossOrigin = "Anonymous", o.onload = function () {
                                        o.onload = null, o.onerror = null, n(o)
                                    }, o.onerror = function () {
                                        o.onload = null, o.onerror = null, console.warn("load image resource[" + i + "] failed"), r(e)
                                    }, o.src = i
                                }))
                            }, s.ResourceManager.instance.loader.loadText = function (e, t) {
                                return new Promise((function (n, r) {
                                    var i = new XMLHttpRequest;
                                    i.responseType = "text";
                                    var o = t + "/" + e;
                                    i.open("get", o), i.onload = function () {
                                        i.status >= 400 ? r("load text resource[" + o + "] failed") : n(i.responseText)
                                    }, i.onerror = function () {
                                        console.warn("load text resource[" + o + "] failed"), r()
                                    }, i.send()
                                }))
                            }, s.ResourceManager.instance.loader.loadBinary = function (e, t) {
                                return new Promise((function (n, r) {
                                    var i = t + "/" + e, o = new XMLHttpRequest;
                                    o.responseType = "arraybuffer", o.open("get", i), o.onload = function () {
                                        o.status >= 400 ? r("load binary resource[" + e + "] failed") : n(o.response)
                                    }, o.onerror = function () {
                                        console.warn("load binary resource[" + e + "] failed"), r()
                                    }, o.send()
                                }))
                            }, [4, y.loadProjectSetting()];
                        case 1:
                            return t.sent(), y.initialize(e), egret.pro && egret.pro.egret2dDriveMode ? y.systemManager.registerSystem(_, 0) : y.systemManager.registerSystem(m, 0), y.start(), requestAnimationFrame(C), [2]
                    }
                }))
            }))
        }

        var M = S
    }.call(this, n(6))
}, function (e, t, n) {
    "use strict";
    Object.defineProperty(t, "__esModule", {value: !0}), n(10)
}, function (e, t, n) {
    var r = {"./Main.ts": 10, "./behaviors/RotateAround.ts": 21, "./behaviors/animations/Tree.ts": 22};

    function i(e) {
        var t = o(e);
        return n(t)
    }

    function o(e) {
        if (!n.o(r, e)) {
            var t = new Error("Cannot find module '" + e + "'");
            throw t.code = "MODULE_NOT_FOUND", t
        }
        return r[e]
    }

    i.keys = function () {
        return Object.keys(r)
    }, i.resolve = o, e.exports = i, i.id = 20
}, function (e, t, n) {
    "use strict";
    (function (e) {
        var r = "undefined" != typeof window ? window : e;
        r.__reflectMap = r.__reflectMap || {};
        var i, o = this && this.__reflect || function (e, t, n) {
            e.__class__ = t, n ? n.push(t) : n = [t], e.__types__ = e.__types__ ? n.concat(e.__types__) : n, __reflectMap[t] = e
        }, a = this && this.__extends || (i = function (e, t) {
            return (i = Object.setPrototypeOf || {__proto__: []} instanceof Array && function (e, t) {
                e.__proto__ = t
            } || function (e, t) {
                for (var n in t) t.hasOwnProperty(n) && (e[n] = t[n])
            })(e, t)
        }, function (e, t) {
            function n() {
                this.constructor = e
            }

            i(e, t), e.prototype = null === t ? Object.create(t) : (n.prototype = t.prototype, new n)
        }), s = this && this.__decorate || function (e, t, n, r) {
            var i, o = arguments.length, a = o < 3 ? t : null === r ? r = Object.getOwnPropertyDescriptor(t, n) : r;
            if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) a = Reflect.decorate(e, t, n, r); else for (var s = e.length - 1; s >= 0; s--) (i = e[s]) && (a = (o < 3 ? i(a) : o > 3 ? i(t, n, a) : i(t, n)) || a);
            return o > 3 && a && Object.defineProperty(t, n, a), a
        };
        Object.defineProperty(t, "__esModule", {value: !0}), t.RotateAround = void 0;
        var l = n(2), u = n(0), c = n(1), p = function (e) {
            function t() {
                var t = null !== e && e.apply(this, arguments) || this;
                return t.rotateSpeed = .5, t.lookAtPoint = c.Vector3.create(), t.target = null, t._radius = 0, t._radian = 0, t
            }

            return a(t, e), t.prototype.onLateUpdate = function (e) {
                var t = this.entity.transform, n = t.position, r = this.lookAtPoint;
                if (null !== this.target && r.copy(this.target.position), 0 !== this.rotateSpeed) {
                    var i = Math.sqrt(Math.pow(n.x - r.x, 2) + Math.pow(n.z - r.z, 2)),
                        o = Math.atan2(n.z - r.z, n.x - r.x);
                    Math.abs(this._radius - i) > .05 && (this._radius = i), Math.abs(this._radian - o) > .05 && (this._radian = o), this._radian += e * this.rotateSpeed * .5, t.setPosition(r.x + Math.cos(this._radian) * this._radius, n.y, r.z + Math.sin(this._radian) * this._radius)
                }
                t.lookAt(r)
            }, s([u.property(u.EditType.Float, {
                minimum: -10,
                maximum: 10
            }), u.serializedField], t.prototype, "rotateSpeed", void 0), s([u.property(u.EditType.Vector3), u.serializedField], t.prototype, "lookAtPoint", void 0), s([u.property(u.EditType.Component, {componentClass: c.Transform}), u.serializedField], t.prototype, "target", void 0), t = s([l.component()], t)
        }(c.Behaviour);
        t.RotateAround = p, p.filename = "/Users/gaoqiangzheng/fe/egretPro3d1/src/behaviors/RotateAround.ts", o(p, "RotateAround")
    }).call(this, n(6))
}, function (e, t, n) {
    "use strict";
    (function (e) {
        var r = "undefined" != typeof window ? window : e;
        r.__reflectMap = r.__reflectMap || {};
        var i, o = this && this.__reflect || function (e, t, n) {
            e.__class__ = t, n ? n.push(t) : n = [t], e.__types__ = e.__types__ ? n.concat(e.__types__) : n, __reflectMap[t] = e
        }, a = this && this.__extends || (i = function (e, t) {
            return (i = Object.setPrototypeOf || {__proto__: []} instanceof Array && function (e, t) {
                e.__proto__ = t
            } || function (e, t) {
                for (var n in t) t.hasOwnProperty(n) && (e[n] = t[n])
            })(e, t)
        }, function (e, t) {
            function n() {
                this.constructor = e
            }

            i(e, t), e.prototype = null === t ? Object.create(t) : (n.prototype = t.prototype, new n)
        }), s = this && this.__decorate || function (e, t, n, r) {
            var i, o = arguments.length, a = o < 3 ? t : null === r ? r = Object.getOwnPropertyDescriptor(t, n) : r;
            if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) a = Reflect.decorate(e, t, n, r); else for (var s = e.length - 1; s >= 0; s--) (i = e[s]) && (a = (o < 3 ? i(a) : o > 3 ? i(t, n, a) : i(t, n)) || a);
            return o > 3 && a && Object.defineProperty(t, n, a), a
        };
        Object.defineProperty(t, "__esModule", {value: !0}), t.AnimationTree = t.treeAnimations = void 0;
        var l = n(5), u = n(0), c = n(2), p = n(1);
        t.treeAnimations = [];
        var d = function (e) {
            function n() {
                var t = null !== e && e.apply(this, arguments) || this;
                return t.firstAnimation = "", t.secondAnimation = "", t._isPlaying = !1, t
            }

            return a(n, e), n.prototype.onStart = function () {
                var e = this.entity.getComponent(l.Animation);
                if (e) for (var n = 0, r = e.animations; n < r.length; n++) {
                    var i = r[n];
                    if (i) for (var o = 0, a = i.glTF.animations; o < a.length; o++) for (var s = 0, u = a[o].extensions.egret.clips; s < u.length; s++) {
                        var c = u[s];
                        t.treeAnimations.push({
                            label: "assets/animations/Mixamo/xbot@" + c.name + ".ani.bin",
                            value: c.name
                        })
                    }
                }
                t.treeAnimations.length > 0 && (this.secondAnimation = t.treeAnimations[1].value, this.firstAnimation = t.treeAnimations[0].value), this.play = !0
            }, n.prototype.onUpdate = function () {
                var e = this.entity.getComponent(l.Animation), t = e.getState(this.firstAnimation),
                    n = e.getState(this.secondAnimation);
                this._blending1DStates(t, n, .5 * (Math.sin(p.Application.instance.clock.frameTime) + 1))
            }, n.prototype._blending1DStates = function (e, t, n) {
                e.weight = 1 - n, t.weight = n, e.timeScale = p.MathUtil.lerp(e.totalTime / t.totalTime, 1, e.weight), t.timeScale = p.MathUtil.lerp(t.totalTime / e.totalTime, 1, t.weight)
            }, Object.defineProperty(n.prototype, "play", {
                get: function () {
                    return this._isPlaying
                }, set: function (e) {
                    if (this._isPlaying !== e) {
                        var n = this.entity.getComponent(l.Animation);
                        if (n) {
                            var r = n.animationController, i = r.getOrAddLayer(0),
                                o = r.createAnimationTree(i.machine, "treeTest");
                            r.createAnimationNode(o, t.treeAnimations[0].label, this.firstAnimation), r.createAnimationNode(o, t.treeAnimations[1].label, this.secondAnimation), e ? n.play("treeTest", 0) : n.stop()
                        }
                        this._isPlaying = e
                    }
                }, enumerable: !1, configurable: !0
            }), s([u.property(u.EditType.Boolean), u.serializedField], n.prototype, "play", null), n = s([c.component()], n)
        }(p.Behaviour);
        t.AnimationTree = d, d.filename = "/Users/gaoqiangzheng/fe/egretPro3d1/src/behaviors/animations/Tree.ts", o(d, "AnimationTree")
    }).call(this, n(6))
}]);